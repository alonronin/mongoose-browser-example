/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, callbacks = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId])
/******/ 				callbacks.push.apply(callbacks, installedChunks[chunkId]);
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			modules[moduleId] = moreModules[moduleId];
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);
/******/ 		while(callbacks.length)
/******/ 			callbacks.shift().call(null, __webpack_require__);
/******/ 		if(moreModules[0]) {
/******/ 			installedModules[0] = 0;
/******/ 			return __webpack_require__(0);
/******/ 		}
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// "0" means "already loaded"
/******/ 	// Array means "loading", array contains callbacks
/******/ 	var installedChunks = {
/******/ 		1:0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId, callback) {
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] === 0)
/******/ 			return callback.call(null, __webpack_require__);
/******/
/******/ 		// an array means "currently loading".
/******/ 		if(installedChunks[chunkId] !== undefined) {
/******/ 			installedChunks[chunkId].push(callback);
/******/ 		} else {
/******/ 			// start chunk loading
/******/ 			installedChunks[chunkId] = [callback];
/******/ 			var head = document.getElementsByTagName('head')[0];
/******/ 			var script = document.createElement('script');
/******/ 			script.type = 'text/javascript';
/******/ 			script.charset = 'utf-8';
/******/ 			script.async = true;
/******/
/******/ 			script.src = __webpack_require__.p + "" + chunkId + ".bundle.js";
/******/ 			head.appendChild(script);
/******/ 		}
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!*********************!*\
  !*** multi vendors ***!
  \*********************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! jquery */14);
	__webpack_require__(/*! bootstrap */12);
	module.exports = __webpack_require__(/*! mongoose */27);


/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */
/*!************************************!*\
  !*** ./~/bootstrap/dist/js/npm.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	// This file is autogenerated via the `commonjs` Grunt task. You can require() this file in a CommonJS environment.
	__webpack_require__(/*! ../../js/transition.js */ 15)
	__webpack_require__(/*! ../../js/alert.js */ 16)
	__webpack_require__(/*! ../../js/button.js */ 17)
	__webpack_require__(/*! ../../js/carousel.js */ 18)
	__webpack_require__(/*! ../../js/collapse.js */ 19)
	__webpack_require__(/*! ../../js/dropdown.js */ 20)
	__webpack_require__(/*! ../../js/modal.js */ 13)
	__webpack_require__(/*! ../../js/tooltip.js */ 21)
	__webpack_require__(/*! ../../js/popover.js */ 22)
	__webpack_require__(/*! ../../js/scrollspy.js */ 23)
	__webpack_require__(/*! ../../js/tab.js */ 24)
	__webpack_require__(/*! ../../js/affix.js */ 25)

/***/ },
/* 13 */
/*!*********************************!*\
  !*** ./~/bootstrap/js/modal.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/* ========================================================================
	 * Bootstrap: modal.js v3.3.4
	 * http://getbootstrap.com/javascript/#modals
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // MODAL CLASS DEFINITION
	  // ======================
	
	  var Modal = function (element, options) {
	    this.options             = options
	    this.$body               = $(document.body)
	    this.$element            = $(element)
	    this.$dialog             = this.$element.find('.modal-dialog')
	    this.$backdrop           = null
	    this.isShown             = null
	    this.originalBodyPad     = null
	    this.scrollbarWidth      = 0
	    this.ignoreBackdropClick = false
	
	    if (this.options.remote) {
	      this.$element
	        .find('.modal-content')
	        .load(this.options.remote, $.proxy(function () {
	          this.$element.trigger('loaded.bs.modal')
	        }, this))
	    }
	  }
	
	  Modal.VERSION  = '3.3.4'
	
	  Modal.TRANSITION_DURATION = 300
	  Modal.BACKDROP_TRANSITION_DURATION = 150
	
	  Modal.DEFAULTS = {
	    backdrop: true,
	    keyboard: true,
	    show: true
	  }
	
	  Modal.prototype.toggle = function (_relatedTarget) {
	    return this.isShown ? this.hide() : this.show(_relatedTarget)
	  }
	
	  Modal.prototype.show = function (_relatedTarget) {
	    var that = this
	    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })
	
	    this.$element.trigger(e)
	
	    if (this.isShown || e.isDefaultPrevented()) return
	
	    this.isShown = true
	
	    this.checkScrollbar()
	    this.setScrollbar()
	    this.$body.addClass('modal-open')
	
	    this.escape()
	    this.resize()
	
	    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))
	
	    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
	      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
	        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
	      })
	    })
	
	    this.backdrop(function () {
	      var transition = $.support.transition && that.$element.hasClass('fade')
	
	      if (!that.$element.parent().length) {
	        that.$element.appendTo(that.$body) // don't move modals dom position
	      }
	
	      that.$element
	        .show()
	        .scrollTop(0)
	
	      that.adjustDialog()
	
	      if (transition) {
	        that.$element[0].offsetWidth // force reflow
	      }
	
	      that.$element
	        .addClass('in')
	        .attr('aria-hidden', false)
	
	      that.enforceFocus()
	
	      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })
	
	      transition ?
	        that.$dialog // wait for modal to slide in
	          .one('bsTransitionEnd', function () {
	            that.$element.trigger('focus').trigger(e)
	          })
	          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
	        that.$element.trigger('focus').trigger(e)
	    })
	  }
	
	  Modal.prototype.hide = function (e) {
	    if (e) e.preventDefault()
	
	    e = $.Event('hide.bs.modal')
	
	    this.$element.trigger(e)
	
	    if (!this.isShown || e.isDefaultPrevented()) return
	
	    this.isShown = false
	
	    this.escape()
	    this.resize()
	
	    $(document).off('focusin.bs.modal')
	
	    this.$element
	      .removeClass('in')
	      .attr('aria-hidden', true)
	      .off('click.dismiss.bs.modal')
	      .off('mouseup.dismiss.bs.modal')
	
	    this.$dialog.off('mousedown.dismiss.bs.modal')
	
	    $.support.transition && this.$element.hasClass('fade') ?
	      this.$element
	        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
	        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
	      this.hideModal()
	  }
	
	  Modal.prototype.enforceFocus = function () {
	    $(document)
	      .off('focusin.bs.modal') // guard against infinite focus loop
	      .on('focusin.bs.modal', $.proxy(function (e) {
	        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
	          this.$element.trigger('focus')
	        }
	      }, this))
	  }
	
	  Modal.prototype.escape = function () {
	    if (this.isShown && this.options.keyboard) {
	      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
	        e.which == 27 && this.hide()
	      }, this))
	    } else if (!this.isShown) {
	      this.$element.off('keydown.dismiss.bs.modal')
	    }
	  }
	
	  Modal.prototype.resize = function () {
	    if (this.isShown) {
	      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
	    } else {
	      $(window).off('resize.bs.modal')
	    }
	  }
	
	  Modal.prototype.hideModal = function () {
	    var that = this
	    this.$element.hide()
	    this.backdrop(function () {
	      that.$body.removeClass('modal-open')
	      that.resetAdjustments()
	      that.resetScrollbar()
	      that.$element.trigger('hidden.bs.modal')
	    })
	  }
	
	  Modal.prototype.removeBackdrop = function () {
	    this.$backdrop && this.$backdrop.remove()
	    this.$backdrop = null
	  }
	
	  Modal.prototype.backdrop = function (callback) {
	    var that = this
	    var animate = this.$element.hasClass('fade') ? 'fade' : ''
	
	    if (this.isShown && this.options.backdrop) {
	      var doAnimate = $.support.transition && animate
	
	      this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
	        .appendTo(this.$body)
	
	      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
	        if (this.ignoreBackdropClick) {
	          this.ignoreBackdropClick = false
	          return
	        }
	        if (e.target !== e.currentTarget) return
	        this.options.backdrop == 'static'
	          ? this.$element[0].focus()
	          : this.hide()
	      }, this))
	
	      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow
	
	      this.$backdrop.addClass('in')
	
	      if (!callback) return
	
	      doAnimate ?
	        this.$backdrop
	          .one('bsTransitionEnd', callback)
	          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
	        callback()
	
	    } else if (!this.isShown && this.$backdrop) {
	      this.$backdrop.removeClass('in')
	
	      var callbackRemove = function () {
	        that.removeBackdrop()
	        callback && callback()
	      }
	      $.support.transition && this.$element.hasClass('fade') ?
	        this.$backdrop
	          .one('bsTransitionEnd', callbackRemove)
	          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
	        callbackRemove()
	
	    } else if (callback) {
	      callback()
	    }
	  }
	
	  // these following methods are used to handle overflowing modals
	
	  Modal.prototype.handleUpdate = function () {
	    this.adjustDialog()
	  }
	
	  Modal.prototype.adjustDialog = function () {
	    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight
	
	    this.$element.css({
	      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
	      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
	    })
	  }
	
	  Modal.prototype.resetAdjustments = function () {
	    this.$element.css({
	      paddingLeft: '',
	      paddingRight: ''
	    })
	  }
	
	  Modal.prototype.checkScrollbar = function () {
	    var fullWindowWidth = window.innerWidth
	    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
	      var documentElementRect = document.documentElement.getBoundingClientRect()
	      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
	    }
	    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
	    this.scrollbarWidth = this.measureScrollbar()
	  }
	
	  Modal.prototype.setScrollbar = function () {
	    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
	    this.originalBodyPad = document.body.style.paddingRight || ''
	    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
	  }
	
	  Modal.prototype.resetScrollbar = function () {
	    this.$body.css('padding-right', this.originalBodyPad)
	  }
	
	  Modal.prototype.measureScrollbar = function () { // thx walsh
	    var scrollDiv = document.createElement('div')
	    scrollDiv.className = 'modal-scrollbar-measure'
	    this.$body.append(scrollDiv)
	    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
	    this.$body[0].removeChild(scrollDiv)
	    return scrollbarWidth
	  }
	
	
	  // MODAL PLUGIN DEFINITION
	  // =======================
	
	  function Plugin(option, _relatedTarget) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.modal')
	      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)
	
	      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
	      if (typeof option == 'string') data[option](_relatedTarget)
	      else if (options.show) data.show(_relatedTarget)
	    })
	  }
	
	  var old = $.fn.modal
	
	  $.fn.modal             = Plugin
	  $.fn.modal.Constructor = Modal
	
	
	  // MODAL NO CONFLICT
	  // =================
	
	  $.fn.modal.noConflict = function () {
	    $.fn.modal = old
	    return this
	  }
	
	
	  // MODAL DATA-API
	  // ==============
	
	  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
	    var $this   = $(this)
	    var href    = $this.attr('href')
	    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
	    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())
	
	    if ($this.is('a')) e.preventDefault()
	
	    $target.one('show.bs.modal', function (showEvent) {
	      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
	      $target.one('hidden.bs.modal', function () {
	        $this.is(':visible') && $this.trigger('focus')
	      })
	    })
	    Plugin.call($target, option, this)
	  })
	
	}(jQuery);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 14)))

/***/ },
/* 14 */
/*!*********************************!*\
  !*** ./~/jquery/dist/jquery.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v2.1.4
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2015-04-28T16:01Z
	 */
	
	(function( global, factory ) {
	
		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}
	
	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
	
	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//
	
	var arr = [];
	
	var slice = arr.slice;
	
	var concat = arr.concat;
	
	var push = arr.push;
	
	var indexOf = arr.indexOf;
	
	var class2type = {};
	
	var toString = class2type.toString;
	
	var hasOwn = class2type.hasOwnProperty;
	
	var support = {};
	
	
	
	var
		// Use the correct document accordingly with window argument (sandbox)
		document = window.document,
	
		version = "2.1.4",
	
		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},
	
		// Support: Android<4.1
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	
		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,
	
		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};
	
	jQuery.fn = jQuery.prototype = {
		// The current version of jQuery being used
		jquery: version,
	
		constructor: jQuery,
	
		// Start with an empty selector
		selector: "",
	
		// The default length of a jQuery object is 0
		length: 0,
	
		toArray: function() {
			return slice.call( this );
		},
	
		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?
	
				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :
	
				// Return all the elements in a clean array
				slice.call( this );
		},
	
		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {
	
			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );
	
			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;
	
			// Return the newly-formed element set
			return ret;
		},
	
		// Execute a callback for every element in the matched set.
		// (You can seed the arguments with an array of args, but this is
		// only used internally.)
		each: function( callback, args ) {
			return jQuery.each( this, callback, args );
		},
	
		map: function( callback ) {
			return this.pushStack( jQuery.map(this, function( elem, i ) {
				return callback.call( elem, i, elem );
			}));
		},
	
		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},
	
		first: function() {
			return this.eq( 0 );
		},
	
		last: function() {
			return this.eq( -1 );
		},
	
		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
		},
	
		end: function() {
			return this.prevObject || this.constructor(null);
		},
	
		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};
	
	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;
	
		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
	
			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}
	
		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
			target = {};
		}
	
		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}
	
		for ( ; i < length; i++ ) {
			// Only deal with non-null/undefined values
			if ( (options = arguments[ i ]) != null ) {
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];
	
					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}
	
					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray(src) ? src : [];
	
						} else {
							clone = src && jQuery.isPlainObject(src) ? src : {};
						}
	
						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );
	
					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	
	jQuery.extend({
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
	
		// Assume jQuery is ready without the ready module
		isReady: true,
	
		error: function( msg ) {
			throw new Error( msg );
		},
	
		noop: function() {},
	
		isFunction: function( obj ) {
			return jQuery.type(obj) === "function";
		},
	
		isArray: Array.isArray,
	
		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},
	
		isNumeric: function( obj ) {
			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
		},
	
		isPlainObject: function( obj ) {
			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}
	
			if ( obj.constructor &&
					!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
				return false;
			}
	
			// If the function hasn't returned already, we're confident that
			// |obj| is a plain object, created by {} or constructed with new Object
			return true;
		},
	
		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},
	
		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}
			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call(obj) ] || "object" :
				typeof obj;
		},
	
		// Evaluates a script in a global context
		globalEval: function( code ) {
			var script,
				indirect = eval;
	
			code = jQuery.trim( code );
	
			if ( code ) {
				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if ( code.indexOf("use strict") === 1 ) {
					script = document.createElement("script");
					script.text = code;
					document.head.appendChild( script ).parentNode.removeChild( script );
				} else {
				// Otherwise, avoid the DOM node creation, insertion
				// and removal by using an indirect global eval
					indirect( code );
				}
			}
		},
	
		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},
	
		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},
	
		// args is for internal usage only
		each: function( obj, callback, args ) {
			var value,
				i = 0,
				length = obj.length,
				isArray = isArraylike( obj );
	
			if ( args ) {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.apply( obj[ i ], args );
	
						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.apply( obj[ i ], args );
	
						if ( value === false ) {
							break;
						}
					}
				}
	
			// A special, fast, case for the most common use of each
			} else {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.call( obj[ i ], i, obj[ i ] );
	
						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.call( obj[ i ], i, obj[ i ] );
	
						if ( value === false ) {
							break;
						}
					}
				}
			}
	
			return obj;
		},
	
		// Support: Android<4.1
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},
	
		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];
	
			if ( arr != null ) {
				if ( isArraylike( Object(arr) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}
	
			return ret;
		},
	
		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},
	
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;
	
			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}
	
			first.length = i;
	
			return first;
		},
	
		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;
	
			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}
	
			return matches;
		},
	
		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var value,
				i = 0,
				length = elems.length,
				isArray = isArraylike( elems ),
				ret = [];
	
			// Go through the array, translating each of the items to their new values
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
	
			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
			}
	
			// Flatten any nested arrays
			return concat.apply( [], ret );
		},
	
		// A global GUID counter for objects
		guid: 1,
	
		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;
	
			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}
	
			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}
	
			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};
	
			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	
			return proxy;
		},
	
		now: Date.now,
	
		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	});
	
	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	});
	
	function isArraylike( obj ) {
	
		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = "length" in obj && obj.length,
			type = jQuery.type( obj );
	
		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}
	
		if ( obj.nodeType === 1 && length ) {
			return true;
		}
	
		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.2.0-pre
	 * http://sizzlejs.com/
	 *
	 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2014-12-16
	 */
	(function( window ) {
	
	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,
	
		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
	
		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},
	
		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,
	
		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},
	
		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	
		// Regular expressions
	
		// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
		// http://www.w3.org/TR/css3-syntax/#characters
		characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
	
		// Loosely modeled on CSS identifier characters
		// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
		// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = characterEncoding.replace( "w", "w#" ),
	
		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",
	
		pseudos = ":(" + characterEncoding + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",
	
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
	
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	
		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
	
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),
	
		matchExpr = {
			"ID": new RegExp( "^#(" + characterEncoding + ")" ),
			"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
			"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},
	
		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,
	
		rnative = /^[^{]+\{\s*\[native \w/,
	
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	
		rsibling = /[+~]/,
		rescape = /'|\\/g,
	
		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},
	
		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		};
	
	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?
	
			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :
	
			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}
	
	function Sizzle( selector, context, results, seed ) {
		var match, elem, m, nodeType,
			// QSA vars
			i, groups, old, nid, newContext, newSelector;
	
		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
	
		context = context || document;
		results = results || [];
		nodeType = context.nodeType;
	
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
	
			return results;
		}
	
		if ( !seed && documentIsHTML ) {
	
			// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
				// Speed-up: Sizzle("#ID")
				if ( (m = match[1]) ) {
					if ( nodeType === 9 ) {
						elem = context.getElementById( m );
						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document (jQuery #6963)
						if ( elem && elem.parentNode ) {
							// Handle the case where IE, Opera, and Webkit return items
							// by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}
					} else {
						// Context is not a document
						if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
							contains( context, elem ) && elem.id === m ) {
							results.push( elem );
							return results;
						}
					}
	
				// Speed-up: Sizzle("TAG")
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;
	
				// Speed-up: Sizzle(".CLASS")
				} else if ( (m = match[3]) && support.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}
	
			// QSA path
			if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
				nid = old = expando;
				newContext = context;
				newSelector = nodeType !== 1 && selector;
	
				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					groups = tokenize( selector );
	
					if ( (old = context.getAttribute("id")) ) {
						nid = old.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", nid );
					}
					nid = "[id='" + nid + "'] ";
	
					i = groups.length;
					while ( i-- ) {
						groups[i] = nid + toSelector( groups[i] );
					}
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
					newSelector = groups.join(",");
				}
	
				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute("id");
						}
					}
				}
			}
		}
	
		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}
	
	/**
	 * Create key-value caches of limited size
	 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];
	
		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}
	
	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}
	
	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");
	
		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}
	
	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = attrs.length;
	
		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}
	
	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );
	
		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}
	
		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}
	
		return a ? 1 : -1;
	}
	
	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;
	
				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}
	
	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}
	
	// Expose support vars for convenience
	support = Sizzle.support = {};
	
	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};
	
	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, parent,
			doc = node ? node.ownerDocument || node : preferredDoc;
	
		// If no document and documentElement is available, return
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}
	
		// Set our document
		document = doc;
		docElem = doc.documentElement;
		parent = doc.defaultView;
	
		// Support: IE>8
		// If iframe document is assigned to "document" variable and if iframe has been reloaded,
		// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
		// IE6-8 do not support the defaultView property so parent will be undefined
		if ( parent && parent !== parent.top ) {
			// IE11 does not have attachEvent, so all must suffer
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", unloadHandler, false );
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", unloadHandler );
			}
		}
	
		/* Support tests
		---------------------------------------------------------------------- */
		documentIsHTML = !isXML( doc );
	
		/* Attributes
		---------------------------------------------------------------------- */
	
		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});
	
		/* getElement(s)By*
		---------------------------------------------------------------------- */
	
		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( doc.createComment("") );
			return !div.getElementsByTagName("*").length;
		});
	
		// Support: IE<9
		support.getElementsByClassName = rnative.test( doc.getElementsByClassName );
	
		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
		});
	
		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m && m.parentNode ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];
	
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}
	
		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );
	
				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :
	
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );
	
				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}
	
					return tmp;
				}
				return results;
			};
	
		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};
	
		/* QSA/matchesSelector
		---------------------------------------------------------------------- */
	
		// QSA and matchesSelector support
	
		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];
	
		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];
	
		if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\f]' msallowcapture=''>" +
					"<option selected=''></option></select>";
	
				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}
	
				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}
	
				// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
				if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}
	
				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
	
				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibing-combinator selector` fails
				if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});
	
			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = doc.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );
	
				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}
	
				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}
	
		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {
	
			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );
	
				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}
	
		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
	
		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );
	
		// Element contains another
		// Purposefully does not implement inclusive descendent
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};
	
		/* Sorting
		---------------------------------------------------------------------- */
	
		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {
	
			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}
	
			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :
	
				// Otherwise we know they are disconnected
				1;
	
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
	
				// Choose the first element that is related to our preferred document
				if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}
	
				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}
	
			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];
	
			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === doc ? -1 :
					b === doc ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
	
			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}
	
			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}
	
			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}
	
			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :
	
				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};
	
		return doc;
	};
	
	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};
	
	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );
	
		if ( support.matchesSelector && documentIsHTML &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
	
			try {
				var ret = matches.call( elem, expr );
	
				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}
	
		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};
	
	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};
	
	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;
	
		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};
	
	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	
	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;
	
		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );
	
		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}
	
		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;
	
		return results;
	};
	
	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;
	
		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	
		return ret;
	};
	
	Expr = Sizzle.selectors = {
	
		// Can be adjusted by the user
		cacheLength: 50,
	
		createPseudo: markFunction,
	
		match: matchExpr,
	
		attrHandle: {},
	
		find: {},
	
		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},
	
		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );
	
				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
	
				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}
	
				return match.slice( 0, 4 );
			},
	
			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();
	
				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}
	
					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
	
				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}
	
				return match;
			},
	
			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];
	
				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}
	
				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";
	
				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
	
					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}
	
				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},
	
		filter: {
	
			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},
	
			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];
	
				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},
	
			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );
	
					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}
	
					result += "";
	
					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},
	
			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";
	
				return first === 1 && last === 0 ?
	
					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :
	
					function( elem, context, xml ) {
						var cache, outerCache, node, diff, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType;
	
						if ( parent ) {
	
							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}
	
							start = [ forward ? parent.firstChild : parent.lastChild ];
	
							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
								// Seek `elem` from a previously-cached index
								outerCache = parent[ expando ] || (parent[ expando ] = {});
								cache = outerCache[ type ] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = cache[0] === dirruns && cache[2];
								node = nodeIndex && parent.childNodes[ nodeIndex ];
	
								while ( (node = ++nodeIndex && node && node[ dir ] ||
	
									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										outerCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}
	
							// Use previously-cached element index if available
							} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
								diff = cache[1];
	
							// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
							} else {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
										// Cache the index of each encountered element
										if ( useCache ) {
											(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
										}
	
										if ( node === elem ) {
											break;
										}
									}
								}
							}
	
							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},
	
			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );
	
				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}
	
				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}
	
				return fn;
			}
		},
	
		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );
	
				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;
	
						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),
	
			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),
	
			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),
	
			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
	
							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),
	
			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},
	
			"root": function( elem ) {
				return elem === docElem;
			},
	
			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},
	
			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},
	
			"disabled": function( elem ) {
				return elem.disabled === true;
			},
	
			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},
	
			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}
	
				return elem.selected === true;
			},
	
			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},
	
			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},
	
			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},
	
			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},
	
			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},
	
			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
	
					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},
	
			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),
	
			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),
	
			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),
	
			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};
	
	Expr.pseudos["nth"] = Expr.pseudos["eq"];
	
	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}
	
	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();
	
	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];
	
		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}
	
		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;
	
		while ( soFar ) {
	
			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}
	
			matched = false;
	
			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}
	
			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}
	
			if ( !matched ) {
				break;
			}
		}
	
		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};
	
	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}
	
	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;
	
		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :
	
			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, outerCache,
					newCache = [ dirruns, doneName ];
	
				// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
							if ( (oldCache = outerCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
	
								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								outerCache[ dir ] = newCache;
	
								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}
	
	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}
	
	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}
	
	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;
	
		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}
	
		return newUnmatched;
	}
	
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,
	
				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
	
				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,
	
				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	
						// ...intermediate processing is necessary
						[] :
	
						// ...otherwise use results directly
						results :
					matcherIn;
	
			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}
	
			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );
	
				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}
	
			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}
	
					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
	
							seed[temp] = !(results[temp] = elem);
						}
					}
				}
	
			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}
	
	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,
	
			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];
	
		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
	
				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}
	
		return elementMatcher( matchers );
	}
	
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;
	
				if ( outermost ) {
					outermostContext = context !== document && context;
				}
	
				// Add elements passing elementMatchers directly to results
				// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context, xml ) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}
	
					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}
	
						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}
	
				// Apply set filters to unmatched elements
				matchedCount += i;
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}
	
					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}
	
						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}
	
					// Add matches to results
					push.apply( results, setMatched );
	
					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {
	
						Sizzle.uniqueSort( results );
					}
				}
	
				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}
	
				return unmatched;
			};
	
		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}
	
	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];
	
		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}
	
			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	
			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};
	
	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );
	
		results = results || [];
	
		// Try to minimize operations if there is no seed and only one group
		if ( match.length === 1 ) {
	
			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {
	
				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
	
				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}
	
				selector = selector.slice( tokens.shift().value.length );
			}
	
			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];
	
				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {
	
						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}
	
						break;
					}
				}
			}
		}
	
		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};
	
	// One-time assignments
	
	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
	
	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;
	
	// Initialize against the default document
	setDocument();
	
	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});
	
	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}
	
	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}
	
	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}
	
	return Sizzle;
	
	})( window );
	
	
	
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	
	
	
	var rneedsContext = jQuery.expr.match.needsContext;
	
	var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);
	
	
	
	var risSimple = /^.[^:#\[\.,]*$/;
	
	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				/* jshint -W018 */
				return !!qualifier.call( elem, i, elem ) !== not;
			});
	
		}
	
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			});
	
		}
	
		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}
	
			qualifier = jQuery.filter( qualifier, elements );
		}
	
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
		});
	}
	
	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];
	
		if ( not ) {
			expr = ":not(" + expr + ")";
		}
	
		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			}));
	};
	
	jQuery.fn.extend({
		find: function( selector ) {
			var i,
				len = this.length,
				ret = [],
				self = this;
	
			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter(function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				}) );
			}
	
			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}
	
			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow(this, selector || [], false) );
		},
		not: function( selector ) {
			return this.pushStack( winnow(this, selector || [], true) );
		},
		is: function( selector ) {
			return !!winnow(
				this,
	
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	});
	
	
	// Initialize a jQuery object
	
	
	// A central reference to the root jQuery(document)
	var rootjQuery,
	
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
	
		init = jQuery.fn.init = function( selector, context ) {
			var match, elem;
	
			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}
	
			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];
	
				} else {
					match = rquickExpr.exec( selector );
				}
	
				// Match html or make sure no context is specified for #id
				if ( match && (match[1] || !context) ) {
	
					// HANDLE: $(html) -> $(array)
					if ( match[1] ) {
						context = context instanceof jQuery ? context[0] : context;
	
						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[1],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );
	
						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );
	
								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}
	
						return this;
	
					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[2] );
	
						// Support: Blackberry 4.6
						// gEBID returns nodes no longer in the document (#6963)
						if ( elem && elem.parentNode ) {
							// Inject the element directly into the jQuery object
							this.length = 1;
							this[0] = elem;
						}
	
						this.context = document;
						this.selector = selector;
						return this;
					}
	
				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || rootjQuery ).find( selector );
	
				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}
	
			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[0] = selector;
				this.length = 1;
				return this;
	
			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return typeof rootjQuery.ready !== "undefined" ?
					rootjQuery.ready( selector ) :
					// Execute immediately if ready is not present
					selector( jQuery );
			}
	
			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}
	
			return jQuery.makeArray( selector, this );
		};
	
	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;
	
	// Initialize central reference
	rootjQuery = jQuery( document );
	
	
	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};
	
	jQuery.extend({
		dir: function( elem, dir, until ) {
			var matched = [],
				truncate = until !== undefined;
	
			while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
				if ( elem.nodeType === 1 ) {
					if ( truncate && jQuery( elem ).is( until ) ) {
						break;
					}
					matched.push( elem );
				}
			}
			return matched;
		},
	
		sibling: function( n, elem ) {
			var matched = [];
	
			for ( ; n; n = n.nextSibling ) {
				if ( n.nodeType === 1 && n !== elem ) {
					matched.push( n );
				}
			}
	
			return matched;
		}
	});
	
	jQuery.fn.extend({
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;
	
			return this.filter(function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[i] ) ) {
						return true;
					}
				}
			});
		},
	
		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;
	
			for ( ; i < l; i++ ) {
				for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
					// Always skip document fragments
					if ( cur.nodeType < 11 && (pos ?
						pos.index(cur) > -1 :
	
						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector(cur, selectors)) ) {
	
						matched.push( cur );
						break;
					}
				}
			}
	
			return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
		},
	
		// Determine the position of an element within the set
		index: function( elem ) {
	
			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}
	
			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}
	
			// Locate the position of the desired element
			return indexOf.call( this,
	
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},
	
		add: function( selector, context ) {
			return this.pushStack(
				jQuery.unique(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},
	
		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter(selector)
			);
		}
	});
	
	function sibling( cur, dir ) {
		while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
		return cur;
	}
	
	jQuery.each({
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return jQuery.dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return jQuery.dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return jQuery.dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return jQuery.sibling( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );
	
			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}
	
			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}
	
			if ( this.length > 1 ) {
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.unique( matched );
				}
	
				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}
	
			return this.pushStack( matched );
		};
	});
	var rnotwhite = (/\S+/g);
	
	
	
	// String to Object options format cache
	var optionsCache = {};
	
	// Convert String-formatted options into Object-formatted ones and store in cache
	function createOptions( options ) {
		var object = optionsCache[ options ] = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		});
		return object;
	}
	
	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {
	
		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			( optionsCache[ options ] || createOptions( options ) ) :
			jQuery.extend( {}, options );
	
		var // Last fire value (for non-forgettable lists)
			memory,
			// Flag to know if list was already fired
			fired,
			// Flag to know if list is currently firing
			firing,
			// First callback to fire (used internally by add and fireWith)
			firingStart,
			// End of the loop when firing
			firingLength,
			// Index of currently firing callback (modified by remove if needed)
			firingIndex,
			// Actual callback list
			list = [],
			// Stack of fire calls for repeatable lists
			stack = !options.once && [],
			// Fire callbacks
			fire = function( data ) {
				memory = options.memory && data;
				fired = true;
				firingIndex = firingStart || 0;
				firingStart = 0;
				firingLength = list.length;
				firing = true;
				for ( ; list && firingIndex < firingLength; firingIndex++ ) {
					if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
						memory = false; // To prevent further calls using add
						break;
					}
				}
				firing = false;
				if ( list ) {
					if ( stack ) {
						if ( stack.length ) {
							fire( stack.shift() );
						}
					} else if ( memory ) {
						list = [];
					} else {
						self.disable();
					}
				}
			},
			// Actual Callbacks object
			self = {
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
						// First, we save the current length
						var start = list.length;
						(function add( args ) {
							jQuery.each( args, function( _, arg ) {
								var type = jQuery.type( arg );
								if ( type === "function" ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && type !== "string" ) {
									// Inspect recursively
									add( arg );
								}
							});
						})( arguments );
						// Do we need to add the callbacks to the
						// current firing batch?
						if ( firing ) {
							firingLength = list.length;
						// With memory, if we're not firing then
						// we should call right away
						} else if ( memory ) {
							firingStart = start;
							fire( memory );
						}
					}
					return this;
				},
				// Remove a callback from the list
				remove: function() {
					if ( list ) {
						jQuery.each( arguments, function( _, arg ) {
							var index;
							while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
								list.splice( index, 1 );
								// Handle firing indexes
								if ( firing ) {
									if ( index <= firingLength ) {
										firingLength--;
									}
									if ( index <= firingIndex ) {
										firingIndex--;
									}
								}
							}
						});
					}
					return this;
				},
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
				},
				// Remove all callbacks from the list
				empty: function() {
					list = [];
					firingLength = 0;
					return this;
				},
				// Have the list do nothing anymore
				disable: function() {
					list = stack = memory = undefined;
					return this;
				},
				// Is it disabled?
				disabled: function() {
					return !list;
				},
				// Lock the list in its current state
				lock: function() {
					stack = undefined;
					if ( !memory ) {
						self.disable();
					}
					return this;
				},
				// Is it locked?
				locked: function() {
					return !stack;
				},
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( list && ( !fired || stack ) ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						if ( firing ) {
							stack.push( args );
						} else {
							fire( args );
						}
					}
					return this;
				},
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};
	
		return self;
	};
	
	
	jQuery.extend({
	
		Deferred: function( func ) {
			var tuples = [
					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks("memory") ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred(function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[1] ](function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.done( newDefer.resolve )
											.fail( newDefer.reject )
											.progress( newDefer.notify );
									} else {
										newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
									}
								});
							});
							fns = null;
						}).promise();
					},
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};
	
			// Keep pipe for back-compat
			promise.pipe = promise.then;
	
			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];
	
				// promise[ done | fail | progress ] = list.add
				promise[ tuple[1] ] = list.add;
	
				// Handle state
				if ( stateString ) {
					list.add(function() {
						// state = [ resolved | rejected ]
						state = stateString;
	
					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}
	
				// deferred[ resolve | reject | notify ]
				deferred[ tuple[0] ] = function() {
					deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[0] + "With" ] = list.fireWith;
			});
	
			// Make the deferred a promise
			promise.promise( deferred );
	
			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}
	
			// All done!
			return deferred;
		},
	
		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = slice.call( arguments ),
				length = resolveValues.length,
	
				// the count of uncompleted subordinates
				remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
	
				// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
	
				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},
	
				progressValues, progressContexts, resolveContexts;
	
			// Add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject )
							.progress( updateFunc( i, progressContexts, progressValues ) );
					} else {
						--remaining;
					}
				}
			}
	
			// If we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}
	
			return deferred.promise();
		}
	});
	
	
	// The deferred used on DOM ready
	var readyList;
	
	jQuery.fn.ready = function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );
	
		return this;
	};
	
	jQuery.extend({
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
	
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
	
		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},
	
		// Handle when the DOM is ready
		ready: function( wait ) {
	
			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}
	
			// Remember that the DOM is ready
			jQuery.isReady = true;
	
			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}
	
			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
	
			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
				jQuery( document ).off( "ready" );
			}
		}
	});
	
	/**
	 * The ready event handler and self cleanup method
	 */
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed, false );
		window.removeEventListener( "load", completed, false );
		jQuery.ready();
	}
	
	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {
	
			readyList = jQuery.Deferred();
	
			// Catch cases where $(document).ready() is called after the browser event has already occurred.
			// We once tried to use readyState "interactive" here, but it caused issues like the one
			// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
			if ( document.readyState === "complete" ) {
				// Handle it asynchronously to allow scripts the opportunity to delay ready
				setTimeout( jQuery.ready );
	
			} else {
	
				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed, false );
	
				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed, false );
			}
		}
		return readyList.promise( obj );
	};
	
	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();
	
	
	
	
	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;
	
		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
			}
	
		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;
	
			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}
	
			if ( bulk ) {
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;
	
				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}
	
			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
				}
			}
		}
	
		return chainable ?
			elems :
	
			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[0], key ) : emptyGet;
	};
	
	
	/**
	 * Determines whether an object can have data
	 */
	jQuery.acceptData = function( owner ) {
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};
	
	
	function Data() {
		// Support: Android<4,
		// Old WebKit does not have Object.preventExtensions/freeze method,
		// return new empty object instead with no [[set]] accessor
		Object.defineProperty( this.cache = {}, 0, {
			get: function() {
				return {};
			}
		});
	
		this.expando = jQuery.expando + Data.uid++;
	}
	
	Data.uid = 1;
	Data.accepts = jQuery.acceptData;
	
	Data.prototype = {
		key: function( owner ) {
			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return the key for a frozen object.
			if ( !Data.accepts( owner ) ) {
				return 0;
			}
	
			var descriptor = {},
				// Check if the owner object already has a cache key
				unlock = owner[ this.expando ];
	
			// If not, create one
			if ( !unlock ) {
				unlock = Data.uid++;
	
				// Secure it in a non-enumerable, non-writable property
				try {
					descriptor[ this.expando ] = { value: unlock };
					Object.defineProperties( owner, descriptor );
	
				// Support: Android<4
				// Fallback to a less secure definition
				} catch ( e ) {
					descriptor[ this.expando ] = unlock;
					jQuery.extend( owner, descriptor );
				}
			}
	
			// Ensure the cache object
			if ( !this.cache[ unlock ] ) {
				this.cache[ unlock ] = {};
			}
	
			return unlock;
		},
		set: function( owner, data, value ) {
			var prop,
				// There may be an unlock assigned to this node,
				// if there is no entry for this "owner", create one inline
				// and set the unlock as though an owner entry had always existed
				unlock = this.key( owner ),
				cache = this.cache[ unlock ];
	
			// Handle: [ owner, key, value ] args
			if ( typeof data === "string" ) {
				cache[ data ] = value;
	
			// Handle: [ owner, { properties } ] args
			} else {
				// Fresh assignments by object are shallow copied
				if ( jQuery.isEmptyObject( cache ) ) {
					jQuery.extend( this.cache[ unlock ], data );
				// Otherwise, copy the properties one-by-one to the cache object
				} else {
					for ( prop in data ) {
						cache[ prop ] = data[ prop ];
					}
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			// Either a valid cache is found, or will be created.
			// New caches will be created and the unlock returned,
			// allowing direct access to the newly created
			// empty data object. A valid owner object must be provided.
			var cache = this.cache[ this.key( owner ) ];
	
			return key === undefined ?
				cache : cache[ key ];
		},
		access: function( owner, key, value ) {
			var stored;
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					((key && typeof key === "string") && value === undefined) ) {
	
				stored = this.get( owner, key );
	
				return stored !== undefined ?
					stored : this.get( owner, jQuery.camelCase(key) );
			}
	
			// [*]When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );
	
			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i, name, camel,
				unlock = this.key( owner ),
				cache = this.cache[ unlock ];
	
			if ( key === undefined ) {
				this.cache[ unlock ] = {};
	
			} else {
				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {
					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat( key.map( jQuery.camelCase ) );
				} else {
					camel = jQuery.camelCase( key );
					// Try the string as a key before any manipulation
					if ( key in cache ) {
						name = [ key, camel ];
					} else {
						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ?
							[ name ] : ( name.match( rnotwhite ) || [] );
					}
				}
	
				i = name.length;
				while ( i-- ) {
					delete cache[ name[ i ] ];
				}
			}
		},
		hasData: function( owner ) {
			return !jQuery.isEmptyObject(
				this.cache[ owner[ this.expando ] ] || {}
			);
		},
		discard: function( owner ) {
			if ( owner[ this.expando ] ) {
				delete this.cache[ owner[ this.expando ] ];
			}
		}
	};
	var data_priv = new Data();
	
	var data_user = new Data();
	
	
	
	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
	
	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /([A-Z])/g;
	
	function dataAttr( elem, key, data ) {
		var name;
	
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
			data = elem.getAttribute( name );
	
			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :
						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch( e ) {}
	
				// Make sure we set the data so it isn't changed later
				data_user.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}
	
	jQuery.extend({
		hasData: function( elem ) {
			return data_user.hasData( elem ) || data_priv.hasData( elem );
		},
	
		data: function( elem, name, data ) {
			return data_user.access( elem, name, data );
		},
	
		removeData: function( elem, name ) {
			data_user.remove( elem, name );
		},
	
		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to data_priv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return data_priv.access( elem, name, data );
		},
	
		_removeData: function( elem, name ) {
			data_priv.remove( elem, name );
		}
	});
	
	jQuery.fn.extend({
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;
	
			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = data_user.get( elem );
	
					if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {
	
							// Support: IE11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice(5) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						data_priv.set( elem, "hasDataAttrs", true );
					}
				}
	
				return data;
			}
	
			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each(function() {
					data_user.set( this, key );
				});
			}
	
			return access( this, function( value ) {
				var data,
					camelKey = jQuery.camelCase( key );
	
				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {
					// Attempt to get data from the cache
					// with the key as-is
					data = data_user.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// Attempt to get data from the cache
					// with the key camelized
					data = data_user.get( elem, camelKey );
					if ( data !== undefined ) {
						return data;
					}
	
					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, camelKey, undefined );
					if ( data !== undefined ) {
						return data;
					}
	
					// We tried really hard, but the data doesn't exist.
					return;
				}
	
				// Set the data...
				this.each(function() {
					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = data_user.get( this, camelKey );
	
					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					data_user.set( this, camelKey, value );
	
					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if ( key.indexOf("-") !== -1 && data !== undefined ) {
						data_user.set( this, key, value );
					}
				});
			}, null, value, arguments.length > 1, null, true );
		},
	
		removeData: function( key ) {
			return this.each(function() {
				data_user.remove( this, key );
			});
		}
	});
	
	
	jQuery.extend({
		queue: function( elem, type, data ) {
			var queue;
	
			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = data_priv.get( elem, type );
	
				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = data_priv.access( elem, type, jQuery.makeArray(data) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},
	
		dequeue: function( elem, type ) {
			type = type || "fx";
	
			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};
	
			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}
	
			if ( fn ) {
	
				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}
	
				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}
	
			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},
	
		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return data_priv.get( elem, key ) || data_priv.access( elem, key, {
				empty: jQuery.Callbacks("once memory").add(function() {
					data_priv.remove( elem, [ type + "queue", key ] );
				})
			});
		}
	});
	
	jQuery.fn.extend({
		queue: function( type, data ) {
			var setter = 2;
	
			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}
	
			if ( arguments.length < setter ) {
				return jQuery.queue( this[0], type );
			}
	
			return data === undefined ?
				this :
				this.each(function() {
					var queue = jQuery.queue( this, type, data );
	
					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );
	
					if ( type === "fx" && queue[0] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				});
		},
		dequeue: function( type ) {
			return this.each(function() {
				jQuery.dequeue( this, type );
			});
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};
	
			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";
	
			while ( i-- ) {
				tmp = data_priv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	});
	var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
	
	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
	
	var isHidden = function( elem, el ) {
			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
		};
	
	var rcheckableType = (/^(?:checkbox|radio)$/i);
	
	
	
	(function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );
	
		// Support: Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );
	
		div.appendChild( input );
	
		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
	
		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	})();
	var strundefined = typeof undefined;
	
	
	
	support.focusinBubbles = "onfocusin" in window;
	
	
	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
		rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
	
	function returnTrue() {
		return true;
	}
	
	function returnFalse() {
		return false;
	}
	
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}
	
	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {
	
		global: {},
	
		add: function( elem, types, handler, data, selector ) {
	
			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = data_priv.get( elem );
	
			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}
	
			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}
	
			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}
	
			// Init the element's event structure and main handler, if this is the first
			if ( !(events = elemData.events) ) {
				events = elemData.events = {};
			}
			if ( !(eventHandle = elemData.handle) ) {
				eventHandle = elemData.handle = function( e ) {
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}
	
			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();
	
				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}
	
				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};
	
				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;
	
				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};
	
				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join(".")
				}, handleObjIn );
	
				// Init the event handler queue if we're the first
				if ( !(handlers = events[ type ]) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;
	
					// Only use addEventListener if the special events handler returns false
					if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle, false );
						}
					}
				}
	
				if ( special.add ) {
					special.add.call( elem, handleObj );
	
					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}
	
				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}
	
				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}
	
		},
	
		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {
	
			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = data_priv.hasData( elem ) && data_priv.get( elem );
	
			if ( !elemData || !(events = elemData.events) ) {
				return;
			}
	
			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();
	
				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}
	
				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );
	
				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];
	
					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );
	
						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}
	
				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
						jQuery.removeEvent( elem, type, elemData.handle );
					}
	
					delete events[ type ];
				}
			}
	
			// Remove the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				delete elemData.handle;
				data_priv.remove( elem, "events" );
			}
		},
	
		trigger: function( event, data, elem, onlyHandlers ) {
	
			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];
	
			cur = tmp = elem = elem || document;
	
			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}
	
			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}
	
			if ( type.indexOf(".") >= 0 ) {
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;
	
			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );
	
			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join(".");
			event.namespace_re = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
				null;
	
			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}
	
			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );
	
			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}
	
			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
	
				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}
	
				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === (elem.ownerDocument || document) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}
	
			// Fire handlers on the event path
			i = 0;
			while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {
	
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;
	
				// jQuery handler
				handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}
	
				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;
	
			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {
	
				if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
					jQuery.acceptData( elem ) ) {
	
					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
	
						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];
	
						if ( tmp ) {
							elem[ ontype ] = null;
						}
	
						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;
	
						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}
	
			return event.result;
		},
	
		dispatch: function( event ) {
	
			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );
	
			var i, j, ret, matched, handleObj,
				handlerQueue = [],
				args = slice.call( arguments ),
				handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};
	
			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;
			event.delegateTarget = this;
	
			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}
	
			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );
	
			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;
	
				j = 0;
				while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {
	
					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {
	
						event.handleObj = handleObj;
						event.data = handleObj.data;
	
						ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
								.apply( matched.elem, args );
	
						if ( ret !== undefined ) {
							if ( (event.result = ret) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}
	
			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}
	
			return event.result;
		},
	
		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;
	
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			// Avoid non-left-click bubbling in Firefox (#3861)
			if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {
	
				for ( ; cur !== this; cur = cur.parentNode || this ) {
	
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.disabled !== true || event.type !== "click" ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];
	
							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";
	
							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) >= 0 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push({ elem: cur, handlers: matches });
						}
					}
				}
			}
	
			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
			}
	
			return handlerQueue;
		},
	
		// Includes some event props shared by KeyEvent and MouseEvent
		props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
	
		fixHooks: {},
	
		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function( event, original ) {
	
				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}
	
				return event;
			}
		},
	
		mouseHooks: {
			props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
			filter: function( event, original ) {
				var eventDoc, doc, body,
					button = original.button;
	
				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;
	
					event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}
	
				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}
	
				return event;
			}
		},
	
		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}
	
			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];
	
			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
	
			event = new jQuery.Event( originalEvent );
	
			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}
	
			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if ( !event.target ) {
				event.target = document;
			}
	
			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}
	
			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},
	
		special: {
			load: {
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},
	
				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},
	
			beforeunload: {
				postDispatch: function( event ) {
	
					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		},
	
		simulate: function( type, elem, event, bubble ) {
			// Piggyback on a donor event to simulate a different one.
			// Fake originalEvent to avoid donor's stopPropagation, but if the
			// simulated event prevents default then we do the same on the donor.
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true,
					originalEvent: {}
				}
			);
			if ( bubble ) {
				jQuery.event.trigger( e, null, elem );
			} else {
				jQuery.event.dispatch.call( elem, e );
			}
			if ( e.isDefaultPrevented() ) {
				event.preventDefault();
			}
		}
	};
	
	jQuery.removeEvent = function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	};
	
	jQuery.Event = function( src, props ) {
		// Allow instantiation without the 'new' keyword
		if ( !(this instanceof jQuery.Event) ) {
			return new jQuery.Event( src, props );
		}
	
		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;
	
			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
					// Support: Android<4.0
					src.returnValue === false ?
				returnTrue :
				returnFalse;
	
		// Event type
		} else {
			this.type = src;
		}
	
		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}
	
		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();
	
		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};
	
	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
	
		preventDefault: function() {
			var e = this.originalEvent;
	
			this.isDefaultPrevented = returnTrue;
	
			if ( e && e.preventDefault ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;
	
			this.isPropagationStopped = returnTrue;
	
			if ( e && e.stopPropagation ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;
	
			this.isImmediatePropagationStopped = returnTrue;
	
			if ( e && e.stopImmediatePropagation ) {
				e.stopImmediatePropagation();
			}
	
			this.stopPropagation();
		}
	};
	
	// Create mouseenter/leave events using mouseover/out and event-time checks
	// Support: Chrome 15+
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,
	
			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;
	
				// For mousenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	});
	
	// Support: Firefox, Chrome, Safari
	// Create "bubbling" focus and blur events
	if ( !support.focusinBubbles ) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
	
			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
					jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
				};
	
			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = data_priv.access( doc, fix );
	
					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = data_priv.access( doc, fix ) - 1;
	
					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						data_priv.remove( doc, fix );
	
					} else {
						data_priv.access( doc, fix, attaches );
					}
				}
			};
		});
	}
	
	jQuery.fn.extend({
	
		on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
			var origFn, type;
	
			// Types can be a map of types/handlers
			if ( typeof types === "object" ) {
				// ( types-Object, selector, data )
				if ( typeof selector !== "string" ) {
					// ( types-Object, data )
					data = data || selector;
					selector = undefined;
				}
				for ( type in types ) {
					this.on( type, selector, data, types[ type ], one );
				}
				return this;
			}
	
			if ( data == null && fn == null ) {
				// ( types, fn )
				fn = selector;
				data = selector = undefined;
			} else if ( fn == null ) {
				if ( typeof selector === "string" ) {
					// ( types, selector, fn )
					fn = data;
					data = undefined;
				} else {
					// ( types, data, fn )
					fn = data;
					data = selector;
					selector = undefined;
				}
			}
			if ( fn === false ) {
				fn = returnFalse;
			} else if ( !fn ) {
				return this;
			}
	
			if ( one === 1 ) {
				origFn = fn;
				fn = function( event ) {
					// Can use an empty set, since event contains the info
					jQuery().off( event );
					return origFn.apply( this, arguments );
				};
				// Use same guid so caller can remove using origFn
				fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
			}
			return this.each( function() {
				jQuery.event.add( this, types, fn, data, selector );
			});
		},
		one: function( types, selector, data, fn ) {
			return this.on( types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each(function() {
				jQuery.event.remove( this, types, fn, selector );
			});
		},
	
		trigger: function( type, data ) {
			return this.each(function() {
				jQuery.event.trigger( type, data, this );
			});
		},
		triggerHandler: function( type, data ) {
			var elem = this[0];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	});
	
	
	var
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
		rtagName = /<([\w:]+)/,
		rhtml = /<|&#?\w+;/,
		rnoInnerhtml = /<(?:script|style|link)/i,
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptType = /^$|\/(?:java|ecma)script/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
	
		// We have to close these tags to support XHTML (#13200)
		wrapMap = {
	
			// Support: IE9
			option: [ 1, "<select multiple='multiple'>", "</select>" ],
	
			thead: [ 1, "<table>", "</table>" ],
			col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
			tr: [ 2, "<table><tbody>", "</tbody></table>" ],
			td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
	
			_default: [ 0, "", "" ]
		};
	
	// Support: IE9
	wrapMap.optgroup = wrapMap.option;
	
	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;
	
	// Support: 1.x compatibility
	// Manipulating tables requires a tbody
	function manipulationTarget( elem, content ) {
		return jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?
	
			elem.getElementsByTagName("tbody")[0] ||
				elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
			elem;
	}
	
	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );
	
		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute("type");
		}
	
		return elem;
	}
	
	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			data_priv.set(
				elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
			);
		}
	}
	
	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
	
		if ( dest.nodeType !== 1 ) {
			return;
		}
	
		// 1. Copy private data: events, handlers, etc.
		if ( data_priv.hasData( src ) ) {
			pdataOld = data_priv.access( src );
			pdataCur = data_priv.set( dest, pdataOld );
			events = pdataOld.events;
	
			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};
	
				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}
	
		// 2. Copy user data
		if ( data_user.hasData( src ) ) {
			udataOld = data_user.access( src );
			udataCur = jQuery.extend( {}, udataOld );
	
			data_user.set( dest, udataCur );
		}
	}
	
	function getAll( context, tag ) {
		var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
				context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
				[];
	
		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}
	
	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();
	
		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;
	
		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}
	
	jQuery.extend({
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );
	
			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {
	
				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );
	
				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}
	
			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );
	
					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}
	
			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}
	
			// Return the cloned set
			return clone;
		},
	
		buildFragment: function( elems, context, scripts, selection ) {
			var elem, tmp, tag, wrap, contains, j,
				fragment = context.createDocumentFragment(),
				nodes = [],
				i = 0,
				l = elems.length;
	
			for ( ; i < l; i++ ) {
				elem = elems[ i ];
	
				if ( elem || elem === 0 ) {
	
					// Add nodes directly
					if ( jQuery.type( elem ) === "object" ) {
						// Support: QtWebKit, PhantomJS
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
	
					// Convert non-html into a text node
					} else if ( !rhtml.test( elem ) ) {
						nodes.push( context.createTextNode( elem ) );
	
					// Convert html into DOM nodes
					} else {
						tmp = tmp || fragment.appendChild( context.createElement("div") );
	
						// Deserialize a standard representation
						tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
						wrap = wrapMap[ tag ] || wrapMap._default;
						tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];
	
						// Descend through wrappers to the right content
						j = wrap[ 0 ];
						while ( j-- ) {
							tmp = tmp.lastChild;
						}
	
						// Support: QtWebKit, PhantomJS
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( nodes, tmp.childNodes );
	
						// Remember the top-level container
						tmp = fragment.firstChild;
	
						// Ensure the created nodes are orphaned (#12392)
						tmp.textContent = "";
					}
				}
			}
	
			// Remove wrapper from fragment
			fragment.textContent = "";
	
			i = 0;
			while ( (elem = nodes[ i++ ]) ) {
	
				// #4087 - If origin and destination elements are the same, and this is
				// that element, do not do anything
				if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
					continue;
				}
	
				contains = jQuery.contains( elem.ownerDocument, elem );
	
				// Append to fragment
				tmp = getAll( fragment.appendChild( elem ), "script" );
	
				// Preserve script evaluation history
				if ( contains ) {
					setGlobalEval( tmp );
				}
	
				// Capture executables
				if ( scripts ) {
					j = 0;
					while ( (elem = tmp[ j++ ]) ) {
						if ( rscriptType.test( elem.type || "" ) ) {
							scripts.push( elem );
						}
					}
				}
			}
	
			return fragment;
		},
	
		cleanData: function( elems ) {
			var data, elem, type, key,
				special = jQuery.event.special,
				i = 0;
	
			for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
				if ( jQuery.acceptData( elem ) ) {
					key = elem[ data_priv.expando ];
	
					if ( key && (data = data_priv.cache[ key ]) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );
	
								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
						if ( data_priv.cache[ key ] ) {
							// Discard any remaining `private` data
							delete data_priv.cache[ key ];
						}
					}
				}
				// Discard any remaining `user` data
				delete data_user.cache[ elem[ data_user.expando ] ];
			}
		}
	});
	
	jQuery.fn.extend({
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each(function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					});
			}, null, value, arguments.length );
		},
	
		append: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			});
		},
	
		prepend: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			});
		},
	
		before: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			});
		},
	
		after: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			});
		},
	
		remove: function( selector, keepData /* Internal Use Only */ ) {
			var elem,
				elems = selector ? jQuery.filter( selector, this ) : this,
				i = 0;
	
			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( getAll( elem ) );
				}
	
				if ( elem.parentNode ) {
					if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
						setGlobalEval( getAll( elem, "script" ) );
					}
					elem.parentNode.removeChild( elem );
				}
			}
	
			return this;
		},
	
		empty: function() {
			var elem,
				i = 0;
	
			for ( ; (elem = this[i]) != null; i++ ) {
				if ( elem.nodeType === 1 ) {
	
					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );
	
					// Remove any remaining nodes
					elem.textContent = "";
				}
			}
	
			return this;
		},
	
		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	
			return this.map(function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			});
		},
	
		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;
	
				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}
	
				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
	
					value = value.replace( rxhtmlTag, "<$1></$2>" );
	
					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};
	
							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}
	
						elem = 0;
	
					// If using innerHTML throws an exception, use the fallback method
					} catch( e ) {}
				}
	
				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},
	
		replaceWith: function() {
			var arg = arguments[ 0 ];
	
			// Make the changes, replacing each context element with the new content
			this.domManip( arguments, function( elem ) {
				arg = this.parentNode;
	
				jQuery.cleanData( getAll( this ) );
	
				if ( arg ) {
					arg.replaceChild( elem, this );
				}
			});
	
			// Force removal if there was no new content (e.g., from empty arguments)
			return arg && (arg.length || arg.nodeType) ? this : this.remove();
		},
	
		detach: function( selector ) {
			return this.remove( selector, true );
		},
	
		domManip: function( args, callback ) {
	
			// Flatten any nested arrays
			args = concat.apply( [], args );
	
			var fragment, first, scripts, hasScripts, node, doc,
				i = 0,
				l = this.length,
				set = this,
				iNoClone = l - 1,
				value = args[ 0 ],
				isFunction = jQuery.isFunction( value );
	
			// We can't cloneNode fragments that contain checked, in WebKit
			if ( isFunction ||
					( l > 1 && typeof value === "string" &&
						!support.checkClone && rchecked.test( value ) ) ) {
				return this.each(function( index ) {
					var self = set.eq( index );
					if ( isFunction ) {
						args[ 0 ] = value.call( this, index, self.html() );
					}
					self.domManip( args, callback );
				});
			}
	
			if ( l ) {
				fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
				first = fragment.firstChild;
	
				if ( fragment.childNodes.length === 1 ) {
					fragment = first;
				}
	
				if ( first ) {
					scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
					hasScripts = scripts.length;
	
					// Use the original fragment for the last item instead of the first because it can end up
					// being emptied incorrectly in certain situations (#8070).
					for ( ; i < l; i++ ) {
						node = fragment;
	
						if ( i !== iNoClone ) {
							node = jQuery.clone( node, true, true );
	
							// Keep references to cloned scripts for later restoration
							if ( hasScripts ) {
								// Support: QtWebKit
								// jQuery.merge because push.apply(_, arraylike) throws
								jQuery.merge( scripts, getAll( node, "script" ) );
							}
						}
	
						callback.call( this[ i ], node, i );
					}
	
					if ( hasScripts ) {
						doc = scripts[ scripts.length - 1 ].ownerDocument;
	
						// Reenable scripts
						jQuery.map( scripts, restoreScript );
	
						// Evaluate executable scripts on first document insertion
						for ( i = 0; i < hasScripts; i++ ) {
							node = scripts[ i ];
							if ( rscriptType.test( node.type || "" ) &&
								!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {
	
								if ( node.src ) {
									// Optional AJAX dependency, but won't run scripts if not present
									if ( jQuery._evalUrl ) {
										jQuery._evalUrl( node.src );
									}
								} else {
									jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
								}
							}
						}
					}
				}
			}
	
			return this;
		}
	});
	
	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;
	
			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );
	
				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply( ret, elems.get() );
			}
	
			return this.pushStack( ret );
		};
	});
	
	
	var iframe,
		elemdisplay = {};
	
	/**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */
	// Called only from within defaultDisplay
	function actualDisplay( name, doc ) {
		var style,
			elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
	
			// getDefaultComputedStyle might be reliably used only on attached element
			display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?
	
				// Use of this method is a temporary fix (more like optimization) until something better comes along,
				// since it was removed from specification and supported only in FF
				style.display : jQuery.css( elem[ 0 ], "display" );
	
		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();
	
		return display;
	}
	
	/**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */
	function defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];
	
		if ( !display ) {
			display = actualDisplay( nodeName, doc );
	
			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {
	
				// Use the already-created iframe if possible
				iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );
	
				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[ 0 ].contentDocument;
	
				// Support: IE
				doc.write();
				doc.close();
	
				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}
	
			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}
	
		return display;
	}
	var rmargin = (/^margin/);
	
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
	
	var getStyles = function( elem ) {
			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			if ( elem.ownerDocument.defaultView.opener ) {
				return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
			}
	
			return window.getComputedStyle( elem, null );
		};
	
	
	
	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;
	
		computed = computed || getStyles( elem );
	
		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];
		}
	
		if ( computed ) {
	
			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}
	
			// Support: iOS < 6
			// A tribute to the "awesome hack by Dean Edwards"
			// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {
	
				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;
	
				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;
	
				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}
	
		return ret !== undefined ?
			// Support: IE
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}
	
	
	function addGetHookIf( conditionFn, hookFn ) {
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}
	
				// Hook needed; redefine it so that the support test is not executed again.
				return (this.get = hookFn).apply( this, arguments );
			}
		};
	}
	
	
	(function() {
		var pixelPositionVal, boxSizingReliableVal,
			docElem = document.documentElement,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );
	
		if ( !div.style ) {
			return;
		}
	
		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";
	
		container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
			"position:absolute";
		container.appendChild( div );
	
		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computePixelPositionAndBoxSizingReliable() {
			div.style.cssText =
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
				"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
				"border:1px;padding:1px;width:4px;position:absolute";
			div.innerHTML = "";
			docElem.appendChild( container );
	
			var divStyle = window.getComputedStyle( div, null );
			pixelPositionVal = divStyle.top !== "1%";
			boxSizingReliableVal = divStyle.width === "4px";
	
			docElem.removeChild( container );
		}
	
		// Support: node.js jsdom
		// Don't assume that getComputedStyle is a property of the global object
		if ( window.getComputedStyle ) {
			jQuery.extend( support, {
				pixelPosition: function() {
	
					// This test is executed only once but we still do memoizing
					// since we can use the boxSizingReliable pre-computing.
					// No need to check if the test was already performed, though.
					computePixelPositionAndBoxSizingReliable();
					return pixelPositionVal;
				},
				boxSizingReliable: function() {
					if ( boxSizingReliableVal == null ) {
						computePixelPositionAndBoxSizingReliable();
					}
					return boxSizingReliableVal;
				},
				reliableMarginRight: function() {
	
					// Support: Android 2.3
					// Check if div with explicit width and no margin-right incorrectly
					// gets computed margin-right based on width of container. (#3333)
					// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
					// This support function is only executed once so no memoizing is needed.
					var ret,
						marginDiv = div.appendChild( document.createElement( "div" ) );
	
					// Reset CSS: box-sizing; display; margin; border; padding
					marginDiv.style.cssText = div.style.cssText =
						// Support: Firefox<29, Android 2.3
						// Vendor-prefix box-sizing
						"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
						"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
					marginDiv.style.marginRight = marginDiv.style.width = "0";
					div.style.width = "1px";
					docElem.appendChild( container );
	
					ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );
	
					docElem.removeChild( container );
					div.removeChild( marginDiv );
	
					return ret;
				}
			});
		}
	})();
	
	
	// A method for quickly swapping in/out CSS properties to get correct calculations.
	jQuery.swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};
	
		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}
	
		ret = callback.apply( elem, args || [] );
	
		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	
		return ret;
	};
	
	
	var
		// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
		rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),
	
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},
	
		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
	
	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( style, name ) {
	
		// Shortcut for names that are not vendor prefixed
		if ( name in style ) {
			return name;
		}
	
		// Check for vendor prefixed names
		var capName = name[0].toUpperCase() + name.slice(1),
			origName = name,
			i = cssPrefixes.length;
	
		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in style ) {
				return name;
			}
		}
	
		return origName;
	}
	
	function setPositiveNumber( elem, value, subtract ) {
		var matches = rnumsplit.exec( value );
		return matches ?
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
			value;
	}
	
	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?
			// If we already have the right measurement, avoid augmentation
			4 :
			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,
	
			val = 0;
	
		for ( ; i < 4; i += 2 ) {
			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}
	
			if ( isBorderBox ) {
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}
	
				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
	
				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}
	
		return val;
	}
	
	function getWidthOrHeight( elem, name, extra ) {
	
		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
	
		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}
	
			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test(val) ) {
				return val;
			}
	
			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );
	
			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}
	
		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}
	
	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;
	
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
	
			values[ index ] = data_priv.get( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {
				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}
	
				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
				}
			} else {
				hidden = isHidden( elem );
	
				if ( display !== "none" || !hidden ) {
					data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
				}
			}
		}
	
		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}
	
		return elements;
	}
	
	jQuery.extend({
	
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {
	
						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},
	
		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},
	
		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},
	
		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {
	
			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}
	
			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;
	
			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );
	
			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;
	
				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && (ret = rrelNum.exec( value )) ) {
					value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
					// Fixes bug #9237
					type = "number";
				}
	
				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}
	
				// If a number, add 'px' to the (except for certain CSS properties)
				if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
					value += "px";
				}
	
				// Support: IE9-11+
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}
	
				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
					style[ name ] = value;
				}
	
			} else {
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
					return ret;
				}
	
				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},
	
		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );
	
			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );
	
			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}
	
			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}
	
			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}
	
			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
			}
			return val;
		}
	});
	
	jQuery.each([ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {
	
					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
						jQuery.swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						}) :
						getWidthOrHeight( elem, name, extra );
				}
			},
	
			set: function( elem, value, extra ) {
				var styles = extra && getStyles( elem );
				return setPositiveNumber( elem, value, extra ?
					augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					) : 0
				);
			}
		};
	});
	
	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
		function( elem, computed ) {
			if ( computed ) {
				return jQuery.swap( elem, { "display": "inline-block" },
					curCSS, [ elem, "marginRight" ] );
			}
		}
	);
	
	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},
	
					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split(" ") : [ value ];
	
				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}
	
				return expanded;
			}
		};
	
		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	});
	
	jQuery.fn.extend({
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;
	
				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;
	
					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}
	
					return map;
				}
	
				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}
	
			return this.each(function() {
				if ( isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			});
		}
	});
	
	
	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;
	
	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || "swing";
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];
	
			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];
	
			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;
	
			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}
	
			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};
	
	Tween.prototype.init.prototype = Tween.prototype;
	
	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;
	
				if ( tween.elem[ tween.prop ] != null &&
					(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
					return tween.elem[ tween.prop ];
				}
	
				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};
	
	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};
	
	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		}
	};
	
	jQuery.fx = Tween.prototype.init;
	
	// Back Compat <1.8 extension point
	jQuery.fx.step = {};
	
	
	
	
	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
		rrun = /queueHooks$/,
		animationPrefilters = [ defaultPrefilter ],
		tweeners = {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value ),
					target = tween.cur(),
					parts = rfxnum.exec( value ),
					unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
	
					// Starting value computation is required for potential unit mismatches
					start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
						rfxnum.exec( jQuery.css( tween.elem, prop ) ),
					scale = 1,
					maxIterations = 20;
	
				if ( start && start[ 3 ] !== unit ) {
					// Trust units reported by jQuery.css
					unit = unit || start[ 3 ];
	
					// Make sure we update the tween properties later on
					parts = parts || [];
	
					// Iteratively approximate from a nonzero starting point
					start = +target || 1;
	
					do {
						// If previous iteration zeroed out, double until we get *something*.
						// Use string for doubling so we don't accidentally see scale as unchanged below
						scale = scale || ".5";
	
						// Adjust and apply
						start = start / scale;
						jQuery.style( tween.elem, prop, start + unit );
	
					// Update scale, tolerating zero or NaN from tween.cur(),
					// break the loop if scale is unchanged or perfect, or if we've just had enough
					} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
				}
	
				// Update tween properties
				if ( parts ) {
					start = tween.start = +start || +target || 0;
					tween.unit = unit;
					// If a +=/-= token was provided, we're doing a relative animation
					tween.end = parts[ 1 ] ?
						start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
						+parts[ 2 ];
				}
	
				return tween;
			} ]
		};
	
	// Animations created synchronously will run synchronously
	function createFxNow() {
		setTimeout(function() {
			fxNow = undefined;
		});
		return ( fxNow = jQuery.now() );
	}
	
	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };
	
		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}
	
		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}
	
		return attrs;
	}
	
	function createTween( value, prop, animation ) {
		var tween,
			collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( (tween = collection[ index ].call( animation, prop, value )) ) {
	
				// We're done with this property
				return tween;
			}
		}
	}
	
	function defaultPrefilter( elem, props, opts ) {
		/* jshint validthis: true */
		var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHidden( elem ),
			dataShow = data_priv.get( elem, "fxshow" );
	
		// Handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;
	
			anim.always(function() {
				// Ensure the complete handler is called before this completes
				anim.always(function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				});
			});
		}
	
		// Height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
	
			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css( elem, "display" );
	
			// Test default display if display is currently "none"
			checkDisplay = display === "none" ?
				data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;
	
			if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
				style.display = "inline-block";
			}
		}
	
		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	
		// show/hide pass
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {
	
					// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
	
			// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}
	
		if ( !jQuery.isEmptyObject( orig ) ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = data_priv.access( elem, "fxshow", {} );
			}
	
			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done(function() {
					jQuery( elem ).hide();
				});
			}
			anim.done(function() {
				var prop;
	
				data_priv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			});
			for ( prop in orig ) {
				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
	
				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}
	
		// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
			style.display = display;
		}
	}
	
	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;
	
		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}
	
			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}
	
			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];
	
				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}
	
	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = animationPrefilters.length,
			deferred = jQuery.Deferred().always( function() {
				// Don't match elem in the :animated selector
				delete tick.elem;
			}),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
					// Support: Android 2.3
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;
	
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}
	
				deferred.notifyWith( elem, [ animation, percent, remaining ]);
	
				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise({
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, { specialEasing: {} }, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}
	
					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			}),
			props = animation.props;
	
		propFilter( props, animation.opts.specialEasing );
	
		for ( ; index < length ; index++ ) {
			result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				return result;
			}
		}
	
		jQuery.map( props, createTween, animation );
	
		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}
	
		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			})
		);
	
		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}
	
	jQuery.Animation = jQuery.extend( Animation, {
	
		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.split(" ");
			}
	
			var prop,
				index = 0,
				length = props.length;
	
			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				tweeners[ prop ] = tweeners[ prop ] || [];
				tweeners[ prop ].unshift( callback );
			}
		},
	
		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				animationPrefilters.unshift( callback );
			} else {
				animationPrefilters.push( callback );
			}
		}
	});
	
	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};
	
		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
	
		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}
	
		// Queueing
		opt.old = opt.complete;
	
		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
	
			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};
	
		return opt;
	};
	
	jQuery.fn.extend({
		fadeTo: function( speed, to, easing, callback ) {
	
			// Show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()
	
				// Animate to the value specified
				.end().animate({ opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
	
					// Empty animations, or finishing resolves immediately
					if ( empty || data_priv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;
	
			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};
	
			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}
	
			return this.each(function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = data_priv.get( this );
	
				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}
	
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}
	
				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			});
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each(function() {
				var index,
					data = data_priv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;
	
				// Enable finishing flag on private data
				data.finish = true;
	
				// Empty the queue first
				jQuery.queue( this, type, [] );
	
				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}
	
				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}
	
				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}
	
				// Turn off finishing flag
				delete data.finish;
			});
		}
	});
	
	jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	});
	
	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	});
	
	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;
	
		fxNow = jQuery.now();
	
		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}
	
		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};
	
	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};
	
	jQuery.fx.interval = 13;
	
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};
	
	jQuery.fx.stop = function() {
		clearInterval( timerId );
		timerId = null;
	};
	
	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	};
	
	
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";
	
		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	};
	
	
	(function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );
	
		input.type = "checkbox";
	
		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";
	
		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;
	
		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;
	
		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	})();
	
	
	var nodeHook, boolHook,
		attrHandle = jQuery.expr.attrHandle;
	
	jQuery.fn.extend({
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},
	
		removeAttr: function( name ) {
			return this.each(function() {
				jQuery.removeAttr( this, name );
			});
		}
	});
	
	jQuery.extend({
		attr: function( elem, name, value ) {
			var hooks, ret,
				nType = elem.nodeType;
	
			// don't get/set attributes on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === strundefined ) {
				return jQuery.prop( elem, name, value );
			}
	
			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
			}
	
			if ( value !== undefined ) {
	
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
	
				} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
					return ret;
	
				} else {
					elem.setAttribute( name, value + "" );
					return value;
				}
	
			} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;
	
			} else {
				ret = jQuery.find.attr( elem, name );
	
				// Non-existent attributes return null, we normalize to undefined
				return ret == null ?
					undefined :
					ret;
			}
		},
	
		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( rnotwhite );
	
			if ( attrNames && elem.nodeType === 1 ) {
				while ( (name = attrNames[i++]) ) {
					propName = jQuery.propFix[ name ] || name;
	
					// Boolean attributes get special treatment (#10870)
					if ( jQuery.expr.match.bool.test( name ) ) {
						// Set corresponding property to false
						elem[ propName ] = false;
					}
	
					elem.removeAttribute( name );
				}
			}
		},
	
		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		}
	});
	
	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;
	
		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		};
	});
	
	
	
	
	var rfocusable = /^(?:input|select|textarea|button)$/i;
	
	jQuery.fn.extend({
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},
	
		removeProp: function( name ) {
			return this.each(function() {
				delete this[ jQuery.propFix[ name ] || name ];
			});
		}
	});
	
	jQuery.extend({
		propFix: {
			"for": "htmlFor",
			"class": "className"
		},
	
		prop: function( elem, name, value ) {
			var ret, hooks, notxml,
				nType = elem.nodeType;
	
			// Don't get/set properties on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
	
			if ( notxml ) {
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}
	
			if ( value !== undefined ) {
				return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
					ret :
					( elem[ name ] = value );
	
			} else {
				return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
					ret :
					elem[ name ];
			}
		},
	
		propHooks: {
			tabIndex: {
				get: function( elem ) {
					return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
						elem.tabIndex :
						-1;
				}
			}
		}
	});
	
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			}
		};
	}
	
	jQuery.each([
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	});
	
	
	
	
	var rclass = /[\t\r\n\f]/g;
	
	jQuery.fn.extend({
		addClass: function( value ) {
			var classes, elem, cur, clazz, j, finalValue,
				proceed = typeof value === "string" && value,
				i = 0,
				len = this.length;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).addClass( value.call( this, j, this.className ) );
				});
			}
	
			if ( proceed ) {
				// The disjunction here is for better compressibility (see removeClass)
				classes = ( value || "" ).match( rnotwhite ) || [];
	
				for ( ; i < len; i++ ) {
					elem = this[ i ];
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						" "
					);
	
					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}
	
						// only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( elem.className !== finalValue ) {
							elem.className = finalValue;
						}
					}
				}
			}
	
			return this;
		},
	
		removeClass: function( value ) {
			var classes, elem, cur, clazz, j, finalValue,
				proceed = arguments.length === 0 || typeof value === "string" && value,
				i = 0,
				len = this.length;
	
			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).removeClass( value.call( this, j, this.className ) );
				});
			}
			if ( proceed ) {
				classes = ( value || "" ).match( rnotwhite ) || [];
	
				for ( ; i < len; i++ ) {
					elem = this[ i ];
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						""
					);
	
					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = value ? jQuery.trim( cur ) : "";
						if ( elem.className !== finalValue ) {
							elem.className = finalValue;
						}
					}
				}
			}
	
			return this;
		},
	
		toggleClass: function( value, stateVal ) {
			var type = typeof value;
	
			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}
	
			if ( jQuery.isFunction( value ) ) {
				return this.each(function( i ) {
					jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
				});
			}
	
			return this.each(function() {
				if ( type === "string" ) {
					// Toggle individual class names
					var className,
						i = 0,
						self = jQuery( this ),
						classNames = value.match( rnotwhite ) || [];
	
					while ( (className = classNames[ i++ ]) ) {
						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}
	
				// Toggle whole class name
				} else if ( type === strundefined || type === "boolean" ) {
					if ( this.className ) {
						// store className if set
						data_priv.set( this, "__className__", this.className );
					}
	
					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
				}
			});
		},
	
		hasClass: function( selector ) {
			var className = " " + selector + " ",
				i = 0,
				l = this.length;
			for ( ; i < l; i++ ) {
				if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
					return true;
				}
			}
	
			return false;
		}
	});
	
	
	
	
	var rreturn = /\r/g;
	
	jQuery.fn.extend({
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[0];
	
			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];
	
					if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
						return ret;
					}
	
					ret = elem.value;
	
					return typeof ret === "string" ?
						// Handle most common string cases
						ret.replace(rreturn, "") :
						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}
	
				return;
			}
	
			isFunction = jQuery.isFunction( value );
	
			return this.each(function( i ) {
				var val;
	
				if ( this.nodeType !== 1 ) {
					return;
				}
	
				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}
	
				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";
	
				} else if ( typeof val === "number" ) {
					val += "";
	
				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					});
				}
	
				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
	
				// If set returns undefined, fall back to normal setting
				if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			});
		}
	});
	
	jQuery.extend({
		valHooks: {
			option: {
				get: function( elem ) {
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
						// Support: IE10-11+
						// option.text throws exceptions (#14686, #14858)
						jQuery.trim( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;
	
					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];
	
						// IE6-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
								// Don't return options that are disabled or in a disabled optgroup
								( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
								( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
	
							// Get the specific value for the option
							value = jQuery( option ).val();
	
							// We don't need an array for one selects
							if ( one ) {
								return value;
							}
	
							// Multi-Selects return an array
							values.push( value );
						}
					}
	
					return values;
				},
	
				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;
	
					while ( i-- ) {
						option = options[ i ];
						if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
							optionSet = true;
						}
					}
	
					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	});
	
	// Radios and checkboxes getter/setter
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute("value") === null ? "on" : elem.value;
			};
		}
	});
	
	
	
	
	// Return jQuery for attributes-only inclusion
	
	
	jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {
	
		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	});
	
	jQuery.fn.extend({
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		},
	
		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},
	
		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
		}
	});
	
	
	var nonce = jQuery.now();
	
	var rquery = (/\?/);
	
	
	
	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function( data ) {
		return JSON.parse( data + "" );
	};
	
	
	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
	
		// Support: IE9
		try {
			tmp = new DOMParser();
			xml = tmp.parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}
	
		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};
	
	
	var
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
		rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
	
		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},
	
		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},
	
		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),
	
		// Document location
		ajaxLocation = window.location.href,
	
		// Segment location into parts
		ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
	
	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {
	
		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {
	
			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}
	
			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];
	
			if ( jQuery.isFunction( func ) ) {
				// For each dataType in the dataTypeExpression
				while ( (dataType = dataTypes[i++]) ) {
					// Prepend if requested
					if ( dataType[0] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						(structure[ dataType ] = structure[ dataType ] || []).unshift( func );
	
					// Otherwise append
					} else {
						(structure[ dataType ] = structure[ dataType ] || []).push( func );
					}
				}
			}
		};
	}
	
	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
	
		var inspected = {},
			seekingTransport = ( structure === transports );
	
		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			});
			return selected;
		}
	
		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}
	
	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};
	
		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}
	
		return target;
	}
	
	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {
	
		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;
	
		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}
	
		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}
	
		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}
	
		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}
	
	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();
	
		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}
	
		current = dataTypes.shift();
	
		// Convert to each sequential dataType
		while ( current ) {
	
			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}
	
			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}
	
			prev = current;
			current = dataTypes.shift();
	
			if ( current ) {
	
			// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {
	
					current = prev;
	
				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {
	
					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];
	
					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {
	
							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {
	
								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];
	
									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}
	
					// Apply converter (if not an equivalence)
					if ( conv !== true ) {
	
						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s[ "throws" ] ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
							}
						}
					}
				}
			}
		}
	
		return { state: "success", data: response };
	}
	
	jQuery.extend({
	
		// Counter for holding the number of active queries
		active: 0,
	
		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},
	
		ajaxSettings: {
			url: ajaxLocation,
			type: "GET",
			isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/
	
			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
	
			contents: {
				xml: /xml/,
				html: /html/,
				json: /json/
			},
	
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
	
			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {
	
				// Convert anything to text
				"* text": String,
	
				// Text to html (true = no transformation)
				"text html": true,
	
				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,
	
				// Parse text as xml
				"text xml": jQuery.parseXML
			},
	
			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},
	
		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?
	
				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
	
				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},
	
		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),
	
		// Main method
		ajax: function( url, options ) {
	
			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}
	
			// Force options to be an object
			options = options || {};
	
			var transport,
				// URL without anti-cache param
				cacheURL,
				// Response headers
				responseHeadersString,
				responseHeaders,
				// timeout handle
				timeoutTimer,
				// Cross-domain detection vars
				parts,
				// To know if global events are to be dispatched
				fireGlobals,
				// Loop variable
				i,
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
				// Callbacks context
				callbackContext = s.context || s,
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks("once memory"),
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
				// The jqXHR state
				state = 0,
				// Default abort message
				strAbort = "canceled",
				// Fake xhr
				jqXHR = {
					readyState: 0,
	
					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( (match = rheaders.exec( responseHeadersString )) ) {
									responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},
	
					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},
	
					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},
	
					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},
	
					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {
									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},
	
					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};
	
			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;
	
			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
				.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
	
			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;
	
			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];
	
			// A cross-domain request is in order when we have a protocol:host:port mismatch
			if ( s.crossDomain == null ) {
				parts = rurl.exec( s.url.toLowerCase() );
				s.crossDomain = !!( parts &&
					( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
						( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
							( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
				);
			}
	
			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}
	
			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
	
			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}
	
			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;
	
			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger("ajaxStart");
			}
	
			// Uppercase the type
			s.type = s.type.toUpperCase();
	
			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );
	
			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;
	
			// More options handling for requests with no content
			if ( !s.hasContent ) {
	
				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}
	
				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?
	
						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + nonce++ ) :
	
						// Otherwise add one to the end
						cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
				}
			}
	
			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}
	
			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}
	
			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
					s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);
	
			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}
	
			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already and return
				return jqXHR.abort();
			}
	
			// Aborting is no longer a cancellation
			strAbort = "abort";
	
			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}
	
			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
	
			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;
	
				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = setTimeout(function() {
						jqXHR.abort("timeout");
					}, s.timeout );
				}
	
				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {
					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );
					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}
	
			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;
	
				// Called once
				if ( state === 2 ) {
					return;
				}
	
				// State is "done" now
				state = 2;
	
				// Clear timeout if it exists
				if ( timeoutTimer ) {
					clearTimeout( timeoutTimer );
				}
	
				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;
	
				// Cache response headers
				responseHeadersString = headers || "";
	
				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;
	
				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;
	
				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}
	
				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );
	
				// If successful, handle type chaining
				if ( isSuccess ) {
	
					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}
	
					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";
	
					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";
	
					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}
	
				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";
	
				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}
	
				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;
	
				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}
	
				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
	
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}
	
			return jqXHR;
		},
	
		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},
	
		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	});
	
	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}
	
			return jQuery.ajax({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			});
		};
	});
	
	
	jQuery._evalUrl = function( url ) {
		return jQuery.ajax({
			url: url,
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	};
	
	
	jQuery.fn.extend({
		wrapAll: function( html ) {
			var wrap;
	
			if ( jQuery.isFunction( html ) ) {
				return this.each(function( i ) {
					jQuery( this ).wrapAll( html.call(this, i) );
				});
			}
	
			if ( this[ 0 ] ) {
	
				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
	
				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}
	
				wrap.map(function() {
					var elem = this;
	
					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}
	
					return elem;
				}).append( this );
			}
	
			return this;
		},
	
		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each(function( i ) {
					jQuery( this ).wrapInner( html.call(this, i) );
				});
			}
	
			return this.each(function() {
				var self = jQuery( this ),
					contents = self.contents();
	
				if ( contents.length ) {
					contents.wrapAll( html );
	
				} else {
					self.append( html );
				}
			});
		},
	
		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );
	
			return this.each(function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
			});
		},
	
		unwrap: function() {
			return this.parent().each(function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			}).end();
		}
	});
	
	
	jQuery.expr.filters.hidden = function( elem ) {
		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
	};
	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
	
	
	
	
	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;
	
	function buildParams( prefix, obj, traditional, add ) {
		var name;
	
		if ( jQuery.isArray( obj ) ) {
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
					// Treat each array item as a scalar.
					add( prefix, v );
	
				} else {
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
				}
			});
	
		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}
	
		} else {
			// Serialize scalar item.
			add( prefix, obj );
		}
	}
	
	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};
	
		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}
	
		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});
	
		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}
	
		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};
	
	jQuery.fn.extend({
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map(function() {
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			})
			.filter(function() {
				var type = this.type;
	
				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			})
			.map(function( i, elem ) {
				var val = jQuery( this ).val();
	
				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						}) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			}).get();
		}
	});
	
	
	jQuery.ajaxSettings.xhr = function() {
		try {
			return new XMLHttpRequest();
		} catch( e ) {}
	};
	
	var xhrId = 0,
		xhrCallbacks = {},
		xhrSuccessStatus = {
			// file protocol always yields status code 0, assume 200
			0: 200,
			// Support: IE9
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();
	
	// Support: IE9
	// Open requests must be manually aborted on unload (#5280)
	// See https://support.microsoft.com/kb/2856746 for more info
	if ( window.attachEvent ) {
		window.attachEvent( "onunload", function() {
			for ( var key in xhrCallbacks ) {
				xhrCallbacks[ key ]();
			}
		});
	}
	
	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;
	
	jQuery.ajaxTransport(function( options ) {
		var callback;
	
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr(),
						id = ++xhrId;
	
					xhr.open( options.type, options.url, options.async, options.username, options.password );
	
					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}
	
					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}
	
					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}
	
					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}
	
					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								delete xhrCallbacks[ id ];
								callback = xhr.onload = xhr.onerror = null;
	
								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {
									complete(
										// file: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,
										// Support: IE9
										// Accessing binary-data responseText throws an exception
										// (#11426)
										typeof xhr.responseText === "string" ? {
											text: xhr.responseText
										} : undefined,
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};
	
					// Listen to events
					xhr.onload = callback();
					xhr.onerror = callback("error");
	
					// Create the abort callback
					callback = xhrCallbacks[ id ] = callback("abort");
	
					try {
						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},
	
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	});
	
	
	
	
	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /(?:java|ecma)script/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	});
	
	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	});
	
	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery("<script>").prop({
						async: true,
						charset: s.scriptCharset,
						src: s.url
					}).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	});
	
	
	
	
	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;
	
	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	});
	
	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
	
		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
			);
	
		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
	
			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;
	
			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}
	
			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};
	
			// force json dataType
			s.dataTypes[ 0 ] = "json";
	
			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};
	
			// Clean-up function (fires after converters)
			jqXHR.always(function() {
				// Restore preexisting value
				window[ callbackName ] = overwritten;
	
				// Save back as free
				if ( s[ callbackName ] ) {
					// make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;
	
					// save the callback name for future use
					oldCallbacks.push( callbackName );
				}
	
				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}
	
				responseContainer = overwritten = undefined;
			});
	
			// Delegate to script
			return "script";
		}
	});
	
	
	
	
	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;
	
		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];
	
		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[1] ) ];
		}
	
		parsed = jQuery.buildFragment( [ data ], context, scripts );
	
		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}
	
		return jQuery.merge( [], parsed.childNodes );
	};
	
	
	// Keep a copy of the old load method
	var _load = jQuery.fn.load;
	
	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}
	
		var selector, type, response,
			self = this,
			off = url.indexOf(" ");
	
		if ( off >= 0 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}
	
		// If it's a function
		if ( jQuery.isFunction( params ) ) {
	
			// We assume that it's the callback
			callback = params;
			params = undefined;
	
		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}
	
		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax({
				url: url,
	
				// if "type" variable is undefined, then "GET" method will be used
				type: type,
				dataType: "html",
				data: params
			}).done(function( responseText ) {
	
				// Save response for use in complete callback
				response = arguments;
	
				self.html( selector ?
	
					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :
	
					// Otherwise use the full result
					responseText );
	
			}).complete( callback && function( jqXHR, status ) {
				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
			});
		}
	
		return this;
	};
	
	
	
	
	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	});
	
	
	
	
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
	
	
	
	
	var docElem = window.document.documentElement;
	
	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}
	
	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};
	
			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}
	
			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf("auto") > -1;
	
			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
	
			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}
	
			if ( jQuery.isFunction( options ) ) {
				options = options.call( elem, i, curOffset );
			}
	
			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}
	
			if ( "using" in options ) {
				options.using.call( elem, props );
	
			} else {
				curElem.css( props );
			}
		}
	};
	
	jQuery.fn.extend({
		offset: function( options ) {
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each(function( i ) {
						jQuery.offset.setOffset( this, options, i );
					});
			}
	
			var docElem, win,
				elem = this[ 0 ],
				box = { top: 0, left: 0 },
				doc = elem && elem.ownerDocument;
	
			if ( !doc ) {
				return;
			}
	
			docElem = doc.documentElement;
	
			// Make sure it's not a disconnected DOM node
			if ( !jQuery.contains( docElem, elem ) ) {
				return box;
			}
	
			// Support: BlackBerry 5, iOS 3 (original iPhone)
			// If we don't have gBCR, just use 0,0 rather than error
			if ( typeof elem.getBoundingClientRect !== strundefined ) {
				box = elem.getBoundingClientRect();
			}
			win = getWindow( doc );
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},
	
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}
	
			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };
	
			// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
	
			} else {
				// Get *real* offsetParent
				offsetParent = this.offsetParent();
	
				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}
	
				// Add offsetParent borders
				parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
			}
	
			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},
	
		offsetParent: function() {
			return this.map(function() {
				var offsetParent = this.offsetParent || docElem;
	
				while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
					offsetParent = offsetParent.offsetParent;
				}
	
				return offsetParent || docElem;
			});
		}
	});
	
	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;
	
		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );
	
				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}
	
				if ( win ) {
					win.scrollTo(
						!top ? val : window.pageXOffset,
						top ? val : window.pageYOffset
					);
	
				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length, null );
		};
	});
	
	// Support: Safari<7+, Chrome<37+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	});
	
	
	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
	
				return access( this, function( elem, type, value ) {
					var doc;
	
					if ( jQuery.isWindow( elem ) ) {
						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}
	
					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;
	
						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}
	
					return value === undefined ?
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :
	
						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		});
	});
	
	
	// The number of elements contained in the matched element set
	jQuery.fn.size = function() {
		return this.length;
	};
	
	jQuery.fn.andSelf = jQuery.fn.addBack;
	
	
	
	
	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	
	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
	
	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	
	
	
	
	var
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
	
		// Map over the $ in case of overwrite
		_$ = window.$;
	
	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}
	
		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}
	
		return jQuery;
	};
	
	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( typeof noGlobal === strundefined ) {
		window.jQuery = window.$ = jQuery;
	}
	
	
	
	
	return jQuery;
	
	}));


/***/ },
/* 15 */
/*!**************************************!*\
  !*** ./~/bootstrap/js/transition.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/* ========================================================================
	 * Bootstrap: transition.js v3.3.4
	 * http://getbootstrap.com/javascript/#transitions
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
	  // ============================================================
	
	  function transitionEnd() {
	    var el = document.createElement('bootstrap')
	
	    var transEndEventNames = {
	      WebkitTransition : 'webkitTransitionEnd',
	      MozTransition    : 'transitionend',
	      OTransition      : 'oTransitionEnd otransitionend',
	      transition       : 'transitionend'
	    }
	
	    for (var name in transEndEventNames) {
	      if (el.style[name] !== undefined) {
	        return { end: transEndEventNames[name] }
	      }
	    }
	
	    return false // explicit for ie8 (  ._.)
	  }
	
	  // http://blog.alexmaccaw.com/css-transitions
	  $.fn.emulateTransitionEnd = function (duration) {
	    var called = false
	    var $el = this
	    $(this).one('bsTransitionEnd', function () { called = true })
	    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
	    setTimeout(callback, duration)
	    return this
	  }
	
	  $(function () {
	    $.support.transition = transitionEnd()
	
	    if (!$.support.transition) return
	
	    $.event.special.bsTransitionEnd = {
	      bindType: $.support.transition.end,
	      delegateType: $.support.transition.end,
	      handle: function (e) {
	        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
	      }
	    }
	  })
	
	}(jQuery);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 14)))

/***/ },
/* 16 */
/*!*********************************!*\
  !*** ./~/bootstrap/js/alert.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/* ========================================================================
	 * Bootstrap: alert.js v3.3.4
	 * http://getbootstrap.com/javascript/#alerts
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // ALERT CLASS DEFINITION
	  // ======================
	
	  var dismiss = '[data-dismiss="alert"]'
	  var Alert   = function (el) {
	    $(el).on('click', dismiss, this.close)
	  }
	
	  Alert.VERSION = '3.3.4'
	
	  Alert.TRANSITION_DURATION = 150
	
	  Alert.prototype.close = function (e) {
	    var $this    = $(this)
	    var selector = $this.attr('data-target')
	
	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	    }
	
	    var $parent = $(selector)
	
	    if (e) e.preventDefault()
	
	    if (!$parent.length) {
	      $parent = $this.closest('.alert')
	    }
	
	    $parent.trigger(e = $.Event('close.bs.alert'))
	
	    if (e.isDefaultPrevented()) return
	
	    $parent.removeClass('in')
	
	    function removeElement() {
	      // detach from parent, fire event then clean up data
	      $parent.detach().trigger('closed.bs.alert').remove()
	    }
	
	    $.support.transition && $parent.hasClass('fade') ?
	      $parent
	        .one('bsTransitionEnd', removeElement)
	        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
	      removeElement()
	  }
	
	
	  // ALERT PLUGIN DEFINITION
	  // =======================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this = $(this)
	      var data  = $this.data('bs.alert')
	
	      if (!data) $this.data('bs.alert', (data = new Alert(this)))
	      if (typeof option == 'string') data[option].call($this)
	    })
	  }
	
	  var old = $.fn.alert
	
	  $.fn.alert             = Plugin
	  $.fn.alert.Constructor = Alert
	
	
	  // ALERT NO CONFLICT
	  // =================
	
	  $.fn.alert.noConflict = function () {
	    $.fn.alert = old
	    return this
	  }
	
	
	  // ALERT DATA-API
	  // ==============
	
	  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)
	
	}(jQuery);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 14)))

/***/ },
/* 17 */
/*!**********************************!*\
  !*** ./~/bootstrap/js/button.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/* ========================================================================
	 * Bootstrap: button.js v3.3.4
	 * http://getbootstrap.com/javascript/#buttons
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // BUTTON PUBLIC CLASS DEFINITION
	  // ==============================
	
	  var Button = function (element, options) {
	    this.$element  = $(element)
	    this.options   = $.extend({}, Button.DEFAULTS, options)
	    this.isLoading = false
	  }
	
	  Button.VERSION  = '3.3.4'
	
	  Button.DEFAULTS = {
	    loadingText: 'loading...'
	  }
	
	  Button.prototype.setState = function (state) {
	    var d    = 'disabled'
	    var $el  = this.$element
	    var val  = $el.is('input') ? 'val' : 'html'
	    var data = $el.data()
	
	    state = state + 'Text'
	
	    if (data.resetText == null) $el.data('resetText', $el[val]())
	
	    // push to event loop to allow forms to submit
	    setTimeout($.proxy(function () {
	      $el[val](data[state] == null ? this.options[state] : data[state])
	
	      if (state == 'loadingText') {
	        this.isLoading = true
	        $el.addClass(d).attr(d, d)
	      } else if (this.isLoading) {
	        this.isLoading = false
	        $el.removeClass(d).removeAttr(d)
	      }
	    }, this), 0)
	  }
	
	  Button.prototype.toggle = function () {
	    var changed = true
	    var $parent = this.$element.closest('[data-toggle="buttons"]')
	
	    if ($parent.length) {
	      var $input = this.$element.find('input')
	      if ($input.prop('type') == 'radio') {
	        if ($input.prop('checked') && this.$element.hasClass('active')) changed = false
	        else $parent.find('.active').removeClass('active')
	      }
	      if (changed) $input.prop('checked', !this.$element.hasClass('active')).trigger('change')
	    } else {
	      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
	    }
	
	    if (changed) this.$element.toggleClass('active')
	  }
	
	
	  // BUTTON PLUGIN DEFINITION
	  // ========================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.button')
	      var options = typeof option == 'object' && option
	
	      if (!data) $this.data('bs.button', (data = new Button(this, options)))
	
	      if (option == 'toggle') data.toggle()
	      else if (option) data.setState(option)
	    })
	  }
	
	  var old = $.fn.button
	
	  $.fn.button             = Plugin
	  $.fn.button.Constructor = Button
	
	
	  // BUTTON NO CONFLICT
	  // ==================
	
	  $.fn.button.noConflict = function () {
	    $.fn.button = old
	    return this
	  }
	
	
	  // BUTTON DATA-API
	  // ===============
	
	  $(document)
	    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
	      var $btn = $(e.target)
	      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
	      Plugin.call($btn, 'toggle')
	      e.preventDefault()
	    })
	    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
	      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
	    })
	
	}(jQuery);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 14)))

/***/ },
/* 18 */
/*!************************************!*\
  !*** ./~/bootstrap/js/carousel.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/* ========================================================================
	 * Bootstrap: carousel.js v3.3.4
	 * http://getbootstrap.com/javascript/#carousel
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // CAROUSEL CLASS DEFINITION
	  // =========================
	
	  var Carousel = function (element, options) {
	    this.$element    = $(element)
	    this.$indicators = this.$element.find('.carousel-indicators')
	    this.options     = options
	    this.paused      = null
	    this.sliding     = null
	    this.interval    = null
	    this.$active     = null
	    this.$items      = null
	
	    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))
	
	    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
	      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
	      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
	  }
	
	  Carousel.VERSION  = '3.3.4'
	
	  Carousel.TRANSITION_DURATION = 600
	
	  Carousel.DEFAULTS = {
	    interval: 5000,
	    pause: 'hover',
	    wrap: true,
	    keyboard: true
	  }
	
	  Carousel.prototype.keydown = function (e) {
	    if (/input|textarea/i.test(e.target.tagName)) return
	    switch (e.which) {
	      case 37: this.prev(); break
	      case 39: this.next(); break
	      default: return
	    }
	
	    e.preventDefault()
	  }
	
	  Carousel.prototype.cycle = function (e) {
	    e || (this.paused = false)
	
	    this.interval && clearInterval(this.interval)
	
	    this.options.interval
	      && !this.paused
	      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))
	
	    return this
	  }
	
	  Carousel.prototype.getItemIndex = function (item) {
	    this.$items = item.parent().children('.item')
	    return this.$items.index(item || this.$active)
	  }
	
	  Carousel.prototype.getItemForDirection = function (direction, active) {
	    var activeIndex = this.getItemIndex(active)
	    var willWrap = (direction == 'prev' && activeIndex === 0)
	                || (direction == 'next' && activeIndex == (this.$items.length - 1))
	    if (willWrap && !this.options.wrap) return active
	    var delta = direction == 'prev' ? -1 : 1
	    var itemIndex = (activeIndex + delta) % this.$items.length
	    return this.$items.eq(itemIndex)
	  }
	
	  Carousel.prototype.to = function (pos) {
	    var that        = this
	    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))
	
	    if (pos > (this.$items.length - 1) || pos < 0) return
	
	    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
	    if (activeIndex == pos) return this.pause().cycle()
	
	    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
	  }
	
	  Carousel.prototype.pause = function (e) {
	    e || (this.paused = true)
	
	    if (this.$element.find('.next, .prev').length && $.support.transition) {
	      this.$element.trigger($.support.transition.end)
	      this.cycle(true)
	    }
	
	    this.interval = clearInterval(this.interval)
	
	    return this
	  }
	
	  Carousel.prototype.next = function () {
	    if (this.sliding) return
	    return this.slide('next')
	  }
	
	  Carousel.prototype.prev = function () {
	    if (this.sliding) return
	    return this.slide('prev')
	  }
	
	  Carousel.prototype.slide = function (type, next) {
	    var $active   = this.$element.find('.item.active')
	    var $next     = next || this.getItemForDirection(type, $active)
	    var isCycling = this.interval
	    var direction = type == 'next' ? 'left' : 'right'
	    var that      = this
	
	    if ($next.hasClass('active')) return (this.sliding = false)
	
	    var relatedTarget = $next[0]
	    var slideEvent = $.Event('slide.bs.carousel', {
	      relatedTarget: relatedTarget,
	      direction: direction
	    })
	    this.$element.trigger(slideEvent)
	    if (slideEvent.isDefaultPrevented()) return
	
	    this.sliding = true
	
	    isCycling && this.pause()
	
	    if (this.$indicators.length) {
	      this.$indicators.find('.active').removeClass('active')
	      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
	      $nextIndicator && $nextIndicator.addClass('active')
	    }
	
	    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
	    if ($.support.transition && this.$element.hasClass('slide')) {
	      $next.addClass(type)
	      $next[0].offsetWidth // force reflow
	      $active.addClass(direction)
	      $next.addClass(direction)
	      $active
	        .one('bsTransitionEnd', function () {
	          $next.removeClass([type, direction].join(' ')).addClass('active')
	          $active.removeClass(['active', direction].join(' '))
	          that.sliding = false
	          setTimeout(function () {
	            that.$element.trigger(slidEvent)
	          }, 0)
	        })
	        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
	    } else {
	      $active.removeClass('active')
	      $next.addClass('active')
	      this.sliding = false
	      this.$element.trigger(slidEvent)
	    }
	
	    isCycling && this.cycle()
	
	    return this
	  }
	
	
	  // CAROUSEL PLUGIN DEFINITION
	  // ==========================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.carousel')
	      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
	      var action  = typeof option == 'string' ? option : options.slide
	
	      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
	      if (typeof option == 'number') data.to(option)
	      else if (action) data[action]()
	      else if (options.interval) data.pause().cycle()
	    })
	  }
	
	  var old = $.fn.carousel
	
	  $.fn.carousel             = Plugin
	  $.fn.carousel.Constructor = Carousel
	
	
	  // CAROUSEL NO CONFLICT
	  // ====================
	
	  $.fn.carousel.noConflict = function () {
	    $.fn.carousel = old
	    return this
	  }
	
	
	  // CAROUSEL DATA-API
	  // =================
	
	  var clickHandler = function (e) {
	    var href
	    var $this   = $(this)
	    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
	    if (!$target.hasClass('carousel')) return
	    var options = $.extend({}, $target.data(), $this.data())
	    var slideIndex = $this.attr('data-slide-to')
	    if (slideIndex) options.interval = false
	
	    Plugin.call($target, options)
	
	    if (slideIndex) {
	      $target.data('bs.carousel').to(slideIndex)
	    }
	
	    e.preventDefault()
	  }
	
	  $(document)
	    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
	    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)
	
	  $(window).on('load', function () {
	    $('[data-ride="carousel"]').each(function () {
	      var $carousel = $(this)
	      Plugin.call($carousel, $carousel.data())
	    })
	  })
	
	}(jQuery);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 14)))

/***/ },
/* 19 */
/*!************************************!*\
  !*** ./~/bootstrap/js/collapse.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/* ========================================================================
	 * Bootstrap: collapse.js v3.3.4
	 * http://getbootstrap.com/javascript/#collapse
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // COLLAPSE PUBLIC CLASS DEFINITION
	  // ================================
	
	  var Collapse = function (element, options) {
	    this.$element      = $(element)
	    this.options       = $.extend({}, Collapse.DEFAULTS, options)
	    this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
	                           '[data-toggle="collapse"][data-target="#' + element.id + '"]')
	    this.transitioning = null
	
	    if (this.options.parent) {
	      this.$parent = this.getParent()
	    } else {
	      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
	    }
	
	    if (this.options.toggle) this.toggle()
	  }
	
	  Collapse.VERSION  = '3.3.4'
	
	  Collapse.TRANSITION_DURATION = 350
	
	  Collapse.DEFAULTS = {
	    toggle: true
	  }
	
	  Collapse.prototype.dimension = function () {
	    var hasWidth = this.$element.hasClass('width')
	    return hasWidth ? 'width' : 'height'
	  }
	
	  Collapse.prototype.show = function () {
	    if (this.transitioning || this.$element.hasClass('in')) return
	
	    var activesData
	    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')
	
	    if (actives && actives.length) {
	      activesData = actives.data('bs.collapse')
	      if (activesData && activesData.transitioning) return
	    }
	
	    var startEvent = $.Event('show.bs.collapse')
	    this.$element.trigger(startEvent)
	    if (startEvent.isDefaultPrevented()) return
	
	    if (actives && actives.length) {
	      Plugin.call(actives, 'hide')
	      activesData || actives.data('bs.collapse', null)
	    }
	
	    var dimension = this.dimension()
	
	    this.$element
	      .removeClass('collapse')
	      .addClass('collapsing')[dimension](0)
	      .attr('aria-expanded', true)
	
	    this.$trigger
	      .removeClass('collapsed')
	      .attr('aria-expanded', true)
	
	    this.transitioning = 1
	
	    var complete = function () {
	      this.$element
	        .removeClass('collapsing')
	        .addClass('collapse in')[dimension]('')
	      this.transitioning = 0
	      this.$element
	        .trigger('shown.bs.collapse')
	    }
	
	    if (!$.support.transition) return complete.call(this)
	
	    var scrollSize = $.camelCase(['scroll', dimension].join('-'))
	
	    this.$element
	      .one('bsTransitionEnd', $.proxy(complete, this))
	      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
	  }
	
	  Collapse.prototype.hide = function () {
	    if (this.transitioning || !this.$element.hasClass('in')) return
	
	    var startEvent = $.Event('hide.bs.collapse')
	    this.$element.trigger(startEvent)
	    if (startEvent.isDefaultPrevented()) return
	
	    var dimension = this.dimension()
	
	    this.$element[dimension](this.$element[dimension]())[0].offsetHeight
	
	    this.$element
	      .addClass('collapsing')
	      .removeClass('collapse in')
	      .attr('aria-expanded', false)
	
	    this.$trigger
	      .addClass('collapsed')
	      .attr('aria-expanded', false)
	
	    this.transitioning = 1
	
	    var complete = function () {
	      this.transitioning = 0
	      this.$element
	        .removeClass('collapsing')
	        .addClass('collapse')
	        .trigger('hidden.bs.collapse')
	    }
	
	    if (!$.support.transition) return complete.call(this)
	
	    this.$element
	      [dimension](0)
	      .one('bsTransitionEnd', $.proxy(complete, this))
	      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
	  }
	
	  Collapse.prototype.toggle = function () {
	    this[this.$element.hasClass('in') ? 'hide' : 'show']()
	  }
	
	  Collapse.prototype.getParent = function () {
	    return $(this.options.parent)
	      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
	      .each($.proxy(function (i, element) {
	        var $element = $(element)
	        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
	      }, this))
	      .end()
	  }
	
	  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
	    var isOpen = $element.hasClass('in')
	
	    $element.attr('aria-expanded', isOpen)
	    $trigger
	      .toggleClass('collapsed', !isOpen)
	      .attr('aria-expanded', isOpen)
	  }
	
	  function getTargetFromTrigger($trigger) {
	    var href
	    var target = $trigger.attr('data-target')
	      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7
	
	    return $(target)
	  }
	
	
	  // COLLAPSE PLUGIN DEFINITION
	  // ==========================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.collapse')
	      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)
	
	      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
	      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  var old = $.fn.collapse
	
	  $.fn.collapse             = Plugin
	  $.fn.collapse.Constructor = Collapse
	
	
	  // COLLAPSE NO CONFLICT
	  // ====================
	
	  $.fn.collapse.noConflict = function () {
	    $.fn.collapse = old
	    return this
	  }
	
	
	  // COLLAPSE DATA-API
	  // =================
	
	  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
	    var $this   = $(this)
	
	    if (!$this.attr('data-target')) e.preventDefault()
	
	    var $target = getTargetFromTrigger($this)
	    var data    = $target.data('bs.collapse')
	    var option  = data ? 'toggle' : $this.data()
	
	    Plugin.call($target, option)
	  })
	
	}(jQuery);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 14)))

/***/ },
/* 20 */
/*!************************************!*\
  !*** ./~/bootstrap/js/dropdown.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/* ========================================================================
	 * Bootstrap: dropdown.js v3.3.4
	 * http://getbootstrap.com/javascript/#dropdowns
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // DROPDOWN CLASS DEFINITION
	  // =========================
	
	  var backdrop = '.dropdown-backdrop'
	  var toggle   = '[data-toggle="dropdown"]'
	  var Dropdown = function (element) {
	    $(element).on('click.bs.dropdown', this.toggle)
	  }
	
	  Dropdown.VERSION = '3.3.4'
	
	  Dropdown.prototype.toggle = function (e) {
	    var $this = $(this)
	
	    if ($this.is('.disabled, :disabled')) return
	
	    var $parent  = getParent($this)
	    var isActive = $parent.hasClass('open')
	
	    clearMenus()
	
	    if (!isActive) {
	      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
	        // if mobile we use a backdrop because click events don't delegate
	        $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on('click', clearMenus)
	      }
	
	      var relatedTarget = { relatedTarget: this }
	      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))
	
	      if (e.isDefaultPrevented()) return
	
	      $this
	        .trigger('focus')
	        .attr('aria-expanded', 'true')
	
	      $parent
	        .toggleClass('open')
	        .trigger('shown.bs.dropdown', relatedTarget)
	    }
	
	    return false
	  }
	
	  Dropdown.prototype.keydown = function (e) {
	    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return
	
	    var $this = $(this)
	
	    e.preventDefault()
	    e.stopPropagation()
	
	    if ($this.is('.disabled, :disabled')) return
	
	    var $parent  = getParent($this)
	    var isActive = $parent.hasClass('open')
	
	    if ((!isActive && e.which != 27) || (isActive && e.which == 27)) {
	      if (e.which == 27) $parent.find(toggle).trigger('focus')
	      return $this.trigger('click')
	    }
	
	    var desc = ' li:not(.disabled):visible a'
	    var $items = $parent.find('[role="menu"]' + desc + ', [role="listbox"]' + desc)
	
	    if (!$items.length) return
	
	    var index = $items.index(e.target)
	
	    if (e.which == 38 && index > 0)                 index--                        // up
	    if (e.which == 40 && index < $items.length - 1) index++                        // down
	    if (!~index)                                      index = 0
	
	    $items.eq(index).trigger('focus')
	  }
	
	  function clearMenus(e) {
	    if (e && e.which === 3) return
	    $(backdrop).remove()
	    $(toggle).each(function () {
	      var $this         = $(this)
	      var $parent       = getParent($this)
	      var relatedTarget = { relatedTarget: this }
	
	      if (!$parent.hasClass('open')) return
	
	      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))
	
	      if (e.isDefaultPrevented()) return
	
	      $this.attr('aria-expanded', 'false')
	      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget)
	    })
	  }
	
	  function getParent($this) {
	    var selector = $this.attr('data-target')
	
	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	    }
	
	    var $parent = selector && $(selector)
	
	    return $parent && $parent.length ? $parent : $this.parent()
	  }
	
	
	  // DROPDOWN PLUGIN DEFINITION
	  // ==========================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this = $(this)
	      var data  = $this.data('bs.dropdown')
	
	      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
	      if (typeof option == 'string') data[option].call($this)
	    })
	  }
	
	  var old = $.fn.dropdown
	
	  $.fn.dropdown             = Plugin
	  $.fn.dropdown.Constructor = Dropdown
	
	
	  // DROPDOWN NO CONFLICT
	  // ====================
	
	  $.fn.dropdown.noConflict = function () {
	    $.fn.dropdown = old
	    return this
	  }
	
	
	  // APPLY TO STANDARD DROPDOWN ELEMENTS
	  // ===================================
	
	  $(document)
	    .on('click.bs.dropdown.data-api', clearMenus)
	    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
	    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
	    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
	    .on('keydown.bs.dropdown.data-api', '[role="menu"]', Dropdown.prototype.keydown)
	    .on('keydown.bs.dropdown.data-api', '[role="listbox"]', Dropdown.prototype.keydown)
	
	}(jQuery);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 14)))

/***/ },
/* 21 */
/*!***********************************!*\
  !*** ./~/bootstrap/js/tooltip.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/* ========================================================================
	 * Bootstrap: tooltip.js v3.3.4
	 * http://getbootstrap.com/javascript/#tooltip
	 * Inspired by the original jQuery.tipsy by Jason Frame
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // TOOLTIP PUBLIC CLASS DEFINITION
	  // ===============================
	
	  var Tooltip = function (element, options) {
	    this.type       = null
	    this.options    = null
	    this.enabled    = null
	    this.timeout    = null
	    this.hoverState = null
	    this.$element   = null
	
	    this.init('tooltip', element, options)
	  }
	
	  Tooltip.VERSION  = '3.3.4'
	
	  Tooltip.TRANSITION_DURATION = 150
	
	  Tooltip.DEFAULTS = {
	    animation: true,
	    placement: 'top',
	    selector: false,
	    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
	    trigger: 'hover focus',
	    title: '',
	    delay: 0,
	    html: false,
	    container: false,
	    viewport: {
	      selector: 'body',
	      padding: 0
	    }
	  }
	
	  Tooltip.prototype.init = function (type, element, options) {
	    this.enabled   = true
	    this.type      = type
	    this.$element  = $(element)
	    this.options   = this.getOptions(options)
	    this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport)
	
	    if (this.$element[0] instanceof document.constructor && !this.options.selector) {
	      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
	    }
	
	    var triggers = this.options.trigger.split(' ')
	
	    for (var i = triggers.length; i--;) {
	      var trigger = triggers[i]
	
	      if (trigger == 'click') {
	        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
	      } else if (trigger != 'manual') {
	        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
	        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'
	
	        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
	        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
	      }
	    }
	
	    this.options.selector ?
	      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
	      this.fixTitle()
	  }
	
	  Tooltip.prototype.getDefaults = function () {
	    return Tooltip.DEFAULTS
	  }
	
	  Tooltip.prototype.getOptions = function (options) {
	    options = $.extend({}, this.getDefaults(), this.$element.data(), options)
	
	    if (options.delay && typeof options.delay == 'number') {
	      options.delay = {
	        show: options.delay,
	        hide: options.delay
	      }
	    }
	
	    return options
	  }
	
	  Tooltip.prototype.getDelegateOptions = function () {
	    var options  = {}
	    var defaults = this.getDefaults()
	
	    this._options && $.each(this._options, function (key, value) {
	      if (defaults[key] != value) options[key] = value
	    })
	
	    return options
	  }
	
	  Tooltip.prototype.enter = function (obj) {
	    var self = obj instanceof this.constructor ?
	      obj : $(obj.currentTarget).data('bs.' + this.type)
	
	    if (self && self.$tip && self.$tip.is(':visible')) {
	      self.hoverState = 'in'
	      return
	    }
	
	    if (!self) {
	      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
	      $(obj.currentTarget).data('bs.' + this.type, self)
	    }
	
	    clearTimeout(self.timeout)
	
	    self.hoverState = 'in'
	
	    if (!self.options.delay || !self.options.delay.show) return self.show()
	
	    self.timeout = setTimeout(function () {
	      if (self.hoverState == 'in') self.show()
	    }, self.options.delay.show)
	  }
	
	  Tooltip.prototype.leave = function (obj) {
	    var self = obj instanceof this.constructor ?
	      obj : $(obj.currentTarget).data('bs.' + this.type)
	
	    if (!self) {
	      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
	      $(obj.currentTarget).data('bs.' + this.type, self)
	    }
	
	    clearTimeout(self.timeout)
	
	    self.hoverState = 'out'
	
	    if (!self.options.delay || !self.options.delay.hide) return self.hide()
	
	    self.timeout = setTimeout(function () {
	      if (self.hoverState == 'out') self.hide()
	    }, self.options.delay.hide)
	  }
	
	  Tooltip.prototype.show = function () {
	    var e = $.Event('show.bs.' + this.type)
	
	    if (this.hasContent() && this.enabled) {
	      this.$element.trigger(e)
	
	      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
	      if (e.isDefaultPrevented() || !inDom) return
	      var that = this
	
	      var $tip = this.tip()
	
	      var tipId = this.getUID(this.type)
	
	      this.setContent()
	      $tip.attr('id', tipId)
	      this.$element.attr('aria-describedby', tipId)
	
	      if (this.options.animation) $tip.addClass('fade')
	
	      var placement = typeof this.options.placement == 'function' ?
	        this.options.placement.call(this, $tip[0], this.$element[0]) :
	        this.options.placement
	
	      var autoToken = /\s?auto?\s?/i
	      var autoPlace = autoToken.test(placement)
	      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'
	
	      $tip
	        .detach()
	        .css({ top: 0, left: 0, display: 'block' })
	        .addClass(placement)
	        .data('bs.' + this.type, this)
	
	      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
	
	      var pos          = this.getPosition()
	      var actualWidth  = $tip[0].offsetWidth
	      var actualHeight = $tip[0].offsetHeight
	
	      if (autoPlace) {
	        var orgPlacement = placement
	        var $container   = this.options.container ? $(this.options.container) : this.$element.parent()
	        var containerDim = this.getPosition($container)
	
	        placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top'    :
	                    placement == 'top'    && pos.top    - actualHeight < containerDim.top    ? 'bottom' :
	                    placement == 'right'  && pos.right  + actualWidth  > containerDim.width  ? 'left'   :
	                    placement == 'left'   && pos.left   - actualWidth  < containerDim.left   ? 'right'  :
	                    placement
	
	        $tip
	          .removeClass(orgPlacement)
	          .addClass(placement)
	      }
	
	      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)
	
	      this.applyPlacement(calculatedOffset, placement)
	
	      var complete = function () {
	        var prevHoverState = that.hoverState
	        that.$element.trigger('shown.bs.' + that.type)
	        that.hoverState = null
	
	        if (prevHoverState == 'out') that.leave(that)
	      }
	
	      $.support.transition && this.$tip.hasClass('fade') ?
	        $tip
	          .one('bsTransitionEnd', complete)
	          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
	        complete()
	    }
	  }
	
	  Tooltip.prototype.applyPlacement = function (offset, placement) {
	    var $tip   = this.tip()
	    var width  = $tip[0].offsetWidth
	    var height = $tip[0].offsetHeight
	
	    // manually read margins because getBoundingClientRect includes difference
	    var marginTop = parseInt($tip.css('margin-top'), 10)
	    var marginLeft = parseInt($tip.css('margin-left'), 10)
	
	    // we must check for NaN for ie 8/9
	    if (isNaN(marginTop))  marginTop  = 0
	    if (isNaN(marginLeft)) marginLeft = 0
	
	    offset.top  = offset.top  + marginTop
	    offset.left = offset.left + marginLeft
	
	    // $.fn.offset doesn't round pixel values
	    // so we use setOffset directly with our own function B-0
	    $.offset.setOffset($tip[0], $.extend({
	      using: function (props) {
	        $tip.css({
	          top: Math.round(props.top),
	          left: Math.round(props.left)
	        })
	      }
	    }, offset), 0)
	
	    $tip.addClass('in')
	
	    // check to see if placing tip in new offset caused the tip to resize itself
	    var actualWidth  = $tip[0].offsetWidth
	    var actualHeight = $tip[0].offsetHeight
	
	    if (placement == 'top' && actualHeight != height) {
	      offset.top = offset.top + height - actualHeight
	    }
	
	    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)
	
	    if (delta.left) offset.left += delta.left
	    else offset.top += delta.top
	
	    var isVertical          = /top|bottom/.test(placement)
	    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
	    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'
	
	    $tip.offset(offset)
	    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
	  }
	
	  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
	    this.arrow()
	      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
	      .css(isVertical ? 'top' : 'left', '')
	  }
	
	  Tooltip.prototype.setContent = function () {
	    var $tip  = this.tip()
	    var title = this.getTitle()
	
	    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
	    $tip.removeClass('fade in top bottom left right')
	  }
	
	  Tooltip.prototype.hide = function (callback) {
	    var that = this
	    var $tip = $(this.$tip)
	    var e    = $.Event('hide.bs.' + this.type)
	
	    function complete() {
	      if (that.hoverState != 'in') $tip.detach()
	      that.$element
	        .removeAttr('aria-describedby')
	        .trigger('hidden.bs.' + that.type)
	      callback && callback()
	    }
	
	    this.$element.trigger(e)
	
	    if (e.isDefaultPrevented()) return
	
	    $tip.removeClass('in')
	
	    $.support.transition && $tip.hasClass('fade') ?
	      $tip
	        .one('bsTransitionEnd', complete)
	        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
	      complete()
	
	    this.hoverState = null
	
	    return this
	  }
	
	  Tooltip.prototype.fixTitle = function () {
	    var $e = this.$element
	    if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {
	      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
	    }
	  }
	
	  Tooltip.prototype.hasContent = function () {
	    return this.getTitle()
	  }
	
	  Tooltip.prototype.getPosition = function ($element) {
	    $element   = $element || this.$element
	
	    var el     = $element[0]
	    var isBody = el.tagName == 'BODY'
	
	    var elRect    = el.getBoundingClientRect()
	    if (elRect.width == null) {
	      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
	      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
	    }
	    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
	    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
	    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null
	
	    return $.extend({}, elRect, scroll, outerDims, elOffset)
	  }
	
	  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
	    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
	           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
	           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
	        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }
	
	  }
	
	  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
	    var delta = { top: 0, left: 0 }
	    if (!this.$viewport) return delta
	
	    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
	    var viewportDimensions = this.getPosition(this.$viewport)
	
	    if (/right|left/.test(placement)) {
	      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
	      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
	      if (topEdgeOffset < viewportDimensions.top) { // top overflow
	        delta.top = viewportDimensions.top - topEdgeOffset
	      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
	        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
	      }
	    } else {
	      var leftEdgeOffset  = pos.left - viewportPadding
	      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
	      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
	        delta.left = viewportDimensions.left - leftEdgeOffset
	      } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow
	        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
	      }
	    }
	
	    return delta
	  }
	
	  Tooltip.prototype.getTitle = function () {
	    var title
	    var $e = this.$element
	    var o  = this.options
	
	    title = $e.attr('data-original-title')
	      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)
	
	    return title
	  }
	
	  Tooltip.prototype.getUID = function (prefix) {
	    do prefix += ~~(Math.random() * 1000000)
	    while (document.getElementById(prefix))
	    return prefix
	  }
	
	  Tooltip.prototype.tip = function () {
	    return (this.$tip = this.$tip || $(this.options.template))
	  }
	
	  Tooltip.prototype.arrow = function () {
	    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
	  }
	
	  Tooltip.prototype.enable = function () {
	    this.enabled = true
	  }
	
	  Tooltip.prototype.disable = function () {
	    this.enabled = false
	  }
	
	  Tooltip.prototype.toggleEnabled = function () {
	    this.enabled = !this.enabled
	  }
	
	  Tooltip.prototype.toggle = function (e) {
	    var self = this
	    if (e) {
	      self = $(e.currentTarget).data('bs.' + this.type)
	      if (!self) {
	        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
	        $(e.currentTarget).data('bs.' + this.type, self)
	      }
	    }
	
	    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
	  }
	
	  Tooltip.prototype.destroy = function () {
	    var that = this
	    clearTimeout(this.timeout)
	    this.hide(function () {
	      that.$element.off('.' + that.type).removeData('bs.' + that.type)
	    })
	  }
	
	
	  // TOOLTIP PLUGIN DEFINITION
	  // =========================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.tooltip')
	      var options = typeof option == 'object' && option
	
	      if (!data && /destroy|hide/.test(option)) return
	      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  var old = $.fn.tooltip
	
	  $.fn.tooltip             = Plugin
	  $.fn.tooltip.Constructor = Tooltip
	
	
	  // TOOLTIP NO CONFLICT
	  // ===================
	
	  $.fn.tooltip.noConflict = function () {
	    $.fn.tooltip = old
	    return this
	  }
	
	}(jQuery);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 14)))

/***/ },
/* 22 */
/*!***********************************!*\
  !*** ./~/bootstrap/js/popover.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/* ========================================================================
	 * Bootstrap: popover.js v3.3.4
	 * http://getbootstrap.com/javascript/#popovers
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // POPOVER PUBLIC CLASS DEFINITION
	  // ===============================
	
	  var Popover = function (element, options) {
	    this.init('popover', element, options)
	  }
	
	  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')
	
	  Popover.VERSION  = '3.3.4'
	
	  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
	    placement: 'right',
	    trigger: 'click',
	    content: '',
	    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
	  })
	
	
	  // NOTE: POPOVER EXTENDS tooltip.js
	  // ================================
	
	  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)
	
	  Popover.prototype.constructor = Popover
	
	  Popover.prototype.getDefaults = function () {
	    return Popover.DEFAULTS
	  }
	
	  Popover.prototype.setContent = function () {
	    var $tip    = this.tip()
	    var title   = this.getTitle()
	    var content = this.getContent()
	
	    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
	    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
	      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
	    ](content)
	
	    $tip.removeClass('fade top bottom left right in')
	
	    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
	    // this manually by checking the contents.
	    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
	  }
	
	  Popover.prototype.hasContent = function () {
	    return this.getTitle() || this.getContent()
	  }
	
	  Popover.prototype.getContent = function () {
	    var $e = this.$element
	    var o  = this.options
	
	    return $e.attr('data-content')
	      || (typeof o.content == 'function' ?
	            o.content.call($e[0]) :
	            o.content)
	  }
	
	  Popover.prototype.arrow = function () {
	    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
	  }
	
	
	  // POPOVER PLUGIN DEFINITION
	  // =========================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.popover')
	      var options = typeof option == 'object' && option
	
	      if (!data && /destroy|hide/.test(option)) return
	      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  var old = $.fn.popover
	
	  $.fn.popover             = Plugin
	  $.fn.popover.Constructor = Popover
	
	
	  // POPOVER NO CONFLICT
	  // ===================
	
	  $.fn.popover.noConflict = function () {
	    $.fn.popover = old
	    return this
	  }
	
	}(jQuery);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 14)))

/***/ },
/* 23 */
/*!*************************************!*\
  !*** ./~/bootstrap/js/scrollspy.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/* ========================================================================
	 * Bootstrap: scrollspy.js v3.3.4
	 * http://getbootstrap.com/javascript/#scrollspy
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // SCROLLSPY CLASS DEFINITION
	  // ==========================
	
	  function ScrollSpy(element, options) {
	    this.$body          = $(document.body)
	    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
	    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
	    this.selector       = (this.options.target || '') + ' .nav li > a'
	    this.offsets        = []
	    this.targets        = []
	    this.activeTarget   = null
	    this.scrollHeight   = 0
	
	    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
	    this.refresh()
	    this.process()
	  }
	
	  ScrollSpy.VERSION  = '3.3.4'
	
	  ScrollSpy.DEFAULTS = {
	    offset: 10
	  }
	
	  ScrollSpy.prototype.getScrollHeight = function () {
	    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
	  }
	
	  ScrollSpy.prototype.refresh = function () {
	    var that          = this
	    var offsetMethod  = 'offset'
	    var offsetBase    = 0
	
	    this.offsets      = []
	    this.targets      = []
	    this.scrollHeight = this.getScrollHeight()
	
	    if (!$.isWindow(this.$scrollElement[0])) {
	      offsetMethod = 'position'
	      offsetBase   = this.$scrollElement.scrollTop()
	    }
	
	    this.$body
	      .find(this.selector)
	      .map(function () {
	        var $el   = $(this)
	        var href  = $el.data('target') || $el.attr('href')
	        var $href = /^#./.test(href) && $(href)
	
	        return ($href
	          && $href.length
	          && $href.is(':visible')
	          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
	      })
	      .sort(function (a, b) { return a[0] - b[0] })
	      .each(function () {
	        that.offsets.push(this[0])
	        that.targets.push(this[1])
	      })
	  }
	
	  ScrollSpy.prototype.process = function () {
	    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
	    var scrollHeight = this.getScrollHeight()
	    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
	    var offsets      = this.offsets
	    var targets      = this.targets
	    var activeTarget = this.activeTarget
	    var i
	
	    if (this.scrollHeight != scrollHeight) {
	      this.refresh()
	    }
	
	    if (scrollTop >= maxScroll) {
	      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
	    }
	
	    if (activeTarget && scrollTop < offsets[0]) {
	      this.activeTarget = null
	      return this.clear()
	    }
	
	    for (i = offsets.length; i--;) {
	      activeTarget != targets[i]
	        && scrollTop >= offsets[i]
	        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])
	        && this.activate(targets[i])
	    }
	  }
	
	  ScrollSpy.prototype.activate = function (target) {
	    this.activeTarget = target
	
	    this.clear()
	
	    var selector = this.selector +
	      '[data-target="' + target + '"],' +
	      this.selector + '[href="' + target + '"]'
	
	    var active = $(selector)
	      .parents('li')
	      .addClass('active')
	
	    if (active.parent('.dropdown-menu').length) {
	      active = active
	        .closest('li.dropdown')
	        .addClass('active')
	    }
	
	    active.trigger('activate.bs.scrollspy')
	  }
	
	  ScrollSpy.prototype.clear = function () {
	    $(this.selector)
	      .parentsUntil(this.options.target, '.active')
	      .removeClass('active')
	  }
	
	
	  // SCROLLSPY PLUGIN DEFINITION
	  // ===========================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.scrollspy')
	      var options = typeof option == 'object' && option
	
	      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  var old = $.fn.scrollspy
	
	  $.fn.scrollspy             = Plugin
	  $.fn.scrollspy.Constructor = ScrollSpy
	
	
	  // SCROLLSPY NO CONFLICT
	  // =====================
	
	  $.fn.scrollspy.noConflict = function () {
	    $.fn.scrollspy = old
	    return this
	  }
	
	
	  // SCROLLSPY DATA-API
	  // ==================
	
	  $(window).on('load.bs.scrollspy.data-api', function () {
	    $('[data-spy="scroll"]').each(function () {
	      var $spy = $(this)
	      Plugin.call($spy, $spy.data())
	    })
	  })
	
	}(jQuery);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 14)))

/***/ },
/* 24 */
/*!*******************************!*\
  !*** ./~/bootstrap/js/tab.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/* ========================================================================
	 * Bootstrap: tab.js v3.3.4
	 * http://getbootstrap.com/javascript/#tabs
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // TAB CLASS DEFINITION
	  // ====================
	
	  var Tab = function (element) {
	    this.element = $(element)
	  }
	
	  Tab.VERSION = '3.3.4'
	
	  Tab.TRANSITION_DURATION = 150
	
	  Tab.prototype.show = function () {
	    var $this    = this.element
	    var $ul      = $this.closest('ul:not(.dropdown-menu)')
	    var selector = $this.data('target')
	
	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	    }
	
	    if ($this.parent('li').hasClass('active')) return
	
	    var $previous = $ul.find('.active:last a')
	    var hideEvent = $.Event('hide.bs.tab', {
	      relatedTarget: $this[0]
	    })
	    var showEvent = $.Event('show.bs.tab', {
	      relatedTarget: $previous[0]
	    })
	
	    $previous.trigger(hideEvent)
	    $this.trigger(showEvent)
	
	    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return
	
	    var $target = $(selector)
	
	    this.activate($this.closest('li'), $ul)
	    this.activate($target, $target.parent(), function () {
	      $previous.trigger({
	        type: 'hidden.bs.tab',
	        relatedTarget: $this[0]
	      })
	      $this.trigger({
	        type: 'shown.bs.tab',
	        relatedTarget: $previous[0]
	      })
	    })
	  }
	
	  Tab.prototype.activate = function (element, container, callback) {
	    var $active    = container.find('> .active')
	    var transition = callback
	      && $.support.transition
	      && (($active.length && $active.hasClass('fade')) || !!container.find('> .fade').length)
	
	    function next() {
	      $active
	        .removeClass('active')
	        .find('> .dropdown-menu > .active')
	          .removeClass('active')
	        .end()
	        .find('[data-toggle="tab"]')
	          .attr('aria-expanded', false)
	
	      element
	        .addClass('active')
	        .find('[data-toggle="tab"]')
	          .attr('aria-expanded', true)
	
	      if (transition) {
	        element[0].offsetWidth // reflow for transition
	        element.addClass('in')
	      } else {
	        element.removeClass('fade')
	      }
	
	      if (element.parent('.dropdown-menu').length) {
	        element
	          .closest('li.dropdown')
	            .addClass('active')
	          .end()
	          .find('[data-toggle="tab"]')
	            .attr('aria-expanded', true)
	      }
	
	      callback && callback()
	    }
	
	    $active.length && transition ?
	      $active
	        .one('bsTransitionEnd', next)
	        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
	      next()
	
	    $active.removeClass('in')
	  }
	
	
	  // TAB PLUGIN DEFINITION
	  // =====================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this = $(this)
	      var data  = $this.data('bs.tab')
	
	      if (!data) $this.data('bs.tab', (data = new Tab(this)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  var old = $.fn.tab
	
	  $.fn.tab             = Plugin
	  $.fn.tab.Constructor = Tab
	
	
	  // TAB NO CONFLICT
	  // ===============
	
	  $.fn.tab.noConflict = function () {
	    $.fn.tab = old
	    return this
	  }
	
	
	  // TAB DATA-API
	  // ============
	
	  var clickHandler = function (e) {
	    e.preventDefault()
	    Plugin.call($(this), 'show')
	  }
	
	  $(document)
	    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
	    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)
	
	}(jQuery);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 14)))

/***/ },
/* 25 */
/*!*********************************!*\
  !*** ./~/bootstrap/js/affix.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/* ========================================================================
	 * Bootstrap: affix.js v3.3.4
	 * http://getbootstrap.com/javascript/#affix
	 * ========================================================================
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */
	
	
	+function ($) {
	  'use strict';
	
	  // AFFIX CLASS DEFINITION
	  // ======================
	
	  var Affix = function (element, options) {
	    this.options = $.extend({}, Affix.DEFAULTS, options)
	
	    this.$target = $(this.options.target)
	      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
	      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))
	
	    this.$element     = $(element)
	    this.affixed      = null
	    this.unpin        = null
	    this.pinnedOffset = null
	
	    this.checkPosition()
	  }
	
	  Affix.VERSION  = '3.3.4'
	
	  Affix.RESET    = 'affix affix-top affix-bottom'
	
	  Affix.DEFAULTS = {
	    offset: 0,
	    target: window
	  }
	
	  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
	    var scrollTop    = this.$target.scrollTop()
	    var position     = this.$element.offset()
	    var targetHeight = this.$target.height()
	
	    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false
	
	    if (this.affixed == 'bottom') {
	      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
	      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
	    }
	
	    var initializing   = this.affixed == null
	    var colliderTop    = initializing ? scrollTop : position.top
	    var colliderHeight = initializing ? targetHeight : height
	
	    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
	    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'
	
	    return false
	  }
	
	  Affix.prototype.getPinnedOffset = function () {
	    if (this.pinnedOffset) return this.pinnedOffset
	    this.$element.removeClass(Affix.RESET).addClass('affix')
	    var scrollTop = this.$target.scrollTop()
	    var position  = this.$element.offset()
	    return (this.pinnedOffset = position.top - scrollTop)
	  }
	
	  Affix.prototype.checkPositionWithEventLoop = function () {
	    setTimeout($.proxy(this.checkPosition, this), 1)
	  }
	
	  Affix.prototype.checkPosition = function () {
	    if (!this.$element.is(':visible')) return
	
	    var height       = this.$element.height()
	    var offset       = this.options.offset
	    var offsetTop    = offset.top
	    var offsetBottom = offset.bottom
	    var scrollHeight = $(document.body).height()
	
	    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
	    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
	    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)
	
	    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)
	
	    if (this.affixed != affix) {
	      if (this.unpin != null) this.$element.css('top', '')
	
	      var affixType = 'affix' + (affix ? '-' + affix : '')
	      var e         = $.Event(affixType + '.bs.affix')
	
	      this.$element.trigger(e)
	
	      if (e.isDefaultPrevented()) return
	
	      this.affixed = affix
	      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null
	
	      this.$element
	        .removeClass(Affix.RESET)
	        .addClass(affixType)
	        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
	    }
	
	    if (affix == 'bottom') {
	      this.$element.offset({
	        top: scrollHeight - height - offsetBottom
	      })
	    }
	  }
	
	
	  // AFFIX PLUGIN DEFINITION
	  // =======================
	
	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.affix')
	      var options = typeof option == 'object' && option
	
	      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }
	
	  var old = $.fn.affix
	
	  $.fn.affix             = Plugin
	  $.fn.affix.Constructor = Affix
	
	
	  // AFFIX NO CONFLICT
	  // =================
	
	  $.fn.affix.noConflict = function () {
	    $.fn.affix = old
	    return this
	  }
	
	
	  // AFFIX DATA-API
	  // ==============
	
	  $(window).on('load', function () {
	    $('[data-spy="affix"]').each(function () {
	      var $spy = $(this)
	      var data = $spy.data()
	
	      data.offset = data.offset || {}
	
	      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
	      if (data.offsetTop    != null) data.offset.top    = data.offsetTop
	
	      Plugin.call($spy, data)
	    })
	  })
	
	}(jQuery);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 14)))

/***/ },
/* 26 */,
/* 27 */
/*!***********************************!*\
  !*** ./~/mongoose/lib/browser.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/**
	 * The [MongooseError](#error_MongooseError) constructor.
	 *
	 * @method Error
	 * @api public
	 */
	
	exports.Error = __webpack_require__(/*! ./error */ 32);
	
	/**
	 * The Mongoose [Schema](#schema_Schema) constructor
	 *
	 * ####Example:
	 *
	 *     var mongoose = require('mongoose');
	 *     var Schema = mongoose.Schema;
	 *     var CatSchema = new Schema(..);
	 *
	 * @method Schema
	 * @api public
	 */
	
	exports.Schema = __webpack_require__(/*! ./schema */ 41);
	
	/**
	 * The various Mongoose Types.
	 *
	 * ####Example:
	 *
	 *     var mongoose = require('mongoose');
	 *     var array = mongoose.Types.Array;
	 *
	 * ####Types:
	 *
	 * - [ObjectId](#types-objectid-js)
	 * - [Buffer](#types-buffer-js)
	 * - [SubDocument](#types-embedded-js)
	 * - [Array](#types-array-js)
	 * - [DocumentArray](#types-documentarray-js)
	 *
	 * Using this exposed access to the `ObjectId` type, we can construct ids on demand.
	 *
	 *     var ObjectId = mongoose.Types.ObjectId;
	 *     var id1 = new ObjectId;
	 *
	 * @property Types
	 * @api public
	 */
	exports.Types = __webpack_require__(/*! ./types */ 197);
	
	/**
	 * The Mongoose [VirtualType](#virtualtype_VirtualType) constructor
	 *
	 * @method VirtualType
	 * @api public
	 */
	exports.VirtualType = __webpack_require__(/*! ./virtualtype */ 229);
	
	/**
	 * The various Mongoose SchemaTypes.
	 *
	 * ####Note:
	 *
	 * _Alias of mongoose.Schema.Types for backwards compatibility._
	 *
	 * @property SchemaTypes
	 * @see Schema.SchemaTypes #schema_Schema.Types
	 * @api public
	 */
	
	exports.SchemaType = __webpack_require__(/*! ./schematype.js */ 177);
	
	/**
	 * Internal utils
	 *
	 * @property utils
	 * @api private
	 */
	
	exports.utils = __webpack_require__(/*! ./utils.js */ 42);
	
	/**
	 * The Mongoose browser [Document](#document-js) constructor.
	 *
	 * @method Document
	 * @api public
	 */
	exports.Document = __webpack_require__(/*! ./document_provider.js */ 186)();
	
	/*!
	 * Module exports.
	 */
	
	if (typeof window !== 'undefined') {
	  window.mongoose = module.exports;
	  window.Buffer = Buffer;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 28 */
/*!***********************************************!*\
  !*** ./~/node-libs-browser/~/buffer/index.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	
	var base64 = __webpack_require__(/*! base64-js */ 29)
	var ieee754 = __webpack_require__(/*! ieee754 */ 30)
	var isArray = __webpack_require__(/*! is-array */ 31)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation
	
	var kMaxLength = 0x3fffffff
	var rootParent = {}
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Note:
	 *
	 * - Implementation must support adding new properties to `Uint8Array` instances.
	 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
	 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *    incorrect length in some situations.
	 *
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
	 * get the Object implementation, which is slower but will work correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = (function () {
	  try {
	    var buf = new ArrayBuffer(0)
	    var arr = new Uint8Array(buf)
	    arr.foo = function () { return 42 }
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	})()
	
	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }
	
	  this.length = 0
	  this.parent = undefined
	
	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }
	
	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }
	
	  // Unusual.
	  return fromObject(this, arg)
	}
	
	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
	
	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)
	
	  that.write(string, encoding)
	  return that
	}
	
	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)
	
	  if (isArray(object)) return fromArray(that, object)
	
	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined' && object.buffer instanceof ArrayBuffer) {
	    return fromTypedArray(that, object)
	  }
	
	  if (object.length) return fromArrayLike(that, object)
	
	  return fromJsonObject(that, object)
	}
	
	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}
	
	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0
	
	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)
	
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }
	
	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent
	
	  return that
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength.toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
	
	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break
	
	    ++i
	  }
	
	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
	
	  if (list.length === 0) {
	    return new Buffer(0)
	  } else if (list.length === 1) {
	    return list[0]
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }
	
	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}
	
	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = String(string)
	
	  if (string.length === 0) return 0
	
	  switch (encoding || 'utf8') {
	    case 'ascii':
	    case 'binary':
	    case 'raw':
	      return string.length
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return string.length * 2
	    case 'hex':
	      return string.length >>> 1
	    case 'utf8':
	    case 'utf-8':
	      return utf8ToBytes(string).length
	    case 'base64':
	      return base64ToBytes(string).length
	    default:
	      return string.length
	  }
	}
	Buffer.byteLength = byteLength
	
	// pre-set for values that may exist in the future
	Buffer.prototype.length = undefined
	Buffer.prototype.parent = undefined
	
	// toString(encoding, start=0, end=buffer.length)
	Buffer.prototype.toString = function toString (encoding, start, end) {
	  var loweredCase = false
	
	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0
	
	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'binary':
	        return binarySlice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0
	
	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1
	
	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
	
	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }
	
	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	// `get` will be removed in Node 0.13+
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}
	
	// `set` will be removed in Node 0.13+
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'binary':
	        return binaryWrite(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  var res = ''
	  var tmp = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    if (buf[i] <= 0x7F) {
	      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
	      tmp = ''
	    } else {
	      tmp += '%' + buf[i].toString(16)
	    }
	  }
	
	  return res + decodeUtf8Char(tmp)
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  if (newBuf.length) newBuf.parent = this.parent || this
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = value
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = value
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = value
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = value
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = value
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = value
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = value
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	
	  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }
	
	  return len
	}
	
	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length
	
	  if (end < start) throw new RangeError('end < start')
	
	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return
	
	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
	
	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var BP = Buffer.prototype
	
	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true
	
	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set
	
	  // deprecated, will be removed in node 0.13+
	  arr.get = BP.get
	  arr.set = BP.set
	
	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer
	
	  return arr
	}
	
	var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	  var i = 0
	
	  for (; i < length; i++) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (leadSurrogate) {
	        // 2 leads in a row
	        if (codePoint < 0xDC00) {
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          leadSurrogate = codePoint
	          continue
	        } else {
	          // valid surrogate pair
	          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
	          leadSurrogate = null
	        }
	      } else {
	        // no lead yet
	
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else {
	          // valid lead
	          leadSurrogate = codePoint
	          continue
	        }
	      }
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	      leadSurrogate = null
	    }
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x200000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	function decodeUtf8Char (str) {
	  try {
	    return decodeURIComponent(str)
	  } catch (err) {
	    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 29 */
/*!*************************************************************!*\
  !*** ./~/node-libs-browser/~/buffer/~/base64-js/lib/b64.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	
	;(function (exports) {
		'use strict';
	
	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array
	
		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)
	
		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}
	
		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr
	
			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}
	
			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0
	
			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)
	
			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length
	
			var L = 0
	
			function push (v) {
				arr[L++] = v
			}
	
			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}
	
			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}
	
			return arr
		}
	
		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length
	
			function encode (num) {
				return lookup.charAt(num)
			}
	
			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}
	
			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}
	
			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}
	
			return output
		}
	
		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}(false ? (this.base64js = {}) : exports))


/***/ },
/* 30 */
/*!*********************************************************!*\
  !*** ./~/node-libs-browser/~/buffer/~/ieee754/index.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m,
	      eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      nBits = -7,
	      i = isLE ? (nBytes - 1) : 0,
	      d = isLE ? -1 : 1,
	      s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c,
	      eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
	      i = isLE ? 0 : (nBytes - 1),
	      d = isLE ? 1 : -1,
	      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 31 */
/*!**********************************************************!*\
  !*** ./~/node-libs-browser/~/buffer/~/is-array/index.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * isArray
	 */
	
	var isArray = Array.isArray;
	
	/**
	 * toString
	 */
	
	var str = Object.prototype.toString;
	
	/**
	 * Whether or not the given `val`
	 * is an array.
	 *
	 * example:
	 *
	 *        isArray([]);
	 *        // > true
	 *        isArray(arguments);
	 *        // > false
	 *        isArray('');
	 *        // > false
	 *
	 * @param {mixed} val
	 * @return {bool}
	 */
	
	module.exports = isArray || function (val) {
	  return !! val && '[object Array]' == str.call(val);
	};


/***/ },
/* 32 */
/*!*********************************!*\
  !*** ./~/mongoose/lib/error.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * MongooseError constructor
	 *
	 * @param {String} msg Error message
	 * @inherits Error https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error
	 */
	
	function MongooseError (msg) {
	  Error.call(this);
	  Error.captureStackTrace && Error.captureStackTrace(this, arguments.callee);
	  this.message = msg;
	  this.name = 'MongooseError';
	};
	
	/*!
	 * Inherits from Error.
	 */
	
	MongooseError.prototype = Object.create(Error.prototype);
	MongooseError.prototype.constructor = Error;
	
	/*!
	 * Module exports.
	 */
	
	module.exports = exports = MongooseError;
	
	/**
	 * The default built-in validator error messages.
	 *
	 * @see Error.messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	MongooseError.messages = __webpack_require__(/*! ./error/messages */ 34);
	
	// backward compat
	MongooseError.Messages = MongooseError.messages;
	
	/*!
	 * Expose subclasses
	 */
	
	MongooseError.CastError = __webpack_require__(/*! ./error/cast */ 35);
	MongooseError.ValidationError = __webpack_require__(/*! ./error/validation */ 36)
	MongooseError.ValidatorError = __webpack_require__(/*! ./error/validator */ 37)
	MongooseError.VersionError =__webpack_require__(/*! ./error/version */ 33)
	MongooseError.OverwriteModelError = __webpack_require__(/*! ./error/overwriteModel */ 38)
	MongooseError.MissingSchemaError = __webpack_require__(/*! ./error/missingSchema */ 39)
	MongooseError.DivergentArrayError = __webpack_require__(/*! ./error/divergentArray */ 40)
	


/***/ },
/* 33 */
/*!*****************************************!*\
  !*** ./~/mongoose/lib/error/version.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(/*! ../error.js */ 32);
	
	/**
	 * Version Error constructor.
	 *
	 * @inherits MongooseError
	 * @api private
	 */
	
	function VersionError () {
	  MongooseError.call(this, 'No matching document found.');
	  Error.captureStackTrace && Error.captureStackTrace(this, arguments.callee);
	  this.name = 'VersionError';
	};
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	VersionError.prototype = Object.create(MongooseError.prototype);
	VersionError.prototype.constructor = MongooseError;
	
	/*!
	 * exports
	 */
	
	module.exports = VersionError;


/***/ },
/* 34 */
/*!******************************************!*\
  !*** ./~/mongoose/lib/error/messages.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * The default built-in validator error messages. These may be customized.
	 *
	 *     // customize within each schema or globally like so
	 *     var mongoose = require('mongoose');
	 *     mongoose.Error.messages.String.enum  = "Your custom message for {PATH}.";
	 *
	 * As you might have noticed, error messages support basic templating
	 *
	 * - `{PATH}` is replaced with the invalid document path
	 * - `{VALUE}` is replaced with the invalid value
	 * - `{TYPE}` is replaced with the validator type such as "regexp", "min", or "user defined"
	 * - `{MIN}` is replaced with the declared min value for the Number.min validator
	 * - `{MAX}` is replaced with the declared max value for the Number.max validator
	 *
	 * Click the "show code" link below to see all defaults.
	 *
	 * @property messages
	 * @receiver MongooseError
	 * @api public
	 */
	
	var msg = module.exports = exports = {};
	
	msg.general = {};
	msg.general.default = "Validator failed for path `{PATH}` with value `{VALUE}`";
	msg.general.required = "Path `{PATH}` is required.";
	
	msg.Number = {};
	msg.Number.min = "Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).";
	msg.Number.max = "Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).";
	
	msg.Date = {};
	msg.Date.min = "Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).";
	msg.Date.max = "Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).";
	
	msg.String = {};
	msg.String.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.";
	msg.String.match = "Path `{PATH}` is invalid ({VALUE}).";
	msg.String.minlength = "Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).";
	msg.String.maxlength = "Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).";
	


/***/ },
/* 35 */
/*!**************************************!*\
  !*** ./~/mongoose/lib/error/cast.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(/*! ../error.js */ 32);
	
	/**
	 * Casting Error constructor.
	 *
	 * @param {String} type
	 * @param {String} value
	 * @inherits MongooseError
	 * @api private
	 */
	
	function CastError (type, value, path) {
	  MongooseError.call(this, 'Cast to ' + type + ' failed for value "' + value + '" at path "' + path + '"');
	  Error.captureStackTrace && Error.captureStackTrace(this, arguments.callee);
	  this.name = 'CastError';
	  this.kind = type;
	  this.value = value;
	  this.path = path;
	};
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	CastError.prototype = Object.create(MongooseError.prototype);
	CastError.prototype.constructor = MongooseError;
	
	
	/*!
	 * exports
	 */
	
	module.exports = CastError;


/***/ },
/* 36 */
/*!********************************************!*\
  !*** ./~/mongoose/lib/error/validation.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module requirements
	 */
	
	var MongooseError = __webpack_require__(/*! ../error.js */ 32);
	
	/**
	 * Document Validation Error
	 *
	 * @api private
	 * @param {Document} instance
	 * @inherits MongooseError
	 */
	
	function ValidationError (instance) {
	  if (instance && instance.constructor.name === 'model') {
	    MongooseError.call(this, instance.constructor.modelName + " validation failed");
	  } else {
	    MongooseError.call(this, "Validation failed");
	  }
	  Error.captureStackTrace && Error.captureStackTrace(this, arguments.callee);
	  this.name = 'ValidationError';
	  this.errors = {};
	  if (instance) {
	    instance.errors = this.errors;
	  }
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	ValidationError.prototype = Object.create(MongooseError.prototype);
	ValidationError.prototype.constructor = MongooseError;
	
	
	/**
	 * Console.log helper
	 */
	
	ValidationError.prototype.toString = function () {
	  var ret = this.name + ': ';
	  var msgs = [];
	
	  Object.keys(this.errors).forEach(function (key) {
	    if (this == this.errors[key]) return;
	    msgs.push(String(this.errors[key]));
	  }, this);
	
	  return ret + msgs.join(', ');
	};
	
	/*!
	 * Module exports
	 */
	
	module.exports = exports = ValidationError;


/***/ },
/* 37 */
/*!*******************************************!*\
  !*** ./~/mongoose/lib/error/validator.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(/*! ../error.js */ 32);
	var errorMessages = MongooseError.messages;
	
	/**
	 * Schema validator error
	 *
	 * @param {Object} properties
	 * @inherits MongooseError
	 * @api private
	 */
	
	function ValidatorError (properties) {
	  var msg = properties.message;
	  if (!msg) {
	    msg = errorMessages.general.default;
	  }
	
	  this.properties = properties;
	  var message = this.formatMessage(msg, properties);
	  MongooseError.call(this, message);
	  Error.captureStackTrace && Error.captureStackTrace(this, arguments.callee);
	  this.name = 'ValidatorError';
	  this.kind = properties.type;
	  this.path = properties.path;
	  this.value = properties.value;
	};
	
	/*!
	 * Inherits from MongooseError
	 */
	
	ValidatorError.prototype = Object.create(MongooseError.prototype);
	ValidatorError.prototype.constructor = MongooseError;
	
	/*!
	 * Formats error messages
	 */
	
	ValidatorError.prototype.formatMessage = function (msg, properties) {
	  var propertyNames = Object.keys(properties);
	  for (var i = 0; i < propertyNames.length; ++i) {
	    var propertyName = propertyNames[i];
	    if (propertyName === 'message') {
	      continue;
	    }
	    msg = msg.replace('{' + propertyName.toUpperCase() + '}', properties[propertyName]);
	  }
	  return msg;
	};
	
	/*!
	 * toString helper
	 */
	
	ValidatorError.prototype.toString = function () {
	  return this.message;
	}
	
	/*!
	 * exports
	 */
	
	module.exports = ValidatorError;


/***/ },
/* 38 */
/*!************************************************!*\
  !*** ./~/mongoose/lib/error/overwriteModel.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(/*! ../error.js */ 32);
	
	/*!
	 * OverwriteModel Error constructor.
	 *
	 * @inherits MongooseError
	 */
	
	function OverwriteModelError (name) {
	  MongooseError.call(this, 'Cannot overwrite `' + name + '` model once compiled.');
	  Error.captureStackTrace && Error.captureStackTrace(this, arguments.callee);
	  this.name = 'OverwriteModelError';
	};
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	OverwriteModelError.prototype = Object.create(MongooseError.prototype);
	OverwriteModelError.prototype.constructor = MongooseError;
	
	/*!
	 * exports
	 */
	
	module.exports = OverwriteModelError;


/***/ },
/* 39 */
/*!***********************************************!*\
  !*** ./~/mongoose/lib/error/missingSchema.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(/*! ../error.js */ 32);
	
	/*!
	 * MissingSchema Error constructor.
	 *
	 * @inherits MongooseError
	 */
	
	function MissingSchemaError (name) {
	  var msg = 'Schema hasn\'t been registered for model "' + name + '".\n'
	          + 'Use mongoose.model(name, schema)';
	  MongooseError.call(this, msg);
	  Error.captureStackTrace && Error.captureStackTrace(this, arguments.callee);
	  this.name = 'MissingSchemaError';
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	MissingSchemaError.prototype = Object.create(MongooseError.prototype);
	MissingSchemaError.prototype.constructor = MongooseError;
	
	/*!
	 * exports
	 */
	
	module.exports = MissingSchemaError;


/***/ },
/* 40 */
/*!************************************************!*\
  !*** ./~/mongoose/lib/error/divergentArray.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(/*! ../error.js */ 32);
	
	/*!
	 * DivergentArrayError constructor.
	 *
	 * @inherits MongooseError
	 */
	
	function DivergentArrayError (paths) {
	  var msg = 'For your own good, using `document.save()` to update an array '
	          + 'which was selected using an $elemMatch projection OR '
	          + 'populated using skip, limit, query conditions, or exclusion of '
	          + 'the _id field when the operation results in a $pop or $set of '
	          + 'the entire array is not supported. The following '
	          + 'path(s) would have been modified unsafely:\n'
	          + '  ' + paths.join('\n  ') + '\n'
	          + 'Use Model.update() to update these arrays instead.'
	          // TODO write up a docs page (FAQ) and link to it
	
	  MongooseError.call(this, msg);
	  Error.captureStackTrace && Error.captureStackTrace(this, arguments.callee);
	  this.name = 'DivergentArrayError';
	};
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	DivergentArrayError.prototype = Object.create(MongooseError.prototype);
	DivergentArrayError.prototype.constructor = MongooseError;
	
	
	/*!
	 * exports
	 */
	
	module.exports = DivergentArrayError;


/***/ },
/* 41 */
/*!**********************************!*\
  !*** ./~/mongoose/lib/schema.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * Module dependencies.
	 */
	
	var readPref = __webpack_require__(/*! ./drivers */ 46).ReadPreference;
	var EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter;
	var VirtualType = __webpack_require__(/*! ./virtualtype */ 229);
	var utils = __webpack_require__(/*! ./utils */ 42);
	var MongooseTypes;
	var Kareem = __webpack_require__(/*! kareem */ 230);
	
	var IS_QUERY_HOOK = {
	  count: true,
	  find: true,
	  findOne: true,
	  findOneAndUpdate: true,
	  findOneAndRemove: true,
	  update: true
	};
	
	/**
	 * Schema constructor.
	 *
	 * ####Example:
	 *
	 *     var child = new Schema({ name: String });
	 *     var schema = new Schema({ name: String, age: Number, children: [child] });
	 *     var Tree = mongoose.model('Tree', schema);
	 *
	 *     // setting schema options
	 *     new Schema({ name: String }, { _id: false, autoIndex: false })
	 *
	 * ####Options:
	 *
	 * - [autoIndex](/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)
	 * - [bufferCommands](/docs/guide.html#bufferCommands): bool - defaults to true
	 * - [capped](/docs/guide.html#capped): bool - defaults to false
	 * - [collection](/docs/guide.html#collection): string - no default
	 * - [id](/docs/guide.html#id): bool - defaults to true
	 * - [_id](/docs/guide.html#_id): bool - defaults to true
	 * - `minimize`: bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true
	 * - [read](/docs/guide.html#read): string
	 * - [safe](/docs/guide.html#safe): bool - defaults to true.
	 * - [shardKey](/docs/guide.html#shardKey): bool - defaults to `null`
	 * - [strict](/docs/guide.html#strict): bool - defaults to true
	 * - [toJSON](/docs/guide.html#toJSON) - object - no default
	 * - [toObject](/docs/guide.html#toObject) - object - no default
	 * - [validateBeforeSave](/docs/guide.html#validateBeforeSave) - bool - defaults to `true`
	 * - [versionKey](/docs/guide.html#versionKey): bool - defaults to "__v"
	 *
	 * ####Note:
	 *
	 * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._
	 *
	 * @param {Object} definition
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `init`: Emitted after the schema is compiled into a `Model`.
	 * @api public
	 */
	
	function Schema (obj, options) {
	  if (!(this instanceof Schema))
	    return new Schema(obj, options);
	
	  this.paths = {};
	  this.subpaths = {};
	  this.virtuals = {};
	  this.nested = {};
	  this.inherits = {};
	  this.callQueue = [];
	  this._indexes = [];
	  this.methods = {};
	  this.statics = {};
	  this.tree = {};
	  this._requiredpaths = undefined;
	  this.discriminatorMapping = undefined;
	  this._indexedpaths = undefined;
	
	  this.s = {
	    hooks: new Kareem(),
	    queryHooks: IS_QUERY_HOOK
	  };
	
	  this.options = this.defaultOptions(options);
	
	  // build paths
	  if (obj) {
	    this.add(obj);
	  }
	
	  // check if _id's value is a subdocument (gh-2276)
	  var _idSubDoc = obj && obj._id && utils.isObject(obj._id);
	
	  // ensure the documents get an auto _id unless disabled
	  var auto_id = !this.paths['_id'] && (!this.options.noId && this.options._id) && !_idSubDoc;
	
	  if (auto_id) {
	    this.add({ _id: {type: Schema.ObjectId, auto: true} });
	  }
	
	  // ensure the documents receive an id getter unless disabled
	  var autoid = !this.paths['id'] && (!this.options.noVirtualId && this.options.id);
	  if (autoid) {
	    this.virtual('id').get(idGetter);
	  }
	
	  for (var i = 0; i < this._defaultMiddleware.length; ++i) {
	    var m = this._defaultMiddleware[i];
	    this[m.kind](m.hook, m.fn);
	  }
	
	  // adds updatedAt and createdAt timestamps to documents if enabled
	  var timestamps = this.options.timestamps;
	  if (timestamps) {
	    var createdAt = timestamps.createdAt || 'createdAt'
	      , updatedAt = timestamps.updatedAt || 'updatedAt'
	      , schemaAdditions = {};
	
	    schemaAdditions[updatedAt] = Date;
	
	    if (!this.paths[createdAt]) {
	      schemaAdditions[createdAt] = Date;
	    }
	
	    this.add(schemaAdditions);
	
	    this.pre('save', function (next) {
	      var defaultTimestamp = new Date();
	
	      if (!this[createdAt]){
	        this[createdAt] = auto_id ? this._id.getTimestamp() : defaultTimestamp;
	      }
	
	      this[updatedAt] = this.isNew ? this[createdAt] : defaultTimestamp;
	
	      next();
	    });
	  }
	
	}
	
	/*!
	 * Returns this documents _id cast to a string.
	 */
	
	function idGetter () {
	  if (this.$__._id) {
	    return this.$__._id;
	  }
	
	  return this.$__._id = null == this._id
	    ? null
	    : String(this._id);
	}
	
	/*!
	 * Inherit from EventEmitter.
	 */
	Schema.prototype = Object.create( EventEmitter.prototype );
	Schema.prototype.constructor = Schema;
	
	/**
	 * Default middleware attached to a schema. Cannot be changed.
	 *
	 * This field is used to make sure discriminators don't get multiple copies of
	 * built-in middleware. Declared as a constant because changing this at runtime
	 * may lead to instability with Model.prototype.discriminator().
	 *
	 * @api private
	 * @property _defaultMiddleware
	 */
	Object.defineProperty(Schema.prototype, '_defaultMiddleware', {
	  configurable: false,
	  enumerable: false,
	  writable: false,
	  value: [
	    {
	      kind: 'pre',
	      hook: 'save',
	      fn: function(next) {
	        // Nested docs have their own presave
	        if (this.ownerDocument) {
	          return next();
	        }
	
	        // Validate
	        if (this.schema.options.validateBeforeSave) {
	          this.validate(next);
	        } else {
	          next();
	        }
	      }
	    }
	  ]
	});
	
	/**
	 * Schema as flat paths
	 *
	 * ####Example:
	 *     {
	 *         '_id'        : SchemaType,
	 *       , 'nested.key' : SchemaType,
	 *     }
	 *
	 * @api private
	 * @property paths
	 */
	
	Schema.prototype.paths;
	
	/**
	 * Schema as a tree
	 *
	 * ####Example:
	 *     {
	 *         '_id'     : ObjectId
	 *       , 'nested'  : {
	 *             'key' : String
	 *         }
	 *     }
	 *
	 * @api private
	 * @property tree
	 */
	
	Schema.prototype.tree;
	
	/**
	 * Returns default options for this schema, merged with `options`.
	 *
	 * @param {Object} options
	 * @return {Object}
	 * @api private
	 */
	
	Schema.prototype.defaultOptions = function (options) {
	  if (options && false === options.safe) {
	    options.safe = { w: 0 };
	  }
	
	  if (options && options.safe && 0 === options.safe.w) {
	    // if you turn off safe writes, then versioning goes off as well
	    options.versionKey = false;
	  }
	
	  options = utils.options({
	      strict: true
	    , bufferCommands: true
	    , capped: false // { size, max, autoIndexId }
	    , versionKey: '__v'
	    , discriminatorKey: '__t'
	    , minimize: true
	    , autoIndex: null
	    , shardKey: null
	    , read: null
	    , validateBeforeSave: true
	    // the following are only applied at construction time
	    , noId: false // deprecated, use { _id: false }
	    , _id: true
	    , noVirtualId: false // deprecated, use { id: false }
	    , id: true
	//    , pluralization: true  // only set this to override the global option
	  }, options);
	
	  if (options.read) {
	    options.read = readPref(options.read);
	  }
	
	  return options;
	}
	
	/**
	 * Adds key path / schema type pairs to this schema.
	 *
	 * ####Example:
	 *
	 *     var ToySchema = new Schema;
	 *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });
	 *
	 * @param {Object} obj
	 * @param {String} prefix
	 * @api public
	 */
	
	Schema.prototype.add = function add (obj, prefix) {
	  prefix = prefix || '';
	  var keys = Object.keys(obj);
	
	  for (var i = 0; i < keys.length; ++i) {
	    var key = keys[i];
	
	    if (null == obj[key]) {
	      throw new TypeError('Invalid value for schema path `'+ prefix + key +'`');
	    }
	
	    if (Array.isArray(obj[key]) && obj[key].length === 1 && null == obj[key][0]) {
	      throw new TypeError('Invalid value for schema Array path `'+ prefix + key +'`');
	    }
	
	    if (utils.isObject(obj[key]) && (!obj[key].constructor || 'Object' == utils.getFunctionName(obj[key].constructor)) && (!obj[key].type || obj[key].type.type)) {
	      if (Object.keys(obj[key]).length) {
	        // nested object { last: { name: String }}
	        this.nested[prefix + key] = true;
	        this.add(obj[key], prefix + key + '.');
	      } else {
	        this.path(prefix + key, obj[key]); // mixed type
	      }
	    } else {
	      this.path(prefix + key, obj[key]);
	    }
	  }
	};
	
	/**
	 * Reserved document keys.
	 *
	 * Keys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error.
	 *
	 *      on, emit, _events, db, get, set, init, isNew, errors, schema, options, modelName, collection, _pres, _posts, toObject
	 *
	 * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.
	 *
	 *      var schema = new Schema(..);
	 *      schema.methods.init = function () {} // potentially breaking
	 */
	
	Schema.reserved = Object.create(null);
	var reserved = Schema.reserved;
	// EventEmitter
	reserved.emit =
	reserved.on =
	reserved.once =
	// document properties and functions
	reserved.collection =
	reserved.db =
	reserved.errors =
	reserved.init =
	reserved.isModified =
	reserved.isNew =
	reserved.get =
	reserved.modelName =
	reserved.save =
	reserved.schema =
	reserved.set =
	reserved.toObject =
	reserved.validate =
	// hooks.js
	reserved._pres = reserved._posts = 1;
	
	var warnings = {};
	warnings.increment = '`increment` should not be used as a schema path name ' +
	  'unless you have disabled versioning.';
	
	/**
	 * Gets/sets schema paths.
	 *
	 * Sets a path (if arity 2)
	 * Gets a path (if arity 1)
	 *
	 * ####Example
	 *
	 *     schema.path('name') // returns a SchemaType
	 *     schema.path('name', Number) // changes the schemaType of `name` to Number
	 *
	 * @param {String} path
	 * @param {Object} constructor
	 * @api public
	 */
	
	Schema.prototype.path = function (path, obj) {
	  if (obj == undefined) {
	    if (this.paths[path]) return this.paths[path];
	    if (this.subpaths[path]) return this.subpaths[path];
	
	    // subpaths?
	    return /\.\d+\.?.*$/.test(path)
	      ? getPositionalPath(this, path)
	      : undefined;
	  }
	
	  // some path names conflict with document methods
	  if (reserved[path]) {
	    throw new Error("`" + path + "` may not be used as a schema pathname");
	  }
	
	  if (warnings[path]) {
	    console.log('WARN: ' + warnings[path]);
	  }
	
	  // update the tree
	  var subpaths = path.split(/\./)
	    , last = subpaths.pop()
	    , branch = this.tree;
	
	  subpaths.forEach(function(sub, i) {
	    if (!branch[sub]) branch[sub] = {};
	    if ('object' != typeof branch[sub]) {
	      var msg = 'Cannot set nested path `' + path + '`. '
	              + 'Parent path `'
	              + subpaths.slice(0, i).concat([sub]).join('.')
	              + '` already set to type ' + branch[sub].name
	              + '.';
	      throw new Error(msg);
	    }
	    branch = branch[sub];
	  });
	
	  branch[last] = utils.clone(obj);
	
	  this.paths[path] = Schema.interpretAsType(path, obj);
	  return this;
	};
	
	/**
	 * Converts type arguments into Mongoose Types.
	 *
	 * @param {String} path
	 * @param {Object} obj constructor
	 * @api private
	 */
	
	Schema.interpretAsType = function (path, obj) {
	  if (obj.constructor) {
	    var constructorName = utils.getFunctionName(obj.constructor);
	    if (constructorName != 'Object') {
	      obj = { type: obj };
	    }
	  }
	
	  // Get the type making sure to allow keys named "type"
	  // and default to mixed if not specified.
	  // { type: { type: String, default: 'freshcut' } }
	  var type = obj.type && !obj.type.type
	    ? obj.type
	    : {};
	
	  if ('Object' == utils.getFunctionName(type.constructor) || 'mixed' == type) {
	    return new MongooseTypes.Mixed(path, obj);
	  }
	
	  if (Array.isArray(type) || Array == type || 'array' == type) {
	    // if it was specified through { type } look for `cast`
	    var cast = (Array == type || 'array' == type)
	      ? obj.cast
	      : type[0];
	
	    if (cast instanceof Schema) {
	      return new MongooseTypes.DocumentArray(path, cast, obj);
	    }
	
	    if ('string' == typeof cast) {
	      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];
	    } else if (cast && (!cast.type || cast.type.type)
	                    && 'Object' == utils.getFunctionName(cast.constructor)
	                    && Object.keys(cast).length) {
	      return new MongooseTypes.DocumentArray(path, new Schema(cast), obj);
	    }
	
	    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj);
	  }
	
	  var name;
	  if (Buffer.isBuffer(type)) {
	    name = 'Buffer';
	  } else {
	    name = 'string' == typeof type
	      ? type
	      // If not string, `type` is a function. Outside of IE, function.name
	      // gives you the function name. In IE, you need to compute it
	      : type.schemaName || utils.getFunctionName(type);
	  }
	
	  if (name) {
	    name = name.charAt(0).toUpperCase() + name.substring(1);
	  }
	
	  if (undefined == MongooseTypes[name]) {
	    throw new TypeError('Undefined type `' + name + '` at `' + path +
	        '`\n  Did you try nesting Schemas? ' +
	        'You can only nest using refs or arrays.');
	  }
	
	  return new MongooseTypes[name](path, obj);
	};
	
	/**
	 * Iterates the schemas paths similar to Array#forEach.
	 *
	 * The callback is passed the pathname and schemaType as arguments on each iteration.
	 *
	 * @param {Function} fn callback function
	 * @return {Schema} this
	 * @api public
	 */
	
	Schema.prototype.eachPath = function (fn) {
	  var keys = Object.keys(this.paths)
	    , len = keys.length;
	
	  for (var i = 0; i < len; ++i) {
	    fn(keys[i], this.paths[keys[i]]);
	  }
	
	  return this;
	};
	
	/**
	 * Returns an Array of path strings that are required by this schema.
	 *
	 * @api public
	 * @return {Array}
	 */
	
	Schema.prototype.requiredPaths = function requiredPaths () {
	  if (this._requiredpaths) return this._requiredpaths;
	
	  var paths = Object.keys(this.paths)
	    , i = paths.length
	    , ret = [];
	
	  while (i--) {
	    var path = paths[i];
	    if (this.paths[path].isRequired) ret.push(path);
	  }
	
	  return this._requiredpaths = ret;
	}
	
	/**
	 * Returns indexes from fields and schema-level indexes (cached).
	 *
	 * @api private
	 * @return {Array}
	 */
	
	Schema.prototype.indexedPaths = function indexedPaths () {
	  if (this._indexedpaths) return this._indexedpaths;
	
	  return this._indexedpaths = this.indexes();
	}
	
	/**
	 * Returns the pathType of `path` for this schema.
	 *
	 * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.
	 *
	 * @param {String} path
	 * @return {String}
	 * @api public
	 */
	
	Schema.prototype.pathType = function (path) {
	  if (path in this.paths) return 'real';
	  if (path in this.virtuals) return 'virtual';
	  if (path in this.nested) return 'nested';
	  if (path in this.subpaths) return 'real';
	
	  if (/\.\d+\.|\.\d+$/.test(path) && getPositionalPath(this, path)) {
	    return 'real';
	  } else {
	    return 'adhocOrUndefined'
	  }
	};
	
	/*!
	 * ignore
	 */
	
	function getPositionalPath (self, path) {
	  var subpaths = path.split(/\.(\d+)\.|\.(\d+)$/).filter(Boolean);
	  if (subpaths.length < 2) {
	    return self.paths[subpaths[0]];
	  }
	
	  var val = self.path(subpaths[0]);
	  if (!val) return val;
	
	  var last = subpaths.length - 1
	    , subpath
	    , i = 1;
	
	  for (; i < subpaths.length; ++i) {
	    subpath = subpaths[i];
	
	    if (i === last && val && !val.schema && !/\D/.test(subpath)) {
	      if (val instanceof MongooseTypes.Array) {
	        // StringSchema, NumberSchema, etc
	        val = val.caster;
	      } else {
	        val = undefined;
	      }
	      break;
	    }
	
	    // ignore if its just a position segment: path.0.subpath
	    if (!/\D/.test(subpath)) continue;
	
	    if (!(val && val.schema)) {
	      val = undefined;
	      break;
	    }
	
	    val = val.schema.path(subpath);
	  }
	
	  return self.subpaths[path] = val;
	}
	
	/**
	 * Adds a method call to the queue.
	 *
	 * @param {String} name name of the document method to call later
	 * @param {Array} args arguments to pass to the method
	 * @api private
	 */
	
	Schema.prototype.queue = function(name, args){
	  this.callQueue.push([name, args]);
	  return this;
	};
	
	/**
	 * Defines a pre hook for the document.
	 *
	 * ####Example
	 *
	 *     var toySchema = new Schema(..);
	 *
	 *     toySchema.pre('save', function (next) {
	 *       if (!this.created) this.created = new Date;
	 *       next();
	 *     })
	 *
	 *     toySchema.pre('validate', function (next) {
	 *       if (this.name != 'Woody') this.name = 'Woody';
	 *       next();
	 *     })
	 *
	 * @param {String} method
	 * @param {Function} callback
	 * @see hooks.js https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3
	 * @api public
	 */
	
	Schema.prototype.pre = function() {
	  var name = arguments[0];
	  if (IS_QUERY_HOOK[name]) {
	    this.s.hooks.pre.apply(this.s.hooks, arguments);
	    return this;
	  }
	  return this.queue('pre', arguments);
	};
	
	/**
	 * Defines a post hook for the document
	 *
	 * Post hooks fire `on` the event emitted from document instances of Models compiled from this schema.
	 *
	 *     var schema = new Schema(..);
	 *     schema.post('save', function (doc) {
	 *       console.log('this fired after a document was saved');
	 *     });
	 *
	 *     var Model = mongoose.model('Model', schema);
	 *
	 *     var m = new Model(..);
	 *     m.save(function (err) {
	 *       console.log('this fires after the `post` hook');
	 *     });
	 *
	 * @param {String} method name of the method to hook
	 * @param {Function} fn callback
	 * @see hooks.js https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3
	 * @api public
	 */
	
	Schema.prototype.post = function(method, fn) {
	  if (IS_QUERY_HOOK[method]) {
	    this.s.hooks.post.apply(this.s.hooks, arguments);
	    return this;
	  }
	  // assuming that all callbacks with arity < 2 are synchronous post hooks
	  if (fn.length < 2) {
	    return this.queue('on', [arguments[0], function(doc) {
	      return fn.call(doc, doc);
	    }]);
	  }
	
	  return this.queue('post', [arguments[0], function(next){
	    // wrap original function so that the callback goes last,
	    // for compatibility with old code that is using synchronous post hooks
	    fn.call(this, this, next);
	  }]);
	};
	
	/**
	 * Registers a plugin for this schema.
	 *
	 * @param {Function} plugin callback
	 * @param {Object} [opts]
	 * @see plugins
	 * @api public
	 */
	
	Schema.prototype.plugin = function (fn, opts) {
	  fn(this, opts);
	  return this;
	};
	
	/**
	 * Adds an instance method to documents constructed from Models compiled from this schema.
	 *
	 * ####Example
	 *
	 *     var schema = kittySchema = new Schema(..);
	 *
	 *     schema.method('meow', function () {
	 *       console.log('meeeeeoooooooooooow');
	 *     })
	 *
	 *     var Kitty = mongoose.model('Kitty', schema);
	 *
	 *     var fizz = new Kitty;
	 *     fizz.meow(); // meeeeeooooooooooooow
	 *
	 * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.
	 *
	 *     schema.method({
	 *         purr: function () {}
	 *       , scratch: function () {}
	 *     });
	 *
	 *     // later
	 *     fizz.purr();
	 *     fizz.scratch();
	 *
	 * @param {String|Object} method name
	 * @param {Function} [fn]
	 * @api public
	 */
	
	Schema.prototype.method = function (name, fn) {
	  if ('string' != typeof name)
	    for (var i in name)
	      this.methods[i] = name[i];
	  else
	    this.methods[name] = fn;
	  return this;
	};
	
	/**
	 * Adds static "class" methods to Models compiled from this schema.
	 *
	 * ####Example
	 *
	 *     var schema = new Schema(..);
	 *     schema.static('findByName', function (name, callback) {
	 *       return this.find({ name: name }, callback);
	 *     });
	 *
	 *     var Drink = mongoose.model('Drink', schema);
	 *     Drink.findByName('sanpellegrino', function (err, drinks) {
	 *       //
	 *     });
	 *
	 * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.
	 *
	 * @param {String} name
	 * @param {Function} fn
	 * @api public
	 */
	
	Schema.prototype.static = function(name, fn) {
	  if ('string' != typeof name)
	    for (var i in name)
	      this.statics[i] = name[i];
	  else
	    this.statics[name] = fn;
	  return this;
	};
	
	/**
	 * Defines an index (most likely compound) for this schema.
	 *
	 * ####Example
	 *
	 *     schema.index({ first: 1, last: -1 })
	 *
	 * @param {Object} fields
	 * @param {Object} [options]
	 * @api public
	 */
	
	Schema.prototype.index = function (fields, options) {
	  options || (options = {});
	
	  if (options.expires)
	    utils.expires(options);
	
	  this._indexes.push([fields, options]);
	  return this;
	};
	
	/**
	 * Sets/gets a schema option.
	 *
	 * @param {String} key option name
	 * @param {Object} [value] if not passed, the current option value is returned
	 * @api public
	 */
	
	Schema.prototype.set = function (key, value, _tags) {
	  if (1 === arguments.length) {
	    return this.options[key];
	  }
	
	  switch (key) {
	    case 'read':
	      this.options[key] = readPref(value, _tags);
	      break;
	    case 'safe':
	      this.options[key] = false === value
	        ? { w: 0 }
	        : value
	      break;
	    default:
	      this.options[key] = value;
	  }
	
	  return this;
	}
	
	/**
	 * Gets a schema option.
	 *
	 * @param {String} key option name
	 * @api public
	 */
	
	Schema.prototype.get = function (key) {
	  return this.options[key];
	}
	
	/**
	 * The allowed index types
	 *
	 * @static indexTypes
	 * @receiver Schema
	 * @api public
	 */
	
	var indexTypes = '2d 2dsphere hashed text'.split(' ');
	
	Object.defineProperty(Schema, 'indexTypes', {
	    get: function () { return indexTypes }
	  , set: function () { throw new Error('Cannot overwrite Schema.indexTypes') }
	})
	
	/**
	 * Compiles indexes from fields and schema-level indexes
	 *
	 * @api public
	 */
	
	Schema.prototype.indexes = function () {
	  'use strict';
	
	  var indexes = [];
	  var seenPrefix = {};
	
	  var collectIndexes = function(schema, prefix) {
	    if (seenPrefix[prefix]) {
	      return;
	    }
	    seenPrefix[prefix] = true;
	
	    prefix = prefix || '';
	    var key, path, index, field, isObject, options, type;
	    var keys = Object.keys(schema.paths);
	
	    for (var i = 0; i < keys.length; ++i) {
	      key = keys[i];
	      path = schema.paths[key];
	
	      if (path instanceof MongooseTypes.DocumentArray) {
	        collectIndexes(path.schema, key + '.');
	      } else {
	        index = path._index;
	
	        if (false !== index && null != index) {
	          field = {};
	          isObject = utils.isObject(index);
	          options = isObject ? index : {};
	          type = 'string' == typeof index ? index :
	            isObject ? index.type :
	            false;
	
	          if (type && ~Schema.indexTypes.indexOf(type)) {
	            field[prefix + key] = type;
	          } else {
	            field[prefix + key] = 1;
	          }
	
	          delete options.type;
	          if (!('background' in options)) {
	            options.background = true;
	          }
	
	          indexes.push([field, options]);
	        }
	      }
	    }
	
	    if (prefix) {
	      fixSubIndexPaths(schema, prefix);
	    } else {
	      schema._indexes.forEach(function (index) {
	        if (!('background' in index[1])) index[1].background = true;
	      });
	      indexes = indexes.concat(schema._indexes);
	    }
	
	  };
	
	  collectIndexes(this);
	  return indexes;
	
	  /*!
	   * Checks for indexes added to subdocs using Schema.index().
	   * These indexes need their paths prefixed properly.
	   *
	   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]
	   */
	
	  function fixSubIndexPaths (schema, prefix) {
	    var subindexes = schema._indexes
	      , len = subindexes.length
	      , indexObj
	      , newindex
	      , klen
	      , keys
	      , key
	      , i = 0
	      , j
	
	    for (i = 0; i < len; ++i) {
	      indexObj = subindexes[i][0];
	      keys = Object.keys(indexObj);
	      klen = keys.length;
	      newindex = {};
	
	      // use forward iteration, order matters
	      for (j = 0; j < klen; ++j) {
	        key = keys[j];
	        newindex[prefix + key] = indexObj[key];
	      }
	
	      indexes.push([newindex, subindexes[i][1]]);
	    }
	  }
	}
	
	/**
	 * Creates a virtual type with the given name.
	 *
	 * @param {String} name
	 * @param {Object} [options]
	 * @return {VirtualType}
	 */
	
	Schema.prototype.virtual = function (name, options) {
	  var virtuals = this.virtuals;
	  var parts = name.split('.');
	  return virtuals[name] = parts.reduce(function (mem, part, i) {
	    mem[part] || (mem[part] = (i === parts.length-1)
	                            ? new VirtualType(options, name)
	                            : {});
	    return mem[part];
	  }, this.tree);
	};
	
	/**
	 * Returns the virtual type with the given `name`.
	 *
	 * @param {String} name
	 * @return {VirtualType}
	 */
	
	Schema.prototype.virtualpath = function (name) {
	  return this.virtuals[name];
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = exports = Schema;
	
	// require down here because of reference issues
	
	/**
	 * The various built-in Mongoose Schema Types.
	 *
	 * ####Example:
	 *
	 *     var mongoose = require('mongoose');
	 *     var ObjectId = mongoose.Schema.Types.ObjectId;
	 *
	 * ####Types:
	 *
	 * - [String](#schema-string-js)
	 * - [Number](#schema-number-js)
	 * - [Boolean](#schema-boolean-js) | Bool
	 * - [Array](#schema-array-js)
	 * - [Buffer](#schema-buffer-js)
	 * - [Date](#schema-date-js)
	 * - [ObjectId](#schema-objectid-js) | Oid
	 * - [Mixed](#schema-mixed-js)
	 *
	 * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.
	 *
	 *     var Mixed = mongoose.Schema.Types.Mixed;
	 *     new mongoose.Schema({ _user: Mixed })
	 *
	 * @api public
	 */
	
	Schema.Types = MongooseTypes = __webpack_require__(/*! ./schema/index */ 175);
	
	/*!
	 * ignore
	 */
	
	var ObjectId = exports.ObjectId = MongooseTypes.ObjectId;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 42 */
/*!*********************************!*\
  !*** ./~/mongoose/lib/utils.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {/*!
	 * Module dependencies.
	 */
	
	var ObjectId = __webpack_require__(/*! ./types/objectid */ 45);
	var cloneRegExp = __webpack_require__(/*! regexp-clone */ 207);
	var sliced = __webpack_require__(/*! sliced */ 203);
	var mpath = __webpack_require__(/*! mpath */ 227);
	var ms = __webpack_require__(/*! ms */ 44);
	var MongooseBuffer;
	var MongooseArray;
	var Document;
	
	/*!
	 * Produces a collection name from model `name`.
	 *
	 * @param {String} name a model name
	 * @return {String} a collection name
	 * @api private
	 */
	
	exports.toCollectionName = function (name, options) {
	  options = options || {};
	  if ('system.profile' === name) return name;
	  if ('system.indexes' === name) return name;
	  if (options.pluralization === false) return name;
	  return pluralize(name.toLowerCase());
	};
	
	/**
	 * Pluralization rules.
	 *
	 * These rules are applied while processing the argument to `toCollectionName`.
	 *
	 * @deprecated remove in 4.x gh-1350
	 */
	
	exports.pluralization = [
	  [/(m)an$/gi, '$1en'],
	  [/(pe)rson$/gi, '$1ople'],
	  [/(child)$/gi, '$1ren'],
	  [/^(ox)$/gi, '$1en'],
	  [/(ax|test)is$/gi, '$1es'],
	  [/(octop|vir)us$/gi, '$1i'],
	  [/(alias|status)$/gi, '$1es'],
	  [/(bu)s$/gi, '$1ses'],
	  [/(buffal|tomat|potat)o$/gi, '$1oes'],
	  [/([ti])um$/gi, '$1a'],
	  [/sis$/gi, 'ses'],
	  [/(?:([^f])fe|([lr])f)$/gi, '$1$2ves'],
	  [/(hive)$/gi, '$1s'],
	  [/([^aeiouy]|qu)y$/gi, '$1ies'],
	  [/(x|ch|ss|sh)$/gi, '$1es'],
	  [/(matr|vert|ind)ix|ex$/gi, '$1ices'],
	  [/([m|l])ouse$/gi, '$1ice'],
	  [/(kn|w|l)ife$/gi, '$1ives'],
	  [/(quiz)$/gi, '$1zes'],
	  [/s$/gi, 's'],
	  [/([^a-z])$/, '$1'],
	  [/$/gi, 's']
	];
	var rules = exports.pluralization;
	
	/**
	 * Uncountable words.
	 *
	 * These words are applied while processing the argument to `toCollectionName`.
	 * @api public
	 */
	
	exports.uncountables = [
	  'advice',
	  'energy',
	  'excretion',
	  'digestion',
	  'cooperation',
	  'health',
	  'justice',
	  'labour',
	  'machinery',
	  'equipment',
	  'information',
	  'pollution',
	  'sewage',
	  'paper',
	  'money',
	  'species',
	  'series',
	  'rain',
	  'rice',
	  'fish',
	  'sheep',
	  'moose',
	  'deer',
	  'news',
	  'expertise',
	  'status',
	  'media'
	];
	var uncountables = exports.uncountables;
	
	/*!
	 * Pluralize function.
	 *
	 * @author TJ Holowaychuk (extracted from _ext.js_)
	 * @param {String} string to pluralize
	 * @api private
	 */
	
	function pluralize (str) {
	  var rule, found;
	  if (!~uncountables.indexOf(str.toLowerCase())){
	    found = rules.filter(function(rule){
	      return str.match(rule[0]);
	    });
	    if (found[0]) return str.replace(found[0][0], found[0][1]);
	  }
	  return str;
	};
	
	/*!
	 * Determines if `a` and `b` are deep equal.
	 *
	 * Modified from node/lib/assert.js
	 *
	 * @param {any} a a value to compare to `b`
	 * @param {any} b a value to compare to `a`
	 * @return {Boolean}
	 * @api private
	 */
	
	exports.deepEqual = function deepEqual (a, b) {
	  if (a === b) return true;
	
	  if (a instanceof Date && b instanceof Date)
	    return a.getTime() === b.getTime();
	
	  if (a instanceof ObjectId && b instanceof ObjectId) {
	    return a.toString() === b.toString();
	  }
	
	  if (a instanceof RegExp && b instanceof RegExp) {
	    return a.source == b.source &&
	           a.ignoreCase == b.ignoreCase &&
	           a.multiline == b.multiline &&
	           a.global == b.global;
	  }
	
	  if (typeof a !== 'object' && typeof b !== 'object')
	    return a == b;
	
	  if (a === null || b === null || a === undefined || b === undefined)
	    return false
	
	  if (a.prototype !== b.prototype) return false;
	
	  // Handle MongooseNumbers
	  if (a instanceof Number && b instanceof Number) {
	    return a.valueOf() === b.valueOf();
	  }
	
	  if (Buffer.isBuffer(a)) {
	    return exports.buffer.areEqual(a, b);
	  }
	
	  if (isMongooseObject(a)) a = a.toObject();
	  if (isMongooseObject(b)) b = b.toObject();
	
	  try {
	    var ka = Object.keys(a),
	        kb = Object.keys(b),
	        key, i;
	  } catch (e) {//happens when one is a string literal and the other isn't
	    return false;
	  }
	
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key])) return false;
	  }
	
	  return true;
	};
	
	/*!
	 * Object clone with Mongoose natives support.
	 *
	 * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.
	 *
	 * Functions are never cloned.
	 *
	 * @param {Object} obj the object to clone
	 * @param {Object} options
	 * @return {Object} the cloned object
	 * @api private
	 */
	
	exports.clone = function clone (obj, options) {
	  if (obj === undefined || obj === null)
	    return obj;
	
	  if (Array.isArray(obj))
	    return cloneArray(obj, options);
	
	  if (isMongooseObject(obj)) {
	    if (options && options.json && 'function' === typeof obj.toJSON) {
	      return obj.toJSON(options);
	    } else {
	      return obj.toObject(options);
	    }
	  }
	
	  if (obj.constructor) {
	    switch (exports.getFunctionName(obj.constructor)) {
	      case 'Object':
	        return cloneObject(obj, options);
	      case 'Date':
	        return new obj.constructor(+obj);
	      case 'RegExp':
	        return cloneRegExp(obj);
	      default:
	        // ignore
	        break;
	    }
	  }
	
	  if (obj instanceof ObjectId)
	    return new ObjectId(obj.id);
	
	  if (!obj.constructor && exports.isObject(obj)) {
	    // object created with Object.create(null)
	    return cloneObject(obj, options);
	  }
	
	  if (obj.valueOf)
	    return obj.valueOf();
	};
	var clone = exports.clone;
	
	/*!
	 * ignore
	 */
	
	function cloneObject (obj, options) {
	  var retainKeyOrder = options && options.retainKeyOrder
	    , minimize = options && options.minimize
	    , ret = {}
	    , hasKeys
	    , keys
	    , val
	    , k
	    , i
	
	  if (retainKeyOrder) {
	    for (k in obj) {
	      val = clone(obj[k], options);
	
	      if (!minimize || ('undefined' !== typeof val)) {
	        hasKeys || (hasKeys = true);
	        ret[k] = val;
	      }
	    }
	  } else {
	    // faster
	
	    keys = Object.keys(obj);
	    i = keys.length;
	
	    while (i--) {
	      k = keys[i];
	      val = clone(obj[k], options);
	
	      if (!minimize || ('undefined' !== typeof val)) {
	        if (!hasKeys) hasKeys = true;
	        ret[k] = val;
	      }
	    }
	  }
	
	  return minimize
	    ? hasKeys && ret
	    : ret;
	};
	
	function cloneArray (arr, options) {
	  var ret = [];
	  for (var i = 0, l = arr.length; i < l; i++)
	    ret.push(clone(arr[i], options));
	  return ret;
	};
	
	/*!
	 * Shallow copies defaults into options.
	 *
	 * @param {Object} defaults
	 * @param {Object} options
	 * @return {Object} the merged object
	 * @api private
	 */
	
	exports.options = function (defaults, options) {
	  var keys = Object.keys(defaults)
	    , i = keys.length
	    , k ;
	
	  options = options || {};
	
	  while (i--) {
	    k = keys[i];
	    if (!(k in options)) {
	      options[k] = defaults[k];
	    }
	  }
	
	  return options;
	};
	
	/*!
	 * Generates a random string
	 *
	 * @api private
	 */
	
	exports.random = function () {
	  return Math.random().toString().substr(3);
	};
	
	/*!
	 * Merges `from` into `to` without overwriting existing properties.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 * @api private
	 */
	
	exports.merge = function merge (to, from) {
	  var keys = Object.keys(from)
	    , i = keys.length
	    , key;
	
	  while (i--) {
	    key = keys[i];
	    if ('undefined' === typeof to[key]) {
	      to[key] = from[key];
	    } else if (exports.isObject(from[key])) {
	      merge(to[key], from[key]);
	    }
	  }
	};
	
	/*!
	 * toString helper
	 */
	
	var toString = Object.prototype.toString;
	
	/*!
	 * Determines if `arg` is an object.
	 *
	 * @param {Object|Array|String|Function|RegExp|any} arg
	 * @api private
	 * @return {Boolean}
	 */
	
	exports.isObject = function (arg) {
	  return '[object Object]' == toString.call(arg);
	}
	
	/*!
	 * A faster Array.prototype.slice.call(arguments) alternative
	 * @api private
	 */
	
	exports.args = sliced;
	
	/*!
	 * process.nextTick helper.
	 *
	 * Wraps `callback` in a try/catch + nextTick.
	 *
	 * node-mongodb-native has a habit of state corruption when an error is immediately thrown from within a collection callback.
	 *
	 * @param {Function} callback
	 * @api private
	 */
	
	exports.tick = function tick (callback) {
	  if ('function' !== typeof callback) return;
	  return function () {
	    try {
	      callback.apply(this, arguments);
	    } catch (err) {
	      // only nextTick on err to get out of
	      // the event loop and avoid state corruption.
	      process.nextTick(function () {
	        throw err;
	      });
	    }
	  }
	}
	
	/*!
	 * Returns if `v` is a mongoose object that has a `toObject()` method we can use.
	 *
	 * This is for compatibility with libs like Date.js which do foolish things to Natives.
	 *
	 * @param {any} v
	 * @api private
	 */
	
	exports.isMongooseObject = function (v) {
	  Document || (Document = __webpack_require__(/*! ./document */ 178));
	  MongooseArray || (MongooseArray = __webpack_require__(/*! ./types */ 197).Array);
	  MongooseBuffer || (MongooseBuffer = __webpack_require__(/*! ./types */ 197).Buffer);
	
	  return v instanceof Document ||
	         (v && v.isMongooseArray) ||
	         (v && v.isMongooseBuffer);
	};
	var isMongooseObject = exports.isMongooseObject;
	
	/*!
	 * Converts `expires` options of index objects to `expiresAfterSeconds` options for MongoDB.
	 *
	 * @param {Object} object
	 * @api private
	 */
	
	exports.expires = function expires (object) {
	  if (!(object && 'Object' == object.constructor.name)) return;
	  if (!('expires' in object)) return;
	
	  var when;
	  if ('string' != typeof object.expires) {
	    when = object.expires;
	  } else {
	    when = Math.round(ms(object.expires) / 1000);
	  }
	  object.expireAfterSeconds = when;
	  delete object.expires;
	};
	
	/*!
	 * Populate options constructor
	 */
	
	function PopulateOptions (path, select, match, options, model) {
	  this.path = path;
	  this.match = match;
	  this.select = select;
	  this.options = options;
	  this.model = model;
	  this._docs = {};
	}
	
	// make it compatible with utils.clone
	PopulateOptions.prototype.constructor = Object;
	
	// expose
	exports.PopulateOptions = PopulateOptions;
	
	/*!
	 * populate helper
	 */
	
	exports.populate = function populate (path, select, model, match, options) {
	  // The order of select/conditions args is opposite Model.find but
	  // necessary to keep backward compatibility (select could be
	  // an array, string, or object literal).
	
	  // might have passed an object specifying all arguments
	  if (1 === arguments.length) {
	    if (path instanceof PopulateOptions) {
	      return [path];
	    }
	
	    if (Array.isArray(path)) {
	      return path.map(function(o){
	        return exports.populate(o)[0];
	      });
	    }
	
	    if (exports.isObject(path)) {
	      match = path.match;
	      options = path.options;
	      select = path.select;
	      model = path.model;
	      path = path.path;
	    }
	  } else if ('string' !== typeof model && 'function' !== typeof model) {
	    options = match;
	    match = model;
	    model = undefined;
	  }
	
	  if ('string' != typeof path) {
	    throw new TypeError('utils.populate: invalid path. Expected string. Got typeof `' + typeof path + '`');
	  }
	
	  var ret = [];
	  var paths = path.split(' ');
	  for (var i = 0; i < paths.length; ++i) {
	    ret.push(new PopulateOptions(paths[i], select, match, options, model));
	  }
	
	  return ret;
	}
	
	/*!
	 * Return the value of `obj` at the given `path`.
	 *
	 * @param {String} path
	 * @param {Object} obj
	 */
	
	exports.getValue = function (path, obj, map) {
	  return mpath.get(path, obj, '_doc', map);
	}
	
	/*!
	 * Sets the value of `obj` at the given `path`.
	 *
	 * @param {String} path
	 * @param {Anything} val
	 * @param {Object} obj
	 */
	
	exports.setValue = function (path, val, obj, map) {
	  mpath.set(path, val, obj, '_doc', map);
	}
	
	/*!
	 * Returns an array of values from object `o`.
	 *
	 * @param {Object} o
	 * @return {Array}
	 * @private
	 */
	
	exports.object = {};
	exports.object.vals = function vals (o) {
	  var keys = Object.keys(o)
	    , i = keys.length
	    , ret = [];
	
	  while (i--) {
	    ret.push(o[keys[i]]);
	  }
	
	  return ret;
	}
	
	/*!
	 * @see exports.options
	 */
	
	exports.object.shallowCopy = exports.options;
	
	/*!
	 * Safer helper for hasOwnProperty checks
	 *
	 * @param {Object} obj
	 * @param {String} prop
	 */
	
	var hop = Object.prototype.hasOwnProperty;
	exports.object.hasOwnProperty = function (obj, prop) {
	  return hop.call(obj, prop);
	}
	
	/*!
	 * Determine if `val` is null or undefined
	 *
	 * @return {Boolean}
	 */
	
	exports.isNullOrUndefined = function (val) {
	  return null == val
	}
	
	/*!
	 * ignore
	 */
	
	exports.array = {};
	
	/*!
	 * Flattens an array.
	 *
	 * [ 1, [ 2, 3, [4] ]] -> [1,2,3,4]
	 *
	 * @param {Array} arr
	 * @param {Function} [filter] If passed, will be invoked with each item in the array. If `filter` returns a falsey value, the item will not be included in the results.
	 * @return {Array}
	 * @private
	 */
	
	exports.array.flatten = function flatten (arr, filter, ret) {
	  ret || (ret = []);
	
	  arr.forEach(function (item) {
	    if (Array.isArray(item)) {
	      flatten(item, filter, ret);
	    } else {
	      if (!filter || filter(item)) {
	        ret.push(item);
	      }
	    }
	  });
	
	  return ret;
	};
	
	/*!
	 * Removes duplicate values from an array
	 *
	 * [1, 2, 3, 3, 5] => [1, 2, 3, 5]
	 * [ ObjectId("550988ba0c19d57f697dc45e"), ObjectId("550988ba0c19d57f697dc45e") ]
	 *    => [ObjectId("550988ba0c19d57f697dc45e")]
	 *
	 * @param {Array} arr
	 * @return {Array}
	 * @private
	 */
	
	exports.array.unique = function(arr) {
	  var primitives = {};
	  var ids = {};
	  var ret = [];
	  var length = arr.length;
	  for (var i = 0; i < length; ++i) {
	    if (typeof arr[i] === 'number' || typeof arr[i] === 'string') {
	      if (primitives[arr[i]]) {
	        continue;
	      }
	      ret.push(arr[i]);
	      primitives[arr[i]] = true;
	    } else if (arr[i] instanceof ObjectId) {
	      if (ids[arr[i].toString()]) {
	        continue;
	      }
	      ret.push(arr[i]);
	      ids[arr[i].toString()] = true;
	    } else {
	      ret.push(arr[i]);
	    }
	  }
	
	  return ret;
	};
	
	/*!
	 * Determines if two buffers are equal.
	 *
	 * @param {Buffer} a
	 * @param {Object} b
	 */
	
	exports.buffer = {};
	exports.buffer.areEqual = function (a, b) {
	  if (!Buffer.isBuffer(a)) return false;
	  if (!Buffer.isBuffer(b)) return false;
	  if (a.length !== b.length) return false;
	  for (var i = 0, len = a.length; i < len; ++i) {
	    if (a[i] !== b[i]) return false;
	  }
	  return true;
	};
	
	exports.getFunctionName = function(fn) {
	  if (fn.name) {
	    return fn.name;
	  }
	  return (fn.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1];
	};
	
	exports.decorate = function(destination, source) {
	  for (var key in source) {
	    destination[key] = source[key];
	  }
	};
	
	/**
	 * merges to with a copy of from
	 *
	 * @param {Object} to
	 * @param {Object} from
	 * @api private
	 */
	
	exports.mergeClone = function(to, from) {
	  var keys = Object.keys(from)
	    , i = keys.length
	    , key
	
	  while (i--) {
	    key = keys[i];
	    if ('undefined' === typeof to[key]) {
	      // make sure to retain key order here because of a bug handling the $each
	      // operator in mongodb 2.4.4
	      to[key] = exports.clone(from[key], { retainKeyOrder : 1});
	    } else {
	      if (exports.isObject(from[key])) {
	        exports.mergeClone(to[key], from[key]);
	      } else {
	        // make sure to retain key order here because of a bug handling the
	        // $each operator in mongodb 2.4.4
	        to[key] = exports.clone(from[key], { retainKeyOrder : 1});
	      }
	    }
	  }
	};
	
	/**
	 * Executes a function on each element of an array (like _.each)
	 *
	 * @param {Array} arr
	 * @param {Function} fn
	 * @api private
	 */
	
	exports.each = function(arr, fn) {
	  for (var i = 0; i < arr.length; ++i) {
	    fn(arr[i]);
	  }
	};
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 43 */
/*!**************************************************!*\
  !*** ./~/node-libs-browser/~/process/browser.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            currentQueue[queueIndex].run();
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 44 */
/*!*******************************!*\
  !*** ./~/mongoose/~/ms/ms.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	
	# ms.js
	
	No more painful `setTimeout(fn, 60 * 4 * 3 * 2 * 1 * Infinity * NaN * '☃')`.
	
	    ms('2d')      // 172800000
	    ms('1.5h')    // 5400000
	    ms('1h')      // 3600000
	    ms('1m')      // 60000
	    ms('5s')      // 5000
	    ms('500ms')    // 500
	    ms('100')     // '100'
	    ms(100)       // 100
	
	**/
	
	(function (g) {
	  var r = /(\d*.?\d+)([mshd]+)/
	    , _ = {}
	
	  _.ms = 1;
	  _.s = 1000;
	  _.m = _.s * 60;
	  _.h = _.m * 60;
	  _.d = _.h * 24;
	
	  function ms (s) {
	    if (s == Number(s)) return Number(s);
	    r.exec(s.toLowerCase());
	    return RegExp.$1 * _[RegExp.$2];
	  }
	
	  g.top ? g.ms = ms : module.exports = ms;
	})(this);


/***/ },
/* 45 */
/*!******************************************!*\
  !*** ./~/mongoose/lib/types/objectid.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ObjectId type constructor
	 *
	 * ####Example
	 *
	 *     var id = new mongoose.Types.ObjectId;
	 *
	 * @constructor ObjectId
	 */
	
	var ObjectId = __webpack_require__(/*! ../drivers */ 46).ObjectId;
	
	module.exports = ObjectId;


/***/ },
/* 46 */
/*!*****************************************!*\
  !*** ./~/mongoose/lib/drivers/index.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	var driver;
	
	if (typeof window === 'undefined') {
	  driver = __webpack_require__(/*! . */ 47)("./" +
	    (global.MONGOOSE_DRIVER_PATH || 'node-mongodb-native'));
	} else {
	  driver = __webpack_require__(/*! ./browser */ 69);
	}
	
	module.exports = driver;


/***/ },
/* 47 */
/*!*****************************************!*\
  !*** ./~/mongoose/lib/drivers ^\.\/.*$ ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./SPEC.md": 48,
		"./browser/ReadPreference": 49,
		"./browser/ReadPreference.js": 49,
		"./browser/binary": 50,
		"./browser/binary.js": 50,
		"./browser/collection": 67,
		"./browser/collection.js": 67,
		"./browser/connection": 68,
		"./browser/connection.js": 68,
		"./browser/index": 69,
		"./browser/index.js": 69,
		"./browser/objectid": 70,
		"./browser/objectid.js": 70,
		"./index": 46,
		"./index.js": 46,
		"./node-mongodb-native/ReadPreference": 71,
		"./node-mongodb-native/ReadPreference.js": 71,
		"./node-mongodb-native/binary": 162,
		"./node-mongodb-native/binary.js": 162,
		"./node-mongodb-native/collection": 163,
		"./node-mongodb-native/collection.js": 163,
		"./node-mongodb-native/connection": 166,
		"./node-mongodb-native/connection.js": 166,
		"./node-mongodb-native/index": 225,
		"./node-mongodb-native/index.js": 225,
		"./node-mongodb-native/objectid": 226,
		"./node-mongodb-native/objectid.js": 226
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 47;


/***/ },
/* 48 */
/*!****************************************!*\
  !*** ./~/mongoose/lib/drivers/SPEC.md ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = "\n# Driver Spec\n\nTODO\n"

/***/ },
/* 49 */
/*!**********************************************************!*\
  !*** ./~/mongoose/lib/drivers/browser/ReadPreference.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = function() {};


/***/ },
/* 50 */
/*!**************************************************!*\
  !*** ./~/mongoose/lib/drivers/browser/binary.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var Binary = __webpack_require__(/*! bson */ 51).Binary;
	
	module.exports = exports = Binary;


/***/ },
/* 51 */
/*!********************************************!*\
  !*** ./~/mongoose/~/bson/lib/bson/bson.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var Long = __webpack_require__(/*! ./long */ 52).Long
	  , Double = __webpack_require__(/*! ./double */ 53).Double
	  , Timestamp = __webpack_require__(/*! ./timestamp */ 54).Timestamp
	  , ObjectID = __webpack_require__(/*! ./objectid */ 55).ObjectID
	  , Symbol = __webpack_require__(/*! ./symbol */ 60).Symbol
	  , Code = __webpack_require__(/*! ./code */ 61).Code
	  , MinKey = __webpack_require__(/*! ./min_key */ 62).MinKey
	  , MaxKey = __webpack_require__(/*! ./max_key */ 63).MaxKey
	  , DBRef = __webpack_require__(/*! ./db_ref */ 64).DBRef
	  , Binary = __webpack_require__(/*! ./binary */ 65).Binary
	  , BinaryParser = __webpack_require__(/*! ./binary_parser */ 56).BinaryParser
	  , writeIEEE754 = __webpack_require__(/*! ./float_parser */ 66).writeIEEE754
	  , readIEEE754 = __webpack_require__(/*! ./float_parser */ 66).readIEEE754
	
	// To ensure that 0.4 of node works correctly
	var isDate = function isDate(d) {
	  return typeof d === 'object' && Object.prototype.toString.call(d) === '[object Date]';
	}
	
	/**
	 * Create a new BSON instance
	 *
	 * @class
	 * @return {BSON} instance of BSON Parser.
	 */
	function BSON () {};
	
	/**
	 * @ignore
	 * @api private
	 */
	// BSON MAX VALUES
	BSON.BSON_INT32_MAX = 0x7FFFFFFF;
	BSON.BSON_INT32_MIN = -0x80000000;
	
	BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
	BSON.BSON_INT64_MIN = -Math.pow(2, 63);
	
	// JS MAX PRECISE VALUES
	BSON.JS_INT_MAX = 0x20000000000000;  // Any integer up to 2^53 can be precisely represented by a double.
	BSON.JS_INT_MIN = -0x20000000000000;  // Any integer down to -2^53 can be precisely represented by a double.
	
	// Internal long versions
	var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000);  // Any integer up to 2^53 can be precisely represented by a double.
	var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000);  // Any integer down to -2^53 can be precisely represented by a double.
	
	/**
	 * Number BSON Type
	 *
	 * @classconstant BSON_DATA_NUMBER
	 **/
	BSON.BSON_DATA_NUMBER = 1;
	/**
	 * String BSON Type
	 *
	 * @classconstant BSON_DATA_STRING
	 **/
	BSON.BSON_DATA_STRING = 2;
	/**
	 * Object BSON Type
	 *
	 * @classconstant BSON_DATA_OBJECT
	 **/
	BSON.BSON_DATA_OBJECT = 3;
	/**
	 * Array BSON Type
	 *
	 * @classconstant BSON_DATA_ARRAY
	 **/
	BSON.BSON_DATA_ARRAY = 4;
	/**
	 * Binary BSON Type
	 *
	 * @classconstant BSON_DATA_BINARY
	 **/
	BSON.BSON_DATA_BINARY = 5;
	/**
	 * Binary BSON Type
	 *
	 * @classconstant BSON_DATA_UNDEFINED
	 **/
	BSON.BSON_DATA_UNDEFINED = 6;
	/**
	 * ObjectID BSON Type
	 *
	 * @classconstant BSON_DATA_OID
	 **/
	BSON.BSON_DATA_OID = 7;
	/**
	 * Boolean BSON Type
	 *
	 * @classconstant BSON_DATA_BOOLEAN
	 **/
	BSON.BSON_DATA_BOOLEAN = 8;
	/**
	 * Date BSON Type
	 *
	 * @classconstant BSON_DATA_DATE
	 **/
	BSON.BSON_DATA_DATE = 9;
	/**
	 * null BSON Type
	 *
	 * @classconstant BSON_DATA_NULL
	 **/
	BSON.BSON_DATA_NULL = 10;
	/**
	 * RegExp BSON Type
	 *
	 * @classconstant BSON_DATA_REGEXP
	 **/
	BSON.BSON_DATA_REGEXP = 11;
	/**
	 * Code BSON Type
	 *
	 * @classconstant BSON_DATA_CODE
	 **/
	BSON.BSON_DATA_CODE = 13;
	/**
	 * Symbol BSON Type
	 *
	 * @classconstant BSON_DATA_SYMBOL
	 **/
	BSON.BSON_DATA_SYMBOL = 14;
	/**
	 * Code with Scope BSON Type
	 *
	 * @classconstant BSON_DATA_CODE_W_SCOPE
	 **/
	BSON.BSON_DATA_CODE_W_SCOPE = 15;
	/**
	 * 32 bit Integer BSON Type
	 *
	 * @classconstant BSON_DATA_INT
	 **/
	BSON.BSON_DATA_INT = 16;
	/**
	 * Timestamp BSON Type
	 *
	 * @classconstant BSON_DATA_TIMESTAMP
	 **/
	BSON.BSON_DATA_TIMESTAMP = 17;
	/**
	 * Long BSON Type
	 *
	 * @classconstant BSON_DATA_LONG
	 **/
	BSON.BSON_DATA_LONG = 18;
	/**
	 * MinKey BSON Type
	 *
	 * @classconstant BSON_DATA_MIN_KEY
	 **/
	BSON.BSON_DATA_MIN_KEY = 0xff;
	/**
	 * MaxKey BSON Type
	 *
	 * @classconstant BSON_DATA_MAX_KEY
	 **/
	BSON.BSON_DATA_MAX_KEY = 0x7f;
	
	/**
	 * Binary Default Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_DEFAULT
	 **/
	BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
	/**
	 * Binary Function Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_FUNCTION
	 **/
	BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
	/**
	 * Binary Byte Array Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY
	 **/
	BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
	/**
	 * Binary UUID Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_UUID
	 **/
	BSON.BSON_BINARY_SUBTYPE_UUID = 3;
	/**
	 * Binary MD5 Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_MD5
	 **/
	BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
	/**
	 * Binary User Defined Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED
	 **/
	BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
	
	/**
	 * Calculate the bson size for a passed in Javascript object.
	 *
	 * @param {Object} object the Javascript object to calculate the BSON byte size for.
	 * @param {Boolean} [serializeFunctions] serialize all functions in the object **(default:false)**.
	 * @return {Number} returns the number of bytes the BSON object will take up.
	 * @api public
	 */
	BSON.calculateObjectSize = function calculateObjectSize(object, serializeFunctions) {
	  var totalLength = (4 + 1);
	
	  if(Array.isArray(object)) {
	    for(var i = 0; i < object.length; i++) {
	      totalLength += calculateElement(i.toString(), object[i], serializeFunctions)
	    }
	  } else {
			// If we have toBSON defined, override the current object
			if(object.toBSON) {
				object = object.toBSON();
			}
	
			// Calculate size
	    for(var key in object) {
	      totalLength += calculateElement(key, object[key], serializeFunctions)
	    }
	  }
	
	  return totalLength;
	}
	
	/**
	 * @ignore
	 * @api private
	 */
	function calculateElement(name, value, serializeFunctions) {
	  var isBuffer = typeof Buffer !== 'undefined';
	  
	  // If we have toBSON defined, override the current object
	  if(value && value.toBSON){
	        value = value.toBSON();
	  }
	  
	  switch(typeof value) {
	    case 'string':
	      return 1 + (!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1 + 4 + (!isBuffer ? numberOfBytes(value) : Buffer.byteLength(value, 'utf8')) + 1;
	    case 'number':
	      if(Math.floor(value) === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
	        if(value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX) { // 32 bit
	          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (4 + 1);
	        } else {
	          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (8 + 1);
	        }
	      } else {  // 64 bit
	        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (8 + 1);
	      }
	    case 'undefined':
	      return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (1);
	    case 'boolean':
	      return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (1 + 1);
	    case 'object':
	      if(value == null || value instanceof MinKey || value instanceof MaxKey || value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
	        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (1);
	      } else if(value instanceof ObjectID || value['_bsontype'] == 'ObjectID') {
	        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (12 + 1);
	      } else if(value instanceof Date || isDate(value)) {
	        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (8 + 1);
	      } else if(typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {
	        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (1 + 4 + 1) + value.length;
	      } else if(value instanceof Long || value instanceof Double || value instanceof Timestamp
	          || value['_bsontype'] == 'Long' || value['_bsontype'] == 'Double' || value['_bsontype'] == 'Timestamp') {
	        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (8 + 1);
	      } else if(value instanceof Code || value['_bsontype'] == 'Code') {
	        // Calculate size depending on the availability of a scope
	        if(value.scope != null && Object.keys(value.scope).length > 0) {
	          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + 4 + 4 + (!isBuffer ? numberOfBytes(value.code.toString()) : Buffer.byteLength(value.code.toString(), 'utf8')) + 1 + BSON.calculateObjectSize(value.scope, serializeFunctions);
	        } else {
	          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + 4 + (!isBuffer ? numberOfBytes(value.code.toString()) : Buffer.byteLength(value.code.toString(), 'utf8')) + 1;
	        }
	      } else if(value instanceof Binary || value['_bsontype'] == 'Binary') {
	        // Check what kind of subtype we have
	        if(value.sub_type == Binary.SUBTYPE_BYTE_ARRAY) {
	          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (value.position + 1 + 4 + 1 + 4);
	        } else {
	          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (value.position + 1 + 4 + 1);
	        }
	      } else if(value instanceof Symbol || value['_bsontype'] == 'Symbol') {
	        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + ((!isBuffer ? numberOfBytes(value.value) : Buffer.byteLength(value.value, 'utf8')) + 4 + 1 + 1);
	      } else if(value instanceof DBRef || value['_bsontype'] == 'DBRef') {
	        // Set up correct object for serialization
	        var ordered_values = {
	            '$ref': value.namespace
	          , '$id' : value.oid
	        };
	
	        // Add db reference if it exists
	        if(null != value.db) {
	          ordered_values['$db'] = value.db;
	        }
	
	        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + BSON.calculateObjectSize(ordered_values, serializeFunctions);
	      } else if(value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]') {
	          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + (!isBuffer ? numberOfBytes(value.source) : Buffer.byteLength(value.source, 'utf8')) + 1
	            + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1
	      } else {
	        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + BSON.calculateObjectSize(value, serializeFunctions) + 1;
	      }
	    case 'function':
	      // WTF for 0.4.X where typeof /someregexp/ === 'function'
	      if(value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]' || String.call(value) == '[object RegExp]') {
	        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + (!isBuffer ? numberOfBytes(value.source) : Buffer.byteLength(value.source, 'utf8')) + 1
	          + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1
	      } else {
	        if(serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
	          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + 4 + 4 + (!isBuffer ? numberOfBytes(value.toString()) : Buffer.byteLength(value.toString(), 'utf8')) + 1 + BSON.calculateObjectSize(value.scope, serializeFunctions);
	        } else if(serializeFunctions) {
	          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + 4 + (!isBuffer ? numberOfBytes(value.toString()) : Buffer.byteLength(value.toString(), 'utf8')) + 1;
	        }
	      }
	  }
	
	  return 0;
	}
	
	/**
	 * Serialize a Javascript object using a predefined Buffer and index into the buffer, useful when pre-allocating the space for serialization.
	 *
	 * @param {Object} object the Javascript object to serialize.
	 * @param {Boolean} checkKeys the serializer will check if keys are valid.
	 * @param {Buffer} buffer the Buffer you pre-allocated to store the serialized BSON object.
	 * @param {Number} index the index in the buffer where we wish to start serializing into.
	 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false)**.
	 * @return {Number} returns the new write index in the Buffer.
	 * @api public
	 */
	BSON.serializeWithBufferAndIndex = function serializeWithBufferAndIndex(object, checkKeys, buffer, index, serializeFunctions) {
	  // Default setting false
	  serializeFunctions = serializeFunctions == null ? false : serializeFunctions;
	  // Write end information (length of the object)
	  var size = buffer.length;
	  // Write the size of the object
	  buffer[index++] = size & 0xff;
	  buffer[index++] = (size >> 8) & 0xff;
	  buffer[index++] = (size >> 16) & 0xff;
	  buffer[index++] = (size >> 24) & 0xff;
	  return serializeObject(object, checkKeys, buffer, index, serializeFunctions) - 1;
	}
	
	/**
	 * @ignore
	 * @api private
	 */
	var serializeObject = function(object, checkKeys, buffer, index, serializeFunctions) {
	  if(object.toBSON) {
	    if(typeof object.toBSON != 'function') throw new Error("toBSON is not a function");
	    object = object.toBSON();
	    if(object != null && typeof object != 'object') throw new Error("toBSON function did not return an object");
	  }
	
	  // Process the object
	  if(Array.isArray(object)) {
	    for(var i = 0; i < object.length; i++) {
	      index = packElement(i.toString(), object[i], checkKeys, buffer, index, serializeFunctions);
	    }
	  } else {
			// If we have toBSON defined, override the current object
			if(object.toBSON) {
				object = object.toBSON();
			}
	
			// Serialize the object
	    for(var key in object) {
	      // Check the key and throw error if it's illegal
	      if (key != '$db' && key != '$ref' && key != '$id') {
	        // dollars and dots ok
	        BSON.checkKey(key, !checkKeys);
	      }
	
	      // Pack the element
	      index = packElement(key, object[key], checkKeys, buffer, index, serializeFunctions);
	    }
	  }
	
	  // Write zero
	  buffer[index++] = 0;
	  return index;
	}
	
	var stringToBytes = function(str) {
	  var ch, st, re = [];
	  for (var i = 0; i < str.length; i++ ) {
	    ch = str.charCodeAt(i);  // get char
	    st = [];                 // set up "stack"
	    do {
	      st.push( ch & 0xFF );  // push byte to stack
	      ch = ch >> 8;          // shift value down by 1 byte
	    }
	    while ( ch );
	    // add stack contents to result
	    // done because chars have "wrong" endianness
	    re = re.concat( st.reverse() );
	  }
	  // return an array of bytes
	  return re;
	}
	
	var numberOfBytes = function(str) {
	  var ch, st, re = 0;
	  for (var i = 0; i < str.length; i++ ) {
	    ch = str.charCodeAt(i);  // get char
	    st = [];                 // set up "stack"
	    do {
	      st.push( ch & 0xFF );  // push byte to stack
	      ch = ch >> 8;          // shift value down by 1 byte
	    }
	    while ( ch );
	    // add stack contents to result
	    // done because chars have "wrong" endianness
	    re = re + st.length;
	  }
	  // return an array of bytes
	  return re;
	}
	
	/**
	 * @ignore
	 * @api private
	 */
	var writeToTypedArray = function(buffer, string, index) {
	  var bytes = stringToBytes(string);
	  for(var i = 0; i < bytes.length; i++) {
	    buffer[index + i] = bytes[i];
	  }
	  return bytes.length;
	}
	
	/**
	 * @ignore
	 * @api private
	 */
	var supportsBuffer = typeof Buffer != 'undefined';
	
	/**
	 * @ignore
	 * @api private
	 */
	var packElement = function(name, value, checkKeys, buffer, index, serializeFunctions) {
		
	  // If we have toBSON defined, override the current object
	  if(value && value.toBSON){
	        value = value.toBSON();
	  }
	  
	  var startIndex = index;
	
	  switch(typeof value) {
	    case 'string':
	      // console.log("+++++++++++ index string:: " + index)
	      // Encode String type
	      buffer[index++] = BSON.BSON_DATA_STRING;
	      // Number of written bytes
	      var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	      // Encode the name
	      index = index + numberOfWrittenBytes + 1;
	      buffer[index - 1] = 0;
	
	      // Calculate size
	      var size = supportsBuffer ? Buffer.byteLength(value) + 1 : numberOfBytes(value) + 1;
	      // console.log("====== key :: " + name + " size ::" + size)
	      // Write the size of the string to buffer
	      buffer[index + 3] = (size >> 24) & 0xff;
	      buffer[index + 2] = (size >> 16) & 0xff;
	      buffer[index + 1] = (size >> 8) & 0xff;
	      buffer[index] = size & 0xff;
	      // Ajust the index
	      index = index + 4;
	      // Write the string
	      supportsBuffer ? buffer.write(value, index, 'utf8') : writeToTypedArray(buffer, value, index);
	      // Update index
	      index = index + size - 1;
	      // Write zero
	      buffer[index++] = 0;
	      // Return index
	      return index;
	    case 'number':
	      // We have an integer value
	      if(Math.floor(value) === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
	        // If the value fits in 32 bits encode as int, if it fits in a double
	        // encode it as a double, otherwise long
	        if(value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX) {
	          // Set int type 32 bits or less
	          buffer[index++] = BSON.BSON_DATA_INT;
	          // Number of written bytes
	          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	          // Encode the name
	          index = index + numberOfWrittenBytes + 1;
	          buffer[index - 1] = 0;
	          // Write the int value
	          buffer[index++] = value & 0xff;
	          buffer[index++] = (value >> 8) & 0xff;
	          buffer[index++] = (value >> 16) & 0xff;
	          buffer[index++] = (value >> 24) & 0xff;
	        } else if(value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
	          // Encode as double
	          buffer[index++] = BSON.BSON_DATA_NUMBER;
	          // Number of written bytes
	          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	          // Encode the name
	          index = index + numberOfWrittenBytes + 1;
	          buffer[index - 1] = 0;
	          // Write float
	          writeIEEE754(buffer, value, index, 'little', 52, 8);
	          // Ajust index
	          index = index + 8;
	        } else {
	          // Set long type
	          buffer[index++] = BSON.BSON_DATA_LONG;
	          // Number of written bytes
	          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	          // Encode the name
	          index = index + numberOfWrittenBytes + 1;
	          buffer[index - 1] = 0;
	          var longVal = Long.fromNumber(value);
	          var lowBits = longVal.getLowBits();
	          var highBits = longVal.getHighBits();
	          // Encode low bits
	          buffer[index++] = lowBits & 0xff;
	          buffer[index++] = (lowBits >> 8) & 0xff;
	          buffer[index++] = (lowBits >> 16) & 0xff;
	          buffer[index++] = (lowBits >> 24) & 0xff;
	          // Encode high bits
	          buffer[index++] = highBits & 0xff;
	          buffer[index++] = (highBits >> 8) & 0xff;
	          buffer[index++] = (highBits >> 16) & 0xff;
	          buffer[index++] = (highBits >> 24) & 0xff;
	        }
	      } else {
	        // Encode as double
	        buffer[index++] = BSON.BSON_DATA_NUMBER;
	        // Number of written bytes
	        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	        // Encode the name
	        index = index + numberOfWrittenBytes + 1;
	        buffer[index - 1] = 0;
	        // Write float
	        writeIEEE754(buffer, value, index, 'little', 52, 8);
	        // Ajust index
	        index = index + 8;
	      }
	
	      return index;
	    case 'undefined':
	      // Set long type
	      buffer[index++] = BSON.BSON_DATA_NULL;
	      // Number of written bytes
	      var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	      // Encode the name
	      index = index + numberOfWrittenBytes + 1;
	      buffer[index - 1] = 0;
	      return index;
	    case 'boolean':
	      // Write the type
	      buffer[index++] = BSON.BSON_DATA_BOOLEAN;
	      // Number of written bytes
	      var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	      // Encode the name
	      index = index + numberOfWrittenBytes + 1;
	      buffer[index - 1] = 0;
	      // Encode the boolean value
	      buffer[index++] = value ? 1 : 0;
	      return index;
	    case 'object':
	      if(value === null || value instanceof MinKey || value instanceof MaxKey
	          || value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
	        // Write the type of either min or max key
	        if(value === null) {
	          buffer[index++] = BSON.BSON_DATA_NULL;
	        } else if(value instanceof MinKey) {
	          buffer[index++] = BSON.BSON_DATA_MIN_KEY;
	        } else {
	          buffer[index++] = BSON.BSON_DATA_MAX_KEY;
	        }
	
	        // Number of written bytes
	        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	        // Encode the name
	        index = index + numberOfWrittenBytes + 1;
	        buffer[index - 1] = 0;
	        return index;
	      } else if(value instanceof ObjectID || value['_bsontype'] == 'ObjectID') {
	        // console.log("+++++++++++ index OBJECTID:: " + index)
	        // Write the type
	        buffer[index++] = BSON.BSON_DATA_OID;
	        // Number of written bytes
	        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	        // Encode the name
	        index = index + numberOfWrittenBytes + 1;
	        buffer[index - 1] = 0;
	
	        // Write objectid
	        supportsBuffer ? buffer.write(value.id, index, 'binary') : writeToTypedArray(buffer, value.id, index);
	        // Ajust index
	        index = index + 12;
	        return index;
	      } else if(value instanceof Date || isDate(value)) {
	        // Write the type
	        buffer[index++] = BSON.BSON_DATA_DATE;
	        // Number of written bytes
	        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	        // Encode the name
	        index = index + numberOfWrittenBytes + 1;
	        buffer[index - 1] = 0;
	
	        // Write the date
	        var dateInMilis = Long.fromNumber(value.getTime());
	        var lowBits = dateInMilis.getLowBits();
	        var highBits = dateInMilis.getHighBits();
	        // Encode low bits
	        buffer[index++] = lowBits & 0xff;
	        buffer[index++] = (lowBits >> 8) & 0xff;
	        buffer[index++] = (lowBits >> 16) & 0xff;
	        buffer[index++] = (lowBits >> 24) & 0xff;
	        // Encode high bits
	        buffer[index++] = highBits & 0xff;
	        buffer[index++] = (highBits >> 8) & 0xff;
	        buffer[index++] = (highBits >> 16) & 0xff;
	        buffer[index++] = (highBits >> 24) & 0xff;
	        return index;
	      } else if(typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {
	        // Write the type
	        buffer[index++] = BSON.BSON_DATA_BINARY;
	        // Number of written bytes
	        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	        // Encode the name
	        index = index + numberOfWrittenBytes + 1;
	        buffer[index - 1] = 0;
	        // Get size of the buffer (current write point)
	        var size = value.length;
	        // Write the size of the string to buffer
	        buffer[index++] = size & 0xff;
	        buffer[index++] = (size >> 8) & 0xff;
	        buffer[index++] = (size >> 16) & 0xff;
	        buffer[index++] = (size >> 24) & 0xff;
	        // Write the default subtype
	        buffer[index++] = BSON.BSON_BINARY_SUBTYPE_DEFAULT;
	        // Copy the content form the binary field to the buffer
	        value.copy(buffer, index, 0, size);
	        // Adjust the index
	        index = index + size;
	        return index;
	      } else if(value instanceof Long || value instanceof Timestamp || value['_bsontype'] == 'Long' || value['_bsontype'] == 'Timestamp') {
	        // Write the type
	        buffer[index++] = value instanceof Long || value['_bsontype'] == 'Long' ? BSON.BSON_DATA_LONG : BSON.BSON_DATA_TIMESTAMP;
	        // Number of written bytes
	        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	        // Encode the name
	        index = index + numberOfWrittenBytes + 1;
	        buffer[index - 1] = 0;
	        // Write the date
	        var lowBits = value.getLowBits();
	        var highBits = value.getHighBits();
	        // Encode low bits
	        buffer[index++] = lowBits & 0xff;
	        buffer[index++] = (lowBits >> 8) & 0xff;
	        buffer[index++] = (lowBits >> 16) & 0xff;
	        buffer[index++] = (lowBits >> 24) & 0xff;
	        // Encode high bits
	        buffer[index++] = highBits & 0xff;
	        buffer[index++] = (highBits >> 8) & 0xff;
	        buffer[index++] = (highBits >> 16) & 0xff;
	        buffer[index++] = (highBits >> 24) & 0xff;
	        return index;
	      } else if(value instanceof Double || value['_bsontype'] == 'Double') {
	        // Encode as double
	        buffer[index++] = BSON.BSON_DATA_NUMBER;
	        // Number of written bytes
	        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	        // Encode the name
	        index = index + numberOfWrittenBytes + 1;
	        buffer[index - 1] = 0;
	        // Write float
	        writeIEEE754(buffer, value, index, 'little', 52, 8);
	        // Ajust index
	        index = index + 8;
	        return index;
	      } else if(value instanceof Code || value['_bsontype'] == 'Code') {
	        if(value.scope != null && Object.keys(value.scope).length > 0) {
	          // Write the type
	          buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;
	          // Number of written bytes
	          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	          // Encode the name
	          index = index + numberOfWrittenBytes + 1;
	          buffer[index - 1] = 0;
	          // Calculate the scope size
	          var scopeSize = BSON.calculateObjectSize(value.scope, serializeFunctions);
	          // Function string
	          var functionString = value.code.toString();
	          // Function Size
	          var codeSize = supportsBuffer ? Buffer.byteLength(functionString) + 1 : numberOfBytes(functionString) + 1;
	
	          // Calculate full size of the object
	          var totalSize = 4 + codeSize + scopeSize + 4;
	
	          // Write the total size of the object
	          buffer[index++] = totalSize & 0xff;
	          buffer[index++] = (totalSize >> 8) & 0xff;
	          buffer[index++] = (totalSize >> 16) & 0xff;
	          buffer[index++] = (totalSize >> 24) & 0xff;
	
	          // Write the size of the string to buffer
	          buffer[index++] = codeSize & 0xff;
	          buffer[index++] = (codeSize >> 8) & 0xff;
	          buffer[index++] = (codeSize >> 16) & 0xff;
	          buffer[index++] = (codeSize >> 24) & 0xff;
	
	          // Write the string
	          supportsBuffer ? buffer.write(functionString, index, 'utf8') : writeToTypedArray(buffer, functionString, index);
	          // Update index
	          index = index + codeSize - 1;
	          // Write zero
	          buffer[index++] = 0;
	          // Serialize the scope object
	          var scopeObjectBuffer = supportsBuffer ? new Buffer(scopeSize) : new Uint8Array(new ArrayBuffer(scopeSize));
	          // Execute the serialization into a seperate buffer
	          serializeObject(value.scope, checkKeys, scopeObjectBuffer, 0, serializeFunctions);
	
	          // Adjusted scope Size (removing the header)
	          var scopeDocSize = scopeSize;
	          // Write scope object size
	          buffer[index++] = scopeDocSize & 0xff;
	          buffer[index++] = (scopeDocSize >> 8) & 0xff;
	          buffer[index++] = (scopeDocSize >> 16) & 0xff;
	          buffer[index++] = (scopeDocSize >> 24) & 0xff;
	
	          // Write the scopeObject into the buffer
	          supportsBuffer ? scopeObjectBuffer.copy(buffer, index, 0, scopeSize) : buffer.set(scopeObjectBuffer, index);
	          // Adjust index, removing the empty size of the doc (5 bytes 0000000005)
	          index = index + scopeDocSize - 5;
	          // Write trailing zero
	          buffer[index++] = 0;
	          return index
	        } else {
	          buffer[index++] = BSON.BSON_DATA_CODE;
	          // Number of written bytes
	          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	          // Encode the name
	          index = index + numberOfWrittenBytes + 1;
	          buffer[index - 1] = 0;
	          // Function string
	          var functionString = value.code.toString();
	          // Function Size
	          var size = supportsBuffer ? Buffer.byteLength(functionString) + 1 : numberOfBytes(functionString) + 1;
	          // Write the size of the string to buffer
	          buffer[index++] = size & 0xff;
	          buffer[index++] = (size >> 8) & 0xff;
	          buffer[index++] = (size >> 16) & 0xff;
	          buffer[index++] = (size >> 24) & 0xff;
	          // Write the string
	          supportsBuffer ? buffer.write(functionString, index, 'utf8') : writeToTypedArray(buffer, functionString, index);
	          // Update index
	          index = index + size - 1;
	          // Write zero
	          buffer[index++] = 0;
	          return index;
	        }
	      } else if(value instanceof Binary || value['_bsontype'] == 'Binary') {
	        // Write the type
	        buffer[index++] = BSON.BSON_DATA_BINARY;
	        // Number of written bytes
	        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	        // Encode the name
	        index = index + numberOfWrittenBytes + 1;
	        buffer[index - 1] = 0;
	        // Extract the buffer
	        var data = value.value(true);
	        // Calculate size
	        var size = value.position;
	        // Write the size of the string to buffer
	        buffer[index++] = size & 0xff;
	        buffer[index++] = (size >> 8) & 0xff;
	        buffer[index++] = (size >> 16) & 0xff;
	        buffer[index++] = (size >> 24) & 0xff;
	        // Write the subtype to the buffer
	        buffer[index++] = value.sub_type;
	
	        // If we have binary type 2 the 4 first bytes are the size
	        if(value.sub_type == Binary.SUBTYPE_BYTE_ARRAY) {
	          buffer[index++] = size & 0xff;
	          buffer[index++] = (size >> 8) & 0xff;
	          buffer[index++] = (size >> 16) & 0xff;
	          buffer[index++] = (size >> 24) & 0xff;
	        }
	
	        // Write the data to the object
	        supportsBuffer ? data.copy(buffer, index, 0, value.position) : buffer.set(data, index);
	        // Ajust index
	        index = index + value.position;
	        return index;
	      } else if(value instanceof Symbol || value['_bsontype'] == 'Symbol') {
	        // Write the type
	        buffer[index++] = BSON.BSON_DATA_SYMBOL;
	        // Number of written bytes
	        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	        // Encode the name
	        index = index + numberOfWrittenBytes + 1;
	        buffer[index - 1] = 0;
	        // Calculate size
	        var size = supportsBuffer ? Buffer.byteLength(value.value) + 1 : numberOfBytes(value.value) + 1;
	        // Write the size of the string to buffer
	        buffer[index++] = size & 0xff;
	        buffer[index++] = (size >> 8) & 0xff;
	        buffer[index++] = (size >> 16) & 0xff;
	        buffer[index++] = (size >> 24) & 0xff;
	        // Write the string
	        buffer.write(value.value, index, 'utf8');
	        // Update index
	        index = index + size - 1;
	        // Write zero
	        buffer[index++] = 0x00;
	        return index;
	      } else if(value instanceof DBRef || value['_bsontype'] == 'DBRef') {
	        // Write the type
	        buffer[index++] = BSON.BSON_DATA_OBJECT;
	        // Number of written bytes
	        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	        // Encode the name
	        index = index + numberOfWrittenBytes + 1;
	        buffer[index - 1] = 0;
	        // Set up correct object for serialization
	        var ordered_values = {
	            '$ref': value.namespace
	          , '$id' : value.oid
	        };
	
	        // Add db reference if it exists
	        if(null != value.db) {
	          ordered_values['$db'] = value.db;
	        }
	
	        // Message size
	        var size = BSON.calculateObjectSize(ordered_values, serializeFunctions);
	        // Serialize the object
	        var endIndex = BSON.serializeWithBufferAndIndex(ordered_values, checkKeys, buffer, index, serializeFunctions);
	        // Write the size of the string to buffer
	        buffer[index++] = size & 0xff;
	        buffer[index++] = (size >> 8) & 0xff;
	        buffer[index++] = (size >> 16) & 0xff;
	        buffer[index++] = (size >> 24) & 0xff;
	        // Write zero for object
	        buffer[endIndex++] = 0x00;
	        // Return the end index
	        return endIndex;
	      } else if(value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]') {
	        // Write the type
	        buffer[index++] = BSON.BSON_DATA_REGEXP;
	        // Number of written bytes
	        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	        // Encode the name
	        index = index + numberOfWrittenBytes + 1;
	        buffer[index - 1] = 0;
	
	        // Write the regular expression string
	        supportsBuffer ? buffer.write(value.source, index, 'utf8') : writeToTypedArray(buffer, value.source, index);
	        // Adjust the index
	        index = index + (supportsBuffer ? Buffer.byteLength(value.source) : numberOfBytes(value.source));
	        // Write zero
	        buffer[index++] = 0x00;
	        // Write the parameters
	        if(value.global) buffer[index++] = 0x73; // s
	        if(value.ignoreCase) buffer[index++] = 0x69; // i
	        if(value.multiline) buffer[index++] = 0x6d; // m
	        // Add ending zero
	        buffer[index++] = 0x00;
	        return index;
	      } else {
	        // Write the type
	        buffer[index++] = Array.isArray(value) ? BSON.BSON_DATA_ARRAY : BSON.BSON_DATA_OBJECT;
	        // Number of written bytes
	        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	        // Adjust the index
	        index = index + numberOfWrittenBytes + 1;
	        buffer[index - 1] = 0;
		      var endIndex = serializeObject(value, checkKeys, buffer, index + 4, serializeFunctions);
	        // Write size
	        var size = endIndex - index;
	        // Write the size of the string to buffer
	        buffer[index++] = size & 0xff;
	        buffer[index++] = (size >> 8) & 0xff;
	        buffer[index++] = (size >> 16) & 0xff;
	        buffer[index++] = (size >> 24) & 0xff;
	        return endIndex;
	      }
	    case 'function':
	      // WTF for 0.4.X where typeof /someregexp/ === 'function'
	      if(value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]' || String.call(value) == '[object RegExp]') {
	        // Write the type
	        buffer[index++] = BSON.BSON_DATA_REGEXP;
	        // Number of written bytes
	        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	        // Encode the name
	        index = index + numberOfWrittenBytes + 1;
	        buffer[index - 1] = 0;
	
	        // Write the regular expression string
	        buffer.write(value.source, index, 'utf8');
	        // Adjust the index
	        index = index + (supportsBuffer ? Buffer.byteLength(value.source) : numberOfBytes(value.source));
	        // Write zero
	        buffer[index++] = 0x00;
	        // Write the parameters
	        if(value.global) buffer[index++] = 0x73; // s
	        if(value.ignoreCase) buffer[index++] = 0x69; // i
	        if(value.multiline) buffer[index++] = 0x6d; // m
	        // Add ending zero
	        buffer[index++] = 0x00;
	        return index;
	      } else {
	        if(serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
	          // Write the type
	          buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;
	          // Number of written bytes
	          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	          // Encode the name
	          index = index + numberOfWrittenBytes + 1;
	          buffer[index - 1] = 0;
	          // Calculate the scope size
	          var scopeSize = BSON.calculateObjectSize(value.scope, serializeFunctions);
	          // Function string
	          var functionString = value.toString();
	          // Function Size
	          var codeSize = supportsBuffer ? Buffer.byteLength(functionString) + 1 : numberOfBytes(functionString) + 1;
	
	          // Calculate full size of the object
	          var totalSize = 4 + codeSize + scopeSize;
	
	          // Write the total size of the object
	          buffer[index++] = totalSize & 0xff;
	          buffer[index++] = (totalSize >> 8) & 0xff;
	          buffer[index++] = (totalSize >> 16) & 0xff;
	          buffer[index++] = (totalSize >> 24) & 0xff;
	
	          // Write the size of the string to buffer
	          buffer[index++] = codeSize & 0xff;
	          buffer[index++] = (codeSize >> 8) & 0xff;
	          buffer[index++] = (codeSize >> 16) & 0xff;
	          buffer[index++] = (codeSize >> 24) & 0xff;
	
	          // Write the string
	          supportsBuffer ? buffer.write(functionString, index, 'utf8') : writeToTypedArray(buffer, functionString, index);
	          // Update index
	          index = index + codeSize - 1;
	          // Write zero
	          buffer[index++] = 0;
	          // Serialize the scope object
	          var scopeObjectBuffer = new Buffer(scopeSize);
	          // Execute the serialization into a seperate buffer
	          serializeObject(value.scope, checkKeys, scopeObjectBuffer, 0, serializeFunctions);
	
	          // Adjusted scope Size (removing the header)
	          var scopeDocSize = scopeSize - 4;
	          // Write scope object size
	          buffer[index++] = scopeDocSize & 0xff;
	          buffer[index++] = (scopeDocSize >> 8) & 0xff;
	          buffer[index++] = (scopeDocSize >> 16) & 0xff;
	          buffer[index++] = (scopeDocSize >> 24) & 0xff;
	
	          // Write the scopeObject into the buffer
	          scopeObjectBuffer.copy(buffer, index, 0, scopeSize);
	
	          // Adjust index, removing the empty size of the doc (5 bytes 0000000005)
	          index = index + scopeDocSize - 5;
	          // Write trailing zero
	          buffer[index++] = 0;
	          return index
	        } else if(serializeFunctions) {
	          buffer[index++] = BSON.BSON_DATA_CODE;
	          // Number of written bytes
	          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
	          // Encode the name
	          index = index + numberOfWrittenBytes + 1;
	          buffer[index - 1] = 0;
	          // Function string
	          var functionString = value.toString();
	          // Function Size
	          var size = supportsBuffer ? Buffer.byteLength(functionString) + 1 : numberOfBytes(functionString) + 1;
	          // Write the size of the string to buffer
	          buffer[index++] = size & 0xff;
	          buffer[index++] = (size >> 8) & 0xff;
	          buffer[index++] = (size >> 16) & 0xff;
	          buffer[index++] = (size >> 24) & 0xff;
	          // Write the string
	          supportsBuffer ? buffer.write(functionString, index, 'utf8') : writeToTypedArray(buffer, functionString, index);
	          // Update index
	          index = index + size - 1;
	          // Write zero
	          buffer[index++] = 0;
	          return index;
	        }
	      }
	  }
	
	  // If no value to serialize
	  return index;
	}
	
	/**
	 * Serialize a Javascript object.
	 *
	 * @param {Object} object the Javascript object to serialize.
	 * @param {Boolean} checkKeys the serializer will check if keys are valid.
	 * @param {Boolean} asBuffer return the serialized object as a Buffer object **(ignore)**.
	 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false)**.
	 * @return {Buffer} returns the Buffer object containing the serialized object.
	 * @api public
	 */
	BSON.serialize = function(object, checkKeys, asBuffer, serializeFunctions) {
	  // Throw error if we are trying serialize an illegal type
	  if(object == null || typeof object != 'object' || Array.isArray(object)) 
	    throw new Error("Only javascript objects supported");
	  
	  // Emoty target buffer
	  var buffer = null;
	  // Calculate the size of the object
	  var size = BSON.calculateObjectSize(object, serializeFunctions);
	  // Fetch the best available type for storing the binary data
	  if(buffer = typeof Buffer != 'undefined') {
	    buffer = new Buffer(size);
	    asBuffer = true;
	  } else if(typeof Uint8Array != 'undefined') {
	    buffer = new Uint8Array(new ArrayBuffer(size));
	  } else {
	    buffer = new Array(size);
	  }
	
	  // If asBuffer is false use typed arrays
	  BSON.serializeWithBufferAndIndex(object, checkKeys, buffer, 0, serializeFunctions);
	  // console.log("++++++++++++++++++++++++++++++++++++ OLDJS :: " + buffer.length)  
	  // console.log(buffer.toString('hex'))
	  // console.log(buffer.toString('ascii'))
	  return buffer;
	}
	
	/**
	 * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5
	 *
	 * @ignore
	 * @api private
	 */
	var functionCache = BSON.functionCache = {};
	
	/**
	 * Crc state variables shared by function
	 *
	 * @ignore
	 * @api private
	 */
	var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];
	
	/**
	 * CRC32 hash method, Fast and enough versitility for our usage
	 *
	 * @ignore
	 * @api private
	 */
	var crc32 =  function(string, start, end) {
	  var crc = 0
	  var x = 0;
	  var y = 0;
	  crc = crc ^ (-1);
	
	  for(var i = start, iTop = end; i < iTop;i++) {
	  	y = (crc ^ string[i]) & 0xFF;
	    x = table[y];
	  	crc = (crc >>> 8) ^ x;
	  }
	
	  return crc ^ (-1);
	}
	
	/**
	 * Deserialize stream data as BSON documents.
	 *
	 * Options
	 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
	 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
	 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
	 *  - **promoteLongs** {Boolean, default:true}, when deserializing a Long will fit it into a Number if it's smaller than 53 bits
	 *
	 * @param {Buffer} data the buffer containing the serialized set of BSON documents.
	 * @param {Number} startIndex the start index in the data Buffer where the deserialization is to start.
	 * @param {Number} numberOfDocuments number of documents to deserialize.
	 * @param {Array} documents an array where to store the deserialized documents.
	 * @param {Number} docStartIndex the index in the documents array from where to start inserting documents.
	 * @param {Object} [options] additional options used for the deserialization.
	 * @return {Number} returns the next index in the buffer after deserialization **x** numbers of documents.
	 * @api public
	 */
	BSON.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
	  // if(numberOfDocuments !== documents.length) throw new Error("Number of expected results back is less than the number of documents");
	  options = options != null ? options : {};
	  var index = startIndex;
	  // Loop over all documents
	  for(var i = 0; i < numberOfDocuments; i++) {
	    // Find size of the document
	    var size = data[index] | data[index + 1] << 8 | data[index + 2] << 16 | data[index + 3] << 24;
	    // Update options with index
	    options['index'] = index;
	    // Parse the document at this point
	    documents[docStartIndex + i] = BSON.deserialize(data, options);
	    // Adjust index by the document size
	    index = index + size;
	  }
	
	  // Return object containing end index of parsing and list of documents
	  return index;
	}
	
	/**
	 * Ensure eval is isolated.
	 *
	 * @ignore
	 * @api private
	 */
	var isolateEvalWithHash = function(functionCache, hash, functionString, object) {
	  // Contains the value we are going to set
	  var value = null;
	
	  // Check for cache hit, eval if missing and return cached function
	  if(functionCache[hash] == null) {
	    eval("value = " + functionString);
	    functionCache[hash] = value;
	  }
	  // Set the object
	  return functionCache[hash].bind(object);
	}
	
	/**
	 * Ensure eval is isolated.
	 *
	 * @ignore
	 * @api private
	 */
	var isolateEval = function(functionString) {
	  // Contains the value we are going to set
	  var value = null;
	  // Eval the function
	  eval("value = " + functionString);
	  return value;
	}
	
	/**
	 * Convert Uint8Array to String
	 *
	 * @ignore
	 * @api private
	 */
	var convertUint8ArrayToUtf8String = function(byteArray, startIndex, endIndex) {
	  return BinaryParser.decode_utf8(convertArraytoUtf8BinaryString(byteArray, startIndex, endIndex));
	}
	
	var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {
	  var result = "";
	  for(var i = startIndex; i < endIndex; i++) {
	    result = result + String.fromCharCode(byteArray[i]);
	  }
	
	  return result;
	};
	
	/**
	 * Deserialize data as BSON.
	 *
	 * Options
	 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
	 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
	 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
	 *  - **promoteLongs** {Boolean, default:true}, when deserializing a Long will fit it into a Number if it's smaller than 53 bits
	 *
	 * @param {Buffer} buffer the buffer containing the serialized set of BSON documents.
	 * @param {Object} [options] additional options used for the deserialization.
	 * @param {Boolean} [isArray] ignore used for recursive parsing.
	 * @return {Object} returns the deserialized Javascript Object.
	 * @api public
	 */
	BSON.deserialize = function(buffer, options, isArray) {
	  // Options
	  options = options == null ? {} : options;
	  var evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];
	  var cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];
	  var cacheFunctionsCrc32 = options['cacheFunctionsCrc32'] == null ? false : options['cacheFunctionsCrc32'];
	  var promoteLongs = options['promoteLongs'] == null ? true : options['promoteLongs'];
	
	  // Validate that we have at least 4 bytes of buffer
	  if(buffer.length < 5) throw new Error("corrupt bson message < 5 bytes long");
	
	  // Set up index
	  var index = typeof options['index'] == 'number' ? options['index'] : 0;
	  // Reads in a C style string
	  var readCStyleString = function() {
	    // Get the start search index
	    var i = index;
	    // Locate the end of the c string
	    while(buffer[i] !== 0x00 && i < buffer.length) { 
	      i++ 
	    }
	    // If are at the end of the buffer there is a problem with the document
	    if(i >= buffer.length) throw new Error("Bad BSON Document: illegal CString")
	    // Grab utf8 encoded string
	    var string = supportsBuffer && Buffer.isBuffer(buffer) ? buffer.toString('utf8', index, i) : convertUint8ArrayToUtf8String(buffer, index, i);
	    // Update index position
	    index = i + 1;
	    // Return string
	    return string;
	  }
	
	  // Create holding object
	  var object = isArray ? [] : {};
	
	  // Read the document size
	  var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	
	  // Ensure buffer is valid size
	  if(size < 5 || size > buffer.length) throw new Error("corrupt bson message");
	
	  // While we have more left data left keep parsing
	  while(true) {
	    // Read the type
	    var elementType = buffer[index++];
	    // If we get a zero it's the last byte, exit
	    if(elementType == 0) break;
	    // Read the name of the field
	    var name = readCStyleString();
	    // Switch on the type
	    switch(elementType) {
	      case BSON.BSON_DATA_OID:
	        var string = supportsBuffer && Buffer.isBuffer(buffer) ? buffer.toString('binary', index, index + 12) : convertArraytoUtf8BinaryString(buffer, index, index + 12);
	        // Decode the oid
	        object[name] = new ObjectID(string);
	        // Update index
	        index = index + 12;
	        break;
	      case BSON.BSON_DATA_STRING:
	        // Read the content of the field
	        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	        // Add string to object
	        object[name] = supportsBuffer && Buffer.isBuffer(buffer) ? buffer.toString('utf8', index, index + stringSize - 1) : convertUint8ArrayToUtf8String(buffer, index, index + stringSize - 1);
	        // Update parse index position
	        index = index + stringSize;
	        break;
	      case BSON.BSON_DATA_INT:
	        // Decode the 32bit value
	        object[name] = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	        break;
	      case BSON.BSON_DATA_NUMBER:
	        // Decode the double value
	        object[name] = readIEEE754(buffer, index, 'little', 52, 8);
	        // Update the index
	        index = index + 8;
	        break;
	      case BSON.BSON_DATA_DATE:
	        // Unpack the low and high bits
	        var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	        var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	        // Set date object
	        object[name] = new Date(new Long(lowBits, highBits).toNumber());
	        break;
	      case BSON.BSON_DATA_BOOLEAN:
	        // Parse the boolean value
	        object[name] = buffer[index++] == 1;
	        break;
	      case BSON.BSON_DATA_UNDEFINED:
	      case BSON.BSON_DATA_NULL:
	        // Parse the boolean value
	        object[name] = null;
	        break;
	      case BSON.BSON_DATA_BINARY:
	        // Decode the size of the binary blob
	        var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	        // Decode the subtype
	        var subType = buffer[index++];
	        // Decode as raw Buffer object if options specifies it
	        if(buffer['slice'] != null) {
	          // If we have subtype 2 skip the 4 bytes for the size
	          if(subType == Binary.SUBTYPE_BYTE_ARRAY) {
	            binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	          }
	          // Slice the data
	          object[name] = new Binary(buffer.slice(index, index + binarySize), subType);
	        } else {
	          var _buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize);
	          // If we have subtype 2 skip the 4 bytes for the size
	          if(subType == Binary.SUBTYPE_BYTE_ARRAY) {
	            binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	          }
	          // Copy the data
	          for(var i = 0; i < binarySize; i++) {
	            _buffer[i] = buffer[index + i];
	          }
	          // Create the binary object
	          object[name] = new Binary(_buffer, subType);
	        }
	        // Update the index
	        index = index + binarySize;
	        break;
	      case BSON.BSON_DATA_ARRAY:
	        options['index'] = index;
	        // Decode the size of the array document
	        var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
	        // Set the array to the object
	        object[name] = BSON.deserialize(buffer, options, true);
	        // Adjust the index
	        index = index + objectSize;
	        break;
	      case BSON.BSON_DATA_OBJECT:
	        options['index'] = index;
	        // Decode the size of the object document
	        var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
	        // Set the array to the object
	        object[name] = BSON.deserialize(buffer, options, false);
	        // Adjust the index
	        index = index + objectSize;
	        break;
	      case BSON.BSON_DATA_REGEXP:
	        // Create the regexp
	        var source = readCStyleString();
	        var regExpOptions = readCStyleString();
	        // For each option add the corresponding one for javascript
	        var optionsArray = new Array(regExpOptions.length);
	
	        // Parse options
	        for(var i = 0; i < regExpOptions.length; i++) {
	          switch(regExpOptions[i]) {
	            case 'm':
	              optionsArray[i] = 'm';
	              break;
	            case 's':
	              optionsArray[i] = 'g';
	              break;
	            case 'i':
	              optionsArray[i] = 'i';
	              break;
	          }
	        }
	
	        object[name] = new RegExp(source, optionsArray.join(''));
	        break;
	      case BSON.BSON_DATA_LONG:
	        // Unpack the low and high bits
	        var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	        var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	        // Create long object
	        var long = new Long(lowBits, highBits); 
	        // Promote the long if possible
	        if(promoteLongs) {
	          object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
	        } else {
	          object[name] = long;
	        }
	        break;
	      case BSON.BSON_DATA_SYMBOL:
	        // Read the content of the field
	        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	        // Add string to object
	        object[name] = new Symbol(buffer.toString('utf8', index, index + stringSize - 1));
	        // Update parse index position
	        index = index + stringSize;
	        break;
	      case BSON.BSON_DATA_TIMESTAMP:
	        // Unpack the low and high bits
	        var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	        var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	        // Set the object
	        object[name] = new Timestamp(lowBits, highBits);
	        break;
	      case BSON.BSON_DATA_MIN_KEY:
	        // Parse the object
	        object[name] = new MinKey();
	        break;
	      case BSON.BSON_DATA_MAX_KEY:
	        // Parse the object
	        object[name] = new MaxKey();
	        break;
	      case BSON.BSON_DATA_CODE:
	        // Read the content of the field
	        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	        // Function string
	        var functionString = supportsBuffer && Buffer.isBuffer(buffer) ? buffer.toString('utf8', index, index + stringSize - 1) : convertUint8ArrayToUtf8String(buffer, index, index + stringSize - 1);
	
	        // If we are evaluating the functions
	        if(evalFunctions) {
	          // Contains the value we are going to set
	          var value = null;
	          // If we have cache enabled let's look for the md5 of the function in the cache
	          if(cacheFunctions) {
	            var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
	            // Got to do this to avoid V8 deoptimizing the call due to finding eval
	            object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
	          } else {
	            // Set directly
	            object[name] = isolateEval(functionString);
	          }
	        } else {
	          object[name]  = new Code(functionString, {});
	        }
	
	        // Update parse index position
	        index = index + stringSize;
	        break;
	      case BSON.BSON_DATA_CODE_W_SCOPE:
	        // Read the content of the field
	        var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	        // Javascript function
	        var functionString = supportsBuffer && Buffer.isBuffer(buffer) ? buffer.toString('utf8', index, index + stringSize - 1) : convertUint8ArrayToUtf8String(buffer, index, index + stringSize - 1);
	        // Update parse index position
	        index = index + stringSize;
	        // Parse the element
	        options['index'] = index;
	        // Decode the size of the object document
	        var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
	        // Decode the scope object
	        var scopeObject = BSON.deserialize(buffer, options, false);
	        // Adjust the index
	        index = index + objectSize;
	
	        // If we are evaluating the functions
	        if(evalFunctions) {
	          // Contains the value we are going to set
	          var value = null;
	          // If we have cache enabled let's look for the md5 of the function in the cache
	          if(cacheFunctions) {
	            var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
	            // Got to do this to avoid V8 deoptimizing the call due to finding eval
	            object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
	          } else {
	            // Set directly
	            object[name] = isolateEval(functionString);
	          }
	
	          // Set the scope on the object
	          object[name].scope = scopeObject;
	        } else {
	          object[name]  = new Code(functionString, scopeObject);
	        }
	
	        // Add string to object
	        break;
	    }
	  }
	
	  // Check if we have a db ref object
	  if(object['$id'] != null) object = new DBRef(object['$ref'], object['$id'], object['$db']);
	
	  // Return the final objects
	  return object;
	}
	
	/**
	 * Check if key name is valid.
	 *
	 * @ignore
	 * @api private
	 */
	BSON.checkKey = function checkKey (key, dollarsAndDotsOk) {
	  if (!key.length) return;
	  // Check if we have a legal key for the object
	  if (!!~key.indexOf("\x00")) {
	    // The BSON spec doesn't allow keys with null bytes because keys are
	    // null-terminated.
	    throw Error("key " + key + " must not contain null bytes");
	  }
	  if (!dollarsAndDotsOk) {
	    if('$' == key[0]) {
	      throw Error("key " + key + " must not start with '$'");
	    } else if (!!~key.indexOf('.')) {
	      throw Error("key " + key + " must not contain '.'");
	    }
	  }
	};
	
	/**
	 * Deserialize data as BSON.
	 *
	 * Options
	 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
	 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
	 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
	 *
	 * @param {Buffer} buffer the buffer containing the serialized set of BSON documents.
	 * @param {Object} [options] additional options used for the deserialization.
	 * @param {Boolean} [isArray] ignore used for recursive parsing.
	 * @return {Object} returns the deserialized Javascript Object.
	 * @api public
	 */
	BSON.prototype.deserialize = function(data, options) {
	  return BSON.deserialize(data, options);
	}
	
	/**
	 * Deserialize stream data as BSON documents.
	 *
	 * Options
	 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
	 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
	 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
	 *
	 * @param {Buffer} data the buffer containing the serialized set of BSON documents.
	 * @param {Number} startIndex the start index in the data Buffer where the deserialization is to start.
	 * @param {Number} numberOfDocuments number of documents to deserialize.
	 * @param {Array} documents an array where to store the deserialized documents.
	 * @param {Number} docStartIndex the index in the documents array from where to start inserting documents.
	 * @param {Object} [options] additional options used for the deserialization.
	 * @return {Number} returns the next index in the buffer after deserialization **x** numbers of documents.
	 * @api public
	 */
	BSON.prototype.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
	  return BSON.deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options);
	}
	
	/**
	 * Serialize a Javascript object.
	 *
	 * @param {Object} object the Javascript object to serialize.
	 * @param {Boolean} checkKeys the serializer will check if keys are valid.
	 * @param {Boolean} asBuffer return the serialized object as a Buffer object **(ignore)**.
	 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false)**.
	 * @return {Buffer} returns the Buffer object containing the serialized object.
	 * @api public
	 */
	BSON.prototype.serialize = function(object, checkKeys, asBuffer, serializeFunctions) {
	  return BSON.serialize(object, checkKeys, asBuffer, serializeFunctions);
	}
	
	/**
	 * Calculate the bson size for a passed in Javascript object.
	 *
	 * @param {Object} object the Javascript object to calculate the BSON byte size for.
	 * @param {Boolean} [serializeFunctions] serialize all functions in the object **(default:false)**.
	 * @return {Number} returns the number of bytes the BSON object will take up.
	 * @api public
	 */
	BSON.prototype.calculateObjectSize = function(object, serializeFunctions) {
	  return BSON.calculateObjectSize(object, serializeFunctions);
	}
	
	/**
	 * Serialize a Javascript object using a predefined Buffer and index into the buffer, useful when pre-allocating the space for serialization.
	 *
	 * @param {Object} object the Javascript object to serialize.
	 * @param {Boolean} checkKeys the serializer will check if keys are valid.
	 * @param {Buffer} buffer the Buffer you pre-allocated to store the serialized BSON object.
	 * @param {Number} index the index in the buffer where we wish to start serializing into.
	 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false)**.
	 * @return {Number} returns the new write index in the Buffer.
	 * @api public
	 */
	BSON.prototype.serializeWithBufferAndIndex = function(object, checkKeys, buffer, startIndex, serializeFunctions) {
	  return BSON.serializeWithBufferAndIndex(object, checkKeys, buffer, startIndex, serializeFunctions);
	}
	
	/**
	 * @ignore
	 * @api private
	 */
	exports.Code = Code;
	exports.Symbol = Symbol;
	exports.BSON = BSON;
	exports.DBRef = DBRef;
	exports.Binary = Binary;
	exports.ObjectID = ObjectID;
	exports.Long = Long;
	exports.Timestamp = Timestamp;
	exports.Double = Double;
	exports.MinKey = MinKey;
	exports.MaxKey = MaxKey;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 52 */
/*!********************************************!*\
  !*** ./~/mongoose/~/bson/lib/bson/long.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//     http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// Copyright 2009 Google Inc. All Rights Reserved
	
	/**
	 * Defines a Long class for representing a 64-bit two's-complement
	 * integer value, which faithfully simulates the behavior of a Java "Long". This
	 * implementation is derived from LongLib in GWT.
	 *
	 * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
	 * values as *signed* integers.  See the from* functions below for more
	 * convenient ways of constructing Longs.
	 *
	 * The internal representation of a Long is the two given signed, 32-bit values.
	 * We use 32-bit pieces because these are the size of integers on which
	 * Javascript performs bit-operations.  For operations like addition and
	 * multiplication, we split each number into 16-bit pieces, which can easily be
	 * multiplied within Javascript's floating-point representation without overflow
	 * or change in sign.
	 *
	 * In the algorithms below, we frequently reduce the negative case to the
	 * positive case by negating the input(s) and then post-processing the result.
	 * Note that we must ALWAYS check specially whether those values are MIN_VALUE
	 * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
	 * a positive number, it overflows back into a negative).  Not handling this
	 * case would often result in infinite recursion.
	 *
	 * @class
	 * @param {number} low  the low (signed) 32 bits of the Long.
	 * @param {number} high the high (signed) 32 bits of the Long.
	 * @return {Long}
	 */
	function Long(low, high) {
	  if(!(this instanceof Long)) return new Long(low, high);
	  
	  this._bsontype = 'Long';
	  /**
	   * @type {number}
	   * @ignore
	   */
	  this.low_ = low | 0;  // force into 32 signed bits.
	
	  /**
	   * @type {number}
	   * @ignore
	   */
	  this.high_ = high | 0;  // force into 32 signed bits.
	};
	
	/**
	 * Return the int value.
	 *
	 * @method
	 * @return {number} the value, assuming it is a 32-bit integer.
	 */
	Long.prototype.toInt = function() {
	  return this.low_;
	};
	
	/**
	 * Return the Number value.
	 *
	 * @method
	 * @return {number} the closest floating-point representation to this value.
	 */
	Long.prototype.toNumber = function() {
	  return this.high_ * Long.TWO_PWR_32_DBL_ +
	         this.getLowBitsUnsigned();
	};
	
	/**
	 * Return the JSON value.
	 *
	 * @method
	 * @return {string} the JSON representation.
	 */
	Long.prototype.toJSON = function() {
	  return this.toString();
	}
	
	/**
	 * Return the String value.
	 *
	 * @method
	 * @param {number} [opt_radix] the radix in which the text should be written.
	 * @return {string} the textual representation of this value.
	 */
	Long.prototype.toString = function(opt_radix) {
	  var radix = opt_radix || 10;
	  if (radix < 2 || 36 < radix) {
	    throw Error('radix out of range: ' + radix);
	  }
	
	  if (this.isZero()) {
	    return '0';
	  }
	
	  if (this.isNegative()) {
	    if (this.equals(Long.MIN_VALUE)) {
	      // We need to change the Long value before it can be negated, so we remove
	      // the bottom-most digit in this base and then recurse to do the rest.
	      var radixLong = Long.fromNumber(radix);
	      var div = this.div(radixLong);
	      var rem = div.multiply(radixLong).subtract(this);
	      return div.toString(radix) + rem.toInt().toString(radix);
	    } else {
	      return '-' + this.negate().toString(radix);
	    }
	  }
	
	  // Do several (6) digits each time through the loop, so as to
	  // minimize the calls to the very expensive emulated div.
	  var radixToPower = Long.fromNumber(Math.pow(radix, 6));
	
	  var rem = this;
	  var result = '';
	  while (true) {
	    var remDiv = rem.div(radixToPower);
	    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
	    var digits = intval.toString(radix);
	
	    rem = remDiv;
	    if (rem.isZero()) {
	      return digits + result;
	    } else {
	      while (digits.length < 6) {
	        digits = '0' + digits;
	      }
	      result = '' + digits + result;
	    }
	  }
	};
	
	/**
	 * Return the high 32-bits value.
	 *
	 * @method
	 * @return {number} the high 32-bits as a signed value.
	 */
	Long.prototype.getHighBits = function() {
	  return this.high_;
	};
	
	/**
	 * Return the low 32-bits value.
	 *
	 * @method
	 * @return {number} the low 32-bits as a signed value.
	 */
	Long.prototype.getLowBits = function() {
	  return this.low_;
	};
	
	/**
	 * Return the low unsigned 32-bits value.
	 *
	 * @method
	 * @return {number} the low 32-bits as an unsigned value.
	 */
	Long.prototype.getLowBitsUnsigned = function() {
	  return (this.low_ >= 0) ?
	      this.low_ : Long.TWO_PWR_32_DBL_ + this.low_;
	};
	
	/**
	 * Returns the number of bits needed to represent the absolute value of this Long.
	 *
	 * @method
	 * @return {number} Returns the number of bits needed to represent the absolute value of this Long.
	 */
	Long.prototype.getNumBitsAbs = function() {
	  if (this.isNegative()) {
	    if (this.equals(Long.MIN_VALUE)) {
	      return 64;
	    } else {
	      return this.negate().getNumBitsAbs();
	    }
	  } else {
	    var val = this.high_ != 0 ? this.high_ : this.low_;
	    for (var bit = 31; bit > 0; bit--) {
	      if ((val & (1 << bit)) != 0) {
	        break;
	      }
	    }
	    return this.high_ != 0 ? bit + 33 : bit + 1;
	  }
	};
	
	/**
	 * Return whether this value is zero.
	 *
	 * @method
	 * @return {boolean} whether this value is zero.
	 */
	Long.prototype.isZero = function() {
	  return this.high_ == 0 && this.low_ == 0;
	};
	
	/**
	 * Return whether this value is negative.
	 *
	 * @method
	 * @return {boolean} whether this value is negative.
	 */
	Long.prototype.isNegative = function() {
	  return this.high_ < 0;
	};
	
	/**
	 * Return whether this value is odd.
	 *
	 * @method
	 * @return {boolean} whether this value is odd.
	 */
	Long.prototype.isOdd = function() {
	  return (this.low_ & 1) == 1;
	};
	
	/**
	 * Return whether this Long equals the other
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long equals the other
	 */
	Long.prototype.equals = function(other) {
	  return (this.high_ == other.high_) && (this.low_ == other.low_);
	};
	
	/**
	 * Return whether this Long does not equal the other.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long does not equal the other.
	 */
	Long.prototype.notEquals = function(other) {
	  return (this.high_ != other.high_) || (this.low_ != other.low_);
	};
	
	/**
	 * Return whether this Long is less than the other.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long is less than the other.
	 */
	Long.prototype.lessThan = function(other) {
	  return this.compare(other) < 0;
	};
	
	/**
	 * Return whether this Long is less than or equal to the other.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long is less than or equal to the other.
	 */
	Long.prototype.lessThanOrEqual = function(other) {
	  return this.compare(other) <= 0;
	};
	
	/**
	 * Return whether this Long is greater than the other.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long is greater than the other.
	 */
	Long.prototype.greaterThan = function(other) {
	  return this.compare(other) > 0;
	};
	
	/**
	 * Return whether this Long is greater than or equal to the other.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long is greater than or equal to the other.
	 */
	Long.prototype.greaterThanOrEqual = function(other) {
	  return this.compare(other) >= 0;
	};
	
	/**
	 * Compares this Long with the given one.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} 0 if they are the same, 1 if the this is greater, and -1 if the given one is greater.
	 */
	Long.prototype.compare = function(other) {
	  if (this.equals(other)) {
	    return 0;
	  }
	
	  var thisNeg = this.isNegative();
	  var otherNeg = other.isNegative();
	  if (thisNeg && !otherNeg) {
	    return -1;
	  }
	  if (!thisNeg && otherNeg) {
	    return 1;
	  }
	
	  // at this point, the signs are the same, so subtraction will not overflow
	  if (this.subtract(other).isNegative()) {
	    return -1;
	  } else {
	    return 1;
	  }
	};
	
	/**
	 * The negation of this value.
	 *
	 * @method
	 * @return {Long} the negation of this value.
	 */
	Long.prototype.negate = function() {
	  if (this.equals(Long.MIN_VALUE)) {
	    return Long.MIN_VALUE;
	  } else {
	    return this.not().add(Long.ONE);
	  }
	};
	
	/**
	 * Returns the sum of this and the given Long.
	 *
	 * @method
	 * @param {Long} other Long to add to this one.
	 * @return {Long} the sum of this and the given Long.
	 */
	Long.prototype.add = function(other) {
	  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
	
	  var a48 = this.high_ >>> 16;
	  var a32 = this.high_ & 0xFFFF;
	  var a16 = this.low_ >>> 16;
	  var a00 = this.low_ & 0xFFFF;
	
	  var b48 = other.high_ >>> 16;
	  var b32 = other.high_ & 0xFFFF;
	  var b16 = other.low_ >>> 16;
	  var b00 = other.low_ & 0xFFFF;
	
	  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	  c00 += a00 + b00;
	  c16 += c00 >>> 16;
	  c00 &= 0xFFFF;
	  c16 += a16 + b16;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c32 += a32 + b32;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c48 += a48 + b48;
	  c48 &= 0xFFFF;
	  return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
	};
	
	/**
	 * Returns the difference of this and the given Long.
	 *
	 * @method
	 * @param {Long} other Long to subtract from this.
	 * @return {Long} the difference of this and the given Long.
	 */
	Long.prototype.subtract = function(other) {
	  return this.add(other.negate());
	};
	
	/**
	 * Returns the product of this and the given Long.
	 *
	 * @method
	 * @param {Long} other Long to multiply with this.
	 * @return {Long} the product of this and the other.
	 */
	Long.prototype.multiply = function(other) {
	  if (this.isZero()) {
	    return Long.ZERO;
	  } else if (other.isZero()) {
	    return Long.ZERO;
	  }
	
	  if (this.equals(Long.MIN_VALUE)) {
	    return other.isOdd() ? Long.MIN_VALUE : Long.ZERO;
	  } else if (other.equals(Long.MIN_VALUE)) {
	    return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
	  }
	
	  if (this.isNegative()) {
	    if (other.isNegative()) {
	      return this.negate().multiply(other.negate());
	    } else {
	      return this.negate().multiply(other).negate();
	    }
	  } else if (other.isNegative()) {
	    return this.multiply(other.negate()).negate();
	  }
	
	  // If both Longs are small, use float multiplication
	  if (this.lessThan(Long.TWO_PWR_24_) &&
	      other.lessThan(Long.TWO_PWR_24_)) {
	    return Long.fromNumber(this.toNumber() * other.toNumber());
	  }
	
	  // Divide each Long into 4 chunks of 16 bits, and then add up 4x4 products.
	  // We can skip products that would overflow.
	
	  var a48 = this.high_ >>> 16;
	  var a32 = this.high_ & 0xFFFF;
	  var a16 = this.low_ >>> 16;
	  var a00 = this.low_ & 0xFFFF;
	
	  var b48 = other.high_ >>> 16;
	  var b32 = other.high_ & 0xFFFF;
	  var b16 = other.low_ >>> 16;
	  var b00 = other.low_ & 0xFFFF;
	
	  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	  c00 += a00 * b00;
	  c16 += c00 >>> 16;
	  c00 &= 0xFFFF;
	  c16 += a16 * b00;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c16 += a00 * b16;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c32 += a32 * b00;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c32 += a16 * b16;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c32 += a00 * b32;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
	  c48 &= 0xFFFF;
	  return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
	};
	
	/**
	 * Returns this Long divided by the given one.
	 *
	 * @method
	 * @param {Long} other Long by which to divide.
	 * @return {Long} this Long divided by the given one.
	 */
	Long.prototype.div = function(other) {
	  if (other.isZero()) {
	    throw Error('division by zero');
	  } else if (this.isZero()) {
	    return Long.ZERO;
	  }
	
	  if (this.equals(Long.MIN_VALUE)) {
	    if (other.equals(Long.ONE) ||
	        other.equals(Long.NEG_ONE)) {
	      return Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
	    } else if (other.equals(Long.MIN_VALUE)) {
	      return Long.ONE;
	    } else {
	      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
	      var halfThis = this.shiftRight(1);
	      var approx = halfThis.div(other).shiftLeft(1);
	      if (approx.equals(Long.ZERO)) {
	        return other.isNegative() ? Long.ONE : Long.NEG_ONE;
	      } else {
	        var rem = this.subtract(other.multiply(approx));
	        var result = approx.add(rem.div(other));
	        return result;
	      }
	    }
	  } else if (other.equals(Long.MIN_VALUE)) {
	    return Long.ZERO;
	  }
	
	  if (this.isNegative()) {
	    if (other.isNegative()) {
	      return this.negate().div(other.negate());
	    } else {
	      return this.negate().div(other).negate();
	    }
	  } else if (other.isNegative()) {
	    return this.div(other.negate()).negate();
	  }
	
	  // Repeat the following until the remainder is less than other:  find a
	  // floating-point that approximates remainder / other *from below*, add this
	  // into the result, and subtract it from the remainder.  It is critical that
	  // the approximate value is less than or equal to the real value so that the
	  // remainder never becomes negative.
	  var res = Long.ZERO;
	  var rem = this;
	  while (rem.greaterThanOrEqual(other)) {
	    // Approximate the result of division. This may be a little greater or
	    // smaller than the actual value.
	    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
	
	    // We will tweak the approximate result by changing it in the 48-th digit or
	    // the smallest non-fractional digit, whichever is larger.
	    var log2 = Math.ceil(Math.log(approx) / Math.LN2);
	    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);
	
	    // Decrease the approximation until it is smaller than the remainder.  Note
	    // that if it is too large, the product overflows and is negative.
	    var approxRes = Long.fromNumber(approx);
	    var approxRem = approxRes.multiply(other);
	    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
	      approx -= delta;
	      approxRes = Long.fromNumber(approx);
	      approxRem = approxRes.multiply(other);
	    }
	
	    // We know the answer can't be zero... and actually, zero would cause
	    // infinite recursion since we would make no progress.
	    if (approxRes.isZero()) {
	      approxRes = Long.ONE;
	    }
	
	    res = res.add(approxRes);
	    rem = rem.subtract(approxRem);
	  }
	  return res;
	};
	
	/**
	 * Returns this Long modulo the given one.
	 *
	 * @method
	 * @param {Long} other Long by which to mod.
	 * @return {Long} this Long modulo the given one.
	 */
	Long.prototype.modulo = function(other) {
	  return this.subtract(this.div(other).multiply(other));
	};
	
	/**
	 * The bitwise-NOT of this value.
	 *
	 * @method
	 * @return {Long} the bitwise-NOT of this value.
	 */
	Long.prototype.not = function() {
	  return Long.fromBits(~this.low_, ~this.high_);
	};
	
	/**
	 * Returns the bitwise-AND of this Long and the given one.
	 *
	 * @method
	 * @param {Long} other the Long with which to AND.
	 * @return {Long} the bitwise-AND of this and the other.
	 */
	Long.prototype.and = function(other) {
	  return Long.fromBits(this.low_ & other.low_, this.high_ & other.high_);
	};
	
	/**
	 * Returns the bitwise-OR of this Long and the given one.
	 *
	 * @method
	 * @param {Long} other the Long with which to OR.
	 * @return {Long} the bitwise-OR of this and the other.
	 */
	Long.prototype.or = function(other) {
	  return Long.fromBits(this.low_ | other.low_, this.high_ | other.high_);
	};
	
	/**
	 * Returns the bitwise-XOR of this Long and the given one.
	 *
	 * @method
	 * @param {Long} other the Long with which to XOR.
	 * @return {Long} the bitwise-XOR of this and the other.
	 */
	Long.prototype.xor = function(other) {
	  return Long.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
	};
	
	/**
	 * Returns this Long with bits shifted to the left by the given amount.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Long} this shifted to the left by the given amount.
	 */
	Long.prototype.shiftLeft = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var low = this.low_;
	    if (numBits < 32) {
	      var high = this.high_;
	      return Long.fromBits(
	                 low << numBits,
	                 (high << numBits) | (low >>> (32 - numBits)));
	    } else {
	      return Long.fromBits(0, low << (numBits - 32));
	    }
	  }
	};
	
	/**
	 * Returns this Long with bits shifted to the right by the given amount.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Long} this shifted to the right by the given amount.
	 */
	Long.prototype.shiftRight = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var high = this.high_;
	    if (numBits < 32) {
	      var low = this.low_;
	      return Long.fromBits(
	                 (low >>> numBits) | (high << (32 - numBits)),
	                 high >> numBits);
	    } else {
	      return Long.fromBits(
	                 high >> (numBits - 32),
	                 high >= 0 ? 0 : -1);
	    }
	  }
	};
	
	/**
	 * Returns this Long with bits shifted to the right by the given amount, with the new top bits matching the current sign bit.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Long} this shifted to the right by the given amount, with zeros placed into the new leading bits.
	 */
	Long.prototype.shiftRightUnsigned = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var high = this.high_;
	    if (numBits < 32) {
	      var low = this.low_;
	      return Long.fromBits(
	                 (low >>> numBits) | (high << (32 - numBits)),
	                 high >>> numBits);
	    } else if (numBits == 32) {
	      return Long.fromBits(high, 0);
	    } else {
	      return Long.fromBits(high >>> (numBits - 32), 0);
	    }
	  }
	};
	
	/**
	 * Returns a Long representing the given (32-bit) integer value.
	 *
	 * @method
	 * @param {number} value the 32-bit integer in question.
	 * @return {Long} the corresponding Long value.
	 */
	Long.fromInt = function(value) {
	  if (-128 <= value && value < 128) {
	    var cachedObj = Long.INT_CACHE_[value];
	    if (cachedObj) {
	      return cachedObj;
	    }
	  }
	
	  var obj = new Long(value | 0, value < 0 ? -1 : 0);
	  if (-128 <= value && value < 128) {
	    Long.INT_CACHE_[value] = obj;
	  }
	  return obj;
	};
	
	/**
	 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
	 *
	 * @method
	 * @param {number} value the number in question.
	 * @return {Long} the corresponding Long value.
	 */
	Long.fromNumber = function(value) {
	  if (isNaN(value) || !isFinite(value)) {
	    return Long.ZERO;
	  } else if (value <= -Long.TWO_PWR_63_DBL_) {
	    return Long.MIN_VALUE;
	  } else if (value + 1 >= Long.TWO_PWR_63_DBL_) {
	    return Long.MAX_VALUE;
	  } else if (value < 0) {
	    return Long.fromNumber(-value).negate();
	  } else {
	    return new Long(
	               (value % Long.TWO_PWR_32_DBL_) | 0,
	               (value / Long.TWO_PWR_32_DBL_) | 0);
	  }
	};
	
	/**
	 * Returns a Long representing the 64-bit integer that comes by concatenating the given high and low bits. Each is assumed to use 32 bits.
	 *
	 * @method
	 * @param {number} lowBits the low 32-bits.
	 * @param {number} highBits the high 32-bits.
	 * @return {Long} the corresponding Long value.
	 */
	Long.fromBits = function(lowBits, highBits) {
	  return new Long(lowBits, highBits);
	};
	
	/**
	 * Returns a Long representation of the given string, written using the given radix.
	 *
	 * @method
	 * @param {string} str the textual representation of the Long.
	 * @param {number} opt_radix the radix in which the text is written.
	 * @return {Long} the corresponding Long value.
	 */
	Long.fromString = function(str, opt_radix) {
	  if (str.length == 0) {
	    throw Error('number format error: empty string');
	  }
	
	  var radix = opt_radix || 10;
	  if (radix < 2 || 36 < radix) {
	    throw Error('radix out of range: ' + radix);
	  }
	
	  if (str.charAt(0) == '-') {
	    return Long.fromString(str.substring(1), radix).negate();
	  } else if (str.indexOf('-') >= 0) {
	    throw Error('number format error: interior "-" character: ' + str);
	  }
	
	  // Do several (8) digits each time through the loop, so as to
	  // minimize the calls to the very expensive emulated div.
	  var radixToPower = Long.fromNumber(Math.pow(radix, 8));
	
	  var result = Long.ZERO;
	  for (var i = 0; i < str.length; i += 8) {
	    var size = Math.min(8, str.length - i);
	    var value = parseInt(str.substring(i, i + size), radix);
	    if (size < 8) {
	      var power = Long.fromNumber(Math.pow(radix, size));
	      result = result.multiply(power).add(Long.fromNumber(value));
	    } else {
	      result = result.multiply(radixToPower);
	      result = result.add(Long.fromNumber(value));
	    }
	  }
	  return result;
	};
	
	// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
	// from* methods on which they depend.
	
	
	/**
	 * A cache of the Long representations of small integer values.
	 * @type {Object}
	 * @ignore
	 */
	Long.INT_CACHE_ = {};
	
	// NOTE: the compiler should inline these constant values below and then remove
	// these variables, so there should be no runtime penalty for these.
	
	/**
	 * Number used repeated below in calculations.  This must appear before the
	 * first call to any from* function below.
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_16_DBL_ = 1 << 16;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_24_DBL_ = 1 << 24;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_32_DBL_ = Long.TWO_PWR_16_DBL_ * Long.TWO_PWR_16_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_31_DBL_ = Long.TWO_PWR_32_DBL_ / 2;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_48_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_16_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_64_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_32_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_63_DBL_ = Long.TWO_PWR_64_DBL_ / 2;
	
	/** @type {Long} */
	Long.ZERO = Long.fromInt(0);
	
	/** @type {Long} */
	Long.ONE = Long.fromInt(1);
	
	/** @type {Long} */
	Long.NEG_ONE = Long.fromInt(-1);
	
	/** @type {Long} */
	Long.MAX_VALUE =
	    Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);
	
	/** @type {Long} */
	Long.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0);
	
	/**
	 * @type {Long}
	 * @ignore
	 */
	Long.TWO_PWR_24_ = Long.fromInt(1 << 24);
	
	/**
	 * Expose.
	 */
	module.exports = Long;
	module.exports.Long = Long;

/***/ },
/* 53 */
/*!**********************************************!*\
  !*** ./~/mongoose/~/bson/lib/bson/double.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A class representation of the BSON Double type.
	 *
	 * @class
	 * @param {number} value the number we want to represent as a double.
	 * @return {Double}
	 */
	function Double(value) {
	  if(!(this instanceof Double)) return new Double(value);
	  
	  this._bsontype = 'Double';
	  this.value = value;
	}
	
	/**
	 * Access the number value.
	 *
	 * @method
	 * @return {number} returns the wrapped double number.
	 */
	Double.prototype.valueOf = function() {
	  return this.value;
	};
	
	/**
	 * @ignore
	 */
	Double.prototype.toJSON = function() {
	  return this.value;
	}
	
	module.exports = Double;
	module.exports.Double = Double;

/***/ },
/* 54 */
/*!*************************************************!*\
  !*** ./~/mongoose/~/bson/lib/bson/timestamp.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//     http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// Copyright 2009 Google Inc. All Rights Reserved
	
	/**
	 * This type is for INTERNAL use in MongoDB only and should not be used in applications.
	 * The appropriate corresponding type is the JavaScript Date type.
	 * 
	 * Defines a Timestamp class for representing a 64-bit two's-complement
	 * integer value, which faithfully simulates the behavior of a Java "Timestamp". This
	 * implementation is derived from TimestampLib in GWT.
	 *
	 * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
	 * values as *signed* integers.  See the from* functions below for more
	 * convenient ways of constructing Timestamps.
	 *
	 * The internal representation of a Timestamp is the two given signed, 32-bit values.
	 * We use 32-bit pieces because these are the size of integers on which
	 * Javascript performs bit-operations.  For operations like addition and
	 * multiplication, we split each number into 16-bit pieces, which can easily be
	 * multiplied within Javascript's floating-point representation without overflow
	 * or change in sign.
	 *
	 * In the algorithms below, we frequently reduce the negative case to the
	 * positive case by negating the input(s) and then post-processing the result.
	 * Note that we must ALWAYS check specially whether those values are MIN_VALUE
	 * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
	 * a positive number, it overflows back into a negative).  Not handling this
	 * case would often result in infinite recursion.
	 *
	 * @class
	 * @param {number} low  the low (signed) 32 bits of the Timestamp.
	 * @param {number} high the high (signed) 32 bits of the Timestamp.
	 */
	function Timestamp(low, high) {
	  if(!(this instanceof Timestamp)) return new Timestamp(low, high);
	  this._bsontype = 'Timestamp';
	  /**
	   * @type {number}
	   * @ignore
	   */
	  this.low_ = low | 0;  // force into 32 signed bits.
	
	  /**
	   * @type {number}
	   * @ignore
	   */
	  this.high_ = high | 0;  // force into 32 signed bits.
	};
	
	/**
	 * Return the int value.
	 *
	 * @return {number} the value, assuming it is a 32-bit integer.
	 */
	Timestamp.prototype.toInt = function() {
	  return this.low_;
	};
	
	/**
	 * Return the Number value.
	 *
	 * @method
	 * @return {number} the closest floating-point representation to this value.
	 */
	Timestamp.prototype.toNumber = function() {
	  return this.high_ * Timestamp.TWO_PWR_32_DBL_ +
	         this.getLowBitsUnsigned();
	};
	
	/**
	 * Return the JSON value.
	 *
	 * @method
	 * @return {string} the JSON representation.
	 */
	Timestamp.prototype.toJSON = function() {
	  return this.toString();
	}
	
	/**
	 * Return the String value.
	 *
	 * @method
	 * @param {number} [opt_radix] the radix in which the text should be written.
	 * @return {string} the textual representation of this value.
	 */
	Timestamp.prototype.toString = function(opt_radix) {
	  var radix = opt_radix || 10;
	  if (radix < 2 || 36 < radix) {
	    throw Error('radix out of range: ' + radix);
	  }
	
	  if (this.isZero()) {
	    return '0';
	  }
	
	  if (this.isNegative()) {
	    if (this.equals(Timestamp.MIN_VALUE)) {
	      // We need to change the Timestamp value before it can be negated, so we remove
	      // the bottom-most digit in this base and then recurse to do the rest.
	      var radixTimestamp = Timestamp.fromNumber(radix);
	      var div = this.div(radixTimestamp);
	      var rem = div.multiply(radixTimestamp).subtract(this);
	      return div.toString(radix) + rem.toInt().toString(radix);
	    } else {
	      return '-' + this.negate().toString(radix);
	    }
	  }
	
	  // Do several (6) digits each time through the loop, so as to
	  // minimize the calls to the very expensive emulated div.
	  var radixToPower = Timestamp.fromNumber(Math.pow(radix, 6));
	
	  var rem = this;
	  var result = '';
	  while (true) {
	    var remDiv = rem.div(radixToPower);
	    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
	    var digits = intval.toString(radix);
	
	    rem = remDiv;
	    if (rem.isZero()) {
	      return digits + result;
	    } else {
	      while (digits.length < 6) {
	        digits = '0' + digits;
	      }
	      result = '' + digits + result;
	    }
	  }
	};
	
	/**
	 * Return the high 32-bits value.
	 *
	 * @method
	 * @return {number} the high 32-bits as a signed value.
	 */
	Timestamp.prototype.getHighBits = function() {
	  return this.high_;
	};
	
	/**
	 * Return the low 32-bits value.
	 *
	 * @method
	 * @return {number} the low 32-bits as a signed value.
	 */
	Timestamp.prototype.getLowBits = function() {
	  return this.low_;
	};
	
	/**
	 * Return the low unsigned 32-bits value.
	 *
	 * @method
	 * @return {number} the low 32-bits as an unsigned value.
	 */
	Timestamp.prototype.getLowBitsUnsigned = function() {
	  return (this.low_ >= 0) ?
	      this.low_ : Timestamp.TWO_PWR_32_DBL_ + this.low_;
	};
	
	/**
	 * Returns the number of bits needed to represent the absolute value of this Timestamp.
	 *
	 * @method
	 * @return {number} Returns the number of bits needed to represent the absolute value of this Timestamp.
	 */
	Timestamp.prototype.getNumBitsAbs = function() {
	  if (this.isNegative()) {
	    if (this.equals(Timestamp.MIN_VALUE)) {
	      return 64;
	    } else {
	      return this.negate().getNumBitsAbs();
	    }
	  } else {
	    var val = this.high_ != 0 ? this.high_ : this.low_;
	    for (var bit = 31; bit > 0; bit--) {
	      if ((val & (1 << bit)) != 0) {
	        break;
	      }
	    }
	    return this.high_ != 0 ? bit + 33 : bit + 1;
	  }
	};
	
	/**
	 * Return whether this value is zero.
	 *
	 * @method
	 * @return {boolean} whether this value is zero.
	 */
	Timestamp.prototype.isZero = function() {
	  return this.high_ == 0 && this.low_ == 0;
	};
	
	/**
	 * Return whether this value is negative.
	 *
	 * @method
	 * @return {boolean} whether this value is negative.
	 */
	Timestamp.prototype.isNegative = function() {
	  return this.high_ < 0;
	};
	
	/**
	 * Return whether this value is odd.
	 *
	 * @method
	 * @return {boolean} whether this value is odd.
	 */
	Timestamp.prototype.isOdd = function() {
	  return (this.low_ & 1) == 1;
	};
	
	/**
	 * Return whether this Timestamp equals the other
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp equals the other
	 */
	Timestamp.prototype.equals = function(other) {
	  return (this.high_ == other.high_) && (this.low_ == other.low_);
	};
	
	/**
	 * Return whether this Timestamp does not equal the other.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp does not equal the other.
	 */
	Timestamp.prototype.notEquals = function(other) {
	  return (this.high_ != other.high_) || (this.low_ != other.low_);
	};
	
	/**
	 * Return whether this Timestamp is less than the other.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp is less than the other.
	 */
	Timestamp.prototype.lessThan = function(other) {
	  return this.compare(other) < 0;
	};
	
	/**
	 * Return whether this Timestamp is less than or equal to the other.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp is less than or equal to the other.
	 */
	Timestamp.prototype.lessThanOrEqual = function(other) {
	  return this.compare(other) <= 0;
	};
	
	/**
	 * Return whether this Timestamp is greater than the other.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp is greater than the other.
	 */
	Timestamp.prototype.greaterThan = function(other) {
	  return this.compare(other) > 0;
	};
	
	/**
	 * Return whether this Timestamp is greater than or equal to the other.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp is greater than or equal to the other.
	 */
	Timestamp.prototype.greaterThanOrEqual = function(other) {
	  return this.compare(other) >= 0;
	};
	
	/**
	 * Compares this Timestamp with the given one.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} 0 if they are the same, 1 if the this is greater, and -1 if the given one is greater.
	 */
	Timestamp.prototype.compare = function(other) {
	  if (this.equals(other)) {
	    return 0;
	  }
	
	  var thisNeg = this.isNegative();
	  var otherNeg = other.isNegative();
	  if (thisNeg && !otherNeg) {
	    return -1;
	  }
	  if (!thisNeg && otherNeg) {
	    return 1;
	  }
	
	  // at this point, the signs are the same, so subtraction will not overflow
	  if (this.subtract(other).isNegative()) {
	    return -1;
	  } else {
	    return 1;
	  }
	};
	
	/**
	 * The negation of this value.
	 *
	 * @method
	 * @return {Timestamp} the negation of this value.
	 */
	Timestamp.prototype.negate = function() {
	  if (this.equals(Timestamp.MIN_VALUE)) {
	    return Timestamp.MIN_VALUE;
	  } else {
	    return this.not().add(Timestamp.ONE);
	  }
	};
	
	/**
	 * Returns the sum of this and the given Timestamp.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to add to this one.
	 * @return {Timestamp} the sum of this and the given Timestamp.
	 */
	Timestamp.prototype.add = function(other) {
	  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
	
	  var a48 = this.high_ >>> 16;
	  var a32 = this.high_ & 0xFFFF;
	  var a16 = this.low_ >>> 16;
	  var a00 = this.low_ & 0xFFFF;
	
	  var b48 = other.high_ >>> 16;
	  var b32 = other.high_ & 0xFFFF;
	  var b16 = other.low_ >>> 16;
	  var b00 = other.low_ & 0xFFFF;
	
	  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	  c00 += a00 + b00;
	  c16 += c00 >>> 16;
	  c00 &= 0xFFFF;
	  c16 += a16 + b16;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c32 += a32 + b32;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c48 += a48 + b48;
	  c48 &= 0xFFFF;
	  return Timestamp.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
	};
	
	/**
	 * Returns the difference of this and the given Timestamp.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to subtract from this.
	 * @return {Timestamp} the difference of this and the given Timestamp.
	 */
	Timestamp.prototype.subtract = function(other) {
	  return this.add(other.negate());
	};
	
	/**
	 * Returns the product of this and the given Timestamp.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to multiply with this.
	 * @return {Timestamp} the product of this and the other.
	 */
	Timestamp.prototype.multiply = function(other) {
	  if (this.isZero()) {
	    return Timestamp.ZERO;
	  } else if (other.isZero()) {
	    return Timestamp.ZERO;
	  }
	
	  if (this.equals(Timestamp.MIN_VALUE)) {
	    return other.isOdd() ? Timestamp.MIN_VALUE : Timestamp.ZERO;
	  } else if (other.equals(Timestamp.MIN_VALUE)) {
	    return this.isOdd() ? Timestamp.MIN_VALUE : Timestamp.ZERO;
	  }
	
	  if (this.isNegative()) {
	    if (other.isNegative()) {
	      return this.negate().multiply(other.negate());
	    } else {
	      return this.negate().multiply(other).negate();
	    }
	  } else if (other.isNegative()) {
	    return this.multiply(other.negate()).negate();
	  }
	
	  // If both Timestamps are small, use float multiplication
	  if (this.lessThan(Timestamp.TWO_PWR_24_) &&
	      other.lessThan(Timestamp.TWO_PWR_24_)) {
	    return Timestamp.fromNumber(this.toNumber() * other.toNumber());
	  }
	
	  // Divide each Timestamp into 4 chunks of 16 bits, and then add up 4x4 products.
	  // We can skip products that would overflow.
	
	  var a48 = this.high_ >>> 16;
	  var a32 = this.high_ & 0xFFFF;
	  var a16 = this.low_ >>> 16;
	  var a00 = this.low_ & 0xFFFF;
	
	  var b48 = other.high_ >>> 16;
	  var b32 = other.high_ & 0xFFFF;
	  var b16 = other.low_ >>> 16;
	  var b00 = other.low_ & 0xFFFF;
	
	  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	  c00 += a00 * b00;
	  c16 += c00 >>> 16;
	  c00 &= 0xFFFF;
	  c16 += a16 * b00;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c16 += a00 * b16;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c32 += a32 * b00;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c32 += a16 * b16;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c32 += a00 * b32;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
	  c48 &= 0xFFFF;
	  return Timestamp.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
	};
	
	/**
	 * Returns this Timestamp divided by the given one.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp by which to divide.
	 * @return {Timestamp} this Timestamp divided by the given one.
	 */
	Timestamp.prototype.div = function(other) {
	  if (other.isZero()) {
	    throw Error('division by zero');
	  } else if (this.isZero()) {
	    return Timestamp.ZERO;
	  }
	
	  if (this.equals(Timestamp.MIN_VALUE)) {
	    if (other.equals(Timestamp.ONE) ||
	        other.equals(Timestamp.NEG_ONE)) {
	      return Timestamp.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
	    } else if (other.equals(Timestamp.MIN_VALUE)) {
	      return Timestamp.ONE;
	    } else {
	      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
	      var halfThis = this.shiftRight(1);
	      var approx = halfThis.div(other).shiftLeft(1);
	      if (approx.equals(Timestamp.ZERO)) {
	        return other.isNegative() ? Timestamp.ONE : Timestamp.NEG_ONE;
	      } else {
	        var rem = this.subtract(other.multiply(approx));
	        var result = approx.add(rem.div(other));
	        return result;
	      }
	    }
	  } else if (other.equals(Timestamp.MIN_VALUE)) {
	    return Timestamp.ZERO;
	  }
	
	  if (this.isNegative()) {
	    if (other.isNegative()) {
	      return this.negate().div(other.negate());
	    } else {
	      return this.negate().div(other).negate();
	    }
	  } else if (other.isNegative()) {
	    return this.div(other.negate()).negate();
	  }
	
	  // Repeat the following until the remainder is less than other:  find a
	  // floating-point that approximates remainder / other *from below*, add this
	  // into the result, and subtract it from the remainder.  It is critical that
	  // the approximate value is less than or equal to the real value so that the
	  // remainder never becomes negative.
	  var res = Timestamp.ZERO;
	  var rem = this;
	  while (rem.greaterThanOrEqual(other)) {
	    // Approximate the result of division. This may be a little greater or
	    // smaller than the actual value.
	    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
	
	    // We will tweak the approximate result by changing it in the 48-th digit or
	    // the smallest non-fractional digit, whichever is larger.
	    var log2 = Math.ceil(Math.log(approx) / Math.LN2);
	    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);
	
	    // Decrease the approximation until it is smaller than the remainder.  Note
	    // that if it is too large, the product overflows and is negative.
	    var approxRes = Timestamp.fromNumber(approx);
	    var approxRem = approxRes.multiply(other);
	    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
	      approx -= delta;
	      approxRes = Timestamp.fromNumber(approx);
	      approxRem = approxRes.multiply(other);
	    }
	
	    // We know the answer can't be zero... and actually, zero would cause
	    // infinite recursion since we would make no progress.
	    if (approxRes.isZero()) {
	      approxRes = Timestamp.ONE;
	    }
	
	    res = res.add(approxRes);
	    rem = rem.subtract(approxRem);
	  }
	  return res;
	};
	
	/**
	 * Returns this Timestamp modulo the given one.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp by which to mod.
	 * @return {Timestamp} this Timestamp modulo the given one.
	 */
	Timestamp.prototype.modulo = function(other) {
	  return this.subtract(this.div(other).multiply(other));
	};
	
	/**
	 * The bitwise-NOT of this value.
	 *
	 * @method
	 * @return {Timestamp} the bitwise-NOT of this value.
	 */
	Timestamp.prototype.not = function() {
	  return Timestamp.fromBits(~this.low_, ~this.high_);
	};
	
	/**
	 * Returns the bitwise-AND of this Timestamp and the given one.
	 *
	 * @method
	 * @param {Timestamp} other the Timestamp with which to AND.
	 * @return {Timestamp} the bitwise-AND of this and the other.
	 */
	Timestamp.prototype.and = function(other) {
	  return Timestamp.fromBits(this.low_ & other.low_, this.high_ & other.high_);
	};
	
	/**
	 * Returns the bitwise-OR of this Timestamp and the given one.
	 *
	 * @method
	 * @param {Timestamp} other the Timestamp with which to OR.
	 * @return {Timestamp} the bitwise-OR of this and the other.
	 */
	Timestamp.prototype.or = function(other) {
	  return Timestamp.fromBits(this.low_ | other.low_, this.high_ | other.high_);
	};
	
	/**
	 * Returns the bitwise-XOR of this Timestamp and the given one.
	 *
	 * @method
	 * @param {Timestamp} other the Timestamp with which to XOR.
	 * @return {Timestamp} the bitwise-XOR of this and the other.
	 */
	Timestamp.prototype.xor = function(other) {
	  return Timestamp.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
	};
	
	/**
	 * Returns this Timestamp with bits shifted to the left by the given amount.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Timestamp} this shifted to the left by the given amount.
	 */
	Timestamp.prototype.shiftLeft = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var low = this.low_;
	    if (numBits < 32) {
	      var high = this.high_;
	      return Timestamp.fromBits(
	                 low << numBits,
	                 (high << numBits) | (low >>> (32 - numBits)));
	    } else {
	      return Timestamp.fromBits(0, low << (numBits - 32));
	    }
	  }
	};
	
	/**
	 * Returns this Timestamp with bits shifted to the right by the given amount.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Timestamp} this shifted to the right by the given amount.
	 */
	Timestamp.prototype.shiftRight = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var high = this.high_;
	    if (numBits < 32) {
	      var low = this.low_;
	      return Timestamp.fromBits(
	                 (low >>> numBits) | (high << (32 - numBits)),
	                 high >> numBits);
	    } else {
	      return Timestamp.fromBits(
	                 high >> (numBits - 32),
	                 high >= 0 ? 0 : -1);
	    }
	  }
	};
	
	/**
	 * Returns this Timestamp with bits shifted to the right by the given amount, with the new top bits matching the current sign bit.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Timestamp} this shifted to the right by the given amount, with zeros placed into the new leading bits.
	 */
	Timestamp.prototype.shiftRightUnsigned = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var high = this.high_;
	    if (numBits < 32) {
	      var low = this.low_;
	      return Timestamp.fromBits(
	                 (low >>> numBits) | (high << (32 - numBits)),
	                 high >>> numBits);
	    } else if (numBits == 32) {
	      return Timestamp.fromBits(high, 0);
	    } else {
	      return Timestamp.fromBits(high >>> (numBits - 32), 0);
	    }
	  }
	};
	
	/**
	 * Returns a Timestamp representing the given (32-bit) integer value.
	 *
	 * @method
	 * @param {number} value the 32-bit integer in question.
	 * @return {Timestamp} the corresponding Timestamp value.
	 */
	Timestamp.fromInt = function(value) {
	  if (-128 <= value && value < 128) {
	    var cachedObj = Timestamp.INT_CACHE_[value];
	    if (cachedObj) {
	      return cachedObj;
	    }
	  }
	
	  var obj = new Timestamp(value | 0, value < 0 ? -1 : 0);
	  if (-128 <= value && value < 128) {
	    Timestamp.INT_CACHE_[value] = obj;
	  }
	  return obj;
	};
	
	/**
	 * Returns a Timestamp representing the given value, provided that it is a finite number. Otherwise, zero is returned.
	 *
	 * @method
	 * @param {number} value the number in question.
	 * @return {Timestamp} the corresponding Timestamp value.
	 */
	Timestamp.fromNumber = function(value) {
	  if (isNaN(value) || !isFinite(value)) {
	    return Timestamp.ZERO;
	  } else if (value <= -Timestamp.TWO_PWR_63_DBL_) {
	    return Timestamp.MIN_VALUE;
	  } else if (value + 1 >= Timestamp.TWO_PWR_63_DBL_) {
	    return Timestamp.MAX_VALUE;
	  } else if (value < 0) {
	    return Timestamp.fromNumber(-value).negate();
	  } else {
	    return new Timestamp(
	               (value % Timestamp.TWO_PWR_32_DBL_) | 0,
	               (value / Timestamp.TWO_PWR_32_DBL_) | 0);
	  }
	};
	
	/**
	 * Returns a Timestamp representing the 64-bit integer that comes by concatenating the given high and low bits. Each is assumed to use 32 bits.
	 *
	 * @method
	 * @param {number} lowBits the low 32-bits.
	 * @param {number} highBits the high 32-bits.
	 * @return {Timestamp} the corresponding Timestamp value.
	 */
	Timestamp.fromBits = function(lowBits, highBits) {
	  return new Timestamp(lowBits, highBits);
	};
	
	/**
	 * Returns a Timestamp representation of the given string, written using the given radix.
	 *
	 * @method
	 * @param {string} str the textual representation of the Timestamp.
	 * @param {number} opt_radix the radix in which the text is written.
	 * @return {Timestamp} the corresponding Timestamp value.
	 */
	Timestamp.fromString = function(str, opt_radix) {
	  if (str.length == 0) {
	    throw Error('number format error: empty string');
	  }
	
	  var radix = opt_radix || 10;
	  if (radix < 2 || 36 < radix) {
	    throw Error('radix out of range: ' + radix);
	  }
	
	  if (str.charAt(0) == '-') {
	    return Timestamp.fromString(str.substring(1), radix).negate();
	  } else if (str.indexOf('-') >= 0) {
	    throw Error('number format error: interior "-" character: ' + str);
	  }
	
	  // Do several (8) digits each time through the loop, so as to
	  // minimize the calls to the very expensive emulated div.
	  var radixToPower = Timestamp.fromNumber(Math.pow(radix, 8));
	
	  var result = Timestamp.ZERO;
	  for (var i = 0; i < str.length; i += 8) {
	    var size = Math.min(8, str.length - i);
	    var value = parseInt(str.substring(i, i + size), radix);
	    if (size < 8) {
	      var power = Timestamp.fromNumber(Math.pow(radix, size));
	      result = result.multiply(power).add(Timestamp.fromNumber(value));
	    } else {
	      result = result.multiply(radixToPower);
	      result = result.add(Timestamp.fromNumber(value));
	    }
	  }
	  return result;
	};
	
	// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
	// from* methods on which they depend.
	
	
	/**
	 * A cache of the Timestamp representations of small integer values.
	 * @type {Object}
	 * @ignore
	 */
	Timestamp.INT_CACHE_ = {};
	
	// NOTE: the compiler should inline these constant values below and then remove
	// these variables, so there should be no runtime penalty for these.
	
	/**
	 * Number used repeated below in calculations.  This must appear before the
	 * first call to any from* function below.
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_16_DBL_ = 1 << 16;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_24_DBL_ = 1 << 24;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_32_DBL_ = Timestamp.TWO_PWR_16_DBL_ * Timestamp.TWO_PWR_16_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_31_DBL_ = Timestamp.TWO_PWR_32_DBL_ / 2;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_48_DBL_ = Timestamp.TWO_PWR_32_DBL_ * Timestamp.TWO_PWR_16_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_64_DBL_ = Timestamp.TWO_PWR_32_DBL_ * Timestamp.TWO_PWR_32_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_63_DBL_ = Timestamp.TWO_PWR_64_DBL_ / 2;
	
	/** @type {Timestamp} */
	Timestamp.ZERO = Timestamp.fromInt(0);
	
	/** @type {Timestamp} */
	Timestamp.ONE = Timestamp.fromInt(1);
	
	/** @type {Timestamp} */
	Timestamp.NEG_ONE = Timestamp.fromInt(-1);
	
	/** @type {Timestamp} */
	Timestamp.MAX_VALUE =
	    Timestamp.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);
	
	/** @type {Timestamp} */
	Timestamp.MIN_VALUE = Timestamp.fromBits(0, 0x80000000 | 0);
	
	/**
	 * @type {Timestamp}
	 * @ignore
	 */
	Timestamp.TWO_PWR_24_ = Timestamp.fromInt(1 << 24);
	
	/**
	 * Expose.
	 */
	module.exports = Timestamp;
	module.exports.Timestamp = Timestamp;

/***/ },
/* 55 */
/*!************************************************!*\
  !*** ./~/mongoose/~/bson/lib/bson/objectid.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Module dependencies.
	 * @ignore
	 */
	var BinaryParser = __webpack_require__(/*! ./binary_parser */ 56).BinaryParser;
	
	/**
	 * Machine id.
	 *
	 * Create a random 3-byte value (i.e. unique for this
	 * process). Other drivers use a md5 of the machine id here, but
	 * that would mean an asyc call to gethostname, so we don't bother.
	 * @ignore
	 */
	var MACHINE_ID = parseInt(Math.random() * 0xFFFFFF, 10);
	
	// Regular expression that checks for hex value
	var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
	
	/**
	* Create a new ObjectID instance
	*
	* @class
	* @param {(string|number)} id Can be a 24 byte hex string, 12 byte binary string or a Number.
	* @property {number} generationTime The generation time of this ObjectId instance
	* @return {ObjectID} instance of ObjectID.
	*/
	var ObjectID = function ObjectID(id) {
	  if(!(this instanceof ObjectID)) return new ObjectID(id);
	  if((id instanceof ObjectID)) return id;
	
	  this._bsontype = 'ObjectID';
	  var __id = null;
	  var valid = ObjectID.isValid(id);
	
	  // Throw an error if it's not a valid setup
	  if(!valid && id != null){
	    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
	  } else if(valid && typeof id == 'string' && id.length == 24) {
	    return ObjectID.createFromHexString(id);
	  } else if(id == null || typeof id == 'number') {
	    // convert to 12 byte binary string
	    this.id = this.generate(id);
	  } else if(id != null && id.length === 12) {
	    // assume 12 byte string
	    this.id = id;
	  }
	
	  if(ObjectID.cacheHexString) this.__id = this.toHexString();
	};
	
	// Allow usage of ObjectId as well as ObjectID
	var ObjectId = ObjectID;
	
	// Precomputed hex table enables speedy hex string conversion
	var hexTable = [];
	for (var i = 0; i < 256; i++) {
	  hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);
	}
	
	/**
	* Return the ObjectID id as a 24 byte hex string representation
	*
	* @method
	* @return {string} return the 24 byte hex string representation.
	*/
	ObjectID.prototype.toHexString = function() {
	  if(ObjectID.cacheHexString && this.__id) return this.__id;
	
	  var hexString = '';
	
	  for (var i = 0; i < this.id.length; i++) {
	    hexString += hexTable[this.id.charCodeAt(i)];
	  }
	
	  if(ObjectID.cacheHexString) this.__id = hexString;
	  return hexString;
	};
	
	/**
	* Update the ObjectID index used in generating new ObjectID's on the driver
	*
	* @method
	* @return {number} returns next index value.
	* @ignore
	*/
	ObjectID.prototype.get_inc = function() {
	  return ObjectID.index = (ObjectID.index + 1) % 0xFFFFFF;
	};
	
	/**
	* Update the ObjectID index used in generating new ObjectID's on the driver
	*
	* @method
	* @return {number} returns next index value.
	* @ignore
	*/
	ObjectID.prototype.getInc = function() {
	  return this.get_inc();
	};
	
	/**
	* Generate a 12 byte id string used in ObjectID's
	*
	* @method
	* @param {number} [time] optional parameter allowing to pass in a second based timestamp.
	* @return {string} return the 12 byte id binary string.
	*/
	ObjectID.prototype.generate = function(time) {
	  if ('number' != typeof time) {
	    time = parseInt(Date.now()/1000,10);
	  }
	  
	  var time4Bytes = BinaryParser.encodeInt(time, 32, true, true);
	  /* for time-based ObjectID the bytes following the time will be zeroed */
	  var machine3Bytes = BinaryParser.encodeInt(MACHINE_ID, 24, false);
	  var pid2Bytes = BinaryParser.fromShort(typeof process === 'undefined' ? Math.floor(Math.random() * 100000) : process.pid % 0xFFFF);
	  var index3Bytes = BinaryParser.encodeInt(this.get_inc(), 24, false, true);
	
	  return time4Bytes + machine3Bytes + pid2Bytes + index3Bytes;
	};
	
	/**
	* Converts the id into a 24 byte hex string for printing
	*
	* @return {String} return the 24 byte hex string representation.
	* @ignore
	*/
	ObjectID.prototype.toString = function() {
	  return this.toHexString();
	};
	
	/**
	* Converts to a string representation of this Id.
	*
	* @return {String} return the 24 byte hex string representation.
	* @ignore
	*/
	ObjectID.prototype.inspect = ObjectID.prototype.toString;
	
	/**
	* Converts to its JSON representation.
	*
	* @return {String} return the 24 byte hex string representation.
	* @ignore
	*/
	ObjectID.prototype.toJSON = function() {
	  return this.toHexString();
	};
	
	/**
	* Compares the equality of this ObjectID with `otherID`.
	*
	* @method
	* @param {object} otherID ObjectID instance to compare against.
	* @return {boolean} the result of comparing two ObjectID's
	*/
	ObjectID.prototype.equals = function equals (otherID) {
	  if(otherID == null) return false;
	  var id = (otherID instanceof ObjectID || otherID.toHexString)
	    ? otherID.id
	    : ObjectID.createFromHexString(otherID).id;
	
	  return this.id === id;
	}
	
	/**
	* Returns the generation date (accurate up to the second) that this ID was generated.
	*
	* @method
	* @return {date} the generation date
	*/
	ObjectID.prototype.getTimestamp = function() {
	  var timestamp = new Date();
	  timestamp.setTime(Math.floor(BinaryParser.decodeInt(this.id.substring(0,4), 32, true, true)) * 1000);
	  return timestamp;
	}
	
	/**
	* @ignore
	*/
	ObjectID.index = parseInt(Math.random() * 0xFFFFFF, 10);
	
	/**
	* @ignore
	*/
	ObjectID.createPk = function createPk () {
	  return new ObjectID();
	};
	
	/**
	* Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.
	*
	* @method
	* @param {number} time an integer number representing a number of seconds.
	* @return {ObjectID} return the created ObjectID
	*/
	ObjectID.createFromTime = function createFromTime (time) {
	  var id = BinaryParser.encodeInt(time, 32, true, true) +
	           BinaryParser.encodeInt(0, 64, true, true);
	  return new ObjectID(id);
	};
	
	/**
	* Creates an ObjectID from a hex string representation of an ObjectID.
	*
	* @method
	* @param {string} hexString create a ObjectID from a passed in 24 byte hexstring.
	* @return {ObjectID} return the created ObjectID
	*/
	ObjectID.createFromHexString = function createFromHexString (hexString) {
	  // Throw an error if it's not a valid setup
	  if(typeof hexString === 'undefined' || hexString != null && hexString.length != 24)
	    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
	
	  var len = hexString.length;
	
	  if(len > 12*2) {
	    throw new Error('Id cannot be longer than 12 bytes');
	  }
	
	  var result = ''
	    , string
	    , number;
	
	  for (var index = 0; index < len; index += 2) {
	    string = hexString.substr(index, 2);
	    number = parseInt(string, 16);
	    result += BinaryParser.fromByte(number);
	  }
	
	  return new ObjectID(result, hexString);
	};
	
	/**
	* Checks if a value is a valid bson ObjectId
	*
	* @method
	* @return {boolean} return true if the value is a valid bson ObjectId, return false otherwise.
	*/
	ObjectID.isValid = function isValid(id) {
	  if(id == null) return false;
	
	  if(id != null && 'number' != typeof id && (id.length != 12 && id.length != 24)) {
	    return false;
	  } else {
	    // Check specifically for hex correctness
	    if(typeof id == 'string' && id.length == 24) return checkForHexRegExp.test(id);
	    return true;
	  }
	};
	
	/**
	* @ignore
	*/
	Object.defineProperty(ObjectID.prototype, "generationTime", {
	   enumerable: true
	 , get: function () {
	     return Math.floor(BinaryParser.decodeInt(this.id.substring(0,4), 32, true, true));
	   }
	 , set: function (value) {
	     var value = BinaryParser.encodeInt(value, 32, true, true);
	     this.id = value + this.id.substr(4);
	     // delete this.__id;
	     this.toHexString();
	   }
	});
	
	/**
	 * Expose.
	 */
	module.exports = ObjectID;
	module.exports.ObjectID = ObjectID;
	module.exports.ObjectId = ObjectID;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 56 */
/*!*****************************************************!*\
  !*** ./~/mongoose/~/bson/lib/bson/binary_parser.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Binary Parser.
	 * Jonas Raoni Soares Silva
	 * http://jsfromhell.com/classes/binary-parser [v1.0]
	 */
	var chr = String.fromCharCode;
	
	var maxBits = [];
	for (var i = 0; i < 64; i++) {
		maxBits[i] = Math.pow(2, i);
	}
	
	function BinaryParser (bigEndian, allowExceptions) {
	  if(!(this instanceof BinaryParser)) return new BinaryParser(bigEndian, allowExceptions);
	  
		this.bigEndian = bigEndian;
		this.allowExceptions = allowExceptions;
	};
	
	BinaryParser.warn = function warn (msg) {
		if (this.allowExceptions) {
			throw new Error(msg);
	  }
	
		return 1;
	};
	
	BinaryParser.decodeFloat = function decodeFloat (data, precisionBits, exponentBits) {
		var b = new this.Buffer(this.bigEndian, data);
	
		b.checkBuffer(precisionBits + exponentBits + 1);
	
		var bias = maxBits[exponentBits - 1] - 1
	    , signal = b.readBits(precisionBits + exponentBits, 1)
	    , exponent = b.readBits(precisionBits, exponentBits)
	    , significand = 0
	    , divisor = 2
	    , curByte = b.buffer.length + (-precisionBits >> 3) - 1;
	
		do {
			for (var byteValue = b.buffer[ ++curByte ], startBit = precisionBits % 8 || 8, mask = 1 << startBit; mask >>= 1; ( byteValue & mask ) && ( significand += 1 / divisor ), divisor *= 2 );
		} while (precisionBits -= startBit);
	
		return exponent == ( bias << 1 ) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : ( 1 + signal * -2 ) * ( exponent || significand ? !exponent ? Math.pow( 2, -bias + 1 ) * significand : Math.pow( 2, exponent - bias ) * ( 1 + significand ) : 0 );
	};
	
	BinaryParser.decodeInt = function decodeInt (data, bits, signed, forceBigEndian) {
	  var b = new this.Buffer(this.bigEndian || forceBigEndian, data)
	      , x = b.readBits(0, bits)
	      , max = maxBits[bits]; //max = Math.pow( 2, bits );
	  
	  return signed && x >= max / 2
	      ? x - max
	      : x;
	};
	
	BinaryParser.encodeFloat = function encodeFloat (data, precisionBits, exponentBits) {
		var bias = maxBits[exponentBits - 1] - 1
	    , minExp = -bias + 1
	    , maxExp = bias
	    , minUnnormExp = minExp - precisionBits
	    , n = parseFloat(data)
	    , status = isNaN(n) || n == -Infinity || n == +Infinity ? n : 0
	    ,	exp = 0
	    , len = 2 * bias + 1 + precisionBits + 3
	    , bin = new Array(len)
	    , signal = (n = status !== 0 ? 0 : n) < 0
	    , intPart = Math.floor(n = Math.abs(n))
	    , floatPart = n - intPart
	    , lastBit
	    , rounded
	    , result
	    , i
	    , j;
	
		for (i = len; i; bin[--i] = 0);
	
		for (i = bias + 2; intPart && i; bin[--i] = intPart % 2, intPart = Math.floor(intPart / 2));
	
		for (i = bias + 1; floatPart > 0 && i; (bin[++i] = ((floatPart *= 2) >= 1) - 0 ) && --floatPart);
	
		for (i = -1; ++i < len && !bin[i];);
	
		if (bin[(lastBit = precisionBits - 1 + (i = (exp = bias + 1 - i) >= minExp && exp <= maxExp ? i + 1 : bias + 1 - (exp = minExp - 1))) + 1]) {
			if (!(rounded = bin[lastBit])) {
				for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]);
			}
	
			for (j = lastBit + 1; rounded && --j >= 0; (bin[j] = !bin[j] - 0) && (rounded = 0));
		}
	
		for (i = i - 2 < 0 ? -1 : i - 3; ++i < len && !bin[i];);
	
		if ((exp = bias + 1 - i) >= minExp && exp <= maxExp) {
			++i;
	  } else if (exp < minExp) {
			exp != bias + 1 - len && exp < minUnnormExp && this.warn("encodeFloat::float underflow");
			i = bias + 1 - (exp = minExp - 1);
		}
	
		if (intPart || status !== 0) {
			this.warn(intPart ? "encodeFloat::float overflow" : "encodeFloat::" + status);
			exp = maxExp + 1;
			i = bias + 2;
	
			if (status == -Infinity) {
				signal = 1;
	    } else if (isNaN(status)) {
				bin[i] = 1;
	    }
		}
	
		for (n = Math.abs(exp + bias), j = exponentBits + 1, result = ""; --j; result = (n % 2) + result, n = n >>= 1);
	
		for (n = 0, j = 0, i = (result = (signal ? "1" : "0") + result + bin.slice(i, i + precisionBits).join("")).length, r = []; i; j = (j + 1) % 8) {
			n += (1 << j) * result.charAt(--i);
			if (j == 7) {
				r[r.length] = String.fromCharCode(n);
				n = 0;
			}
		}
	
		r[r.length] = n
	    ? String.fromCharCode(n)
	    : "";
	
		return (this.bigEndian ? r.reverse() : r).join("");
	};
	
	BinaryParser.encodeInt = function encodeInt (data, bits, signed, forceBigEndian) {
		var max = maxBits[bits];
	
	  if (data >= max || data < -(max / 2)) {
	    this.warn("encodeInt::overflow");
	    data = 0;
	  }
	
		if (data < 0) {
	    data += max;
	  }
	
		for (var r = []; data; r[r.length] = String.fromCharCode(data % 256), data = Math.floor(data / 256));
	
		for (bits = -(-bits >> 3) - r.length; bits--; r[r.length] = "\0");
	
	  return ((this.bigEndian || forceBigEndian) ? r.reverse() : r).join("");
	};
	
	BinaryParser.toSmall    = function( data ){ return this.decodeInt( data,  8, true  ); };
	BinaryParser.fromSmall  = function( data ){ return this.encodeInt( data,  8, true  ); };
	BinaryParser.toByte     = function( data ){ return this.decodeInt( data,  8, false ); };
	BinaryParser.fromByte   = function( data ){ return this.encodeInt( data,  8, false ); };
	BinaryParser.toShort    = function( data ){ return this.decodeInt( data, 16, true  ); };
	BinaryParser.fromShort  = function( data ){ return this.encodeInt( data, 16, true  ); };
	BinaryParser.toWord     = function( data ){ return this.decodeInt( data, 16, false ); };
	BinaryParser.fromWord   = function( data ){ return this.encodeInt( data, 16, false ); };
	BinaryParser.toInt      = function( data ){ return this.decodeInt( data, 32, true  ); };
	BinaryParser.fromInt    = function( data ){ return this.encodeInt( data, 32, true  ); };
	BinaryParser.toLong     = function( data ){ return this.decodeInt( data, 64, true  ); };
	BinaryParser.fromLong   = function( data ){ return this.encodeInt( data, 64, true  ); };
	BinaryParser.toDWord    = function( data ){ return this.decodeInt( data, 32, false ); };
	BinaryParser.fromDWord  = function( data ){ return this.encodeInt( data, 32, false ); };
	BinaryParser.toQWord    = function( data ){ return this.decodeInt( data, 64, true ); };
	BinaryParser.fromQWord  = function( data ){ return this.encodeInt( data, 64, true ); };
	BinaryParser.toFloat    = function( data ){ return this.decodeFloat( data, 23, 8   ); };
	BinaryParser.fromFloat  = function( data ){ return this.encodeFloat( data, 23, 8   ); };
	BinaryParser.toDouble   = function( data ){ return this.decodeFloat( data, 52, 11  ); };
	BinaryParser.fromDouble = function( data ){ return this.encodeFloat( data, 52, 11  ); };
	
	// Factor out the encode so it can be shared by add_header and push_int32
	BinaryParser.encode_int32 = function encode_int32 (number, asArray) {
	  var a, b, c, d, unsigned;
	  unsigned = (number < 0) ? (number + 0x100000000) : number;
	  a = Math.floor(unsigned / 0xffffff);
	  unsigned &= 0xffffff;
	  b = Math.floor(unsigned / 0xffff);
	  unsigned &= 0xffff;
	  c = Math.floor(unsigned / 0xff);
	  unsigned &= 0xff;
	  d = Math.floor(unsigned);
	  return asArray ? [chr(a), chr(b), chr(c), chr(d)] : chr(a) + chr(b) + chr(c) + chr(d);
	};
	
	BinaryParser.encode_int64 = function encode_int64 (number) {
	  var a, b, c, d, e, f, g, h, unsigned;
	  unsigned = (number < 0) ? (number + 0x10000000000000000) : number;
	  a = Math.floor(unsigned / 0xffffffffffffff);
	  unsigned &= 0xffffffffffffff;
	  b = Math.floor(unsigned / 0xffffffffffff);
	  unsigned &= 0xffffffffffff;
	  c = Math.floor(unsigned / 0xffffffffff);
	  unsigned &= 0xffffffffff;
	  d = Math.floor(unsigned / 0xffffffff);
	  unsigned &= 0xffffffff;
	  e = Math.floor(unsigned / 0xffffff);
	  unsigned &= 0xffffff;
	  f = Math.floor(unsigned / 0xffff);
	  unsigned &= 0xffff;
	  g = Math.floor(unsigned / 0xff);
	  unsigned &= 0xff;
	  h = Math.floor(unsigned);
	  return chr(a) + chr(b) + chr(c) + chr(d) + chr(e) + chr(f) + chr(g) + chr(h);
	};
	
	/**
	 * UTF8 methods
	 */
	
	// Take a raw binary string and return a utf8 string
	BinaryParser.decode_utf8 = function decode_utf8 (binaryStr) {
	  var len = binaryStr.length
	    , decoded = ''
	    , i = 0
	    , c = 0
	    , c1 = 0
	    , c2 = 0
	    , c3;
	
	  while (i < len) {
	    c = binaryStr.charCodeAt(i);
	    if (c < 128) {
	      decoded += String.fromCharCode(c);
	      i++;
	    } else if ((c > 191) && (c < 224)) {
		    c2 = binaryStr.charCodeAt(i+1);
	      decoded += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
	      i += 2;
	    } else {
		    c2 = binaryStr.charCodeAt(i+1);
		    c3 = binaryStr.charCodeAt(i+2);
	      decoded += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
	      i += 3;
	    }
	  }
	
	  return decoded;
	};
	
	// Encode a cstring
	BinaryParser.encode_cstring = function encode_cstring (s) {
	  return unescape(encodeURIComponent(s)) + BinaryParser.fromByte(0);
	};
	
	// Take a utf8 string and return a binary string
	BinaryParser.encode_utf8 = function encode_utf8 (s) {
	  var a = ""
	    , c;
	
	  for (var n = 0, len = s.length; n < len; n++) {
	    c = s.charCodeAt(n);
	
	    if (c < 128) {
		    a += String.fromCharCode(c);
	    } else if ((c > 127) && (c < 2048)) {
		    a += String.fromCharCode((c>>6) | 192) ;
		    a += String.fromCharCode((c&63) | 128);
	    } else {
	      a += String.fromCharCode((c>>12) | 224);
	      a += String.fromCharCode(((c>>6) & 63) | 128);
	      a += String.fromCharCode((c&63) | 128);
	    }
	  }
	
	  return a;
	};
	
	BinaryParser.hprint = function hprint (s) {
	  var number;
	
	  for (var i = 0, len = s.length; i < len; i++) {
	    if (s.charCodeAt(i) < 32) {
	      number = s.charCodeAt(i) <= 15
	        ? "0" + s.charCodeAt(i).toString(16)
	        : s.charCodeAt(i).toString(16);        
	      process.stdout.write(number + " ")
	    } else {
	      number = s.charCodeAt(i) <= 15
	        ? "0" + s.charCodeAt(i).toString(16)
	        : s.charCodeAt(i).toString(16);
	        process.stdout.write(number + " ")
	    }
	  }
	  
	  process.stdout.write("\n\n");
	};
	
	BinaryParser.ilprint = function hprint (s) {
	  var number;
	
	  for (var i = 0, len = s.length; i < len; i++) {
	    if (s.charCodeAt(i) < 32) {
	      number = s.charCodeAt(i) <= 15
	        ? "0" + s.charCodeAt(i).toString(10)
	        : s.charCodeAt(i).toString(10);
	
	      __webpack_require__(/*! util */ 57).debug(number+' : ');
	    } else {
	      number = s.charCodeAt(i) <= 15
	        ? "0" + s.charCodeAt(i).toString(10)
	        : s.charCodeAt(i).toString(10);
	      __webpack_require__(/*! util */ 57).debug(number+' : '+ s.charAt(i));
	    }
	  }
	};
	
	BinaryParser.hlprint = function hprint (s) {
	  var number;
	
	  for (var i = 0, len = s.length; i < len; i++) {
	    if (s.charCodeAt(i) < 32) {
	      number = s.charCodeAt(i) <= 15
	        ? "0" + s.charCodeAt(i).toString(16)
	        : s.charCodeAt(i).toString(16);
	      __webpack_require__(/*! util */ 57).debug(number+' : ');
	    } else {
	      number = s.charCodeAt(i) <= 15
	        ? "0" + s.charCodeAt(i).toString(16)
	        : s.charCodeAt(i).toString(16);
	      __webpack_require__(/*! util */ 57).debug(number+' : '+ s.charAt(i));
	    }
	  }
	};
	
	/**
	 * BinaryParser buffer constructor.
	 */
	function BinaryParserBuffer (bigEndian, buffer) {
	  this.bigEndian = bigEndian || 0;
	  this.buffer = [];
	  this.setBuffer(buffer);
	};
	
	BinaryParserBuffer.prototype.setBuffer = function setBuffer (data) {
	  var l, i, b;
	
		if (data) {
	    i = l = data.length;
	    b = this.buffer = new Array(l);
			for (; i; b[l - i] = data.charCodeAt(--i));
			this.bigEndian && b.reverse();
		}
	};
	
	BinaryParserBuffer.prototype.hasNeededBits = function hasNeededBits (neededBits) {
		return this.buffer.length >= -(-neededBits >> 3);
	};
	
	BinaryParserBuffer.prototype.checkBuffer = function checkBuffer (neededBits) {
		if (!this.hasNeededBits(neededBits)) {
			throw new Error("checkBuffer::missing bytes");
	  }
	};
	
	BinaryParserBuffer.prototype.readBits = function readBits (start, length) {
		//shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni)
	
		function shl (a, b) {
			for (; b--; a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1);
			return a;
		}
	
		if (start < 0 || length <= 0) {
			return 0;
	  }
	
		this.checkBuffer(start + length);
	
	  var offsetLeft
	    , offsetRight = start % 8
	    , curByte = this.buffer.length - ( start >> 3 ) - 1
	    , lastByte = this.buffer.length + ( -( start + length ) >> 3 )
	    , diff = curByte - lastByte
	    , sum = ((this.buffer[ curByte ] >> offsetRight) & ((1 << (diff ? 8 - offsetRight : length)) - 1)) + (diff && (offsetLeft = (start + length) % 8) ? (this.buffer[lastByte++] & ((1 << offsetLeft) - 1)) << (diff-- << 3) - offsetRight : 0);
	
		for(; diff; sum += shl(this.buffer[lastByte++], (diff-- << 3) - offsetRight));
	
		return sum;
	};
	
	/**
	 * Expose.
	 */
	BinaryParser.Buffer = BinaryParserBuffer;
	
	exports.BinaryParser = BinaryParser;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 57 */
/*!********************************************!*\
  !*** ./~/node-libs-browser/~/util/util.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ 58);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(/*! inherits */ 59);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 58 */
/*!***************************************************************!*\
  !*** ./~/node-libs-browser/~/util/support/isBufferBrowser.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 59 */
/*!*******************************************************************!*\
  !*** ./~/node-libs-browser/~/util/~/inherits/inherits_browser.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 60 */
/*!**********************************************!*\
  !*** ./~/mongoose/~/bson/lib/bson/symbol.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A class representation of the BSON Symbol type.
	 *
	 * @class
	 * @deprecated
	 * @param {string} value the string representing the symbol.
	 * @return {Symbol}
	 */
	function Symbol(value) {
	  if(!(this instanceof Symbol)) return new Symbol(value);
	  this._bsontype = 'Symbol';
	  this.value = value;
	}
	
	/**
	 * Access the wrapped string value.
	 *
	 * @method
	 * @return {String} returns the wrapped string.
	 */
	Symbol.prototype.valueOf = function() {
	  return this.value;
	};
	
	/**
	 * @ignore
	 */
	Symbol.prototype.toString = function() {
	  return this.value;
	}
	
	/**
	 * @ignore
	 */
	Symbol.prototype.inspect = function() {
	  return this.value;
	}
	
	/**
	 * @ignore
	 */
	Symbol.prototype.toJSON = function() {
	  return this.value;
	}
	
	module.exports = Symbol;
	module.exports.Symbol = Symbol;

/***/ },
/* 61 */
/*!********************************************!*\
  !*** ./~/mongoose/~/bson/lib/bson/code.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A class representation of the BSON Code type.
	 *
	 * @class
	 * @param {(string|function)} code a string or function.
	 * @param {Object} [scope] an optional scope for the function.
	 * @return {Code}
	 */
	var Code = function Code(code, scope) {
	  if(!(this instanceof Code)) return new Code(code, scope);
	  this._bsontype = 'Code';
	  this.code = code;
	  this.scope = scope == null ? {} : scope;
	};
	
	/**
	 * @ignore
	 */
	Code.prototype.toJSON = function() {
	  return {scope:this.scope, code:this.code};
	}
	
	module.exports = Code;
	module.exports.Code = Code;

/***/ },
/* 62 */
/*!***********************************************!*\
  !*** ./~/mongoose/~/bson/lib/bson/min_key.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A class representation of the BSON MinKey type.
	 *
	 * @class
	 * @return {MinKey} A MinKey instance
	 */
	function MinKey() {
	  if(!(this instanceof MinKey)) return new MinKey();
	  
	  this._bsontype = 'MinKey';
	}
	
	module.exports = MinKey;
	module.exports.MinKey = MinKey;

/***/ },
/* 63 */
/*!***********************************************!*\
  !*** ./~/mongoose/~/bson/lib/bson/max_key.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A class representation of the BSON MaxKey type.
	 *
	 * @class
	 * @return {MaxKey} A MaxKey instance
	 */
	function MaxKey() {
	  if(!(this instanceof MaxKey)) return new MaxKey();
	  
	  this._bsontype = 'MaxKey';  
	}
	
	module.exports = MaxKey;
	module.exports.MaxKey = MaxKey;

/***/ },
/* 64 */
/*!**********************************************!*\
  !*** ./~/mongoose/~/bson/lib/bson/db_ref.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A class representation of the BSON DBRef type.
	 *
	 * @class
	 * @param {string} namespace the collection name.
	 * @param {ObjectID} oid the reference ObjectID.
	 * @param {string} [db] optional db name, if omitted the reference is local to the current db.
	 * @return {DBRef}
	 */
	function DBRef(namespace, oid, db) {
	  if(!(this instanceof DBRef)) return new DBRef(namespace, oid, db);
	  
	  this._bsontype = 'DBRef';
	  this.namespace = namespace;
	  this.oid = oid;
	  this.db = db;
	};
	
	/**
	 * @ignore
	 * @api private
	 */
	DBRef.prototype.toJSON = function() {
	  return {
	    '$ref':this.namespace,
	    '$id':this.oid,
	    '$db':this.db == null ? '' : this.db
	  };
	}
	
	module.exports = DBRef;
	module.exports.DBRef = DBRef;

/***/ },
/* 65 */
/*!**********************************************!*\
  !*** ./~/mongoose/~/bson/lib/bson/binary.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 * @ignore
	 */
	if(typeof window === 'undefined') { 
	  var Buffer = __webpack_require__(/*! buffer */ 28).Buffer; // TODO just use global Buffer
	}
	
	/**
	 * A class representation of the BSON Binary type.
	 * 
	 * Sub types
	 *  - **BSON.BSON_BINARY_SUBTYPE_DEFAULT**, default BSON type.
	 *  - **BSON.BSON_BINARY_SUBTYPE_FUNCTION**, BSON function type.
	 *  - **BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY**, BSON byte array type.
	 *  - **BSON.BSON_BINARY_SUBTYPE_UUID**, BSON uuid type.
	 *  - **BSON.BSON_BINARY_SUBTYPE_MD5**, BSON md5 type.
	 *  - **BSON.BSON_BINARY_SUBTYPE_USER_DEFINED**, BSON user defined type.
	 *
	 * @class
	 * @param {Buffer} buffer a buffer object containing the binary data.
	 * @param {Number} [subType] the option binary type.
	 * @return {Binary}
	 */
	function Binary(buffer, subType) {
	  if(!(this instanceof Binary)) return new Binary(buffer, subType);
	  
	  this._bsontype = 'Binary';
	
	  if(buffer instanceof Number) {
	    this.sub_type = buffer;
	    this.position = 0;
	  } else {    
	    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
	    this.position = 0;
	  }
	
	  if(buffer != null && !(buffer instanceof Number)) {
	    // Only accept Buffer, Uint8Array or Arrays
	    if(typeof buffer == 'string') {
	      // Different ways of writing the length of the string for the different types
	      if(typeof Buffer != 'undefined') {
	        this.buffer = new Buffer(buffer);
	      } else if(typeof Uint8Array != 'undefined' || (Object.prototype.toString.call(buffer) == '[object Array]')) {
	        this.buffer = writeStringToArray(buffer);
	      } else {
	        throw new Error("only String, Buffer, Uint8Array or Array accepted");
	      }
	    } else {
	      this.buffer = buffer;      
	    }
	    this.position = buffer.length;
	  } else {
	    if(typeof Buffer != 'undefined') {
	      this.buffer =  new Buffer(Binary.BUFFER_SIZE);      
	    } else if(typeof Uint8Array != 'undefined'){
	      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
	    } else {
	      this.buffer = new Array(Binary.BUFFER_SIZE);
	    }
	    // Set position to start of buffer
	    this.position = 0;
	  }
	};
	
	/**
	 * Updates this binary with byte_value.
	 *
	 * @method
	 * @param {string} byte_value a single byte we wish to write.
	 */
	Binary.prototype.put = function put(byte_value) {
	  // If it's a string and a has more than one character throw an error
	  if(byte_value['length'] != null && typeof byte_value != 'number' && byte_value.length != 1) throw new Error("only accepts single character String, Uint8Array or Array");
	  if(typeof byte_value != 'number' && byte_value < 0 || byte_value > 255) throw new Error("only accepts number in a valid unsigned byte range 0-255");
	  
	  // Decode the byte value once
	  var decoded_byte = null;
	  if(typeof byte_value == 'string') {
	    decoded_byte = byte_value.charCodeAt(0);      
	  } else if(byte_value['length'] != null) {
	    decoded_byte = byte_value[0];
	  } else {
	    decoded_byte = byte_value;
	  }
	  
	  if(this.buffer.length > this.position) {
	    this.buffer[this.position++] = decoded_byte;
	  } else {
	    if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {    
	      // Create additional overflow buffer
	      var buffer = new Buffer(Binary.BUFFER_SIZE + this.buffer.length);
	      // Combine the two buffers together
	      this.buffer.copy(buffer, 0, 0, this.buffer.length);
	      this.buffer = buffer;
	      this.buffer[this.position++] = decoded_byte;
	    } else {
	      var buffer = null;
	      // Create a new buffer (typed or normal array)
	      if(Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') {
	        buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length));
	      } else {
	        buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length);
	      }      
	      
	      // We need to copy all the content to the new array
	      for(var i = 0; i < this.buffer.length; i++) {
	        buffer[i] = this.buffer[i];
	      }
	      
	      // Reassign the buffer
	      this.buffer = buffer;
	      // Write the byte
	      this.buffer[this.position++] = decoded_byte;
	    }
	  }
	};
	
	/**
	 * Writes a buffer or string to the binary.
	 *
	 * @method
	 * @param {(Buffer|string)} string a string or buffer to be written to the Binary BSON object.
	 * @param {number} offset specify the binary of where to write the content.
	 * @return {null}
	 */
	Binary.prototype.write = function write(string, offset) {
	  offset = typeof offset == 'number' ? offset : this.position;
	
	  // If the buffer is to small let's extend the buffer
	  if(this.buffer.length < offset + string.length) {
	    var buffer = null;
	    // If we are in node.js
	    if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {      
	      buffer = new Buffer(this.buffer.length + string.length);
	      this.buffer.copy(buffer, 0, 0, this.buffer.length);      
	    } else if(Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') {
	      // Create a new buffer
	      buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length))
	      // Copy the content
	      for(var i = 0; i < this.position; i++) {
	        buffer[i] = this.buffer[i];
	      }
	    }
	    
	    // Assign the new buffer
	    this.buffer = buffer;
	  }
	
	  if(typeof Buffer != 'undefined' && Buffer.isBuffer(string) && Buffer.isBuffer(this.buffer)) {
	    string.copy(this.buffer, offset, 0, string.length);
	    this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;
	    // offset = string.length
	  } else if(typeof Buffer != 'undefined' && typeof string == 'string' && Buffer.isBuffer(this.buffer)) {
	    this.buffer.write(string, 'binary', offset);
	    this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;
	    // offset = string.length;
	  } else if(Object.prototype.toString.call(string) == '[object Uint8Array]' 
	    || Object.prototype.toString.call(string) == '[object Array]' && typeof string != 'string') {      
	    for(var i = 0; i < string.length; i++) {
	      this.buffer[offset++] = string[i];
	    }    
	
	    this.position = offset > this.position ? offset : this.position;
	  } else if(typeof string == 'string') {
	    for(var i = 0; i < string.length; i++) {
	      this.buffer[offset++] = string.charCodeAt(i);
	    }
	
	    this.position = offset > this.position ? offset : this.position;
	  }
	};
	
	/**
	 * Reads **length** bytes starting at **position**.
	 *
	 * @method
	 * @param {number} position read from the given position in the Binary.
	 * @param {number} length the number of bytes to read.
	 * @return {Buffer}
	 */
	Binary.prototype.read = function read(position, length) {
	  length = length && length > 0
	    ? length
	    : this.position;
	  
	  // Let's return the data based on the type we have
	  if(this.buffer['slice']) {
	    return this.buffer.slice(position, position + length);
	  } else {
	    // Create a buffer to keep the result
	    var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);
	    for(var i = 0; i < length; i++) {
	      buffer[i] = this.buffer[position++];
	    }
	  }
	  // Return the buffer
	  return buffer;
	};
	
	/**
	 * Returns the value of this binary as a string.
	 *
	 * @method
	 * @return {string}
	 */
	Binary.prototype.value = function value(asRaw) {
	  asRaw = asRaw == null ? false : asRaw;  
	
	  // Optimize to serialize for the situation where the data == size of buffer
	  if(asRaw && typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer) && this.buffer.length == this.position)
	    return this.buffer;
	  
	  // If it's a node.js buffer object
	  if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {
	    return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString('binary', 0, this.position);
	  } else {
	    if(asRaw) {
	      // we support the slice command use it
	      if(this.buffer['slice'] != null) {
	        return this.buffer.slice(0, this.position);
	      } else {
	        // Create a new buffer to copy content to
	        var newBuffer = Object.prototype.toString.call(this.buffer) == '[object Uint8Array]' ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);
	        // Copy content
	        for(var i = 0; i < this.position; i++) {
	          newBuffer[i] = this.buffer[i];
	        }
	        // Return the buffer
	        return newBuffer;
	      }
	    } else {
	      return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
	    }
	  }
	};
	
	/**
	 * Length.
	 *
	 * @method
	 * @return {number} the length of the binary.
	 */
	Binary.prototype.length = function length() {
	  return this.position;
	};
	
	/**
	 * @ignore
	 */
	Binary.prototype.toJSON = function() {
	  return this.buffer != null ? this.buffer.toString('base64') : '';
	}
	
	/**
	 * @ignore
	 */
	Binary.prototype.toString = function(format) {
	  return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : '';
	}
	
	/**
	 * Binary default subtype
	 * @ignore 
	 */
	var BSON_BINARY_SUBTYPE_DEFAULT = 0;
	
	/**
	 * @ignore
	 */
	var writeStringToArray = function(data) {
	  // Create a buffer
	  var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);
	  // Write the content to the buffer
	  for(var i = 0; i < data.length; i++) {
	    buffer[i] = data.charCodeAt(i);
	  }  
	  // Write the string to the buffer
	  return buffer;
	}
	
	/**
	 * Convert Array ot Uint8Array to Binary String
	 *
	 * @ignore
	 */
	var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {
	  var result = "";
	  for(var i = startIndex; i < endIndex; i++) {
	   result = result + String.fromCharCode(byteArray[i]);
	  }
	  return result;  
	};
	
	Binary.BUFFER_SIZE = 256;
	
	/**
	 * Default BSON type
	 *  
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_DEFAULT = 0;
	/**
	 * Function BSON type
	 *  
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_FUNCTION = 1;
	/**
	 * Byte Array BSON type
	 *  
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_BYTE_ARRAY = 2;
	/**
	 * OLD UUID BSON type
	 *  
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_UUID_OLD = 3;
	/**
	 * UUID BSON type
	 *  
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_UUID = 4;
	/**
	 * MD5 BSON type
	 *  
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_MD5 = 5;
	/**
	 * User BSON type
	 *  
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_USER_DEFINED = 128;
	
	/**
	 * Expose.
	 */
	module.exports = Binary;
	module.exports.Binary = Binary;

/***/ },
/* 66 */
/*!****************************************************!*\
  !*** ./~/mongoose/~/bson/lib/bson/float_parser.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright (c) 2008, Fair Oaks Labs, Inc.
	// All rights reserved.
	// 
	// Redistribution and use in source and binary forms, with or without
	// modification, are permitted provided that the following conditions are met:
	// 
	//  * Redistributions of source code must retain the above copyright notice,
	//    this list of conditions and the following disclaimer.
	// 
	//  * Redistributions in binary form must reproduce the above copyright notice,
	//    this list of conditions and the following disclaimer in the documentation
	//    and/or other materials provided with the distribution.
	// 
	//  * Neither the name of Fair Oaks Labs, Inc. nor the names of its contributors
	//    may be used to endorse or promote products derived from this software
	//    without specific prior written permission.
	// 
	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
	// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	// POSSIBILITY OF SUCH DAMAGE.
	//
	//
	// Modifications to writeIEEE754 to support negative zeroes made by Brian White
	
	var readIEEE754 = function(buffer, offset, endian, mLen, nBytes) {
	  var e, m,
	      bBE = (endian === 'big'),
	      eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      nBits = -7,
	      i = bBE ? 0 : (nBytes - 1),
	      d = bBE ? 1 : -1,
	      s = buffer[offset + i];
	
	  i += d;
	
	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
	
	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
	
	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity);
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
	};
	
	var writeIEEE754 = function(buffer, value, offset, endian, mLen, nBytes) {
	  var e, m, c,
	      bBE = (endian === 'big'),
	      eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
	      i = bBE ? (nBytes-1) : 0,
	      d = bBE ? -1 : 1,
	      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
	
	  value = Math.abs(value);
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e+eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
	
	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
	
	  buffer[offset + i - d] |= s * 128;
	};
	
	exports.readIEEE754 = readIEEE754;
	exports.writeIEEE754 = writeIEEE754;

/***/ },
/* 67 */
/*!******************************************************!*\
  !*** ./~/mongoose/lib/drivers/browser/collection.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = null;


/***/ },
/* 68 */
/*!******************************************************!*\
  !*** ./~/mongoose/lib/drivers/browser/connection.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = null;


/***/ },
/* 69 */
/*!*************************************************!*\
  !*** ./~/mongoose/lib/drivers/browser/index.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	exports.Binary = __webpack_require__(/*! ./binary */ 50);
	exports.ObjectId = __webpack_require__(/*! ./objectid */ 70);
	exports.ReadPreference = __webpack_require__(/*! ./ReadPreference */ 49);


/***/ },
/* 70 */
/*!****************************************************!*\
  !*** ./~/mongoose/lib/drivers/browser/objectid.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) ObjectId
	 * @constructor NodeMongoDbObjectId
	 * @see ObjectId
	 */
	
	var ObjectId = __webpack_require__(/*! bson */ 51).ObjectID;
	
	/*!
	 * ignore
	 */
	
	module.exports = exports = ObjectId;


/***/ },
/* 71 */
/*!**********************************************************************!*\
  !*** ./~/mongoose/lib/drivers/node-mongodb-native/ReadPreference.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var mongodb = __webpack_require__(/*! mongodb */ 72);
	var ReadPref = mongodb.ReadPreference;
	
	/*!
	 * Converts arguments to ReadPrefs the driver
	 * can understand.
	 *
	 * @param {String|Array} pref
	 * @param {Array} [tags]
	 */
	
	module.exports = function readPref (pref, tags) {
	  if (Array.isArray(pref)) {
	    tags = pref[1];
	    pref = pref[0];
	  }
	
	  if (pref instanceof ReadPref) {
	    return pref;
	  }
	
	  switch (pref) {
	    case 'p':
	      pref = 'primary';
	      break;
	    case 'pp':
	      pref = 'primaryPreferred';
	      break;
	    case 's':
	      pref = 'secondary';
	      break;
	    case 'sp':
	      pref = 'secondaryPreferred';
	      break;
	    case 'n':
	      pref = 'nearest';
	      break;
	  }
	
	  return new ReadPref(pref, tags);
	}


/***/ },
/* 72 */
/*!***************************************!*\
  !*** ./~/mongoose/~/mongodb/index.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	// Core module
	var core = __webpack_require__(/*! mongodb-core */ 76);
	
	// Set up the connect function
	var connect = __webpack_require__(/*! ./lib/mongo_client */ 150).connect;
	
	// Expose error class
	connect.MongoError = core.MongoError;
	
	// Actual driver classes exported
	connect.MongoClient = __webpack_require__(/*! ./lib/mongo_client */ 150);
	connect.Db = __webpack_require__(/*! ./lib/db */ 152);
	connect.Collection = __webpack_require__(/*! ./lib/collection */ 155);
	connect.Server = __webpack_require__(/*! ./lib/server */ 75);
	connect.ReplSet = __webpack_require__(/*! ./lib/replset */ 73);
	connect.Mongos = __webpack_require__(/*! ./lib/mongos */ 149);
	connect.ReadPreference = __webpack_require__(/*! ./lib/read_preference */ 120);
	connect.GridStore = __webpack_require__(/*! ./lib/gridfs/grid_store */ 160);
	connect.Chunk = __webpack_require__(/*! ./lib/gridfs/chunk */ 161);
	connect.Logger = core.Logger;
	connect.Cursor = __webpack_require__(/*! ./lib/cursor */ 118);
	
	// BSON types exported
	connect.Binary = core.BSON.Binary;
	connect.Code = core.BSON.Code;
	connect.DBRef = core.BSON.DBRef;
	connect.Double = core.BSON.Double;
	connect.Long = core.BSON.Long;
	connect.MinKey = core.BSON.MinKey;
	connect.MaxKey = core.BSON.MaxKey;
	connect.ObjectID = core.BSON.ObjectID;
	connect.ObjectId = core.BSON.ObjectID;
	connect.Symbol = core.BSON.Symbol;
	connect.Timestamp = core.BSON.Timestamp;
	
	// Add connect method
	connect.connect = connect;
	// Set our exports to be the connect function
	module.exports = connect;

/***/ },
/* 73 */
/*!*********************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/replset.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter
	  , inherits = __webpack_require__(/*! util */ 57).inherits
	  , f = __webpack_require__(/*! util */ 57).format
	  , Server = __webpack_require__(/*! ./server */ 75)
	  , Mongos = __webpack_require__(/*! ./mongos */ 149)
	  , Cursor = __webpack_require__(/*! ./cursor */ 118)
	  , ReadPreference = __webpack_require__(/*! ./read_preference */ 120)
	  , MongoCR = __webpack_require__(/*! mongodb-core */ 76).MongoCR
	  , MongoError = __webpack_require__(/*! mongodb-core */ 76).MongoError
	  , ServerCapabilities = __webpack_require__(/*! ./topology_base */ 148).ServerCapabilities
	  , Store = __webpack_require__(/*! ./topology_base */ 148).Store
	  , CServer = __webpack_require__(/*! mongodb-core */ 76).Server
	  , CReplSet = __webpack_require__(/*! mongodb-core */ 76).ReplSet
	  , CoreReadPreference = __webpack_require__(/*! mongodb-core */ 76).ReadPreference
	  , shallowClone = __webpack_require__(/*! ./utils */ 119).shallowClone;
	
	/**
	 * @fileOverview The **ReplSet** class is a class that represents a Replicaset topology and is
	 * used to construct connections.
	 * 
	 * **ReplSet Should not be used, use MongoClient.connect**
	 * @example
	 * var Db = require('mongodb').Db,
	 *   ReplSet = require('mongodb').ReplSet,
	 *   Server = require('mongodb').Server,
	 *   test = require('assert');
	 * // Connect using ReplSet
	 * var server = new Server('localhost', 27017);
	 * var db = new Db('test', new ReplSet([server]));
	 * db.open(function(err, db) {
	 *   // Get an additional db
	 *   db.close();
	 * });
	 */
	
	/**
	 * Creates a new ReplSet instance
	 * @class
	 * @deprecated
	 * @param {Server[]} servers A seedlist of servers participating in the replicaset.
	 * @param {object} [options=null] Optional settings.
	 * @param {booelan} [options.ha=true] Turn on high availability monitoring.
	 * @param {number} [options.haInterval=5000] Time between each replicaset status check.
	 * @param {string} options.replicaSet The name of the replicaset to connect to.
	 * @param {number} [options.secondaryAcceptableLatencyMS=15] Sets the range of servers to pick when using NEAREST (lowest ping ms + the latency fence, ex: range of 1 to (1 + 15) ms) 
	 * @param {boolean} [options.connectWithNoPrimary=false] Sets if the driver should connect even if no primary is available
	 * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.
	 * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support) 
	 * @param {object} [options.sslValidate=true] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {array} [options.sslCA=null] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslCert=null] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslKey=null] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslPass=null] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {object} [options.socketOptions=null] Socket options 
	 * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option. 
	 * @param {number} [options.socketOptions.keepAlive=0] TCP KeepAlive on the socket with a X ms delay before start. 
	 * @param {number} [options.socketOptions.connectTimeoutMS=0] TCP Connection timeout setting 
	 * @param {number} [options.socketOptions.socketTimeoutMS=0] TCP Socket timeout setting 
	 * @fires ReplSet#connect
	 * @fires ReplSet#ha
	 * @fires ReplSet#joined
	 * @fires ReplSet#left
	 * @fires ReplSet#fullsetup
	 * @fires ReplSet#open
	 * @fires ReplSet#close
	 * @fires ReplSet#error
	 * @fires ReplSet#timeout
	 * @fires ReplSet#parseError
	 * @return {ReplSet} a ReplSet instance.
	 */
	var ReplSet = function(servers, options) {  
	  if(!(this instanceof ReplSet)) return new ReplSet(servers, options);
	  options = options || {};
	  var self = this;
	
	  // Ensure all the instances are Server
	  for(var i = 0; i < servers.length; i++) {
	    if(!(servers[i] instanceof Server)) {
	      throw new MongoError("all seed list instances must be of the Server type");
	    }
	  }
	
	  // Store option defaults
	  var storeOptions = {
	      force: false
	    , bufferMaxEntries: -1
	  }
	
	  // Shared global store
	  var store = options.store || new Store(self, storeOptions);
	
	  // Set up event emitter
	  EventEmitter.call(this);
	
	  // Debug tag
	  var tag = options.tag;
	
	  // Build seed list
	  var seedlist = servers.map(function(x) {
	    return {host: x.host, port: x.port}
	  });
	
	  // Final options
	  var finalOptions = shallowClone(options);
	
	  // Default values  
	  finalOptions.size = typeof options.poolSize == 'number' ? options.poolSize : 5;
	  finalOptions.reconnect = typeof options.auto_reconnect == 'boolean' ? options.auto_reconnect : true;
	  finalOptions.emitError = typeof options.emitError == 'boolean' ? options.emitError : true;
	  finalOptions.cursorFactory = Cursor;
	
	  // Add the store
	  finalOptions.disconnectHandler = store;
	
	  // Socket options passed down
	  if(options.socketOptions) {
	    if(options.socketOptions.connectTimeoutMS) {
	      this.connectTimeoutMS = options.socketOptions.connectTimeoutMS;
	      finalOptions.connectionTimeout = options.socketOptions.connectTimeoutMS;
	    }
	    
	    if(options.socketOptions.socketTimeoutMS) {
	      finalOptions.socketTimeout = options.socketOptions.socketTimeoutMS;
	    }
	  } 
	
	  // Get the name
	  var replicaSet = options.replicaSet || options.rs_name;
	
	  // Set up options
	  finalOptions.setName = replicaSet;
	
	  // Are we running in debug mode
	  var debug = typeof options.debug == 'boolean' ? options.debug : false;
	  if(debug) {
	    finalOptions.debug = debug;
	  }
	
	  // Map keep alive setting
	  if(options.socketOptions && typeof options.socketOptions.keepAlive == 'number') {
	    finalOptions.keepAlive = true;
	    if(typeof options.socketOptions.keepAlive == 'number') {
	      finalOptions.keepAliveInitialDelay = options.socketOptions.keepAlive;
	    }
	  }
	
	  // Connection timeout
	  if(options.socketOptions && typeof options.socketOptions.connectionTimeout == 'number') {
	    finalOptions.connectionTimeout = options.socketOptions.connectionTimeout;
	  }
	
	  // Socket timeout
	  if(options.socketOptions && typeof options.socketOptions.socketTimeout == 'number') {
	    finalOptions.socketTimeout = options.socketOptions.socketTimeout;
	  }
	
	  // noDelay
	  if(options.socketOptions && typeof options.socketOptions.noDelay == 'boolean') {
	    finalOptions.noDelay = options.socketOptions.noDelay;
	  }
	
	  if(typeof options.secondaryAcceptableLatencyMS == 'number') {
	    finalOptions.acceptableLatency = options.secondaryAcceptableLatencyMS;
	  }
	
	  if(options.connectWithNoPrimary == true) {
	    finalOptions.secondaryOnlyConnectionAllowed = true;
	  }
	
	  // Add the non connection store
	  finalOptions.disconnectHandler = store;
	
	  // Translate the options
	  if(options.sslCA) finalOptions.ca = options.sslCA;
	  if(typeof options.sslValidate == 'boolean') finalOptions.rejectUnauthorized = options.sslValidate;
	  if(options.sslKey) finalOptions.key = options.sslKey;
	  if(options.sslCert) finalOptions.cert = options.sslCert;
	  if(options.sslPass) finalOptions.passphrase = options.sslPass;
	
	  // Create the ReplSet
	  var replset = new CReplSet(seedlist, finalOptions)
	  // Server capabilities
	  var sCapabilities = null;
	  // Add auth prbufferMaxEntriesoviders
	  replset.addAuthProvider('mongocr', new MongoCR());
	
	  // Listen to reconnect event
	  replset.on('reconnect', function() {
	    self.emit('reconnect');
	    store.execute();
	  });
	
	  // Internal state
	  this.s = {
	    // Replicaset
	    replset: replset
	    // Server capabilities
	    , sCapabilities: null
	    // Debug tag
	    , tag: options.tag
	    // Store options
	    , storeOptions: storeOptions
	    // Cloned options
	    , clonedOptions: finalOptions
	    // Store
	    , store: store
	    // Options
	    , options: options
	  }
	  
	  // Debug
	  if(debug) {
	    // Last ismaster
	    Object.defineProperty(this, 'replset', {
	      enumerable:true, get: function() { return replset; }
	    });    
	  }
	
	  // Last ismaster
	  Object.defineProperty(this, 'isMasterDoc', {
	    enumerable:true, get: function() { return replset.lastIsMaster(); }
	  });
	
	  // BSON property
	  Object.defineProperty(this, 'bson', { 
	    enumerable: true, get: function() { 
	      return replset.bson; 
	    }
	  });
	
	  Object.defineProperty(this, 'haInterval', {
	    enumerable:true, get: function() { return replset.haInterval; }
	  });
	}
	
	/**
	 * @ignore
	 */
	inherits(ReplSet, EventEmitter);
	
	// Ensure the right read Preference object
	var translateReadPreference = function(options) {
	  if(typeof options.readPreference == 'string') {
	    options.readPreference = new CoreReadPreference(options.readPreference);
	  } else if(options.readPreference instanceof ReadPreference) {
	    options.readPreference = new CoreReadPreference(options.readPreference.mode
	      , options.readPreference.tags);
	  }
	
	  return options;  
	}
	
	ReplSet.prototype.parserType = function() {
	  return this.s.replset.parserType();
	}
	
	// Connect method
	ReplSet.prototype.connect = function(db, _options, callback) {
	  var self = this;
	  if('function' === typeof _options) callback = _options, _options = {};
	  if(_options == null) _options = {};
	  if(!('function' === typeof callback)) callback = null;
	  self.s.options = _options;
	
	  // Update bufferMaxEntries
	  self.s.storeOptions.bufferMaxEntries = db.bufferMaxEntries;
	
	  // Actual handler
	  var errorHandler = function(event) {
	    return function(err) {
	      if(event != 'error') {
	        self.emit(event, err);
	      }
	    }
	  }
	
	  // Connect handler
	  var connectHandler = function() {
	    // Clear out all the current handlers left over
	    ["timeout", "error", "close"].forEach(function(e) {
	      self.s.replset.removeAllListeners(e);
	    });
	
	    // Set up listeners
	    self.s.replset.once('timeout', errorHandler('timeout'));
	    self.s.replset.once('error', errorHandler('error'));
	    self.s.replset.once('close', errorHandler('close'));
	
	    // relay the event
	    var relay = function(event) {
	      return function(t, server) {
	        self.emit(event, t, server);
	      }
	    }
	
	    // Replset events relay
	    var replsetRelay = function(event) {
	      return function(t, server) {
	        self.emit(event, t, server.lastIsMaster(), server);
	      }
	    }
	
	    // Relay ha
	    var relayHa = function(t, state) {
	      self.emit('ha', t, state);          
	
	      if(t == 'start') {
	        self.emit('ha_connect', t, state);          
	      } else if(t == 'end') {
	        self.emit('ha_ismaster', t, state);          
	      }
	    }
	
	    // Set up serverConfig listeners
	    self.s.replset.on('joined', replsetRelay('joined'));
	    self.s.replset.on('left', relay('left'));
	    self.s.replset.on('ping', relay('ping'));
	    self.s.replset.on('ha', relayHa);
	    
	    self.s.replset.on('fullsetup', function(topology) {
	      self.emit('fullsetup', null, self);
	    });
	    
	    self.s.replset.on('all', function(topology) {
	      self.emit('all', null, self);
	    });
	
	    // Emit open event
	    self.emit('open', null, self);      
	
	    // Return correctly
	    try {
	      callback(null, self);
	    } catch(err) { 
	      process.nextTick(function() { throw err; })
	    }      
	  }
	
	  // Error handler
	  var connectErrorHandler = function(event) {
	    return function(err) {
	      ['timeout', 'error', 'close'].forEach(function(e) {
	        self.s.replset.removeListener(e, connectErrorHandler);
	      });
	
	      self.s.replset.removeListener('connect', connectErrorHandler);
	      // Destroy the replset
	      self.s.replset.destroy();
	
	      // Try to callback
	      try {
	        callback(err);
	      } catch(err) { 
	        if(!self.s.replset.isConnected())
	          process.nextTick(function() { throw err; })
	      }
	    }
	  }    
	
	  // Set up listeners
	  self.s.replset.once('timeout', connectErrorHandler('timeout'));
	  self.s.replset.once('error', connectErrorHandler('error'));
	  self.s.replset.once('close', connectErrorHandler('close'));
	  self.s.replset.once('connect', connectHandler);
	
	  // Start connection
	  self.s.replset.connect(_options);
	}  
	
	// Server capabilities
	ReplSet.prototype.capabilities = function() {
	  if(this.s.sCapabilities) return this.s.sCapabilities;
	  this.s.sCapabilities = new ServerCapabilities(this.s.replset.lastIsMaster());
	  return this.s.sCapabilities;
	}
	
	// Command
	ReplSet.prototype.command = function(ns, cmd, options, callback) {
	  options = translateReadPreference(options);
	  this.s.replset.command(ns, cmd, options, callback);
	}
	
	// Insert
	ReplSet.prototype.insert = function(ns, ops, options, callback) {
	  this.s.replset.insert(ns, ops, options, callback);
	}
	
	// Update
	ReplSet.prototype.update = function(ns, ops, options, callback) {
	  this.s.replset.update(ns, ops, options, callback);
	}
	
	// Remove
	ReplSet.prototype.remove = function(ns, ops, options, callback) {
	  this.s.replset.remove(ns, ops, options, callback);
	}
	
	// IsConnected
	ReplSet.prototype.isConnected = function() {
	  return this.s.replset.isConnected();
	}
	
	ReplSet.prototype.setBSONParserType = function(type) {
	  return this.s.replset.setBSONParserType(type);
	}  
	
	// Insert
	ReplSet.prototype.cursor = function(ns, cmd, options) {
	  options = translateReadPreference(options);
	  options.disconnectHandler = this.s.store;
	  return this.s.replset.cursor(ns, cmd, options);
	}
	
	ReplSet.prototype.lastIsMaster = function() {
	  return this.s.replset.lastIsMaster();
	}
	
	ReplSet.prototype.close = function(forceClosed) {
	  var self = this;
	  this.s.replset.destroy();
	  // We need to wash out all stored processes
	  if(forceClosed == true) {
	    this.s.storeOptions.force = forceClosed;
	    this.s.store.flush();
	  }
	
	  var events = ['timeout', 'error', 'close', 'joined', 'left'];
	  events.forEach(function(e) {
	    self.removeAllListeners(e);
	  });        
	}
	
	ReplSet.prototype.auth = function() {
	  var args = Array.prototype.slice.call(arguments, 0);
	  this.s.replset.auth.apply(this.s.replset, args);
	}
	
	/**
	 * All raw connections
	 * @method
	 * @return {array}
	 */
	ReplSet.prototype.connections = function() {
	  return this.s.replset.connections();
	}    
	
	/**
	 * A replset connect event, used to verify that the connection is up and running
	 *
	 * @event ReplSet#connect
	 * @type {ReplSet}
	 */
	
	/**
	 * The replset high availability event
	 *
	 * @event ReplSet#ha
	 * @type {function}
	 * @param {string} type The stage in the high availability event (start|end)
	 * @param {boolean} data.norepeat This is a repeating high availability process or a single execution only
	 * @param {number} data.id The id for this high availability request
	 * @param {object} data.state An object containing the information about the current replicaset
	 */
	
	/**
	 * A server member left the replicaset
	 *
	 * @event ReplSet#left
	 * @type {function}
	 * @param {string} type The type of member that left (primary|secondary|arbiter)
	 * @param {Server} server The server object that left
	 */
	
	/**
	 * A server member joined the replicaset
	 *
	 * @event ReplSet#joined
	 * @type {function}
	 * @param {string} type The type of member that joined (primary|secondary|arbiter)
	 * @param {Server} server The server object that joined
	 */
	
	/**
	 * ReplSet open event, emitted when replicaset can start processing commands.
	 *
	 * @event ReplSet#open
	 * @type {Replset}
	 */
	
	/**
	 * ReplSet fullsetup event, emitted when all servers in the topology have been connected to.
	 *
	 * @event ReplSet#fullsetup
	 * @type {Replset}
	 */
	
	/**
	 * ReplSet close event
	 *
	 * @event ReplSet#close
	 * @type {object}
	 */
	
	/**
	 * ReplSet error event, emitted if there is an error listener.
	 *
	 * @event ReplSet#error
	 * @type {MongoError}
	 */
	
	/**
	 * ReplSet timeout event
	 *
	 * @event ReplSet#timeout
	 * @type {object}
	 */
	
	/**
	 * ReplSet parseError event
	 *
	 * @event ReplSet#parseError
	 * @type {object}
	 */
	
	module.exports = ReplSet;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 74 */
/*!************************************************!*\
  !*** ./~/node-libs-browser/~/events/events.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        len = arguments.length;
	        args = new Array(len - 1);
	        for (i = 1; i < len; i++)
	          args[i - 1] = arguments[i];
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    len = arguments.length;
	    args = new Array(len - 1);
	    for (i = 1; i < len; i++)
	      args[i - 1] = arguments[i];
	
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    var m;
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  var ret;
	  if (!emitter._events || !emitter._events[type])
	    ret = 0;
	  else if (isFunction(emitter._events[type]))
	    ret = 1;
	  else
	    ret = emitter._events[type].length;
	  return ret;
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 75 */
/*!********************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/server.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter
	  , inherits = __webpack_require__(/*! util */ 57).inherits
	  , CServer = __webpack_require__(/*! mongodb-core */ 76).Server
	  , Cursor = __webpack_require__(/*! ./cursor */ 118)
	  , f = __webpack_require__(/*! util */ 57).format
	  , ServerCapabilities = __webpack_require__(/*! ./topology_base */ 148).ServerCapabilities
	  , Store = __webpack_require__(/*! ./topology_base */ 148).Store
	  , MongoError = __webpack_require__(/*! mongodb-core */ 76).MongoError
	  , shallowClone = __webpack_require__(/*! ./utils */ 119).shallowClone;
	
	/**
	 * @fileOverview The **Server** class is a class that represents a single server topology and is
	 * used to construct connections.
	 *
	 * **Server Should not be used, use MongoClient.connect**
	 * @example
	 * var Db = require('mongodb').Db,
	 *   Server = require('mongodb').Server,
	 *   test = require('assert');
	 * // Connect using single Server
	 * var db = new Db('test', new Server('localhost', 27017););
	 * db.open(function(err, db) {
	 *   // Get an additional db
	 *   db.close();
	 * });
	 */
	
	/**
	 * Creates a new Server instance
	 * @class
	 * @deprecated
	 * @param {string} host The host for the server, can be either an IP4, IP6 or domain socket style host.
	 * @param {number} [port] The server port if IP4.
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.
	 * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)
	 * @param {object} [options.sslValidate=true] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {array} [options.sslCA=null] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslCert=null] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslKey=null] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslPass=null] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {object} [options.socketOptions=null] Socket options
	 * @param {boolean} [options.socketOptions.autoReconnect=false] Reconnect on error.
	 * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option.
	 * @param {number} [options.socketOptions.keepAlive=0] TCP KeepAlive on the socket with a X ms delay before start.
	 * @param {number} [options.socketOptions.connectTimeoutMS=0] TCP Connection timeout setting
	 * @param {number} [options.socketOptions.socketTimeoutMS=0] TCP Socket timeout setting
	 * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times
	 * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries
	 * @fires Server#connect
	 * @fires Server#close
	 * @fires Server#error
	 * @fires Server#timeout
	 * @fires Server#parseError
	 * @fires Server#reconnect
	 * @return {Server} a Server instance.
	 */
	var Server = function(host, port, options) {
	  options = options || {};
	  if(!(this instanceof Server)) return new Server(host, port, options);
	  EventEmitter.call(this);
	  var self = this;
	
	  // Store option defaults
	  var storeOptions = {
	      force: false
	    , bufferMaxEntries: -1
	  }
	
	  // Shared global store
	  var store = options.store || new Store(self, storeOptions);
	
	  // Detect if we have a socket connection
	  if(host.indexOf('\/') != -1) {
	    if(port != null && typeof port == 'object') {
	      options = port;
	      port = null;
	    }
	  } else if(port == null) {
	    throw new MongoError('port must be specified');
	  }
	
	  // Clone options
	  var clonedOptions = shallowClone(options);
	  clonedOptions.host = host;
	  clonedOptions.port = port;
	
	  // Reconnect
	  var reconnect = typeof options.auto_reconnect == 'boolean' ? options.auto_reconnect : true;
	  reconnect = typeof options.autoReconnect == 'boolean' ? options.autoReconnect : reconnect;
	  var emitError = typeof options.emitError == 'boolean' ? options.emitError : true;
	  var poolSize = typeof options.poolSize == 'number' ? options.poolSize : 5;
	
	  // Socket options passed down
	  if(options.socketOptions) {
	    if(options.socketOptions.connectTimeoutMS) {
	      this.connectTimeoutMS = options.socketOptions.connectTimeoutMS;
	      clonedOptions.connectionTimeout = options.socketOptions.connectTimeoutMS;
	    }
	
	    if(options.socketOptions.socketTimeoutMS) {
	      clonedOptions.socketTimeout = options.socketOptions.socketTimeoutMS;
	    }
	
	    if(typeof options.socketOptions.keepAlive == 'number') {
	      clonedOptions.keepAliveInitialDelay = options.socketOptions.keepAlive;
	      clonedOptions.keepAlive = true;
	    }
	
	    if(typeof options.socketOptions.noDelay == 'boolean') {
	      clonedOptions.noDelay = options.socketOptions.noDelay;
	    }
	  }
	
	  // Add the cursor factory function
	  clonedOptions.cursorFactory = Cursor;
	  clonedOptions.reconnect = reconnect;
	  clonedOptions.emitError = emitError;
	  clonedOptions.size = poolSize;
	
	  // Translate the options
	  if(clonedOptions.sslCA) clonedOptions.ca = clonedOptions.sslCA;
	  if(typeof clonedOptions.sslValidate == 'boolean') clonedOptions.rejectUnauthorized = clonedOptions.sslValidate;
	  if(clonedOptions.sslKey) clonedOptions.key = clonedOptions.sslKey;
	  if(clonedOptions.sslCert) clonedOptions.cert = clonedOptions.sslCert;
	  if(clonedOptions.sslPass) clonedOptions.passphrase = clonedOptions.sslPass;
	
	  // Add the non connection store
	  clonedOptions.disconnectHandler = store;
	
	  // Create an instance of a server instance from mongodb-core
	  var server = new CServer(clonedOptions);
	  // Server capabilities
	  var sCapabilities = null;
	
	  // Define the internal properties
	  this.s = {
	    // Create an instance of a server instance from mongodb-core
	      server: server
	    // Server capabilities
	    , sCapabilities: null
	    // Cloned options
	    , clonedOptions: clonedOptions
	    // Reconnect
	    , reconnect: reconnect
	    // Emit error
	    , emitError: emitError
	    // Pool size
	    , poolSize: poolSize
	    // Store Options
	    , storeOptions: storeOptions
	    // Store
	    , store: store
	    // Host
	    , host: host
	    // Port
	    , port: port
	    // Options
	    , options: options
	  }
	
	  // BSON property
	  Object.defineProperty(this, 'bson', {
	    enumerable: true, get: function() {
	      return self.s.server.bson;
	    }
	  });
	
	  // Last ismaster
	  Object.defineProperty(this, 'isMasterDoc', {
	    enumerable:true, get: function() {
	      return self.s.server.lastIsMaster();
	    }
	  });
	
	  // Last ismaster
	  Object.defineProperty(this, 'poolSize', {
	    enumerable:true, get: function() { return self.s.server.connections().length; }
	  });
	
	  Object.defineProperty(this, 'autoReconnect', {
	    enumerable:true, get: function() { return self.s.reconnect; }
	  });
	
	  Object.defineProperty(this, 'host', {
	    enumerable:true, get: function() { return self.s.host; }
	  });
	
	  Object.defineProperty(this, 'port', {
	    enumerable:true, get: function() { return self.s.port; }
	  });
	}
	
	inherits(Server, EventEmitter);
	
	Server.prototype.parserType = function() {
	  return this.s.server.parserType();
	}
	
	// Connect
	Server.prototype.connect = function(db, _options, callback) {
	  var self = this;
	  if('function' === typeof _options) callback = _options, _options = {};
	  if(_options == null) _options = {};
	  if(!('function' === typeof callback)) callback = null;
	  self.s.options = _options;
	
	  // Update bufferMaxEntries
	  self.s.storeOptions.bufferMaxEntries = db.bufferMaxEntries;
	
	  // Error handler
	  var connectErrorHandler = function(event) {
	    return function(err) {
	      // Remove all event handlers
	      var events = ['timeout', 'error', 'close'];
	      events.forEach(function(e) {
	        self.s.server.removeListener(e, connectHandlers[e]);
	      });
	
	      self.s.server.removeListener('connect', connectErrorHandler);
	
	      // Try to callback
	      try {
	        callback(err);
	      } catch(err) {
	        process.nextTick(function() { throw err; })
	      }
	    }
	  }
	
	  // Actual handler
	  var errorHandler = function(event) {
	    return function(err) {
	      if(event != 'error') {
	        self.emit(event, err);
	      }
	    }
	  }
	
	  // Error handler
	  var reconnectHandler = function(err) {
	    self.emit('reconnect', self);
	    self.s.store.execute();
	  }
	
	  // Destroy called on topology, perform cleanup
	  var destroyHandler = function() {
	    self.s.store.flush();
	  }
	
	  // Connect handler
	  var connectHandler = function() {
	    // Clear out all the current handlers left over
	    ["timeout", "error", "close"].forEach(function(e) {
	      self.s.server.removeAllListeners(e);
	    });
	
	    // Set up listeners
	    self.s.server.once('timeout', errorHandler('timeout'));
	    self.s.server.once('error', errorHandler('error'));
	    self.s.server.on('close', errorHandler('close'));
	    // Only called on destroy
	    self.s.server.once('destroy', destroyHandler);
	
	    // Emit open event
	    self.emit('open', null, self);
	
	    // Return correctly
	    try {
	      callback(null, self);
	    } catch(err) {
	      process.nextTick(function() { throw err; })
	    }
	  }
	
	  // Set up listeners
	  var connectHandlers = {
	    timeout: connectErrorHandler('timeout'),
	    error: connectErrorHandler('error'),
	    close: connectErrorHandler('close')
	  };
	
	  // Add the event handlers
	  self.s.server.once('timeout', connectHandlers.timeout);
	  self.s.server.once('error', connectHandlers.error);
	  self.s.server.once('close', connectHandlers.close);
	  self.s.server.once('connect', connectHandler);
	  // Reconnect server
	  self.s.server.on('reconnect', reconnectHandler);
	
	  // Start connection
	  self.s.server.connect(_options);
	}
	
	// Server capabilities
	Server.prototype.capabilities = function() {
	  if(this.s.sCapabilities) return this.s.sCapabilities;
	  this.s.sCapabilities = new ServerCapabilities(this.s.server.lastIsMaster());
	  return this.s.sCapabilities;
	}
	
	// Command
	Server.prototype.command = function(ns, cmd, options, callback) {
	  this.s.server.command(ns, cmd, options, callback);
	}
	
	// Insert
	Server.prototype.insert = function(ns, ops, options, callback) {
	  this.s.server.insert(ns, ops, options, callback);
	}
	
	// Update
	Server.prototype.update = function(ns, ops, options, callback) {
	  this.s.server.update(ns, ops, options, callback);
	}
	
	// Remove
	Server.prototype.remove = function(ns, ops, options, callback) {
	  this.s.server.remove(ns, ops, options, callback);
	}
	
	// IsConnected
	Server.prototype.isConnected = function() {
	  return this.s.server.isConnected();
	}
	
	// Insert
	Server.prototype.cursor = function(ns, cmd, options) {
	  options.disconnectHandler = this.s.store;
	  return this.s.server.cursor(ns, cmd, options);
	}
	
	Server.prototype.setBSONParserType = function(type) {
	  return this.s.server.setBSONParserType(type);
	}
	
	Server.prototype.lastIsMaster = function() {
	  return this.s.server.lastIsMaster();
	}
	
	Server.prototype.close = function(forceClosed) {
	  this.s.server.destroy();
	  // We need to wash out all stored processes
	  if(forceClosed == true) {
	    this.s.storeOptions.force = forceClosed;
	    this.s.store.flush();
	  }
	}
	
	Server.prototype.auth = function() {
	  var args = Array.prototype.slice.call(arguments, 0);
	  this.s.server.auth.apply(this.s.server, args);
	}
	
	/**
	 * All raw connections
	 * @method
	 * @return {array}
	 */
	Server.prototype.connections = function() {
	  return this.s.server.connections();
	}
	
	/**
	 * Server connect event
	 *
	 * @event Server#connect
	 * @type {object}
	 */
	
	/**
	 * Server close event
	 *
	 * @event Server#close
	 * @type {object}
	 */
	
	/**
	 * Server reconnect event
	 *
	 * @event Server#reconnect
	 * @type {object}
	 */
	
	/**
	 * Server error event
	 *
	 * @event Server#error
	 * @type {MongoError}
	 */
	
	/**
	 * Server timeout event
	 *
	 * @event Server#timeout
	 * @type {object}
	 */
	
	/**
	 * Server parseError event
	 *
	 * @event Server#parseError
	 * @type {object}
	 */
	
	module.exports = Server;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 76 */
/*!******************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/index.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	    MongoError: __webpack_require__(/*! ./lib/error */ 77)
	  , Server: __webpack_require__(/*! ./lib/topologies/server */ 78)
	  , ReplSet: __webpack_require__(/*! ./lib/topologies/replset */ 114)
	  , Mongos: __webpack_require__(/*! ./lib/topologies/mongos */ 117)
	  , Logger: __webpack_require__(/*! ./lib/connection/logger */ 85)
	  , Cursor: __webpack_require__(/*! ./lib/cursor */ 87)
	  , ReadPreference: __webpack_require__(/*! ./lib/topologies/read_preference */ 86)
	  , BSON: __webpack_require__(/*! bson */ 51)
	  // Raw operations
	  , Query: __webpack_require__(/*! ./lib/connection/commands */ 82).Query
	  // Auth mechanisms
	  , MongoCR: __webpack_require__(/*! ./lib/auth/mongocr */ 93)
	  , X509: __webpack_require__(/*! ./lib/auth/x509 */ 109)
	  , Plain: __webpack_require__(/*! ./lib/auth/plain */ 110)
	  , GSSAPI: __webpack_require__(/*! ./lib/auth/gssapi */ 111)
	}

/***/ },
/* 77 */
/*!**********************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/error.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	/**
	 * Creates a new MongoError
	 * @class
	 * @augments Error
	 * @param {string} message The error message
	 * @return {MongoError} A cursor instance
	 */
	function MongoError(message) {
	  this.name = 'MongoError';
	  this.message = message;
	  Error.captureStackTrace(this, MongoError);
	}
	
	/**
	 * Creates a new MongoError object
	 * @class
	 * @param {object} options The error options
	 * @return {MongoError} A cursor instance
	 */
	MongoError.create = function(options) {
	  var err = null;
	
	  if(options instanceof Error) {
	    err = new MongoError(options.message);
	    err.stack = options.stack;
	  } else if(typeof options == 'string') {
	    err = new MongoError(options);
	  } else {
	    err = new MongoError(options.message || options.errmsg || options.$err || "n/a");
	    // Other options
	    for(var name in options) {
	      err[name] = options[name];
	    }
	  }
	
	  return err;
	}
	
	// Extend JavaScript error
	MongoError.prototype = new Error; 
	
	module.exports = MongoError;


/***/ },
/* 78 */
/*!**********************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/topologies/server.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) { "use strict";
	
	var inherits = __webpack_require__(/*! util */ 57).inherits
	  , f = __webpack_require__(/*! util */ 57).format
	  , bindToCurrentDomain = __webpack_require__(/*! ../connection/utils */ 79).bindToCurrentDomain
	  , EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter
	  , Pool = __webpack_require__(/*! ../connection/pool */ 80)
	  , b = __webpack_require__(/*! bson */ 51)
	  , Query = __webpack_require__(/*! ../connection/commands */ 82).Query
	  , MongoError = __webpack_require__(/*! ../error */ 77)
	  , ReadPreference = __webpack_require__(/*! ./read_preference */ 86)
	  , BasicCursor = __webpack_require__(/*! ../cursor */ 87)
	  , CommandResult = __webpack_require__(/*! ./command_result */ 88)
	  , getSingleProperty = __webpack_require__(/*! ../connection/utils */ 79).getSingleProperty
	  , getProperty = __webpack_require__(/*! ../connection/utils */ 79).getProperty
	  , debugOptions = __webpack_require__(/*! ../connection/utils */ 79).debugOptions
	  , BSON = __webpack_require__(/*! bson */ 51).native().BSON
	  , PreTwoSixWireProtocolSupport = __webpack_require__(/*! ../wireprotocol/2_4_support */ 89)
	  , TwoSixWireProtocolSupport = __webpack_require__(/*! ../wireprotocol/2_6_support */ 91)
	  , Session = __webpack_require__(/*! ./session */ 92)
	  , Logger = __webpack_require__(/*! ../connection/logger */ 85)
	  , MongoCR = __webpack_require__(/*! ../auth/mongocr */ 93)
	  , X509 = __webpack_require__(/*! ../auth/x509 */ 109)
	  , Plain = __webpack_require__(/*! ../auth/plain */ 110)
	  , GSSAPI = __webpack_require__(/*! ../auth/gssapi */ 111)
	  , SSPI = __webpack_require__(/*! ../auth/sspi */ 112)
	  , ScramSHA1 = __webpack_require__(/*! ../auth/scram */ 113);
	
	/**
	 * @fileOverview The **Server** class is a class that represents a single server topology and is
	 * used to construct connections.
	 *
	 * @example
	 * var Server = require('mongodb-core').Server
	 *   , ReadPreference = require('mongodb-core').ReadPreference
	 *   , assert = require('assert');
	 *
	 * var server = new Server({host: 'localhost', port: 27017});
	 * // Wait for the connection event
	 * server.on('connect', function(server) {
	 *   server.destroy();
	 * });
	 *
	 * // Start connecting
	 * server.connect();
	 */
	
	// All bson types
	var bsonTypes = [b.Long, b.ObjectID, b.Binary, b.Code, b.DBRef, b.Symbol, b.Double, b.Timestamp, b.MaxKey, b.MinKey];
	// BSON parser
	var bsonInstance = null;
	// Server instance id
	var serverId = 0;
	// Callbacks instance id
	var callbackId = 0;
	
	// Single store for all callbacks
	var Callbacks = function() {
	  // EventEmitter.call(this);
	  var self = this;
	  // Callbacks
	  this.callbacks = {};
	  // Set the callbacks id
	  this.id = callbackId++;
	  // Set the type to server
	  this.type = 'server';
	}
	
	//
	// Clone the options
	var cloneOptions = function(options) {
	  var opts = {};
	  for(var name in options) {
	    opts[name] = options[name];
	  }
	  return opts;
	}
	
	//
	// Flush all callbacks
	Callbacks.prototype.flush = function(err) {
	  for(var id in this.callbacks) {
	    if(!isNaN(parseInt(id, 10))) {
	      var callback = this.callbacks[id];
	      delete this.callbacks[id];
	      callback(err, null);
	    }
	  }
	}
	
	Callbacks.prototype.emit = function(id, err, value) {
	  var callback = this.callbacks[id];
	  delete this.callbacks[id];
	  callback(err, value);
	}
	
	Callbacks.prototype.raw = function(id) {
	  if(this.callbacks[id] == null) return false;
	  return this.callbacks[id].raw == true ? true : false
	}
	
	Callbacks.prototype.unregister = function(id) {
	  delete this.callbacks[id];
	}
	
	Callbacks.prototype.register = function(id, callback) {
	  this.callbacks[id] = bindToCurrentDomain(callback);
	}
	
	/**
	 * @ignore
	 */
	var bindToCurrentDomain = function(callback) {
	  var domain = process.domain;
	  if(domain == null || callback == null) return callback;
	  return domain.bind(callback);
	}
	
	var DISCONNECTED = 'disconnected';
	var CONNECTING = 'connecting';
	var CONNECTED = 'connected';
	var DESTROYED = 'destroyed';
	
	// Supports server
	var supportsServer = function(_s) {
	  return _s.ismaster && typeof _s.ismaster.minWireVersion == 'number';
	}
	
	//
	// createWireProtocolHandler
	var createWireProtocolHandler = function(result) {
	  // 2.6 wire protocol handler
	  if(result && result.maxWireVersion >= 2) {
	    return new TwoSixWireProtocolSupport();
	  }
	
	  // 2.4 or earlier wire protocol handler
	  return new PreTwoSixWireProtocolSupport();
	}
	
	//
	// Reconnect server
	var reconnectServer = function(self, state) {
	  // If the current reconnect retries is 0 stop attempting to reconnect
	  if(state.currentReconnectRetry == 0) {
	    return self.destroy(true, true);
	  }
	
	  // Adjust the number of retries
	  state.currentReconnectRetry = state.currentReconnectRetry - 1;
	
	  // Connect and retrieve the ismaster
	  isMasterDiscovery(self, self.s.options, function(err, r) {
	    // Set status to connecting
	    state.state = CONNECTING;
	    // Create a new Pool
	    state.pool = new Pool(state.options);
	    // error handler
	    var reconnectErrorHandler = function(err) {
	      state.state = DISCONNECTED;
	      // Destroy the pool
	      state.pool.destroy();
	      // Adjust the number of retries
	      state.currentReconnectRetry = state.currentReconnectRetry - 1;
	      // No more retries
	      if(state.currentReconnectRetry <= 0) {
	        self.state = DESTROYED;
	        self.emit('error', f('failed to connect to %s:%s after %s retries', state.options.host, state.options.port, state.reconnectTries));
	      } else {
	        setTimeout(function() {
	          reconnectServer(self, state);
	        }, state.reconnectInterval);
	      }
	    }
	
	    //
	    // Attempt to connect
	    state.pool.once('connect', function() {
	      // Reset retries
	      state.currentReconnectRetry = state.reconnectTries;
	      
	      // Remove any non used handlers
	      var events = ['error', 'close', 'timeout', 'parseError'];
	      events.forEach(function(e) {
	        state.pool.removeAllListeners(e);
	      });
	
	      // Set connected state
	      state.state = CONNECTED;
	
	      // Add proper handlers
	      state.pool.once('error', reconnectErrorHandler);
	      state.pool.once('close', closeHandler(self, state));
	      state.pool.once('timeout', timeoutHandler(self, state));
	      state.pool.once('parseError', fatalErrorHandler(self, state));
	
	      // We need to ensure we have re-authenticated
	      var keys = Object.keys(state.authProviders);
	      if(keys.length == 0) return self.emit('reconnect', self);
	
	      // Execute all providers
	      var count = keys.length;
	      // Iterate over keys
	      for(var i = 0; i < keys.length; i++) {
	        state.authProviders[keys[i]].reauthenticate(self, state.pool, function(err, r) {
	          count = count - 1;
	          // We are done, emit reconnect event
	          if(count == 0) {
	            return self.emit('reconnect', self);
	          }
	        });
	      }
	    });
	
	    //
	    // Handle connection failure
	    state.pool.once('error', errorHandler(self, state));
	    state.pool.once('close', errorHandler(self, state));
	    state.pool.once('timeout', errorHandler(self, state));
	    state.pool.once('parseError', errorHandler(self, state));
	
	    // Connect pool
	    state.pool.connect();
	  });
	}
	
	//
	// Handlers
	var messageHandler = function(self, state) {
	  return function(response, connection) {
	    try {
	      // Parse the message
	      response.parse({raw: state.callbacks.raw(response.responseTo)});
	      if(state.logger.isDebug()) state.logger.debug(f('message [%s] received from %s', response.raw.toString('hex'), self.name));
	      state.callbacks.emit(response.responseTo, null, response);
	    } catch (err) {
	      state.callbacks.flush(new MongoError(err));
	      self.destroy();
	    }
	  }
	}
	
	var errorHandler = function(self, state) {
	  return function(err, connection) {
	    if(state.state == DISCONNECTED || state.state == DESTROYED) return;
	    // Set disconnected state
	    state.state = DISCONNECTED;
	    if(state.readPreferenceStrategies != null) notifyStrategies(self, self.s, 'error', [self]);
	    if(state.logger.isInfo()) state.logger.info(f('server %s errored out with %s', self.name, JSON.stringify(err)));
	    // Flush out all the callbacks
	    if(state.callbacks) state.callbacks.flush(new MongoError(f("server %s received an error %s", self.name, JSON.stringify(err))));
	    // Destroy all connections
	    self.destroy();
	    // Emit error event
	    if(state.emitError && self.listeners('error').length > 0) self.emit('error', err, self);
	    // If we specified the driver to reconnect perform it
	    if(state.reconnect) setTimeout(function() {
	      // state.currentReconnectRetry = state.reconnectTries,
	      reconnectServer(self, state)
	    }, state.reconnectInterval);
	  }
	}
	
	var fatalErrorHandler = function(self, state) {
	  return function(err, connection) {
	    if(state.state == DISCONNECTED || state.state == DESTROYED) return;
	    // Set disconnected state
	    state.state = DISCONNECTED;
	
	    if(state.readPreferenceStrategies != null) notifyStrategies(self, self.s, 'error', [self]);
	    if(state.logger.isInfo()) state.logger.info(f('server %s errored out with %s', self.name, JSON.stringify(err)));
	    // Flush out all the callbacks
	    if(state.callbacks) state.callbacks.flush(new MongoError(f("server %s received an error %s", self.name, JSON.stringify(err))));
	    // Emit error event
	    self.emit('error', err, self);
	    // If we specified the driver to reconnect perform it
	    if(state.reconnect) setTimeout(function() {
	      // state.currentReconnectRetry = state.reconnectTries,
	      reconnectServer(self, state)
	    }, state.reconnectInterval);
	    // Destroy all connections
	    self.destroy();
	  }
	}
	
	var timeoutHandler = function(self, state) {
	  return function(err, connection) {
	    if(state.state == DISCONNECTED || state.state == DESTROYED) return;
	    // Set disconnected state
	    state.state = DISCONNECTED;
	
	    if(state.readPreferenceStrategies != null) notifyStrategies(self, self.s, 'timeout', [self]);
	    if(state.logger.isInfo()) state.logger.info(f('server %s timed out', self.name));
	    // Flush out all the callbacks
	    if(state.callbacks) state.callbacks.flush(new MongoError(f("server %s timed out", self.name)));
	    // Emit error event
	    self.emit('timeout', err, self);
	    // If we specified the driver to reconnect perform it
	    if(state.reconnect) setTimeout(function() {
	      // state.currentReconnectRetry = state.reconnectTries,
	      reconnectServer(self, state)
	    }, state.reconnectInterval);
	    // Destroy all connections
	    self.destroy();
	  }
	}
	
	var closeHandler = function(self, state) {
	  return function(err, connection) {
	    if(state.state == DISCONNECTED || state.state == DESTROYED) return;
	    // Set disconnected state
	    state.state = DISCONNECTED;
	
	    if(state.readPreferenceStrategies != null) notifyStrategies(self, self.s, 'close', [self]);
	    if(state.logger.isInfo()) state.logger.info(f('server %s closed', self.name));
	    // Flush out all the callbacks
	    if(state.callbacks) state.callbacks.flush(new MongoError(f("server %s sockets closed", self.name)));
	    // Emit error event
	    self.emit('close', err, self);
	    // If we specified the driver to reconnect perform it
	    if(state.reconnect) setTimeout(function() {
	      // state.currentReconnectRetry = state.reconnectTries,
	      reconnectServer(self, state)
	    }, state.reconnectInterval);
	    // Destroy all connections
	    self.destroy();
	  }
	}
	
	var connectHandler = function(self, state) {
	  // Apply all stored authentications
	  var applyAuthentications = function(callback) {
	    // We need to ensure we have re-authenticated
	    var keys = Object.keys(state.authProviders);
	    if(keys.length == 0) return callback(null, null);
	
	    // Execute all providers
	    var count = keys.length;
	    // Iterate over keys
	    for(var i = 0; i < keys.length; i++) {
	      state.authProviders[keys[i]].reauthenticate(self, state.pool, function(err, r) {
	        count = count - 1;
	        // We are done, emit reconnect event
	        if(count == 0) {
	          return callback(null, null);
	        }
	      });
	    }
	  }
	
	  return function(connection) {
	    // Apply any applyAuthentications
	    applyAuthentications(function() {
	
	      // Execute an ismaster
	      self.command('system.$cmd', {ismaster:true}, function(err, r) {
	        if(err) {
	          state.state = DISCONNECTED;
	          return self.emit('close', err, self);
	        }
	
	        // Set the current ismaster
	        if(!err) {
	          state.ismaster = r.result;
	        }
	
	        // Determine the wire protocol handler
	        state.wireProtocolHandler = createWireProtocolHandler(state.ismaster);
	
	        // Set the wireProtocolHandler
	        state.options.wireProtocolHandler = state.wireProtocolHandler;
	
	        // Log the ismaster if available
	        if(state.logger.isInfo()) state.logger.info(f('server %s connected with ismaster [%s]', self.name, JSON.stringify(r.result)));
	
	        // Validate if we it's a server we can connect to
	        if(!supportsServer(state) && state.wireProtocolHandler == null) {
	          state.state = DISCONNECTED
	          return self.emit('error', new MongoError("non supported server version"), self);
	        }
	
	        // Set the details
	        if(state.ismaster && state.ismaster.me) state.serverDetails.name = state.ismaster.me;
	
	        // No read preference strategies just emit connect
	        if(state.readPreferenceStrategies == null) {
	          state.state = CONNECTED;
	          return self.emit('connect', self);
	        }
	
	        // Signal connect to all readPreferences
	        notifyStrategies(self, self.s, 'connect', [self], function(err, result) {
	          state.state = CONNECTED;
	          return self.emit('connect', self);
	        });
	      });
	    });
	  }
	}
	
	var slaveOk = function(r) {
	  if(r) return r.slaveOk()
	  return false;
	}
	
	//
	// Execute readPreference Strategies
	var notifyStrategies = function(self, state, op, params, callback) {
	  if(typeof callback != 'function') {
	    // Notify query start to any read Preference strategies
	    for(var name in state.readPreferenceStrategies) {
	      if(state.readPreferenceStrategies[name][op]) {
	        var strat = state.readPreferenceStrategies[name];
	        strat[op].apply(strat, params);
	      }
	    }
	    // Finish up
	    return;
	  }
	
	  // Execute the async callbacks
	  var nPreferences = Object.keys(state.readPreferenceStrategies).length;
	  if(nPreferences == 0) return callback(null, null);
	  for(var name in state.readPreferenceStrategies) {
	    if(state.readPreferenceStrategies[name][op]) {
	      var strat = state.readPreferenceStrategies[name];
	      // Add a callback to params
	      var cParams = params.slice(0);
	      cParams.push(function(err, r) {
	        nPreferences = nPreferences - 1;
	        if(nPreferences == 0) {
	          callback(null, null);
	        }
	      })
	      // Execute the readPreference
	      strat[op].apply(strat, cParams);
	    }
	  }
	}
	
	var debugFields = ['reconnect', 'reconnectTries', 'reconnectInterval', 'emitError', 'cursorFactory', 'host'
	  , 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout'
	  , 'socketTimeout', 'singleBufferSerializtion', 'ssl', 'ca', 'cert', 'key', 'rejectUnauthorized', 'promoteLongs'];
	
	/**
	 * Creates a new Server instance
	 * @class
	 * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection
	 * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times
	 * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries
	 * @param {boolean} [options.emitError=false] Server will emit errors events
	 * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors
	 * @param {string} options.host The server host
	 * @param {number} options.port The server port
	 * @param {number} [options.size=5] Server connection pool size
	 * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled
	 * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled
	 * @param {boolean} [options.noDelay=true] TCP Connection no delay
	 * @param {number} [options.connectionTimeout=0] TCP Connection timeout setting
	 * @param {number} [options.socketTimeout=0] TCP Socket timeout setting
	 * @param {boolean} [options.ssl=false] Use SSL for connection
	 * @param {Buffer} [options.ca] SSL Certificate store binary buffer
	 * @param {Buffer} [options.cert] SSL Certificate binary buffer
	 * @param {Buffer} [options.key] SSL Key file binary buffer
	 * @param {string} [options.passphrase] SSL Certificate pass phrase
	 * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates
	 * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
	 * @return {Server} A cursor instance
	 * @fires Server#connect
	 * @fires Server#close
	 * @fires Server#error
	 * @fires Server#timeout
	 * @fires Server#parseError
	 * @fires Server#reconnect
	 */
	var Server = function(options) {
	  var self = this;
	
	  // Add event listener
	  EventEmitter.call(this);
	
	  // BSON Parser, ensure we have a single instance
	  if(bsonInstance == null) {
	    bsonInstance = new BSON(bsonTypes);
	  }
	
	  // Reconnect retries
	  var reconnectTries = options.reconnectTries || 30;
	
	  // Keeps all the internal state of the server
	  this.s = {
	    // Options
	      options: options
	    // Contains all the callbacks
	    , callbacks: new Callbacks()
	    // Logger
	    , logger: Logger('Server', options)
	    // Server state
	    , state: DISCONNECTED
	    // Reconnect option
	    , reconnect: typeof options.reconnect == 'boolean' ? options.reconnect :  true
	    , reconnectTries: reconnectTries
	    , reconnectInterval: options.reconnectInterval || 1000
	    // Swallow or emit errors
	    , emitError: typeof options.emitError == 'boolean' ? options.emitError : false
	    // Current state
	    , currentReconnectRetry: reconnectTries
	    // Contains the ismaster
	    , ismaster: null
	    // Contains any alternate strategies for picking
	    , readPreferenceStrategies: options.readPreferenceStrategies
	    // Auth providers
	    , authProviders: options.authProviders || {}
	    // Server instance id
	    , id: serverId++
	    // Grouping tag used for debugging purposes
	    , tag: options.tag
	    // Do we have a not connected handler
	    , disconnectHandler: options.disconnectHandler
	    // wireProtocolHandler methods
	    , wireProtocolHandler: options.wireProtocolHandler || new PreTwoSixWireProtocolSupport()
	    // Factory overrides
	    , Cursor: options.cursorFactory || BasicCursor
	    // BSON Parser, ensure we have a single instance
	    , bsonInstance: bsonInstance
	    // Pick the right bson parser
	    , bson: options.bson ? options.bson : bsonInstance
	    // Internal connection pool
	    , pool: null
	    // Server details
	    , serverDetails: {
	        host: options.host
	      , port: options.port
	      , name: options.port ? f("%s:%s", options.host, options.port) : options.host
	    }
	  }
	
	  // Reference state
	  var s = this.s;
	
	  // Add bson parser to options
	  options.bson = s.bson;
	
	  // Set error properties
	  getProperty(this, 'name', 'name', s.serverDetails, {});
	  getProperty(this, 'bson', 'bson', s.options, {});
	  getProperty(this, 'wireProtocolHandler', 'wireProtocolHandler', s.options, {});
	  getSingleProperty(this, 'id', s.id);
	
	  // Add auth providers
	  this.addAuthProvider('mongocr', new MongoCR());
	  this.addAuthProvider('x509', new X509());
	  this.addAuthProvider('plain', new Plain());
	  this.addAuthProvider('gssapi', new GSSAPI());
	  this.addAuthProvider('sspi', new SSPI());
	  this.addAuthProvider('scram-sha-1', new ScramSHA1());
	}
	
	inherits(Server, EventEmitter);
	
	/**
	 * Execute a command
	 * @method
	 * @param {string} type Type of BSON parser to use (c++ or js)
	 */
	Server.prototype.setBSONParserType = function(type) {
	  var nBSON = null;
	
	  if(type == 'c++') {
	    nBSON = __webpack_require__(/*! bson */ 51).native().BSON;
	  } else if(type == 'js') {
	    nBSON = __webpack_require__(/*! bson */ 51).pure().BSON;
	  } else {
	    throw new MongoError(f("% parser not supported", type));
	  }
	
	  this.s.options.bson = new nBSON(bsonTypes);
	}
	
	/**
	 * Returns the last known ismaster document for this server
	 * @method
	 * @return {object}
	 */
	Server.prototype.lastIsMaster = function() {
	  return this.s.ismaster;
	}
	
	var isMasterDiscovery = function(self, options, callback) {
	  if(options.noismaster) return callback();
	  // Clone the options
	  var options = cloneOptions(options);
	  // Set the pool size to a single socket
	  options.size = 1;
	  options.noismaster = true;
	  // Create a new server instance
	  var server = new Server(options)  
	  
	  // Add handlers
	  server.on('connect', function(_server) {
	    // Remove all listeners
	    _server.removeAllListeners('close');
	    _server.removeAllListeners('error');
	    _server.removeAllListeners('timeout');
	    _server.removeAllListeners('parseError');
	    // Destroy socket
	    _server.destroy();
	    // Return lastIsMaster for this server
	    callback(null, _server.lastIsMaster());
	  });
	
	  // Handle all errors
	  var errorHandler = function() {
	    if(callback) {
	      var _internalCallback = callback;
	      callback = null;
	      _internalCallback();
	    }
	  }
	
	  // Intercept all the errors
	  server.on('close', errorHandler);
	  server.on('error', errorHandler);
	  server.on('timeout', errorHandler);
	  server.on('parseError', errorHandler);
	
	  // Connect
	  server.connect();
	}
	
	/**
	 * Initiate server connect
	 * @method
	 */
	Server.prototype.connect = function(_options) {
	  var self = this;
	  // Set server specific settings
	  _options = _options || {}
	  // Set the promotion
	  if(typeof _options.promoteLongs == 'boolean')  {
	    self.s.options.promoteLongs = _options.promoteLongs;
	  }
	
	  // Connect and retrieve the ismaster
	  isMasterDiscovery(self, self.s.options, function(err, r) {
	    // If we have an ismaster
	    if(r) {
	      self.emit('ismaster', r, self);
	    }
	
	    // Destroy existing pool
	    if(self.s.pool) {
	      self.s.pool.destroy();
	      self.s.pool = null;
	    }
	
	    // Set the state to connection
	    self.s.state = CONNECTING;
	    // Create a new connection pool
	    if(!self.s.pool) {
	      self.s.options.messageHandler = messageHandler(self, self.s);
	      self.s.pool = new Pool(self.s.options);
	    }
	
	    // Add all the event handlers
	    self.s.pool.once('timeout', timeoutHandler(self, self.s));
	    self.s.pool.once('close', closeHandler(self, self.s));
	    self.s.pool.once('error', errorHandler(self, self.s));
	    self.s.pool.once('connect', connectHandler(self, self.s));
	    self.s.pool.once('parseError', fatalErrorHandler(self, self.s));
	
	    // Connect the pool
	    self.s.pool.connect();
	  });
	}
	
	/**
	 * Destroy the server connection
	 * @method
	 */
	Server.prototype.destroy = function(emitClose, emitDestroy) {
	  var self = this;
	  if(self.s.logger.isDebug()) self.s.logger.debug(f('destroy called on server %s', self.name));
	  // Emit close
	  if(emitClose && self.listeners('close').length > 0) self.emit('close', self);
	
	  // Emit destroy event
	  if(emitDestroy) self.emit('destroy', self);
	  // Set state as destroyed
	  self.s.state = DESTROYED;
	  // Close the pool
	  self.s.pool.destroy();
	  // Flush out all the callbacks
	  if(self.s.callbacks) self.s.callbacks.flush(new MongoError(f("server %s sockets closed", self.name)));
	}
	
	/**
	 * Figure out if the server is connected
	 * @method
	 * @return {boolean}
	 */
	Server.prototype.isConnected = function() {
	  var self = this;
	  if(self.s.pool) return self.s.pool.isConnected();
	  return false;
	}
	
	/**
	 * Figure out if the server instance was destroyed by calling destroy
	 * @method
	 * @return {boolean}
	 */
	Server.prototype.isDestroyed = function() {
	  return this.s.state == DESTROYED;
	}
	
	var executeSingleOperation = function(self, ns, cmd, queryOptions, options, onAll, callback) {
	  // Create a query instance
	  var query = new Query(self.s.bson, ns, cmd, queryOptions);
	
	  // Set slave OK
	  query.slaveOk = slaveOk(options.readPreference);
	
	  // Notify query start to any read Preference strategies
	  if(self.s.readPreferenceStrategies != null)
	    notifyStrategies(self, self.s, 'startOperation', [self, query, new Date()]);
	
	  // Get a connection (either passed or from the pool)
	  var connection = options.connection || self.s.pool.get();
	
	  // Double check if we have a valid connection
	  if(!connection.isConnected()) {
	    return callback(new MongoError(f("no connection available to server %s", self.name)));
	  }
	
	  // Print cmd and execution connection if in debug mode for logging
	  if(self.s.logger.isDebug()) {
	    var json = connection.toJSON();
	    self.s.logger.debug(f('cmd [%s] about to be executed on connection with id %s at %s:%s', JSON.stringify(cmd), json.id, json.host, json.port));
	  }
	
	  // Execute multiple queries
	  if(onAll) {
	    var connections = self.s.pool.getAll();
	    var total = connections.length;
	    // We have an error
	    var error = null;
	    // Execute on all connections
	    for(var i = 0; i < connections.length; i++) {
	      try {
	        query.incRequestId();
	        connections[i].write(query.toBin());
	      } catch(err) {
	        total = total - 1;
	        if(total == 0) return callback(MongoError.create(err));
	      }
	
	      // Register the callback
	      self.s.callbacks.register(query.requestId, function(err, result) {
	        if(err) error = err;
	        total = total - 1;
	
	        // Done
	        if(total == 0) {
	          // Notify end of command
	          notifyStrategies(self, self.s, 'endOperation', [self, error, result, new Date()]);
	          if(error) return callback(MongoError.create(error));
	          // Execute callback, catch and rethrow if needed
	          try { callback(null, new CommandResult(result.documents[0], connections)); }
	          catch(err) { process.nextTick(function() { throw err}); }
	        }
	      });
	    }
	
	    return;
	  }
	
	  // Execute a single command query
	  try {
	    connection.write(query.toBin());
	  } catch(err) {
	    return callback(MongoError.create(err));
	  }
	
	  // Register the callback
	  self.s.callbacks.register(query.requestId, function(err, result) {
	    // Notify end of command
	    notifyStrategies(self, self.s, 'endOperation', [self, err, result, new Date()]);
	    if(err) return callback(err);
	    if(result.documents[0]['$err']
	      || result.documents[0]['errmsg']
	      || result.documents[0]['err']
	      || result.documents[0]['code']) return callback(MongoError.create(result.documents[0]));
	      // Execute callback, catch and rethrow if needed
	      try { callback(null, new CommandResult(result.documents[0], connection)); }
	      catch(err) { process.nextTick(function() { throw err}); }
	  });  
	}
	
	/**
	 * Execute a command
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {object} cmd The command hash
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {Connection} [options.connection] Specify connection object to execute command against
	 * @param {opResultCallback} callback A callback function
	 */
	Server.prototype.command = function(ns, cmd, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  var self = this;
	  if(this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Ensure we have no options
	  options = options || {};
	  // Do we have a read Preference it need to be of type ReadPreference
	  if(options.readPreference && !(options.readPreference instanceof ReadPreference)) {
	    throw new Error("readPreference must be an instance of ReadPreference");
	  }
	
	  // Debug log
	  if(self.s.logger.isDebug()) self.s.logger.debug(f('executing command [%s] against %s', JSON.stringify({
	    ns: ns, cmd: cmd, options: debugOptions(debugFields, options)
	  }), self.name));
	
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!self.isConnected() && self.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return self.s.disconnectHandler.add('command', ns, cmd, options, callback);
	  }
	
	  // If we have no connection error
	  if(!self.s.pool.isConnected()) return callback(new MongoError(f("no connection available to server %s", self.name)));
	
	  // Execute on all connections
	  var onAll = typeof options.onAll == 'boolean' ? options.onAll : false;
	
	  // Check keys
	  var checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys: false;
	
	  // Serialize function
	  var serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
	
	  // Query options
	  var queryOptions = {
	    numberToSkip: 0, numberToReturn: -1, checkKeys: checkKeys
	  };
	
	  if(serializeFunctions) queryOptions.serializeFunctions = serializeFunctions;
	
	  // Single operation execution
	  if(!Array.isArray(cmd)) {
	    return executeSingleOperation(self, ns, cmd, queryOptions, options, onAll, callback);    
	  }
	
	  // Build commands for each of the instances
	  var queries = new Array(cmd.length);
	  for(var i = 0; i < cmd.length; i++) {
	    queries[i] = new Query(self.s.bson, ns, cmd[i], queryOptions);
	    queries[i].slaveOk = slaveOk(options.readPreference);
	  }
	
	  // Notify query start to any read Preference strategies
	  if(self.s.readPreferenceStrategies != null)
	    notifyStrategies(self, self.s, 'startOperation', [self, queries, new Date()]);
	
	  // Get a connection (either passed or from the pool)
	  var connection = options.connection || self.s.pool.get();
	
	  // Double check if we have a valid connection
	  if(!connection.isConnected()) {
	    return callback(new MongoError(f("no connection available to server %s", self.name)));
	  }
	
	  // Print cmd and execution connection if in debug mode for logging
	  if(self.s.logger.isDebug()) {
	    var json = connection.toJSON();
	    self.s.logger.debug(f('cmd [%s] about to be executed on connection with id %s at %s:%s', JSON.stringify(queries), json.id, json.host, json.port));
	  }
	
	  // Canceled operations
	  var canceled = false;
	  // Number of operations left
	  var operationsLeft = queries.length;
	  // Results
	  var results = [];
	
	  // We need to nest the callbacks
	  for(var i = 0; i < queries.length; i++) {
	    // Get the query object
	    var query = queries[i];
	    
	    // Execute a single command query
	    try {
	      connection.write(query.toBin());
	    } catch(err) {
	      return callback(MongoError.create(err));
	    }    
	
	    // Register the callback
	    self.s.callbacks.register(query.requestId, function(err, result) {
	      // If it's canceled ignore the operation
	      if(canceled) return;
	      // Update the current index
	      operationsLeft = operationsLeft - 1;
	      
	      // If we have an error cancel the operation
	      if(err) {
	        canceled = true;
	        return callback(err);
	      }
	
	      // Return the result
	      if(result.documents[0]['$err']
	        || result.documents[0]['errmsg']
	        || result.documents[0]['err']
	        || result.documents[0]['code']) {
	
	        // Set to canceled
	        canceled = true;
	        // Return the error
	        return callback(MongoError.create(result.documents[0]));
	      }
	
	      // Push results
	      results.push(result.documents[0]);
	
	      // We are done, return the result
	      if(operationsLeft == 0) {
	        // Notify end of command
	        notifyStrategies(self, self.s, 'endOperation', [self, err, result, new Date()]);
	
	        // Turn into command results
	        var commandResults = new Array(results.length);
	        for(var i = 0; i < results.length; i++) {
	          commandResults[i] = new CommandResult(results[i], connection); 
	        }
	
	        // Execute callback, catch and rethrow if needed
	        try { callback(null, commandResults); }
	        catch(err) { process.nextTick(function() { throw err}); }
	      }
	    });
	  }
	}
	
	/**
	 * Insert one or more documents
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of documents to insert
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {opResultCallback} callback A callback function
	 */
	Server.prototype.insert = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  var self = this;
	  if(this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!self.isConnected() && self.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return self.s.disconnectHandler.add('insert', ns, ops, options, callback);
	  }
	
	  // Setup the docs as an array
	  ops = Array.isArray(ops) ? ops : [ops];
	  // Execute write
	  return self.s.wireProtocolHandler.insert(self, self.s.ismaster, ns, self.s.bson, self.s.pool, self.s.callbacks, ops, options, callback);
	}
	
	/**
	 * Perform one or more update operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of updates
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {opResultCallback} callback A callback function
	 */
	Server.prototype.update = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  var self = this;
	  if(this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!self.isConnected() && self.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return self.s.disconnectHandler.add('update', ns, ops, options, callback);
	  }
	
	  // Setup the docs as an array
	  ops = Array.isArray(ops) ? ops : [ops];
	  // Execute write
	  return self.s.wireProtocolHandler.update(self, self.s.ismaster, ns, self.s.bson, self.s.pool, self.s.callbacks, ops, options, callback);
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of removes
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {opResultCallback} callback A callback function
	 */
	Server.prototype.remove = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  var self = this;
	  if(this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!self.isConnected() && self.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return self.s.disconnectHandler.add('remove', ns, ops, options, callback);
	  }
	
	  // Setup the docs as an array
	  ops = Array.isArray(ops) ? ops : [ops];
	  // Execute write
	  return self.s.wireProtocolHandler.remove(self, self.s.ismaster, ns, self.s.bson, self.s.pool, self.s.callbacks, ops, options, callback);
	}
	
	/**
	 * Authenticate using a specified mechanism
	 * @method
	 * @param {string} mechanism The Auth mechanism we are invoking
	 * @param {string} db The db we are invoking the mechanism against
	 * @param {...object} param Parameters for the specific mechanism
	 * @param {authResultCallback} callback A callback function
	 */
	Server.prototype.auth = function(mechanism, db) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  var callback = args.pop();
	
	  // If we don't have the mechanism fail
	  if(self.s.authProviders[mechanism] == null && mechanism != 'default')
	    throw new MongoError(f("auth provider %s does not exist", mechanism));
	
	  // If we have the default mechanism we pick mechanism based on the wire
	  // protocol max version. If it's >= 3 then scram-sha1 otherwise mongodb-cr
	  if(mechanism == 'default' && self.s.ismaster && self.s.ismaster.maxWireVersion >= 3) {
	    mechanism = 'scram-sha-1';
	  } else if(mechanism == 'default') {
	    mechanism = 'mongocr';
	  }
	
	  // Actual arguments
	  var finalArguments = [self, self.s.pool, db].concat(args.slice(0)).concat([function(err, r) {
	    if(err) return callback(err);
	    if(!r) return callback(new MongoError('could not authenticate'));
	    callback(null, new Session({}, self));
	  }]);
	
	  // Let's invoke the auth mechanism
	  self.s.authProviders[mechanism].auth.apply(self.s.authProviders[mechanism], finalArguments);
	}
	
	//
	// Plugin methods
	//
	
	/**
	 * Add custom read preference strategy
	 * @method
	 * @param {string} name Name of the read preference strategy
	 * @param {object} strategy Strategy object instance
	 */
	Server.prototype.addReadPreferenceStrategy = function(name, strategy) {
	  var self = this;
	  if(self.s.readPreferenceStrategies == null) self.s.readPreferenceStrategies = {};
	  self.s.readPreferenceStrategies[name] = strategy;
	}
	
	/**
	 * Add custom authentication mechanism
	 * @method
	 * @param {string} name Name of the authentication mechanism
	 * @param {object} provider Authentication object instance
	 */
	Server.prototype.addAuthProvider = function(name, provider) {
	  var self = this;
	  self.s.authProviders[name] = provider;
	}
	
	/**
	 * Compare two server instances
	 * @method
	 * @param {Server} server Server to compare equality against
	 * @return {boolean}
	 */
	Server.prototype.equals = function(server) {
	  if(typeof server == 'string') return server == this.name;
	  return server.name == this.name;
	}
	
	/**
	 * All raw connections
	 * @method
	 * @return {Connection[]}
	 */
	Server.prototype.connections = function() {
	  return this.s.pool.getAll();
	}
	
	/**
	 * Get server
	 * @method
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @return {Server}
	 */
	Server.prototype.getServer = function(options) {
	  return this;
	}
	
	/**
	 * Get connection
	 * @method
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @return {Connection}
	 */
	Server.prototype.getConnection = function(options) {
	  return this.s.pool.get();
	}
	
	/**
	 * Get callbacks object
	 * @method
	 * @return {Callbacks}
	 */
	Server.prototype.getCallbacks = function() {
	  return this.s.callbacks;
	}
	
	/**
	 * Name of BSON parser currently used
	 * @method
	 * @return {string}
	 */
	Server.prototype.parserType = function() {
	  var s = this.s;
	  if(s.options.bson.serialize.toString().indexOf('[native code]') != -1)
	    return 'c++';
	  return 'js';
	}
	
	// // Command
	// {
	//     find: ns
	//   , query: <object>
	//   , limit: <n>
	//   , fields: <object>
	//   , skip: <n>
	//   , hint: <string>
	//   , explain: <boolean>
	//   , snapshot: <boolean>
	//   , batchSize: <n>
	//   , returnKey: <boolean>
	//   , maxScan: <n>
	//   , min: <n>
	//   , max: <n>
	//   , showDiskLoc: <boolean>
	//   , comment: <string>
	//   , maxTimeMS: <n>
	//   , raw: <boolean>
	//   , readPreference: <ReadPreference>
	//   , tailable: <boolean>
	//   , oplogReplay: <boolean>
	//   , noCursorTimeout: <boolean>
	//   , awaitdata: <boolean>
	//   , exhaust: <boolean>
	//   , partial: <boolean>
	// }
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {{object}|{Long}} cmd Can be either a command returning a cursor or a cursorId
	 * @param {object} [options.batchSize=0] Batchsize for the operation
	 * @param {array} [options.documents=[]] Initial documents list for cursor
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {opResultCallback} callback A callback function
	 */
	Server.prototype.cursor = function(ns, cmd, cursorOptions) {
	  var s = this.s;
	  cursorOptions = cursorOptions || {};
	  var FinalCursor = cursorOptions.cursorFactory || s.Cursor;
	  return new FinalCursor(s.bson, ns, cmd, cursorOptions, this, s.options);
	}
	
	/**
	 * A server connect event, used to verify that the connection is up and running
	 *
	 * @event Server#connect
	 * @type {Server}
	 */
	
	/**
	 * The server connection closed, all pool connections closed
	 *
	 * @event Server#close
	 * @type {Server}
	 */
	
	/**
	 * The server connection caused an error, all pool connections closed
	 *
	 * @event Server#error
	 * @type {Server}
	 */
	
	/**
	 * The server connection timed out, all pool connections closed
	 *
	 * @event Server#timeout
	 * @type {Server}
	 */
	
	/**
	 * The driver experienced an invalid message, all pool connections closed
	 *
	 * @event Server#parseError
	 * @type {Server}
	 */
	
	/**
	 * The server reestablished the connection
	 *
	 * @event Server#reconnect
	 * @type {Server}
	 */
	
	/**
	 * This is an insert result callback
	 *
	 * @callback opResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {CommandResult} command result
	 */
	
	/**
	 * This is an authentication result callback
	 *
	 * @callback authResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {Session} an authenticated session
	 */
	
	module.exports = Server;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 79 */
/*!*********************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/connection/utils.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	// Set property function
	var setProperty = function(obj, prop, flag, values) {
	  Object.defineProperty(obj, prop.name, {
	      enumerable:true,
	      set: function(value) {
	        if(typeof value != 'boolean') throw new Error(f("%s required a boolean", prop.name));
	        // Flip the bit to 1
	        if(value == true) values.flags |= flag;        
	        // Flip the bit to 0 if it's set, otherwise ignore
	        if(value == false && (values.flags & flag) == flag) values.flags ^= flag;
	        prop.value = value;
	      }
	    , get: function() { return prop.value; }
	  });
	}
	
	// Set property function
	var getProperty = function(obj, propName, fieldName, values, func) {
	  Object.defineProperty(obj, propName, {
	    enumerable:true,
	    get: function() { 
	      // Not parsed yet, parse it
	      if(values[fieldName] == null && obj.isParsed && !obj.isParsed()) {
	        obj.parse();
	      }
	
	      // Do we have a post processing function
	      if(typeof func == 'function') return func(values[fieldName]);
	      // Return raw value
	      return values[fieldName];
	    }
	  });
	}
	
	// Set simple property
	var getSingleProperty = function(obj, name, value) {
	  Object.defineProperty(obj, name, {
	    enumerable:true,
	    get: function() {
	      return value 
	    }
	  });  
	}
	
	// Shallow copy
	var copy = function(fObj, tObj) {
	  tObj = tObj || {};
	  for(var name in fObj) tObj[name] = fObj[name];
	  return tObj;
	}
	
	var debugOptions = function(debugFields, options) {
	  var finaloptions = {};
	  debugFields.forEach(function(n) {
	    finaloptions[n] = options[n];
	  });
	
	  return finaloptions;
	}
	
	/**
	 * @ignore
	 */
	var bindToCurrentDomain = function(callback) {
	  var domain = process.domain;
	  if(domain == null || callback == null) return callback;
	  return domain.bind(callback);
	}
	
	exports.setProperty = setProperty;
	exports.getProperty = getProperty;
	exports.getSingleProperty = getSingleProperty;
	exports.copy = copy;
	exports.bindToCurrentDomain = bindToCurrentDomain;
	exports.debugOptions = debugOptions;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 80 */
/*!********************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/connection/pool.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, process) {"use strict";
	
	var inherits = __webpack_require__(/*! util */ 57).inherits
	  , EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter
	  , Connection = __webpack_require__(/*! ./connection */ 83)
	  , Query = __webpack_require__(/*! ./commands */ 82).Query
	  , Logger = __webpack_require__(/*! ./logger */ 85)
	  , f = __webpack_require__(/*! util */ 57).format;
	
	var DISCONNECTED = 'disconnected';
	var CONNECTING = 'connecting';
	var CONNECTED = 'connected';
	var DESTROYED = 'destroyed';
	
	var _id = 0;
	
	/**
	 * Creates a new Pool instance
	 * @class
	 * @param {string} options.host The server host
	 * @param {number} options.port The server port
	 * @param {number} [options.size=5] Server connection pool size
	 * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled
	 * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled
	 * @param {boolean} [options.noDelay=true] TCP Connection no delay
	 * @param {number} [options.connectionTimeout=0] TCP Connection timeout setting
	 * @param {number} [options.socketTimeout=0] TCP Socket timeout setting
	 * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed
	 * @param {boolean} [options.ssl=false] Use SSL for connection
	 * @param {Buffer} [options.ca] SSL Certificate store binary buffer
	 * @param {Buffer} [options.cert] SSL Certificate binary buffer
	 * @param {Buffer} [options.key] SSL Key file binary buffer
	 * @param {string} [options.passPhrase] SSL Certificate pass phrase
	 * @param {boolean} [options.rejectUnauthorized=false] Reject unauthorized server certificates
	 * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
	 * @fires Pool#connect
	 * @fires Pool#close
	 * @fires Pool#error
	 * @fires Pool#timeout
	 * @fires Pool#parseError
	 * @return {Pool} A cursor instance
	 */
	var Pool = function(options) {
	  var self = this;
	  // Add event listener
	  EventEmitter.call(this);
	  // Set empty if no options passed
	  this.options = options || {};
	  this.size = typeof options.size == 'number' ? options.size : 5;  
	  // Message handler
	  this.messageHandler = options.messageHandler;
	  // No bson parser passed in
	  if(!options.bson) throw new Error("must pass in valid bson parser");
	  // Contains all connections
	  this.connections = [];
	  this.state = DISCONNECTED;
	  // Round robin index
	  this.index = 0;
	  this.dead = false;
	  // Logger instance
	  this.logger = Logger('Pool', options);
	  // Pool id
	  this.id = _id++;
	  // Grouping tag used for debugging purposes
	  this.tag = options.tag;
	}
	
	inherits(Pool, EventEmitter);
	
	var errorHandler = function(self) {
	  return function(err, connection) {
	    if(self.logger.isDebug()) self.logger.debug(f('pool [%s] errored out [%s] with connection [%s]', this.dead, JSON.stringify(err), JSON.stringify(connection)));
	    if(!self.dead) {
	      self.state = DISCONNECTED;
	      self.dead = true;
	      self.destroy();
	      self.emit('error', err, self);
	    }
	  }
	}
	
	var timeoutHandler = function(self) {
	  return function(err, connection) {
	    if(self.logger.isDebug()) self.logger.debug(f('pool [%s] timedout out [%s] with connection [%s]', this.dead, JSON.stringify(err), JSON.stringify(connection)));
	    if(!self.dead) {
	      self.state = DISCONNECTED;
	      self.dead = true;
	      self.destroy();
	      self.emit('timeout', err, self);
	    }
	  }
	}
	
	var closeHandler = function(self) {
	  return function(err, connection) {
	    if(self.logger.isDebug()) self.logger.debug(f('pool [%s] closed [%s] with connection [%s]', this.dead, JSON.stringify(err), JSON.stringify(connection)));
	    if(!self.dead) {
	      self.state = DISCONNECTED;
	      self.dead = true;
	      self.destroy();
	      self.emit('close', err, self);
	    }
	  }
	}
	
	var parseErrorHandler = function(self) {
	  return function(err, connection) {
	    if(self.logger.isDebug()) self.logger.debug(f('pool [%s] errored out [%s] with connection [%s]', this.dead, JSON.stringify(err), JSON.stringify(connection)));
	    if(!self.dead) {
	      self.state = DISCONNECTED;
	      self.dead = true;
	      self.destroy();
	      self.emit('parseError', err, self);
	    }
	  }
	}
	
	var connectHandler = function(self) {
	  return function(connection) {
	    self.connections.push(connection);
	    // We have connected to all servers
	    if(self.connections.length == self.size) {
	      self.state = CONNECTED;
	      // Done connecting
	      self.emit("connect", self);
	    }
	  }
	}
	
	/**
	 * Destroy pool
	 * @method
	 */
	Pool.prototype.destroy = function() {
	  this.state = DESTROYED;
	  // Set dead
	  this.dead = true;
	  // Destroy all the connections
	  this.connections.forEach(function(c) {
	    // Destroy all event emitters
	    ["close", "message", "error", "timeout", "parseError", "connect"].forEach(function(e) {
	      c.removeAllListeners(e);
	    });
	
	    // Destroy the connection
	    c.destroy();
	  });
	}
	
	var execute = null;
	
	try {
	  execute = setImmediate;
	} catch(err) {
	  execute = process.nextTick;
	}
	
	/**
	 * Connect pool
	 * @method
	 */
	Pool.prototype.connect = function(_options) {
	  var self = this;
	  // Set to connecting
	  this.state = CONNECTING
	  // No dead
	  this.dead = false;
	  // Connect all sockets
	  for(var i = 0; i < this.size; i++) {
	    execute(function() {
	      self.options.messageHandler = self.messageHandler;
	      var connection = new Connection(self.options);
	      
	      // Add all handlers
	      connection.once('close', closeHandler(self));
	      connection.once('error', errorHandler(self));
	      connection.once('timeout', timeoutHandler(self));
	      connection.once('parseError', parseErrorHandler(self));
	      connection.on('connect', connectHandler(self));
	
	      // Start connection
	      connection.connect(_options);
	    });
	  }
	}
	
	/**
	 * Get a pool connection (round-robin)
	 * @method
	 * @return {Connection}
	 */
	Pool.prototype.get = function() {
	  // if(this.dead) return null;
	  var connection = this.connections[this.index++];
	  this.index = this.index % this.connections.length;
	  return connection;
	}
	
	/**
	 * Get all pool connections
	 * @method
	 * @return {array}
	 */
	Pool.prototype.getAll = function() {
	  return this.connections.slice(0);
	}
	
	/**
	 * Is the pool connected
	 * @method
	 * @return {boolean}
	 */
	Pool.prototype.isConnected = function() {
	  for(var i = 0; i < this.connections.length; i++) {
	    if(!this.connections[i].isConnected()) return false;
	  }
	
	  return this.state == CONNECTED;
	}
	
	/**
	 * Was the pool destroyed
	 * @method
	 * @return {boolean}
	 */
	Pool.prototype.isDestroyed = function() {
	  return this.state == DESTROYED;
	}  
	
	
	/**
	 * A server connect event, used to verify that the connection is up and running
	 *
	 * @event Pool#connect
	 * @type {Pool}
	 */
	
	/**
	 * The server connection closed, all pool connections closed
	 *
	 * @event Pool#close
	 * @type {Pool}
	 */
	
	/**
	 * The server connection caused an error, all pool connections closed
	 *
	 * @event Pool#error
	 * @type {Pool}
	 */
	
	/**
	 * The server connection timed out, all pool connections closed
	 *
	 * @event Pool#timeout
	 * @type {Pool}
	 */
	
	/**
	 * The driver experienced an invalid message, all pool connections closed
	 *
	 * @event Pool#parseError
	 * @type {Pool}
	 */
	
	module.exports = Pool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/timers-browserify/main.js */ 81).setImmediate, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 81 */
/*!*********************************************************!*\
  !*** ./~/node-libs-browser/~/timers-browserify/main.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(/*! process/browser.js */ 43).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/timers-browserify/main.js */ 81).setImmediate, __webpack_require__(/*! ./~/node-libs-browser/~/timers-browserify/main.js */ 81).clearImmediate))

/***/ },
/* 82 */
/*!************************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/connection/commands.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";
	
	var f = __webpack_require__(/*! util */ 57).format
	  , Long = __webpack_require__(/*! bson */ 51).Long
	  , setProperty = __webpack_require__(/*! ./utils */ 79).setProperty
	  , getProperty = __webpack_require__(/*! ./utils */ 79).getProperty
	  , getSingleProperty = __webpack_require__(/*! ./utils */ 79).getSingleProperty;
	
	// Incrementing request id
	var _requestId = 0;
	
	// Wire command operation ids
	var OP_QUERY = 2004;
	var OP_GETMORE = 2005;
	var OP_KILL_CURSORS = 2007;
	
	// Query flags
	var OPTS_NONE = 0;
	var OPTS_TAILABLE_CURSOR = 2;
	var OPTS_SLAVE = 4;
	var OPTS_OPLOG_REPLAY = 8;
	var OPTS_NO_CURSOR_TIMEOUT = 16;
	var OPTS_AWAIT_DATA = 32;
	var OPTS_EXHAUST = 64;
	var OPTS_PARTIAL = 128;
	
	// Response flags
	var CURSOR_NOT_FOUND = 0;
	var QUERY_FAILURE = 2;
	var SHARD_CONFIG_STALE = 4;
	var AWAIT_CAPABLE = 8;
	
	/**************************************************************
	 * QUERY
	 **************************************************************/
	var Query = function(bson, ns, query, options) {
	  var self = this;
	  // Basic options needed to be passed in
	  if(ns == null) throw new Error("ns must be specified for query");
	  if(query == null) throw new Error("query must be specified for query");
	
	  // Validate that we are not passing 0x00 in the colletion name
	  if(!!~ns.indexOf("\x00")) {
	    throw new Error("namespace cannot contain a null character");
	  }
	
	  // Basic options
	  this.bson = bson;
	  this.ns = ns;
	  this.query = query;
	
	  // Ensure empty options
	  this.options = options || {};
	
	  // Additional options
	  this.numberToSkip = options.numberToSkip || 0;
	  this.numberToReturn = options.numberToReturn || 0;
	  this.returnFieldSelector = options.returnFieldSelector || null;  
	  this.requestId = _requestId++;
	
	  // Serialization option
	  this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
	  this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
	  this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : true;
	  this.batchSize = self.numberToReturn;
	
	  // Flags
	  this.tailable = false;
	  this.slaveOk = false;
	  this.oplogReply = false;
	  this.noCursorTimeout = false;
	  this.awaitData = false;
	  this.exhaust = false;
	  this.partial = false;
	}
	
	//
	// Assign a new request Id
	Query.prototype.incRequestId = function() {
	  this.requestId = _requestId++;
	}
	
	//
	// Uses a single allocated buffer for the process, avoiding multiple memory allocations
	Query.prototype.toBin = function() {
	  var self = this;
	  // Basic length
	  var length = 4 
	    + Buffer.byteLength(self.ns) 
	    + 1 + 4 + 4 
	    + self.bson.calculateObjectSize(self.query, self.serializeFunctions, true) 
	    + (4 * 4);
	
	  // Additional size for field selection
	  if(self.returnFieldSelector && Object.keys(self.returnFieldSelector).length > 0) {
	    length += self.bson.calculateObjectSize(self.returnFieldSelector, self.serializeFunctions, true);
	  }
	
	  // Allocate buffer for message
	  var _buffer = new Buffer(length);
	
	  // Set up the flags
	  var flags = 0;
	  if(this.tailable) flags |= OPTS_TAILABLE_CURSOR;
	  if(this.slaveOk) flags |= OPTS_SLAVE;
	  if(this.oplogReply) flags |= OPTS_OPLOG_REPLAY;
	  if(this.noCursorTimeout) flags |= OPTS_NO_CURSOR_TIMEOUT;
	  if(this.awaitData) flags |= OPTS_AWAIT_DATA;
	  if(this.exhaust) flags |= OPTS_EXHAUST;
	  if(this.partial) flags |= OPTS_PARTIAL;
	
	  // If batchSize is different to self.numberToReturn
	  if(self.batchSize != self.numberToReturn) self.numberToReturn = self.batchSize;
	
	  // Initial index
	  var index = 4;
	
	  // Write header information requestId
	  _buffer[index + 3] = (this.requestId >> 24) & 0xff;
	  _buffer[index + 2] = (this.requestId >> 16) & 0xff;
	  _buffer[index + 1] = (this.requestId >> 8) & 0xff;
	  _buffer[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // Write header information responseTo
	  _buffer[index + 3] = (0 >> 24) & 0xff;
	  _buffer[index + 2] = (0 >> 16) & 0xff;
	  _buffer[index + 1] = (0 >> 8) & 0xff;
	  _buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Write header information OP_QUERY
	  _buffer[index + 3] = (OP_QUERY >> 24) & 0xff;
	  _buffer[index + 2] = (OP_QUERY >> 16) & 0xff;
	  _buffer[index + 1] = (OP_QUERY >> 8) & 0xff;
	  _buffer[index] = (OP_QUERY) & 0xff;
	  index = index + 4;
	
	  // Write header information flags
	  _buffer[index + 3] = (flags >> 24) & 0xff;
	  _buffer[index + 2] = (flags >> 16) & 0xff;
	  _buffer[index + 1] = (flags >> 8) & 0xff;
	  _buffer[index] = (flags) & 0xff;
	  index = index + 4;
	
	  // Write collection name
	  index = index + _buffer.write(this.ns, index, 'utf8') + 1;
	  _buffer[index - 1] = 0;
	
	  // Write header information flags numberToSkip
	  _buffer[index + 3] = (this.numberToSkip >> 24) & 0xff;
	  _buffer[index + 2] = (this.numberToSkip >> 16) & 0xff;
	  _buffer[index + 1] = (this.numberToSkip >> 8) & 0xff;
	  _buffer[index] = (this.numberToSkip) & 0xff;
	  index = index + 4;
	
	  // Write header information flags numberToReturn
	  _buffer[index + 3] = (this.numberToReturn >> 24) & 0xff;
	  _buffer[index + 2] = (this.numberToReturn >> 16) & 0xff;
	  _buffer[index + 1] = (this.numberToReturn >> 8) & 0xff;
	  _buffer[index] = (this.numberToReturn) & 0xff;
	  index = index + 4;
	
	  // Serialize query
	  var queryLength = this.bson.serializeWithBufferAndIndex(this.query
	    , this.checkKeys
	    , _buffer, index
	    , this.serializeFunctions) - index + 1;
	
	  // Write header information flags queryLength
	  _buffer[index + 3] = (queryLength >> 24) & 0xff;
	  _buffer[index + 2] = (queryLength >> 16) & 0xff;
	  _buffer[index + 1] = (queryLength >> 8) & 0xff;
	  _buffer[index] = (queryLength) & 0xff;
	  index = index + 4;
	
	  // Add to the index
	  index = index - 4 + queryLength;
	  _buffer[index + 1] = 0x00;
	  
	  // If we have field selectors
	  if(this.returnFieldSelector && Object.keys(this.returnFieldSelector).length > 0) {
	    var fieldSelectorLength = this.bson.serializeWithBufferAndIndex(this.returnFieldSelector
	      , this.checkKeys
	      , _buffer
	      , index
	      , this.serializeFunctions) - index + 1;
	
	    // Write header information flags fieldSelectorLength
	    _buffer[index + 3] = (fieldSelectorLength >> 24) & 0xff;
	    _buffer[index + 2] = (fieldSelectorLength >> 16) & 0xff;
	    _buffer[index + 1] = (fieldSelectorLength >> 8) & 0xff;
	    _buffer[index] = (fieldSelectorLength) & 0xff;
	    index = index + 4;
	
	    index = index - 4 + fieldSelectorLength;
	    _buffer[index + 1] = 0x00;
	  }
	
	  // Write total document length
	  _buffer[3] = (index >> 24) & 0xff;
	  _buffer[2] = (index >> 16) & 0xff;
	  _buffer[1] = (index >> 8) & 0xff;
	  _buffer[0] = (index) & 0xff;
	  // Return buffer
	  return _buffer;
	}
	
	Query.getRequestId = function() {
	  return ++_requestId;
	}
	
	/**************************************************************
	 * GETMORE
	 **************************************************************/
	var GetMore = function(bson, ns, cursorId, opts) {
	  opts = opts || {};
	  this.numberToReturn = opts.numberToReturn || 0;
	  this.requestId = _requestId++;
	  this.bson = bson;
	  this.ns = ns;
	  this.cursorId = cursorId;
	}
	
	//
	// Uses a single allocated buffer for the process, avoiding multiple memory allocations
	GetMore.prototype.toBin = function() {
	  var length = 4 + Buffer.byteLength(this.ns) + 1 + 4 + 8 + (4 * 4);
	  // Create command buffer
	  var index = 0;
	  // Allocate buffer
	  var _buffer = new Buffer(length);
	  
	  // Write header information
	  // index = write32bit(index, _buffer, length);
	  _buffer[index + 3] = (length >> 24) & 0xff;
	  _buffer[index + 2] = (length >> 16) & 0xff;
	  _buffer[index + 1] = (length >> 8) & 0xff;
	  _buffer[index] = (length) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, requestId);
	  _buffer[index + 3] = (this.requestId >> 24) & 0xff;
	  _buffer[index + 2] = (this.requestId >> 16) & 0xff;
	  _buffer[index + 1] = (this.requestId >> 8) & 0xff;
	  _buffer[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, 0);
	  _buffer[index + 3] = (0 >> 24) & 0xff;
	  _buffer[index + 2] = (0 >> 16) & 0xff;
	  _buffer[index + 1] = (0 >> 8) & 0xff;
	  _buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, OP_GETMORE);
	  _buffer[index + 3] = (OP_GETMORE >> 24) & 0xff;
	  _buffer[index + 2] = (OP_GETMORE >> 16) & 0xff;
	  _buffer[index + 1] = (OP_GETMORE >> 8) & 0xff;
	  _buffer[index] = (OP_GETMORE) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, 0);
	  _buffer[index + 3] = (0 >> 24) & 0xff;
	  _buffer[index + 2] = (0 >> 16) & 0xff;
	  _buffer[index + 1] = (0 >> 8) & 0xff;
	  _buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Write collection name
	  index = index + _buffer.write(this.ns, index, 'utf8') + 1;
	  _buffer[index - 1] = 0;
	
	  // Write batch size
	  // index = write32bit(index, _buffer, numberToReturn);
	  _buffer[index + 3] = (this.numberToReturn >> 24) & 0xff;
	  _buffer[index + 2] = (this.numberToReturn >> 16) & 0xff;
	  _buffer[index + 1] = (this.numberToReturn >> 8) & 0xff;
	  _buffer[index] = (this.numberToReturn) & 0xff;
	  index = index + 4;
	
	  // Write cursor id
	  // index = write32bit(index, _buffer, cursorId.getLowBits());
	  _buffer[index + 3] = (this.cursorId.getLowBits() >> 24) & 0xff;
	  _buffer[index + 2] = (this.cursorId.getLowBits() >> 16) & 0xff;
	  _buffer[index + 1] = (this.cursorId.getLowBits() >> 8) & 0xff;
	  _buffer[index] = (this.cursorId.getLowBits()) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, cursorId.getHighBits());
	  _buffer[index + 3] = (this.cursorId.getHighBits() >> 24) & 0xff;
	  _buffer[index + 2] = (this.cursorId.getHighBits() >> 16) & 0xff;
	  _buffer[index + 1] = (this.cursorId.getHighBits() >> 8) & 0xff;
	  _buffer[index] = (this.cursorId.getHighBits()) & 0xff;
	  index = index + 4;
	
	  // Return buffer
	  return _buffer;
	}
	
	/**************************************************************
	 * KILLCURSOR
	 **************************************************************/
	var KillCursor = function(bson, cursorIds) {
	  this.requestId = _requestId++;
	  this.cursorIds = cursorIds;
	}
	
	//
	// Uses a single allocated buffer for the process, avoiding multiple memory allocations
	KillCursor.prototype.toBin = function() {
	  var length = 4 + 4 + (4 * 4) + (this.cursorIds.length * 8);
	
	  // Create command buffer
	  var index = 0;
	  var _buffer = new Buffer(length);
	
	  // Write header information
	  // index = write32bit(index, _buffer, length);
	  _buffer[index + 3] = (length >> 24) & 0xff;
	  _buffer[index + 2] = (length >> 16) & 0xff;
	  _buffer[index + 1] = (length >> 8) & 0xff;
	  _buffer[index] = (length) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, requestId);
	  _buffer[index + 3] = (this.requestId >> 24) & 0xff;
	  _buffer[index + 2] = (this.requestId >> 16) & 0xff;
	  _buffer[index + 1] = (this.requestId >> 8) & 0xff;
	  _buffer[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, 0);
	  _buffer[index + 3] = (0 >> 24) & 0xff;
	  _buffer[index + 2] = (0 >> 16) & 0xff;
	  _buffer[index + 1] = (0 >> 8) & 0xff;
	  _buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, OP_KILL_CURSORS);
	  _buffer[index + 3] = (OP_KILL_CURSORS >> 24) & 0xff;
	  _buffer[index + 2] = (OP_KILL_CURSORS >> 16) & 0xff;
	  _buffer[index + 1] = (OP_KILL_CURSORS >> 8) & 0xff;
	  _buffer[index] = (OP_KILL_CURSORS) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, 0);
	  _buffer[index + 3] = (0 >> 24) & 0xff;
	  _buffer[index + 2] = (0 >> 16) & 0xff;
	  _buffer[index + 1] = (0 >> 8) & 0xff;
	  _buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Write batch size
	  // index = write32bit(index, _buffer, this.cursorIds.length);
	  _buffer[index + 3] = (this.cursorIds.length >> 24) & 0xff;
	  _buffer[index + 2] = (this.cursorIds.length >> 16) & 0xff;
	  _buffer[index + 1] = (this.cursorIds.length >> 8) & 0xff;
	  _buffer[index] = (this.cursorIds.length) & 0xff;
	  index = index + 4;
	
	  // Write all the cursor ids into the array
	  for(var i = 0; i < this.cursorIds.length; i++) {
	    // Write cursor id
	    // index = write32bit(index, _buffer, cursorIds[i].getLowBits());
	    _buffer[index + 3] = (this.cursorIds[i].getLowBits() >> 24) & 0xff;
	    _buffer[index + 2] = (this.cursorIds[i].getLowBits() >> 16) & 0xff;
	    _buffer[index + 1] = (this.cursorIds[i].getLowBits() >> 8) & 0xff;
	    _buffer[index] = (this.cursorIds[i].getLowBits()) & 0xff;
	    index = index + 4;
	
	    // index = write32bit(index, _buffer, cursorIds[i].getHighBits());
	    _buffer[index + 3] = (this.cursorIds[i].getHighBits() >> 24) & 0xff;
	    _buffer[index + 2] = (this.cursorIds[i].getHighBits() >> 16) & 0xff;
	    _buffer[index + 1] = (this.cursorIds[i].getHighBits() >> 8) & 0xff;
	    _buffer[index] = (this.cursorIds[i].getHighBits()) & 0xff;
	    index = index + 4;
	  }
	
	  // Return buffer
	  return _buffer;
	}
	
	var Response = function(bson, data, opts) {
	  opts = opts || {promoteLongs: true};
	  this.parsed = false;
	
	  //
	  // Parse Header
	  //
	  this.index = 0;
	  this.raw = data;
	  this.data = data;
	  this.bson = bson;
	  this.opts = opts;
	
	  // Read the message length
	  this.length = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	  
	  // Fetch the request id for this reply
	  this.requestId = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	  
	  // Fetch the id of the request that triggered the response
	  this.responseTo = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	
	  // Skip op-code field
	  this.index = this.index + 4;
	  
	  // Unpack flags
	  this.responseFlags = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	  
	  // Unpack the cursor
	  var lowBits = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	  var highBits = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	  // Create long object
	  this.cursorId = new Long(lowBits, highBits);
	  
	  // Unpack the starting from
	  this.startingFrom = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	  
	  // Unpack the number of objects returned
	  this.numberReturned = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	
	  // Preallocate document array
	  this.documents = new Array(this.numberReturned);
	
	  // Flag values
	  this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) != 0;
	  this.queryFailure = (this.responseFlags & QUERY_FAILURE) != 0;
	  this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) != 0;
	  this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) != 0;
	  this.promoteLongs = typeof opts.promoteLongs == 'boolean' ? opts.promoteLongs : true;
	}
	
	Response.prototype.isParsed = function() {
	  return this.parsed;
	}
	
	Response.prototype.parse = function(options) {
	  // Don't parse again if not needed
	  if(this.parsed) return;
	  options = options || {};
	  // Allow the return of raw documents instead of parsing
	  var raw = options.raw || false;
	
	  //
	  // Parse Body
	  //
	  for(var i = 0; i < this.numberReturned; i++) {
	    var bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
	    // Parse options
	    var _options = {promoteLongs: this.opts.promoteLongs};
	
	    // If we have raw results specified slice the return document
	    if(raw) {
	      this.documents[i] = this.data.slice(this.index, this.index + bsonSize);
	    } else {
	      this.documents[i] = this.bson.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);
	    }
	
	    // Adjust the index
	    this.index = this.index + bsonSize;
	  }
	
	  // Set parsed
	  this.parsed = true;
	}
	
	module.exports = {
	    Query: Query
	  , GetMore: GetMore
	  , Response: Response
	  , KillCursor: KillCursor
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 83 */
/*!**************************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/connection/connection.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";
	
	var inherits = __webpack_require__(/*! util */ 57).inherits
	  , EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter
	  , net = __webpack_require__(/*! net */ 84)
	  , tls = __webpack_require__(/*! tls */ 84)
	  , f = __webpack_require__(/*! util */ 57).format
	  , getSingleProperty = __webpack_require__(/*! ./utils */ 79).getSingleProperty
	  , debugOptions = __webpack_require__(/*! ./utils */ 79).debugOptions
	  , Response = __webpack_require__(/*! ./commands */ 82).Response
	  , MongoError = __webpack_require__(/*! ../error */ 77)
	  , Logger = __webpack_require__(/*! ./logger */ 85);
	
	var _id = 0;
	var debugFields = ['host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay'
	  , 'connectionTimeout', 'socketTimeout', 'singleBufferSerializtion', 'ssl', 'ca', 'cert'
	  , 'rejectUnauthorized', 'promoteLongs'];
	
	/**
	 * Creates a new Connection instance
	 * @class
	 * @param {string} options.host The server host
	 * @param {number} options.port The server port
	 * @param {number} [options.size=5] Server connection pool size
	 * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled
	 * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled
	 * @param {boolean} [options.noDelay=true] TCP Connection no delay
	 * @param {number} [options.connectionTimeout=0] TCP Connection timeout setting
	 * @param {number} [options.socketTimeout=0] TCP Socket timeout setting
	 * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed
	 * @param {boolean} [options.ssl=false] Use SSL for connection
	 * @param {Buffer} [options.ca] SSL Certificate store binary buffer
	 * @param {Buffer} [options.cert] SSL Certificate binary buffer
	 * @param {Buffer} [options.key] SSL Key file binary buffer
	 * @param {string} [options.passphrase] SSL Certificate pass phrase
	 * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates
	 * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
	 * @fires Connection#connect
	 * @fires Connection#close
	 * @fires Connection#error
	 * @fires Connection#timeout
	 * @fires Connection#parseError
	 * @return {Connection} A cursor instance
	 */
	var Connection = function(options) {
	  // Add event listener
	  EventEmitter.call(this);
	  // Set empty if no options passed
	  this.options = options || {};
	  // Identification information
	  this.id = _id++;
	  // Logger instance
	  this.logger = Logger('Connection', options);
	  // No bson parser passed in
	  if(!options.bson) throw new Error("must pass in valid bson parser");
	  // Get bson parser
	  this.bson = options.bson;
	  // Grouping tag used for debugging purposes
	  this.tag = options.tag;
	  // Message handler
	  this.messageHandler = options.messageHandler;
	
	  // Max BSON message size
	  this.maxBsonMessageSize = options.maxBsonMessageSize || (1024 * 1024 * 16 * 4);
	  // Debug information
	  if(this.logger.isDebug()) this.logger.debug(f('creating connection %s with options [%s]', this.id, JSON.stringify(debugOptions(debugFields, options))));
	
	  // Default options
	  this.port = options.port || 27017;
	  this.host = options.host || 'localhost';
	  this.keepAlive = typeof options.keepAlive == 'boolean' ? options.keepAlive : true;
	  this.keepAliveInitialDelay = options.keepAliveInitialDelay || 0;
	  this.noDelay = typeof options.noDelay == 'boolean' ? options.noDelay : true;
	  this.connectionTimeout = options.connectionTimeout || 0;
	  this.socketTimeout = options.socketTimeout || 0;
	
	  // Check if we have a domain socket
	  this.domainSocket = this.host.indexOf('\/') != -1;
	
	  // Serialize commands using function
	  this.singleBufferSerializtion = typeof options.singleBufferSerializtion == 'boolean' ? options.singleBufferSerializtion : true;
	  this.serializationFunction = this.singleBufferSerializtion ? 'toBinUnified' : 'toBin';
	
	  // SSL options
	  this.ca = options.ca || null;
	  this.cert = options.cert || null;
	  this.key = options.key || null;
	  this.passphrase = options.passphrase || null;
	  this.ssl = typeof options.ssl == 'boolean' ? options.ssl : false;
	  this.rejectUnauthorized = typeof options.rejectUnauthorized == 'boolean' ? options.rejectUnauthorized : true
	
	  // If ssl not enabled
	  if(!this.ssl) this.rejectUnauthorized = false;
	
	  // Response options
	  this.responseOptions = {
	    promoteLongs: typeof options.promoteLongs == 'boolean' ?  options.promoteLongs : true
	  }
	
	  // Flushing
	  this.flushing = false;
	  this.queue = [];
	
	  // Internal state
	  this.connection = null;
	  this.writeStream = null;
	}
	
	inherits(Connection, EventEmitter);
	
	//
	// Connection handlers
	var errorHandler = function(self) {
	  return function(err) {
	    // Debug information
	    if(self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] errored out with [%s]', self.id, self.host, self.port, JSON.stringify(err)));
	    // Emit the error
	    if(self.listeners('error').length > 0) self.emit("error", MongoError.create(err), self);
	  }
	}
	
	var timeoutHandler = function(self) {
	  return function() {
	    // Debug information
	    if(self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] timed out', self.id, self.host, self.port));
	    // Emit timeout error
	    self.emit("timeout"
	      , MongoError.create(f("connection %s to %s:%s timed out", self.id, self.host, self.port))
	      , self);
	  }
	}
	
	var closeHandler = function(self) {
	  return function(hadError) {
	    // Debug information
	    if(self.logger.isDebug()) self.logger.debug(f('connection %s with for [%s:%s] closed', self.id, self.host, self.port));
	    // Emit close event
	    if(!hadError) {
	      self.emit("close"
	        , MongoError.create(f("connection %s to %s:%s closed", self.id, self.host, self.port))
	        , self);
	    }
	  }
	}
	
	var dataHandler = function(self) {
	  return function(data) {
	    // Parse until we are done with the data
	    while(data.length > 0) {
	      // If we still have bytes to read on the current message
	      if(self.bytesRead > 0 && self.sizeOfMessage > 0) {
	        // Calculate the amount of remaining bytes
	        var remainingBytesToRead = self.sizeOfMessage - self.bytesRead;
	        // Check if the current chunk contains the rest of the message
	        if(remainingBytesToRead > data.length) {
	          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)
	          data.copy(self.buffer, self.bytesRead);
	          // Adjust the number of bytes read so it point to the correct index in the buffer
	          self.bytesRead = self.bytesRead + data.length;
	
	          // Reset state of buffer
	          data = new Buffer(0);
	        } else {
	          // Copy the missing part of the data into our current buffer
	          data.copy(self.buffer, self.bytesRead, 0, remainingBytesToRead);
	          // Slice the overflow into a new buffer that we will then re-parse
	          data = data.slice(remainingBytesToRead);
	
	          // Emit current complete message
	          try {
	            var emitBuffer = self.buffer;
	            // Reset state of buffer
	            self.buffer = null;
	            self.sizeOfMessage = 0;
	            self.bytesRead = 0;
	            self.stubBuffer = null;
	            // Emit the buffer
	            self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);
	          } catch(err) {
	            var errorObject = {err:"socketHandler", trace:err, bin:self.buffer, parseState:{
	              sizeOfMessage:self.sizeOfMessage,
	              bytesRead:self.bytesRead,
	              stubBuffer:self.stubBuffer}};
	            // We got a parse Error fire it off then keep going
	            self.emit("parseError", errorObject, self);
	          }
	        }
	      } else {
	        // Stub buffer is kept in case we don't get enough bytes to determine the
	        // size of the message (< 4 bytes)
	        if(self.stubBuffer != null && self.stubBuffer.length > 0) {
	          // If we have enough bytes to determine the message size let's do it
	          if(self.stubBuffer.length + data.length > 4) {
	            // Prepad the data
	            var newData = new Buffer(self.stubBuffer.length + data.length);
	            self.stubBuffer.copy(newData, 0);
	            data.copy(newData, self.stubBuffer.length);
	            // Reassign for parsing
	            data = newData;
	
	            // Reset state of buffer
	            self.buffer = null;
	            self.sizeOfMessage = 0;
	            self.bytesRead = 0;
	            self.stubBuffer = null;
	
	          } else {
	
	            // Add the the bytes to the stub buffer
	            var newStubBuffer = new Buffer(self.stubBuffer.length + data.length);
	            // Copy existing stub buffer
	            self.stubBuffer.copy(newStubBuffer, 0);
	            // Copy missing part of the data
	            data.copy(newStubBuffer, self.stubBuffer.length);
	            // Exit parsing loop
	            data = new Buffer(0);
	          }
	        } else {
	          if(data.length > 4) {
	            // Retrieve the message size
	            // var sizeOfMessage = data.readUInt32LE(0);
	            var sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;
	            // If we have a negative sizeOfMessage emit error and return
	            if(sizeOfMessage < 0 || sizeOfMessage > self.maxBsonMessageSize) {
	              var errorObject = {err:"socketHandler", trace:'', bin:self.buffer, parseState:{
	                sizeOfMessage: sizeOfMessage,
	                bytesRead: self.bytesRead,
	                stubBuffer: self.stubBuffer}};
	              // We got a parse Error fire it off then keep going
	              self.emit("parseError", errorObject, self);
	              return;
	            }
	
	            // Ensure that the size of message is larger than 0 and less than the max allowed
	            if(sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage > data.length) {
	              self.buffer = new Buffer(sizeOfMessage);
	              // Copy all the data into the buffer
	              data.copy(self.buffer, 0);
	              // Update bytes read
	              self.bytesRead = data.length;
	              // Update sizeOfMessage
	              self.sizeOfMessage = sizeOfMessage;
	              // Ensure stub buffer is null
	              self.stubBuffer = null;
	              // Exit parsing loop
	              data = new Buffer(0);
	
	            } else if(sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage == data.length) {
	              try {
	                var emitBuffer = data;
	                // Reset state of buffer
	                self.buffer = null;
	                self.sizeOfMessage = 0;
	                self.bytesRead = 0;
	                self.stubBuffer = null;
	                // Exit parsing loop
	                data = new Buffer(0);
	                // Emit the message
	                self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);
	              } catch (err) {
	                var errorObject = {err:"socketHandler", trace:err, bin:self.buffer, parseState:{
	                  sizeOfMessage:self.sizeOfMessage,
	                  bytesRead:self.bytesRead,
	                  stubBuffer:self.stubBuffer}};
	                // We got a parse Error fire it off then keep going
	                self.emit("parseError", errorObject, self);
	              }
	            } else if(sizeOfMessage <= 4 || sizeOfMessage > self.maxBsonMessageSize) {
	              var errorObject = {err:"socketHandler", trace:null, bin:data, parseState:{
	                sizeOfMessage:sizeOfMessage,
	                bytesRead:0,
	                buffer:null,
	                stubBuffer:null}};
	              // We got a parse Error fire it off then keep going
	              self.emit("parseError", errorObject, self);
	
	              // Clear out the state of the parser
	              self.buffer = null;
	              self.sizeOfMessage = 0;
	              self.bytesRead = 0;
	              self.stubBuffer = null;
	              // Exit parsing loop
	              data = new Buffer(0);
	            } else {
	              var emitBuffer = data.slice(0, sizeOfMessage);
	              // Reset state of buffer
	              self.buffer = null;
	              self.sizeOfMessage = 0;
	              self.bytesRead = 0;
	              self.stubBuffer = null;
	              // Copy rest of message
	              data = data.slice(sizeOfMessage);
	              // Emit the message
	              self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);
	            }
	          } else {
	            // Create a buffer that contains the space for the non-complete message
	            self.stubBuffer = new Buffer(data.length)
	            // Copy the data to the stub buffer
	            data.copy(self.stubBuffer, 0);
	            // Exit parsing loop
	            data = new Buffer(0);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Connect
	 * @method
	 */
	Connection.prototype.connect = function(_options) {
	  var self = this;
	  _options = _options || {};
	  // Check if we are overriding the promoteLongs
	  if(typeof _options.promoteLongs == 'boolean') {
	    self.responseOptions.promoteLongs = _options.promoteLongs;
	  }
	
	  // Create new connection instance
	  self.connection = self.domainSocket
	    ? net.createConnection(self.host)
	    : net.createConnection(self.port, self.host);
	
	  // Set the options for the connection
	  self.connection.setKeepAlive(self.keepAlive, self.keepAliveInitialDelay);
	  self.connection.setTimeout(self.connectionTimeout);
	  self.connection.setNoDelay(self.noDelay);
	
	  // If we have ssl enabled
	  if(self.ssl) {
	    var sslOptions = {
	        socket: self.connection
	      , rejectUnauthorized: self.rejectUnauthorized
	    }
	
	    if(self.ca) sslOptions.ca = self.ca;
	    if(self.cert) sslOptions.cert = self.cert;
	    if(self.key) sslOptions.key = self.key;
	    if(self.passphrase) sslOptions.passphrase = self.passphrase;
	
	    // Attempt SSL connection
	    self.connection = tls.connect(self.port, self.host, sslOptions, function() {
	      // Error on auth or skip
	      if(self.connection.authorizationError && self.rejectUnauthorized) {
	        return self.emit("error", self.connection.authorizationError, self, {ssl:true});
	      }
	
	      // Set socket timeout instead of connection timeout
	      self.connection.setTimeout(self.socketTimeout);
	      // We are done emit connect
	      self.emit('connect', self);
	    });
	  } else {
	    self.connection.on('connect', function() {
	      // Set socket timeout instead of connection timeout
	      self.connection.setTimeout(self.socketTimeout);
	      // Emit connect event
	      self.emit('connect', self);
	    });
	  }
	
	  // Add handlers for events
	  self.connection.once('error', errorHandler(self));
	  self.connection.once('timeout', timeoutHandler(self));
	  self.connection.once('close', closeHandler(self));
	  self.connection.on('data', dataHandler(self));
	}
	
	/**
	 * Destroy connection
	 * @method
	 */
	Connection.prototype.destroy = function() {
	  if(this.connection) this.connection.destroy();
	}
	
	/**
	 * Write to connection
	 * @method
	 * @param {Command} command Command to write out need to implement toBin and toBinUnified
	 */
	Connection.prototype.write = function(buffer) {
	  // Debug log
	  if(this.logger.isDebug()) this.logger.debug(f('writing buffer [%s] to %s:%s', buffer.toString('hex'), this.host, this.port));
	  // Write out the command
	  this.connection.write(buffer, 'binary');
	}
	
	/**
	 * Return id of connection as a string
	 * @method
	 * @return {string}
	 */
	Connection.prototype.toString = function() {
	  return "" + this.id;
	}
	
	/**
	 * Return json object of connection
	 * @method
	 * @return {object}
	 */
	Connection.prototype.toJSON = function() {
	  return {id: this.id, host: this.host, port: this.port};
	}
	
	/**
	 * Is the connection connected
	 * @method
	 * @return {boolean}
	 */
	Connection.prototype.isConnected = function() {
	  return !this.connection.destroyed && this.connection.writable;
	}
	
	/**
	 * A server connect event, used to verify that the connection is up and running
	 *
	 * @event Connection#connect
	 * @type {Connection}
	 */
	
	/**
	 * The server connection closed, all pool connections closed
	 *
	 * @event Connection#close
	 * @type {Connection}
	 */
	
	/**
	 * The server connection caused an error, all pool connections closed
	 *
	 * @event Connection#error
	 * @type {Connection}
	 */
	
	/**
	 * The server connection timed out, all pool connections closed
	 *
	 * @event Connection#timeout
	 * @type {Connection}
	 */
	
	/**
	 * The driver experienced an invalid message, all pool connections closed
	 *
	 * @event Connection#parseError
	 * @type {Connection}
	 */
	
	module.exports = Connection;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 84 */
/*!*******************************************!*\
  !*** ./~/node-libs-browser/mock/empty.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {



/***/ },
/* 85 */
/*!**********************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/connection/logger.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var f = __webpack_require__(/*! util */ 57).format
	  , MongoError = __webpack_require__(/*! ../error */ 77);
	
	// Filters for classes
	var classFilters = {};
	var filteredClasses = {};
	var level = null;
	// Save the process id
	var pid = process.pid;
	// current logger
	var currentLogger = null;
	
	/**
	 * Creates a new Logger instance
	 * @class
	 * @param {string} className The Class name associated with the logging instance
	 * @param {object} [options=null] Optional settings.
	 * @param {Function} [options.logger=null] Custom logger function;
	 * @param {string} [options.loggerLevel=error] Override default global log level.
	 * @return {Logger} a Logger instance.
	 */
	var Logger = function(className, options) {
	  if(!(this instanceof Logger)) return new Logger(className, options);
	  options = options || {};
	
	  // Current reference
	  var self = this;
	  this.className = className;
	
	  // Current logger
	  if(currentLogger == null && options.logger) {
	    currentLogger = options.logger;
	  } else if(currentLogger == null) {
	    currentLogger = console.log;
	  }
	
	  // Set level of logging, default is error
	  if(level == null) {
	    level = options.loggerLevel || 'error';
	  }
	
	  // Add all class names
	  if(filteredClasses[this.className] == null) classFilters[this.className] =  true;
	}
	
	/**
	 * Log a message at the debug level
	 * @method
	 * @param {string} message The message to log
	 * @param {object} object additional meta data to log
	 * @return {null}
	 */
	Logger.prototype.debug = function(message, object) {
	  if(this.isDebug() 
	    && classFilters[this.className] && (filteredClasses[this.className] || Object.keys(filteredClasses).length == 0)) {
	    var dateTime = new Date().getTime();
	    var msg = f("[%s-%s:%s] %s %s", 'DEBUG', this.className, pid, dateTime, message);        
	    var state = {
	      type: 'debug', message: message, className: this.className, pid: pid, date: dateTime
	    };
	    if(object) state.meta = object;
	    currentLogger(msg, state);
	  }
	}
	
	/**
	 * Log a message at the info level
	 * @method
	 * @param {string} message The message to log
	 * @param {object} object additional meta data to log
	 * @return {null}
	 */
	Logger.prototype.info = function(message, object) {
	  if(this.isInfo()
	    && classFilters[this.className] && (filteredClasses[this.className] || Object.keys(filteredClasses).length == 0)) {
	    var dateTime = new Date().getTime();
	    var msg = f("[%s-%s:%s] %s %s", 'INFO', this.className, pid, dateTime, message);
	    var state = {
	      type: 'info', message: message, className: this.className, pid: pid, date: dateTime
	    };
	    if(object) state.meta = object;
	    currentLogger(msg, state);
	  }
	},
	
	/**
	 * Log a message at the error level
	 * @method
	 * @param {string} message The message to log
	 * @param {object} object additional meta data to log
	 * @return {null}
	 */
	Logger.prototype.error = function(message, object) {
	  if(this.isError() 
	    && classFilters[this.className] && (filteredClasses[this.className] || Object.keys(filteredClasses).length == 0)) {
	    var dateTime = new Date().getTime();
	    var msg = f("[%s-%s:%s] %s %s", 'ERROR', this.className, pid, dateTime, message);
	    var state = {
	      type: 'error', message: message, className: this.className, pid: pid, date: dateTime
	    };
	    if(object) state.meta = object;
	    currentLogger(msg, state);
	  }
	},
	
	/**
	 * Is the logger set at info level
	 * @method
	 * @return {boolean}
	 */
	Logger.prototype.isInfo = function() {
	  return level == 'info' || level == 'debug';
	},
	
	/**
	 * Is the logger set at error level
	 * @method
	 * @return {boolean}
	 */
	Logger.prototype.isError = function() {
	  return level == 'error' || level == 'info' || level == 'debug';
	},
	
	/**
	 * Is the logger set at debug level
	 * @method
	 * @return {boolean}
	 */
	Logger.prototype.isDebug = function() {
	  return level == 'debug';
	}
	
	/**
	 * Resets the logger to default settings, error and no filtered classes
	 * @method
	 * @return {null}
	 */
	Logger.reset = function() {
	  level = 'error';
	  filteredClasses = {};
	}
	
	/**
	 * Get the current logger function
	 * @method
	 * @return {function}
	 */
	Logger.currentLogger = function() {
	  return currentLogger;
	}
	
	/**
	 * Set the current logger function
	 * @method
	 * @param {function} logger Logger function.
	 * @return {null}
	 */
	Logger.setCurrentLogger = function(logger) {
	  if(typeof logger != 'function') throw new MongoError("current logger must be a function");
	  currentLogger = logger;
	}
	
	/**
	 * Set what classes to log.
	 * @method
	 * @param {string} type The type of filter (currently only class)
	 * @param {string[]} values The filters to apply
	 * @return {null}
	 */
	Logger.filter = function(type, values) {
	  if(type == 'class' && Array.isArray(values)) {
	    filteredClasses = {};
	
	    values.forEach(function(x) {
	      filteredClasses[x] = true;
	    });
	  }
	}
	
	/**
	 * Set the current log level
	 * @method
	 * @param {string} level Set current log level (debug, info, error)
	 * @return {null}
	 */
	Logger.setLevel = function(_level) {
	  if(_level != 'info' && _level != 'error' && _level != 'debug') throw new Error(f("%s is an illegal logging level", _level));
	  level = _level;
	}
	
	module.exports = Logger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 86 */
/*!*******************************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/topologies/read_preference.js ***!
  \*******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var needSlaveOk = ['primaryPreferred', 'secondary', 'secondaryPreferred', 'nearest'];
	
	/**
	 * @fileOverview The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is
	 * used to construct connections.
	 * 
	 * @example
	 * var ReplSet = require('mongodb-core').ReplSet
	 *   , ReadPreference = require('mongodb-core').ReadPreference
	 *   , assert = require('assert');
	 * 
	 * var server = new ReplSet([{host: 'localhost', port: 30000}], {setName: 'rs'});
	 * // Wait for the connection event
	 * server.on('connect', function(server) {
	 *   var cursor = server.cursor('db.test'
	 *     , {find: 'db.test', query: {}}
	 *     , {readPreference: new ReadPreference('secondary')});
	 *   cursor.next(function(err, doc) {
	 *     server.destroy();
	 *   });
	 * });
	 * 
	 * // Start connecting
	 * server.connect();
	 */
	
	/**
	 * Creates a new Pool instance
	 * @class
	 * @param {string} preference A string describing the preference (primary|primaryPreferred|secondary|secondaryPreferred|nearest)
	 * @param {object} tags The tags object
	 * @param {object} [options] Additional read preference options
	 * @property {string} preference The preference string (primary|primaryPreferred|secondary|secondaryPreferred|nearest)
	 * @property {object} tags The tags object
	 * @property {object} options Additional read preference options
	 * @return {ReadPreference}
	 */
	var ReadPreference = function(preference, tags, options) {
	  this.preference = preference;
	  this.tags = tags;
	  this.options = options;
	}
	
	/**
	 * This needs slaveOk bit set
	 * @method
	 * @return {boolean}
	 */
	ReadPreference.prototype.slaveOk = function() {
	  return needSlaveOk.indexOf(this.preference) != -1;
	}
	
	/**
	 * Are the two read preference equal
	 * @method
	 * @return {boolean}
	 */
	ReadPreference.prototype.equals = function(readPreference) {
	  return readPreference.preference == this.preference;
	}
	
	/**
	 * Return JSON representation
	 * @method
	 * @return {Object}
	 */
	ReadPreference.prototype.toJSON = function() {
	  var readPreference = {mode: this.preference};
	  if(Array.isArray(this.tags)) readPreference.tags = this.tags;
	  return readPreference;
	}
	
	/**
	 * Primary read preference
	 * @method
	 * @return {ReadPreference}
	 */
	ReadPreference.primary = new ReadPreference('primary');
	/**
	 * Primary Preferred read preference
	 * @method
	 * @return {ReadPreference}
	 */
	ReadPreference.primaryPreferred = new ReadPreference('primaryPreferred');
	/**
	 * Secondary read preference
	 * @method
	 * @return {ReadPreference}
	 */
	ReadPreference.secondary = new ReadPreference('secondary');
	/**
	 * Secondary Preferred read preference
	 * @method
	 * @return {ReadPreference}
	 */
	ReadPreference.secondaryPreferred = new ReadPreference('secondaryPreferred');
	/**
	 * Nearest read preference
	 * @method
	 * @return {ReadPreference}
	 */
	ReadPreference.nearest = new ReadPreference('nearest');
	
	module.exports = ReadPreference;

/***/ },
/* 87 */
/*!***********************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/cursor.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var Long = __webpack_require__(/*! bson */ 51).Long
	  , Logger = __webpack_require__(/*! ./connection/logger */ 85)
	  , MongoError = __webpack_require__(/*! ./error */ 77)
	  , f = __webpack_require__(/*! util */ 57).format;  
	
	/**
	 * This is a cursor results callback
	 *
	 * @callback resultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {object} document
	 */
	
	/**
	 * @fileOverview The **Cursor** class is an internal class that embodies a cursor on MongoDB
	 * allowing for iteration over the results returned from the underlying query.
	 * 
	 * **CURSORS Cannot directly be instantiated**
	 * @example
	 * var Server = require('mongodb-core').Server
	 *   , ReadPreference = require('mongodb-core').ReadPreference
	 *   , assert = require('assert');
	 * 
	 * var server = new Server({host: 'localhost', port: 27017});
	 * // Wait for the connection event
	 * server.on('connect', function(server) {
	 *   assert.equal(null, err);
	 * 
	 *   // Execute the write
	 *   var cursor = _server.cursor('integration_tests.inserts_example4', {
	 *       find: 'integration_tests.example4'
	 *     , query: {a:1}
	 *   }, {
	 *     readPreference: new ReadPreference('secondary');
	 *   });
	 * 
	 *   // Get the first document
	 *   cursor.next(function(err, doc) {
	 *     assert.equal(null, err);
	 *     server.destroy();
	 *   });
	 * });
	 * 
	 * // Start connecting
	 * server.connect();
	 */
	
	/**
	 * Creates a new Cursor, not to be used directly
	 * @class
	 * @param {object} bson An instance of the BSON parser
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {{object}|Long} cmd The selector (can be a command or a cursorId)
	 * @param {object} [options=null] Optional settings.
	 * @param {object} [options.batchSize=1000] Batchsize for the operation
	 * @param {array} [options.documents=[]] Initial documents list for cursor
	 * @param {object} [options.transforms=null] Transform methods for the cursor results
	 * @param {function} [options.transforms.query] Transform the value returned from the initial query
	 * @param {function} [options.transforms.doc] Transform each document returned from Cursor.prototype.next
	 * @param {object} topology The server topology instance.
	 * @param {object} topologyOptions The server topology options.
	 * @return {Cursor} A cursor instance
	 * @property {number} cursorBatchSize The current cursorBatchSize for the cursor
	 * @property {number} cursorLimit The current cursorLimit for the cursor
	 * @property {number} cursorSkip The current cursorSkip for the cursor
	 */
	var Cursor = function(bson, ns, cmd, options, topology, topologyOptions) {
	  options = options || {};
	  // Cursor reference
	  var self = this;
	  // Initial query
	  var query = null;
	
	  // Cursor connection
	  this.connection = null;
	  // Cursor server
	  this.server = null;
	
	  // Do we have a not connected handler
	  this.disconnectHandler = options.disconnectHandler;
	
	  // Set local values
	  this.bson = bson;
	  this.ns = ns;
	  this.cmd = cmd;
	  this.options = options;
	  this.topology = topology;
	
	  // All internal state
	  this.cursorState = {
	      cursorId: null
	    , documents: options.documents || []
	    , cursorIndex: 0
	    , dead: false
	    , killed: false
	    , init: false
	    , notified: false
	    , limit: options.limit || cmd.limit || 0
	    , skip: options.skip || cmd.skip || 0
	    , batchSize: options.batchSize || cmd.batchSize || 1000
	    , currentLimit: 0
	    // Result field name if not a cursor (contains the array of results)
	    , transforms: options.transforms
	  }
	
	  // Callback controller
	  this.callbacks = null;
	
	  // Logger
	  this.logger = Logger('Cursor', options);
	
	  // 
	  // Did we pass in a cursor id
	  if(typeof cmd == 'number') {
	    this.cursorState.cursorId = Long.fromNumber(cmd);
	  } else if(cmd instanceof Long) {
	    this.cursorState.cursorId = cmd;
	  }
	}
	
	Cursor.prototype.setCursorBatchSize = function(value) {  
	  this.cursorState.batchSize = value;
	}
	
	Cursor.prototype.cursorBatchSize = function() {  
	  return this.cursorState.batchSize;
	}
	
	Cursor.prototype.setCursorLimit = function(value) {  
	  this.cursorState.limit = value;
	}
	
	Cursor.prototype.cursorLimit = function() {  
	  return this.cursorState.limit;
	}
	
	Cursor.prototype.setCursorSkip = function(value) {  
	  this.cursorState.skip = value;
	}
	
	Cursor.prototype.cursorSkip = function() {  
	  return this.cursorState.skip;
	}
	
	//
	// Execute getMore command
	var execGetMore = function(self, callback) {
	  if(self.logger.isDebug()) self.logger.debug(f("schedule getMore call for query [%s]", JSON.stringify(self.query)))
	  // Determine if it's a raw query
	  var raw = self.options.raw || self.cmd.raw;
	  // We have a wire protocol handler
	  self.server.wireProtocolHandler.getMore(self.bson, self.ns, self.cursorState, self.cursorState.batchSize, raw, self.connection, self.callbacks, self.options, callback);
	}
	
	// 
	// Execute the first query
	var execInitialQuery = function(self, query, cmd, options, cursorState, connection, logger, callbacks, callback) {
	  if(logger.isDebug()) {
	    logger.debug(f("issue initial query [%s] with flags [%s]"
	      , JSON.stringify(cmd)
	      , JSON.stringify(query)));
	  }
	
	  var queryCallback = function(err, result) {
	    if(err) return callback(err);
	
	    if (result.queryFailure) {
	      return callback(MongoError.create(result.documents[0]), null);
	    }
	
	    // Check if we have a command cursor
	    if(Array.isArray(result.documents) && result.documents.length == 1 && !cmd.find) {
	      if(result.documents[0]['$err'] 
	        || result.documents[0]['errmsg']) {
	        return callback(MongoError.create(result.documents[0]), null);          
	      }
	
	      if(result.documents[0].cursor != null 
	        && typeof result.documents[0].cursor != 'string') {
	          var id = result.documents[0].cursor.id;
	          // If we have a namespace change set the new namespace for getmores
	          if(result.documents[0].cursor.ns) {
	            self.ns = result.documents[0].cursor.ns;
	          }
	          // Promote id to long if needed
	          cursorState.cursorId = typeof id == 'number' ? Long.fromNumber(id) : id;
	          // If we have a firstBatch set it
	          if(Array.isArray(result.documents[0].cursor.firstBatch)) {
	            cursorState.documents = result.documents[0].cursor.firstBatch;//.reverse();
	          }
	
	          // Return after processing command cursor
	          return callback(null, null);
	      }
	
	      if(Array.isArray(result.documents[0].result)) {
	        cursorState.documents = result.documents[0].result;
	        cursorState.cursorId = Long.ZERO;
	        return callback(null, null);
	      }      
	    }
	
	    // Otherwise fall back to regular find path
	    cursorState.cursorId = result.cursorId;
	    cursorState.documents = result.documents;
	
	    // Transform the results with passed in transformation method if provided
	    if(cursorState.transforms && typeof cursorState.transforms.query == 'function') {
	      cursorState.documents = cursorState.transforms.query(result);
	    }
	
	    // Return callback
	    callback(null, null);
	  }
	
	  // If we have a raw query decorate the function
	  if(options.raw || cmd.raw) {
	    queryCallback.raw = options.raw || cmd.raw;
	  }
	
	  // Set up callback
	  callbacks.register(query.requestId, queryCallback);
	
	  // Write the initial command out
	  connection.write(query.toBin());
	}
	
	//
	// Handle callback (including any exceptions thrown)
	var handleCallback = function(callback, err, result) {
	  try {
	    callback(err, result);
	  } catch(err) {
	    process.nextTick(function() {
	      throw err;
	    });
	  }
	}
	
	/**
	 * Clone the cursor
	 * @method
	 * @return {Cursor}
	 */  
	Cursor.prototype.clone = function() {
	  return this.topology.cursor(this.ns, this.cmd, this.options);
	}
	
	/**
	 * Checks if the cursor is dead
	 * @method
	 * @return {boolean} A boolean signifying if the cursor is dead or not
	 */
	Cursor.prototype.isDead = function() {
	  return this.cursorState.dead == true;
	}
	
	/**
	 * Checks if the cursor was killed by the application
	 * @method
	 * @return {boolean} A boolean signifying if the cursor was killed by the application
	 */
	Cursor.prototype.isKilled = function() {
	  return this.cursorState.killed == true;
	}
	
	/**
	 * Checks if the cursor notified it's caller about it's death
	 * @method
	 * @return {boolean} A boolean signifying if the cursor notified the callback
	 */
	Cursor.prototype.isNotified = function() {
	  return this.cursorState.notified == true;
	}
	
	/**
	 * Returns current buffered documents length
	 * @method
	 * @return {number} The number of items in the buffered documents
	 */
	Cursor.prototype.bufferedCount = function() {
	  return this.cursorState.documents.length - this.cursorState.cursorIndex;
	}
	
	/**
	 * Returns current buffered documents
	 * @method
	 * @return {Array} An array of buffered documents
	 */
	Cursor.prototype.readBufferedDocuments = function(number) {
	  var unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;
	  var length = number < unreadDocumentsLength ? number : unreadDocumentsLength;
	  var elements = this.cursorState.documents.slice(this.cursorState.cursorIndex, this.cursorState.cursorIndex + length);
	  this.cursorState.currentLimit = this.cursorState.currentLimit + length;
	  this.cursorState.cursorIndex = this.cursorState.cursorIndex + length;
	
	  // Transform the doc with passed in transformation method if provided
	  if(this.cursorState.transforms && typeof this.cursorState.transforms.doc == 'function') {
	    // Transform all the elements
	    for(var i = 0; i < elements.length; i++) {
	      elements[i] = this.cursorState.transforms.doc(elements[i]);
	    }
	  }
	
	  // Return elements
	  return elements;
	}
	
	/**
	 * Kill the cursor
	 * @method
	 * @param {resultCallback} callback A callback function
	 */
	Cursor.prototype.kill = function(callback) {
	  // Set cursor to dead
	  this.cursorState.dead = true;
	  this.cursorState.killed = true;
	  // Remove documents
	  this.cursorState.documents = [];
	
	  // If no cursor id just return
	  if(this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init == false) {
	    if(callback) callback(null, null);
	    return;
	  }
	
	  // Execute command
	  this.server.wireProtocolHandler.killCursor(this.bson, this.cursorState.cursorId, this.connection, callback);
	}
	
	/**
	 * Resets the cursor
	 * @method
	 * @return {null}
	 */  
	Cursor.prototype.rewind = function() {
	  if(this.cursorState.init) {
	    if(!this.cursorState.dead) {
	      this.kill();
	    }
	
	    this.cursorState.currentLimit = 0;
	    this.cursorState.init = false;
	    this.cursorState.dead = false;
	    this.cursorState.killed = false;
	    this.cursorState.notified = false;
	    this.cursorState.documents = [];
	    this.cursorState.cursorId = null;
	    this.cursorState.cursorIndex = 0;
	  }  
	}
	
	/**
	 * Validate if the connection is dead and return error
	 */
	var isConnectionDead = function(self, callback) {
	  if(self.connection 
	    && !self.connection.isConnected()) {
	    self.cursorState.notified = true;
	    self.cursorState.killed = true;
	    self.cursorState.documents = [];
	    self.cursorState.cursorIndex = 0;
	    callback(MongoError.create(f('connection to host %s:%s was destroyed', self.connection.host, self.connection.port)))
	    return true;
	  }
	
	  return false;
	}
	
	/**
	 * Validate if the cursor is dead but was not explicitly killed by user
	 */
	var isCursorDeadButNotkilled = function(self, callback) {
	  // Cursor is dead but not marked killed, return null
	  if(self.cursorState.dead && !self.cursorState.killed) {
	    self.cursorState.notified = true;
	    self.cursorState.killed = true;
	    self.cursorState.documents = [];
	    self.cursorState.cursorIndex = 0;
	    handleCallback(callback, null, null);
	    return true;
	  }    
	
	  return false;
	}
	
	/**
	 * Validate if the cursor is dead and was killed by user
	 */
	var isCursorDeadAndKilled = function(self, callback) {
	  if(self.cursorState.dead && self.cursorState.killed) {
	    handleCallback(callback, MongoError.create("cursor is dead"));
	    return true;
	  }  
	
	  return false;
	}
	
	/**
	 * Validate if the cursor was killed by the user
	 */
	var isCursorKilled = function(self, callback) {
	  if(self.cursorState.killed) {
	    self.cursorState.notified = true;
	    self.cursorState.documents = [];
	    self.cursorState.cursorIndex = 0;
	    handleCallback(callback, null, null);
	    return true;
	  }
	
	  return false;
	}
	
	/**
	 * Mark cursor as being dead and notified
	 */
	var setCursorDeadAndNotified = function(self, callback) {
	  self.cursorState.dead = true;
	  self.cursorState.notified = true;
	  self.cursorState.documents = [];
	  self.cursorState.cursorIndex = 0;
	  handleCallback(callback, null, null);  
	}
	
	/**
	 * Mark cursor as being notified
	 */
	var setCursorNotified = function(self, callback) {
	  self.cursorState.notified = true;
	  self.cursorState.documents = [];
	  self.cursorState.cursorIndex = 0;
	  handleCallback(callback, null, null);
	}
	
	var nextFunction = function(self, callback) {
	  // We have notified about it
	  if(self.cursorState.notified) {
	    return callback(new Error('cursor is exhausted'));
	  }
	  // Cursor is killed return null
	  if(isCursorKilled(self, callback)) return;  
	
	  // Cursor is dead but not marked killed, return null
	  if(isCursorDeadButNotkilled(self, callback)) return;
	
	  // We have a dead and killed cursor, attempting to call next should error
	  if(isCursorDeadAndKilled(self, callback)) return;
	
	  // We have just started the cursor
	  if(!self.cursorState.init) {
	    // Topology is not connected, save the call in the provided store to be
	    // Executed at some point when the handler deems it's reconnected
	    if(!self.topology.isConnected(self.options) && self.disconnectHandler != null) {
	      return self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);
	    }
	
	    try {
	      // Get a server
	      self.server = self.topology.getServer(self.options);
	      // Get a connection
	      self.connection = self.server.getConnection();
	      // Get the callbacks
	      self.callbacks = self.server.getCallbacks();
	    } catch(err) {
	      return callback(err);
	    }
	
	    // Set as init
	    self.cursorState.init = true;
	    // Get the right wire protocol command
	    self.query = self.server.wireProtocolHandler.command(self.bson, self.ns, self.cmd, self.cursorState, self.topology, self.options);
	  }
	
	  // Process exhaust messages
	  var processExhaustMessages = function(err, result) {
	    if(err) {
	      self.cursorState.dead = true;
	      self.callbacks.unregister(self.query.requestId);
	      return callback(err);
	    }
	
	    // Concatenate all the documents
	    self.cursorState.documents = self.cursorState.documents.concat(result.documents);
	
	    // If we have no documents left
	    if(Long.ZERO.equals(result.cursorId)) {
	      self.cursorState.cursorId = Long.ZERO;
	      self.callbacks.unregister(self.query.requestId);
	      return nextFunction(self, callback);
	    }
	
	    // Set up next listener
	    self.callbacks.register(result.requestId, processExhaustMessages)
	
	    // Initial result
	    if(self.cursorState.cursorId == null) {
	      self.cursorState.cursorId = result.cursorId;
	      nextFunction(self, callback);
	    }
	  }    
	
	  // If we have exhaust
	  if(self.cmd.exhaust && self.cursorState.cursorId == null) {
	    // Handle all the exhaust responses
	    self.callbacks.register(self.query.requestId, processExhaustMessages);
	    // Write the initial command out
	    return self.connection.write(self.query.toBin());
	  } else if(self.cmd.exhaust && self.cursorState.cursorIndex < self.cursorState.documents.length) {
	    return handleCallback(callback, null, self.cursorState.documents[self.cursorState.cursorIndex++]);
	  } else if(self.cmd.exhaust && Long.ZERO.equals(self.cursorState.cursorId)) {
	    self.callbacks.unregister(self.query.requestId);
	    return setCursorNotified(self, callback);
	  } else if(self.cmd.exhaust) {
	    return setTimeout(function() {
	      if(Long.ZERO.equals(self.cursorState.cursorId)) return;
	      nextFunction(self, callback);
	    }, 1);
	  }
	
	  // If we don't have a cursorId execute the first query
	  if(self.cursorState.cursorId == null) {
	    // Check if connection is dead and return if not possible to
	    // execute the query against the db
	    if(isConnectionDead(self, callback)) return;
	
	    // Check if topology is destroyed
	    if(self.topology.isDestroyed()) return callback(new MongoError(f('connection destroyed, not possible to instantiate cursor')));
	    
	    // query, cmd, options, cursorState, callback
	    execInitialQuery(self, self.query, self.cmd, self.options, self.cursorState, self.connection, self.logger, self.callbacks, function(err, r) {
	      if(err) return handleCallback(callback, err, null);
	      if(self.cursorState.documents.length == 0 && !self.cmd.tailable && !self.cmd.awaitData) {
	        return setCursorNotified(self, callback);
	      }
	
	      nextFunction(self, callback);
	    });
	  } else if(self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
	      return setCursorDeadAndNotified(self, callback);
	  } else if(self.cursorState.cursorIndex == self.cursorState.documents.length
	      && !Long.ZERO.equals(self.cursorState.cursorId)) {
	      // Ensure an empty cursor state
	      self.cursorState.documents = [];
	      self.cursorState.cursorIndex = 0;
	
	      // Check if topology is destroyed
	      if(self.topology.isDestroyed()) return callback(new MongoError(f('connection destroyed, not possible to instantiate cursor')));
	
	      // Check if connection is dead and return if not possible to
	      // execute a getmore on this connection
	      if(isConnectionDead(self, callback)) return;
	
	      // Execute the next get more
	      execGetMore(self, function(err, doc) {
	        if(err) return handleCallback(callback, err);
	        if(self.cursorState.documents.length == 0 && Long.ZERO.equals(self.cursorState.cursorId)) self.cursorState.dead = true;
	        
	        // Tailable cursor getMore result, notify owner about it
	        // No attempt is made here to retry, this is left to the user of the
	        // core module to handle to keep core simple
	        if(self.cursorState.documents.length == 0 && self.cmd.tailable) {
	          return handleCallback(callback, MongoError.create({
	              message: "No more documents in tailed cursor"
	            , tailable: self.cmd.tailable
	            , awaitData: self.cmd.awaitData
	          }));
	        }
	
	        if(self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
	          return setCursorDeadAndNotified(self, callback);
	        }
	
	        nextFunction(self, callback);
	      });
	  } else if(self.cursorState.documents.length == self.cursorState.cursorIndex 
	    && self.cmd.tailable) { 
	      return handleCallback(callback, MongoError.create({
	          message: "No more documents in tailed cursor"
	        , tailable: self.cmd.tailable
	        , awaitData: self.cmd.awaitData
	      }));
	  } else if(self.cursorState.documents.length == self.cursorState.cursorIndex 
	      && Long.ZERO.equals(self.cursorState.cursorId)) {
	      setCursorDeadAndNotified(self, callback);
	  } else {
	    if(self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
	      return setCursorDeadAndNotified(self, callback);
	    }
	
	    // Increment the current cursor limit
	    self.cursorState.currentLimit += 1;
	
	    // Get the document
	    var doc = self.cursorState.documents[self.cursorState.cursorIndex++];
	
	    // Transform the doc with passed in transformation method if provided
	    if(self.cursorState.transforms && typeof self.cursorState.transforms.doc == 'function') {
	      doc = self.cursorState.transforms.doc(doc);
	    }
	
	    // Return the document
	    handleCallback(callback, null, doc);
	  }  
	}
	
	/**
	 * Retrieve the next document from the cursor
	 * @method
	 * @param {resultCallback} callback A callback function
	 */
	Cursor.prototype.next = function(callback) {
	  nextFunction(this, callback);
	}
	
	module.exports = Cursor;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 88 */
/*!******************************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/topologies/command_result.js ***!
  \******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var setProperty = __webpack_require__(/*! ../connection/utils */ 79).setProperty
	  , getProperty = __webpack_require__(/*! ../connection/utils */ 79).getProperty
	  , getSingleProperty = __webpack_require__(/*! ../connection/utils */ 79).getSingleProperty;
	
	/**
	 * Creates a new CommandResult instance
	 * @class
	 * @param {object} result CommandResult object
	 * @param {Connection} connection A connection instance associated with this result
	 * @return {CommandResult} A cursor instance
	 */
	var CommandResult = function(result, connection) {
	  this.result = result;
	  this.connection = connection;
	}
	
	/**
	 * Convert CommandResult to JSON
	 * @method
	 * @return {object}
	 */
	CommandResult.prototype.toJSON = function() {
	  return this.result;
	}
	
	/**
	 * Convert CommandResult to String representation
	 * @method
	 * @return {string}
	 */
	CommandResult.prototype.toString = function() {
	  return JSON.stringify(this.toJSON());
	}
	
	module.exports = CommandResult;

/***/ },
/* 89 */
/*!*****************************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/wireprotocol/2_4_support.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var Insert = __webpack_require__(/*! ./commands */ 90).Insert
	  , Update = __webpack_require__(/*! ./commands */ 90).Update
	  , Remove = __webpack_require__(/*! ./commands */ 90).Remove
	  , Query = __webpack_require__(/*! ../connection/commands */ 82).Query
	  , copy = __webpack_require__(/*! ../connection/utils */ 79).copy
	  , KillCursor = __webpack_require__(/*! ../connection/commands */ 82).KillCursor
	  , GetMore = __webpack_require__(/*! ../connection/commands */ 82).GetMore
	  , Query = __webpack_require__(/*! ../connection/commands */ 82).Query
	  , ReadPreference = __webpack_require__(/*! ../topologies/read_preference */ 86)
	  , f = __webpack_require__(/*! util */ 57).format
	  , CommandResult = __webpack_require__(/*! ../topologies/command_result */ 88)
	  , MongoError = __webpack_require__(/*! ../error */ 77)
	  , Long = __webpack_require__(/*! bson */ 51).Long;
	
	// Write concern fields
	var writeConcernFields = ['w', 'wtimeout', 'j', 'fsync'];
	
	var LegacySupport = function() {}
	
	//
	// Needs to support legacy mass insert as well as ordered/unordered legacy
	// emulation
	//
	LegacySupport.prototype.insert = function(topology, ismaster, ns, bson, pool, callbacks, ops, options, callback) {
	  options = options || {};  
	  // Default is ordered execution
	  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
	  var legacy = typeof options.legacy == 'boolean' ? options.legacy : false;
	  ops = Array.isArray(ops) ? ops :[ops];
	
	  // If we have more than a 1000 ops fails
	  if(ops.length > 1000) return callback(new MongoError("exceeded maximum write batch size of 1000"));
	
	  // Write concern
	  var writeConcern = options.writeConcern || {w:1};
	
	  // We are unordered
	  if(!ordered || writeConcern.w == 0) {
	    return executeUnordered('insert', Insert, ismaster, ns, bson, pool, callbacks, ops, options, callback);
	  }
	
	  return executeOrdered('insert', Insert, ismaster, ns, bson, pool, callbacks, ops, options, callback);
	}
	
	LegacySupport.prototype.update = function(topology, ismaster, ns, bson, pool, callbacks, ops, options, callback) {    
	  options = options || {};  
	  // Default is ordered execution
	  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
	  ops = Array.isArray(ops) ? ops :[ops];
	
	  // Write concern
	  var writeConcern = options.writeConcern || {w:1};
	
	  // We are unordered
	  if(!ordered || writeConcern.w == 0) {
	    return executeUnordered('update', Update, ismaster, ns, bson, pool, callbacks, ops, options, callback);
	  }
	
	  return executeOrdered('update', Update, ismaster, ns, bson, pool, callbacks, ops, options, callback);    
	}
	
	LegacySupport.prototype.remove = function(topology, ismaster, ns, bson, pool, callbacks, ops, options, callback) {
	  options = options || {};  
	  // Default is ordered execution
	  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
	  ops = Array.isArray(ops) ? ops :[ops];
	
	  // Write concern
	  var writeConcern = options.writeConcern || {w:1};
	
	  // We are unordered
	  if(!ordered || writeConcern.w == 0) {
	    return executeUnordered('remove', Remove, ismaster, ns, bson, pool, callbacks, ops, options, callback);
	  }
	
	  return executeOrdered('remove', Remove, ismaster, ns, bson, pool, callbacks, ops, options, callback);    
	}
	
	LegacySupport.prototype.killCursor = function(bson, cursorId, connection, callback) {
	  // Create a kill cursor command
	  var killCursor = new KillCursor(bson, [cursorId]);
	  // Execute the kill cursor command
	  if(connection && connection.isConnected()) connection.write(killCursor.toBin());
	  // Set cursor to 0
	  cursorId = Long.ZERO;
	  // Return to caller
	  if(callback) callback(null, null);
	}
	
	LegacySupport.prototype.getMore = function(bson, ns, cursorState, batchSize, raw, connection, callbacks, options, callback) {
	  // Create getMore command
	  var getMore = new GetMore(bson, ns, cursorState.cursorId, {numberToReturn: batchSize});
	
	  // Query callback
	  var queryCallback = function(err, r) {
	    if(err) return callback(err);  
	    
	    // If we have a timed out query or a cursor that was killed
	    if((r.responseFlags & (1 << 0)) != 0) {
	      return callback(new MongoError("cursor killed or timed out"), null);
	    }
	
	    // Set all the values
	    cursorState.documents = r.documents;
	    cursorState.cursorId = r.cursorId;
	    // Return
	    callback(null);
	  }
	
	  // If we have a raw query decorate the function
	  if(raw) {
	    queryCallback.raw = raw;
	  }
	  
	  // Register a callback
	  callbacks.register(getMore.requestId, queryCallback);
	  // Write out the getMore command
	  connection.write(getMore.toBin());
	}
	
	LegacySupport.prototype.command = function(bson, ns, cmd, cursorState, topology, options) {
	  // Establish type of command
	  if(cmd.find) {
	    return setupClassicFind(bson, ns, cmd, cursorState, topology, options)
	  } else if(cursorState.cursorId != null) {
	  } else if(cmd) {
	    return setupCommand(bson, ns, cmd, cursorState, topology, options);
	  } else {
	    throw new MongoError(f("command %s does not return a cursor", JSON.stringify(cmd)));
	  }
	}
	
	//
	// Execute a find command
	var setupClassicFind = function(bson, ns, cmd, cursorState, topology, options) {
	  var readPreference = options.readPreference || new ReadPreference('primary');
	  if(typeof readPreference == 'string') readPreference = new ReadPreference(readPreference);
	  if(!(readPreference instanceof ReadPreference)) throw new MongoError('readPreference must be a ReadPreference instance');
	
	  // Ensure we have at least some options
	  options = options || {};
	  // Set the optional batchSize
	  cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
	  var numberToReturn = 0;
	  
	  // Unpack the limit and batchSize values
	  if(cursorState.limit == 0) {
	    numberToReturn = cursorState.batchSize;
	  } else if(cursorState.limit < 0 || cursorState.limit < cursorState.batchSize || (cursorState.limit > 0 && cursorState.batchSize == 0)) {
	    numberToReturn = cursorState.limit;
	  } else {
	    numberToReturn = cursorState.batchSize;
	  }
	
	  var numberToSkip = cursorState.skip || 0;
	  // Build actual find command
	  var findCmd = {};
	  // Using special modifier
	  var usesSpecialModifier = false;
	
	  // We have a Mongos topology, check if we need to add a readPreference
	  if(topology.type == 'mongos' && readPreference) {
	    findCmd['$readPreference'] = readPreference.toJSON();
	    usesSpecialModifier = true;
	  }
	
	  // Add special modifiers to the query
	  if(cmd.sort) findCmd['orderby'] = cmd.sort, usesSpecialModifier = true;
	  if(cmd.hint) findCmd['$hint'] = cmd.hint, usesSpecialModifier = true;
	  if(cmd.snapshot) findCmd['$snapshot'] = cmd.snapshot, usesSpecialModifier = true;
	  if(cmd.returnKey) findCmd['$returnKey'] = cmd.returnKey, usesSpecialModifier = true;
	  if(cmd.maxScan) findCmd['$maxScan'] = cmd.maxScan, usesSpecialModifier = true;
	  if(cmd.min) findCmd['$min'] = cmd.min, usesSpecialModifier = true;
	  if(cmd.max) findCmd['$max'] = cmd.max, usesSpecialModifier = true;
	  if(cmd.showDiskLoc) findCmd['$showDiskLoc'] = cmd.showDiskLoc, usesSpecialModifier = true;
	  if(cmd.comment) findCmd['$comment'] = cmd.comment, usesSpecialModifier = true;
	  if(cmd.maxTimeMS) findCmd['$maxTimeMS'] = cmd.maxTimeMS, usesSpecialModifier = true;
	
	  // If we have explain, return a single document and close cursor
	  if(cmd.explain) {
	    numberToReturn = -1;
	    usesSpecialModifier = true;
	    findCmd['$explain'] = true;
	  }
	
	  // If we have a special modifier
	  if(usesSpecialModifier) {      
	    findCmd['$query'] = cmd.query;
	  } else {
	    findCmd = cmd.query;
	  }
	
	  // Build Query object
	  var query = new Query(bson, ns, findCmd, {
	      numberToSkip: numberToSkip, numberToReturn: numberToReturn
	    , checkKeys: false, returnFieldSelector: cmd.fields
	  });
	
	  // Set query flags
	  query.slaveOk = readPreference.slaveOk();
	
	  // Set up the option bits for wire protocol
	  if(typeof cmd.tailable == 'boolean') query.tailable = cmd.tailable;
	  if(typeof cmd.oplogReplay == 'boolean') query.oplogReplay = cmd.oplogReplay;
	  if(typeof cmd.noCursorTimeout == 'boolean') query.noCursorTimeout = cmd.noCursorTimeout;
	  if(typeof cmd.awaitData == 'boolean') query.awaitData = cmd.awaitData;
	  if(typeof cmd.exhaust == 'boolean') query.exhaust = cmd.exhaust;
	  if(typeof cmd.partial == 'boolean') query.partial = cmd.partial;
	  // Return the query
	  return query;
	}  
	
	//
	// Set up a command cursor
	var setupCommand = function(bson, ns, cmd, cursorState, topology, options) {
	  var readPreference = options.readPreference || new ReadPreference('primary');
	  if(typeof readPreference == 'string') readPreference = new ReadPreference(readPreference);
	  if(!(readPreference instanceof ReadPreference)) throw new MongoError('readPreference must be a ReadPreference instance');
	
	  // Set empty options object
	  options = options || {}
	
	  // Final query
	  var finalCmd = {};
	  for(var name in cmd) {
	    finalCmd[name] = cmd[name];
	  }
	
	  // Build command namespace
	  var parts = ns.split(/\./);
	
	  // We have a Mongos topology, check if we need to add a readPreference
	  if(topology.type == 'mongos' && readPreference) {
	    finalCmd['$readPreference'] = readPreference.toJSON();
	  }
	
	  // Build Query object
	  var query = new Query(bson, f('%s.$cmd', parts.shift()), finalCmd, {
	      numberToSkip: 0, numberToReturn: -1
	    , checkKeys: false
	  });
	
	  // Set query flags
	  query.slaveOk = readPreference.slaveOk();
	
	  // Return the query
	  return query;
	}
	
	/**
	 * @ignore
	 */
	var bindToCurrentDomain = function(callback) {
	  var domain = process.domain;
	  if(domain == null || callback == null) {
	    return callback;
	  } else {
	    return domain.bind(callback);
	  }
	}
	
	var hasWriteConcern = function(writeConcern) {
	  if(writeConcern.w 
	    || writeConcern.wtimeout 
	    || writeConcern.j == true 
	    || writeConcern.fsync == true 
	    || Object.keys(writeConcern).length == 0) {
	    return true;
	  }
	  return false;
	}
	
	var cloneWriteConcern = function(writeConcern) {
	  var wc = {};
	  if(writeConcern.w != null) wc.w = writeConcern.w;
	  if(writeConcern.wtimeout != null) wc.wtimeout = writeConcern.wtimeout;
	  if(writeConcern.j != null) wc.j = writeConcern.j;
	  if(writeConcern.fsync != null) wc.fsync = writeConcern.fsync;
	  return wc;
	}
	
	//
	// Aggregate up all the results
	//
	var aggregateWriteOperationResults = function(opType, ops, results, connection) {
	  var finalResult = { ok: 1, n: 0 }
	  
	  // Map all the results coming back
	  for(var i = 0; i < results.length; i++) {
	    var result = results[i];
	    var op = ops[i];
	
	    if((result.upserted || (result.updatedExisting == false)) && finalResult.upserted == null) {
	      finalResult.upserted = [];
	    }
	
	    // Push the upserted document to the list of upserted values
	    if(result.upserted) {
	      finalResult.upserted.push({index: i, _id: result.upserted});
	    }
	
	    // We have an upsert where we passed in a _id
	    if(result.updatedExisting == false && result.n == 1 && result.upserted == null) {
	      finalResult.upserted.push({index: i, _id: op.q._id});
	    }
	
	    // We have an insert command
	    if(result.ok == 1 && opType == 'insert' && result.err == null) {
	      finalResult.n = finalResult.n + 1;
	    }
	
	    // We have a command error
	    if(result != null && result.ok == 0 || result.err || result.errmsg) {
	      if(result.ok == 0) finalResult.ok = 0;
	      finalResult.code = result.code;
	      finalResult.errmsg = result.errmsg || result.err || result.errMsg;
	
	      // Check if we have a write error
	      if(result.code == 11000 
	        || result.code == 11001 
	        || result.code == 12582
	        || result.code == 16544
	        || result.code == 16538
	        || result.code == 16542
	        || result.code == 14
	        || result.code == 13511) {
	        if(finalResult.writeErrors == null) finalResult.writeErrors = [];
	        finalResult.writeErrors.push({
	            index: i
	          , code: result.code
	          , errmsg: result.errmsg || result.err || result.errMsg
	        });
	      } else {
	        finalResult.writeConcernError = {
	            code: result.code
	          , errmsg: result.errmsg || result.err || result.errMsg            
	        }
	      }
	    } else if(typeof result.n == 'number') {
	      finalResult.n += result.n;
	    } else {
	      finalResult.n += 1;
	    }
	    
	    // Result as expected
	    if(result != null && result.lastOp) finalResult.lastOp = result.lastOp;
	  }
	
	  // Return finalResult aggregated results
	  return new CommandResult(finalResult, connection);
	}
	
	//
	// Execute all inserts in an ordered manner
	//
	var executeOrdered = function(opType ,command, ismaster, ns, bson, pool, callbacks, ops, options, callback) {
	  var _ops = ops.slice(0);
	  // Bind to current domain
	  callback = bindToCurrentDomain(callback);
	  // Collect all the getLastErrors
	  var getLastErrors = [];
	
	  // Execute an operation
	  var executeOp = function(list, _callback) {
	    // Get a pool connection
	    var connection = pool.get();
	    // No more items in the list
	    if(list.length == 0) return _callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, connection));
	    
	    // Get the first operation
	    var doc = list.shift();      
	    
	    // Create an insert command
	    var op = new command(Query.getRequestId(), ismaster, bson, ns, [doc], options);
	    // Write concern
	    var optionWriteConcern = options.writeConcern || {w:1};
	    // Final write concern
	    var writeConcern = cloneWriteConcern(optionWriteConcern);
	
	    // Get the db name
	    var db = ns.split('.').shift();
	
	    // Error out if no connection available
	    if(connection == null) 
	      return _callback(new MongoError("no connection available"));
	
	    try {
	      // Execute the insert
	      connection.write(op.toBin());
	
	      // If write concern 0 don't fire getLastError
	      if(hasWriteConcern(writeConcern)) {
	        var getLastErrorCmd = {getlasterror: 1};
	        // Merge all the fields
	        for(var i = 0; i < writeConcernFields.length; i++) {
	          if(writeConcern[writeConcernFields[i]] != null)
	            getLastErrorCmd[writeConcernFields[i]] = writeConcern[writeConcernFields[i]];
	        }
	
	        // Create a getLastError command
	        var getLastErrorOp = new Query(bson, f("%s.$cmd", db), getLastErrorCmd, {numberToReturn: -1});
	        // Write the lastError message
	        connection.write(getLastErrorOp.toBin());
	        // Register the callback
	        callbacks.register(getLastErrorOp.requestId, function(err, result) {
	          if(err) return callback(err);
	          // Get the document
	          var doc = result.documents[0];
	          // Save the getLastError document
	          getLastErrors.push(doc);
	          // If we have an error terminate
	          if(doc.ok == 0 || doc.err || doc.errmsg) return callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, connection));
	          // Execute the next op in the list
	          executeOp(list, callback);
	        });          
	      }
	    } catch(err) {
	      if(typeof err == 'string') err = new MongoError(err);
	      // We have a serialization error, rewrite as a write error to have same behavior as modern
	      // write commands
	      getLastErrors.push({ ok: 1, errmsg: err.message, code: 14 });
	      // Return due to an error
	      return callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, connection));
	    }
	  }
	
	  // Execute the operations
	  executeOp(_ops, callback);
	}
	
	var executeUnordered = function(opType, command, ismaster, ns, bson, pool, callbacks, ops, options, callback) {
	  // Bind to current domain
	  callback = bindToCurrentDomain(callback);
	  // Total operations to write
	  var totalOps = ops.length;
	  // Collect all the getLastErrors
	  var getLastErrors = [];
	  // Write concern
	  var optionWriteConcern = options.writeConcern || {w:1};
	  // Final write concern
	  var writeConcern = cloneWriteConcern(optionWriteConcern);
	
	  // Execute all the operations
	  for(var i = 0; i < ops.length; i++) {
	    // Create an insert command
	    var op = new command(Query.getRequestId(), ismaster, bson, ns, [ops[i]], options);
	    // Get db name
	    var db = ns.split('.').shift();
	
	    // Get a pool connection
	    var connection = pool.get();
	
	    // Error out if no connection available
	    if(connection == null) 
	      return _callback(new MongoError("no connection available"));
	
	    try {
	      // Execute the insert
	      connection.write(op.toBin());
	      // If write concern 0 don't fire getLastError
	      if(hasWriteConcern(writeConcern)) {
	        var getLastErrorCmd = {getlasterror: 1};
	        // Merge all the fields
	        for(var j = 0; j < writeConcernFields.length; j++) {
	          if(writeConcern[writeConcernFields[j]] != null)
	            getLastErrorCmd[writeConcernFields[j]] = writeConcern[writeConcernFields[j]];
	        }
	
	        // Create a getLastError command
	        var getLastErrorOp = new Query(bson, f("%s.$cmd", db), getLastErrorCmd, {numberToReturn: -1});
	        // Write the lastError message
	        connection.write(getLastErrorOp.toBin());
	  
	        // Give the result from getLastError the right index      
	        var callbackOp = function(_index) {
	          return function(err, result) {
	            // Update the number of operations executed
	            totalOps = totalOps - 1;
	            // Save the getLastError document
	            getLastErrors[_index] = result.documents[0];
	            // Check if we are done
	            if(totalOps == 0) {
	              callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, connection));
	            }
	          }
	        }
	
	        // Register the callback
	        callbacks.register(getLastErrorOp.requestId, callbackOp(i));
	      }
	    } catch(err) {
	      if(typeof err == 'string') err = new MongoError(err);
	      // Update the number of operations executed
	      totalOps = totalOps - 1;
	      // We have a serialization error, rewrite as a write error to have same behavior as modern
	      // write commands
	      getLastErrors[i] = { ok: 1, errmsg: err.message, code: 14 };
	      // Check if we are done
	      if(totalOps == 0) {
	        callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, connection));
	      }
	    }
	  }
	
	  // Empty w:0 return
	  if(writeConcern 
	    && writeConcern.w == 0 && callback) {
	    callback(null, null);
	  }
	}
	
	module.exports = LegacySupport;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 90 */
/*!**************************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/wireprotocol/commands.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";
	
	var MongoError = __webpack_require__(/*! ../error */ 77);
	
	// Wire command operation ids
	var OP_UPDATE = 2001;
	var OP_INSERT = 2002;
	var OP_DELETE = 2006;
	
	var Insert = function(requestId, ismaster, bson, ns, documents, options) {
	  // Basic options needed to be passed in
	  if(ns == null) throw new MongoError("ns must be specified for query");
	  if(!Array.isArray(documents) || documents.length == 0) throw new MongoError("documents array must contain at least one document to insert");
	
	  // Validate that we are not passing 0x00 in the colletion name
	  if(!!~ns.indexOf("\x00")) {
	    throw new MongoError("namespace cannot contain a null character");
	  }
	
	  // Set internal
	  this.requestId = requestId;
	  this.bson = bson;
	  this.ns = ns;
	  this.documents = documents;
	  this.ismaster = ismaster;
	
	  // Ensure empty options
	  options = options || {};
	
	  // Unpack options
	  this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
	  this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : true;
	  this.continueOnError = typeof options.continueOnError == 'boolean' ? options.continueOnError : false;
	  // Set flags
	  this.flags = this.continueOnError ? 1 : 0;
	}
	
	// To Binary
	Insert.prototype.toBin = function() {
	  // Calculate total length of the document
	  var length = 4 + Buffer.byteLength(this.ns) + 1 + (4 * 4);
	
	  // Calculate the size of all documents
	  for(var i = 0; i < this.documents.length; i++) {
	    var docsize = this.bson.calculateObjectSize(this.documents[i], this.serializeFunctions, true);
	
	    // Document is larger than maxBsonObjectSize, terminate serialization
	    if(docsize > this.ismaster.maxBsonObjectSize) {
	      throw new MongoError("Document exceeds maximum allowed bson size of " + this.ismaster.maxBsonObjectSize + " bytes");        
	    }
	
	    // Add to total command size
	    length += docsize;
	  }
	
	  // Command is larger than maxMessageSizeBytes terminate serialization
	  if(length > this.ismaster.maxBsonObjectSize) {
	    throw new MongoError("Command exceeds maximum message size of " + this.ismaster.maxMessageSizeBytes + " bytes");
	  }
	
	  // Create command buffer
	  var buffer = new Buffer(length);
	  var index = 0;
	  
	  // Write header length
	  buffer[index + 3] = (length >> 24) & 0xff;
	  buffer[index + 2] = (length >> 16) & 0xff;
	  buffer[index + 1] = (length >> 8) & 0xff;
	  buffer[index] = (length) & 0xff;
	  index = index + 4;
	
	  // Write header requestId
	  buffer[index + 3] = (this.requestId >> 24) & 0xff;
	  buffer[index + 2] = (this.requestId >> 16) & 0xff;
	  buffer[index + 1] = (this.requestId >> 8) & 0xff;
	  buffer[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // No flags
	  buffer[index + 3] = (0 >> 24) & 0xff;
	  buffer[index + 2] = (0 >> 16) & 0xff;
	  buffer[index + 1] = (0 >> 8) & 0xff;
	  buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Operation
	  buffer[index + 3] = (OP_INSERT >> 24) & 0xff;
	  buffer[index + 2] = (OP_INSERT >> 16) & 0xff;
	  buffer[index + 1] = (OP_INSERT >> 8) & 0xff;
	  buffer[index] = (OP_INSERT) & 0xff;
	  index = index + 4;
	
	  // Flags
	  buffer[index + 3] = (this.flags >> 24) & 0xff;
	  buffer[index + 2] = (this.flags >> 16) & 0xff;
	  buffer[index + 1] = (this.flags >> 8) & 0xff;
	  buffer[index] = (this.flags) & 0xff;
	  index = index + 4;
	
	  // Write collection name
	  index = index + buffer.write(this.ns, index, 'utf8') + 1;
	  buffer[index - 1] = 0;
	
	  // Write all the bson documents to the buffer at the index offset
	  for(var i = 0; i < this.documents.length; i++) {
	    // Serialize the entry
	    var newIndex = this.bson.serializeWithBufferAndIndex(this.documents[i], this.checkKeys, buffer, index, this.serializeFunctions);
	    var docSize = newIndex - index + 1;
	    // Write the doc size
	    buffer[index + 3] = (docSize >> 24) & 0xff;
	    buffer[index + 2] = (docSize >> 16) & 0xff;
	    buffer[index + 1] = (docSize >> 8) & 0xff;
	    buffer[index] = (docSize) & 0xff;
	    // Adjust index
	    index = index + docSize;
	    // Add terminating 0 for the object
	    buffer[index - 1] = 0;      
	  }
	
	  return buffer;
	}
	
	var Update = function(requestId, ismaster, bson, ns, update, options) {  
	  // Basic options needed to be passed in
	  if(ns == null) throw new MongoError("ns must be specified for query");
	
	  // Ensure empty options
	  options = options || {};
	
	  // Set internal
	  this.requestId = requestId;
	  this.bson = bson;
	  this.ns = ns;
	  this.ismaster = ismaster;
	
	  // Unpack options
	  this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
	  this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : false;
	
	  // Unpack the update document
	  this.upsert = typeof update[0].upsert == 'boolean' ? update[0].upsert : false;
	  this.multi = typeof update[0].multi == 'boolean' ? update[0].multi : false;
	  this.q = update[0].q;
	  this.u = update[0].u;
	
	  // Create flag value
	  this.flags = this.upsert ? 1 : 0;
	  this.flags = this.multi ? this.flags | 2 : this.flags;
	}
	
	// To Binary
	Update.prototype.toBin = function() {
	  // Calculate total length of the document
	  var length = (4 * 4) + 4 + Buffer.byteLength(this.ns) + 1 + 4;
	
	  // Calculate the two object sizes
	  var qSize = this.bson.calculateObjectSize(this.q, this.serializeFunctions, true);
	  var uSize = this.bson.calculateObjectSize(this.u, this.serializeFunctions, true);
	
	  // Update the length
	  length = length + qSize + uSize;
	  
	  // Create command buffer
	  var buffer = new Buffer(length);
	  var index = 0;
	
	  // Write header length
	  buffer[index + 3] = (length >> 24) & 0xff;
	  buffer[index + 2] = (length >> 16) & 0xff;
	  buffer[index + 1] = (length >> 8) & 0xff;
	  buffer[index] = (length) & 0xff;
	  index = index + 4;
	
	  // Write header requestId
	  buffer[index + 3] = (this.requestId >> 24) & 0xff;
	  buffer[index + 2] = (this.requestId >> 16) & 0xff;
	  buffer[index + 1] = (this.requestId >> 8) & 0xff;
	  buffer[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // No flags
	  buffer[index + 3] = (0 >> 24) & 0xff;
	  buffer[index + 2] = (0 >> 16) & 0xff;
	  buffer[index + 1] = (0 >> 8) & 0xff;
	  buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Operation
	  buffer[index + 3] = (OP_UPDATE >> 24) & 0xff;
	  buffer[index + 2] = (OP_UPDATE >> 16) & 0xff;
	  buffer[index + 1] = (OP_UPDATE >> 8) & 0xff;
	  buffer[index] = (OP_UPDATE) & 0xff;
	  index = index + 4;
	
	  // Write ZERO
	  buffer[index + 3] = (0 >> 24) & 0xff;
	  buffer[index + 2] = (0 >> 16) & 0xff;
	  buffer[index + 1] = (0 >> 8) & 0xff;
	  buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Write collection name
	  index = index + buffer.write(this.ns, index, 'utf8') + 1;
	  buffer[index - 1] = 0;
	
	  // Flags
	  buffer[index + 3] = (this.flags >> 24) & 0xff;
	  buffer[index + 2] = (this.flags >> 16) & 0xff;
	  buffer[index + 1] = (this.flags >> 8) & 0xff;
	  buffer[index] = (this.flags) & 0xff;
	  index = index + 4;
	
	  // Serialize the selector
	  var length = this.bson.serializeWithBufferAndIndex(this.q, this.checkKeys, buffer, index, this.serializeFunctions) - index + 1;
	  buffer[index + 3] = (length >> 24) & 0xff;
	  buffer[index + 2] = (length >> 16) & 0xff;
	  buffer[index + 1] = (length >> 8) & 0xff;
	  buffer[index] = (length) & 0xff;
	  index = index + length;
	
	  // Serialize the update statement
	  length = this.bson.serializeWithBufferAndIndex(this.u, false, buffer, index, this.serializeFunctions) - index + 1;
	  buffer[index + 3] = (length >> 24) & 0xff;
	  buffer[index + 2] = (length >> 16) & 0xff;
	  buffer[index + 1] = (length >> 8) & 0xff;
	  buffer[index] = (length) & 0xff;  
	  index = index + length;
	
	  // Return the buffer
	  return buffer;
	}
	
	
	var Remove = function(requestId, ismaster, bson, ns, remove, options) {  
	  // Basic options needed to be passed in
	  if(ns == null) throw new MongoError("ns must be specified for query");
	
	  // Ensure empty options
	  options = options || {};
	
	  // Set internal
	  this.requestId = requestId;
	  this.bson = bson;
	  this.ns = ns;
	  this.ismaster = ismaster;
	
	  // Unpack options
	  this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
	  this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : false;
	
	  // Unpack the update document
	  this.limit = typeof remove[0].limit == 'number' ? remove[0].limit : 1;
	  this.q = remove[0].q;
	
	  // Create flag value
	  this.flags = this.limit == 1 ? 1 : 0;
	}
	
	// To Binary
	Remove.prototype.toBin = function() {
	  // Calculate total length of the document
	  var length = (4 * 4) + 4 + Buffer.byteLength(this.ns) + 1 + 4;
	
	  // Calculate the two object sizes
	  var qSize = this.bson.calculateObjectSize(this.q, this.serializeFunctions, true);
	
	  // Update the length
	  length = length + qSize;
	  // Create command buffer
	  var buffer = new Buffer(length);
	  var index = 0;
	
	  // Write header length
	  buffer[index + 3] = (length >> 24) & 0xff;
	  buffer[index + 2] = (length >> 16) & 0xff;
	  buffer[index + 1] = (length >> 8) & 0xff;
	  buffer[index] = (length) & 0xff;
	  index = index + 4;
	
	  // Write header requestId
	  buffer[index + 3] = (this.requestId >> 24) & 0xff;
	  buffer[index + 2] = (this.requestId >> 16) & 0xff;
	  buffer[index + 1] = (this.requestId >> 8) & 0xff;
	  buffer[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // No flags
	  buffer[index + 3] = (0 >> 24) & 0xff;
	  buffer[index + 2] = (0 >> 16) & 0xff;
	  buffer[index + 1] = (0 >> 8) & 0xff;
	  buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Operation
	  buffer[index + 3] = (OP_DELETE >> 24) & 0xff;
	  buffer[index + 2] = (OP_DELETE >> 16) & 0xff;
	  buffer[index + 1] = (OP_DELETE >> 8) & 0xff;
	  buffer[index] = (OP_DELETE) & 0xff;
	  index = index + 4;
	
	  // Write ZERO
	  buffer[index + 3] = (0 >> 24) & 0xff;
	  buffer[index + 2] = (0 >> 16) & 0xff;
	  buffer[index + 1] = (0 >> 8) & 0xff;
	  buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Write collection name
	  index = index + buffer.write(this.ns, index, 'utf8') + 1;
	  buffer[index - 1] = 0;
	
	  // Write ZERO
	  buffer[index + 3] = (this.flags >> 24) & 0xff;
	  buffer[index + 2] = (this.flags >> 16) & 0xff;
	  buffer[index + 1] = (this.flags >> 8) & 0xff;
	  buffer[index] = (this.flags) & 0xff;
	  index = index + 4;
	
	  // Serialize the selector
	  var length = this.bson.serializeWithBufferAndIndex(this.q, this.checkKeys, buffer, index, this.serializeFunctions) - index + 1;
	  buffer[index + 3] = (length >> 24) & 0xff;
	  buffer[index + 2] = (length >> 16) & 0xff;
	  buffer[index + 1] = (length >> 8) & 0xff;
	  buffer[index] = (length) & 0xff;  
	  index = index + length;
	
	  // Return the buffer
	  return buffer;
	}
	
	module.exports = {
	    Insert: Insert
	  , Update: Update
	  , Remove: Remove
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 91 */
/*!*****************************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/wireprotocol/2_6_support.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var Insert = __webpack_require__(/*! ./commands */ 90).Insert
	  , Update = __webpack_require__(/*! ./commands */ 90).Update
	  , Remove = __webpack_require__(/*! ./commands */ 90).Remove
	  , Query = __webpack_require__(/*! ../connection/commands */ 82).Query
	  , copy = __webpack_require__(/*! ../connection/utils */ 79).copy
	  , KillCursor = __webpack_require__(/*! ../connection/commands */ 82).KillCursor
	  , GetMore = __webpack_require__(/*! ../connection/commands */ 82).GetMore
	  , Query = __webpack_require__(/*! ../connection/commands */ 82).Query
	  , ReadPreference = __webpack_require__(/*! ../topologies/read_preference */ 86)
	  , f = __webpack_require__(/*! util */ 57).format
	  , CommandResult = __webpack_require__(/*! ../topologies/command_result */ 88)
	  , MongoError = __webpack_require__(/*! ../error */ 77)
	  , Long = __webpack_require__(/*! bson */ 51).Long;
	
	var LegacySupport = function() {}
	
	//
	// Execute a write operation
	var executeWrite = function(topology, type, opsField, ns, ops, options, callback) {
	  if(ops.length == 0) throw new MongoError("insert must contain at least one document");
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  // Split the ns up to get db and collection
	  var p = ns.split(".");
	  var d = p.shift();
	  // Options
	  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
	  var writeConcern = options.writeConcern || {};
	  // return skeleton
	  var writeCommand = {};
	  writeCommand[type] = p.join('.');
	  writeCommand[opsField] = ops;
	  writeCommand.ordered = ordered;
	  writeCommand.writeConcern = writeConcern;    
	
	  // Options object
	  var opts = {};
	  if(type == 'insert') opts.checkKeys = true;
	  // Ensure we support serialization of functions
	  if(options.serializeFunctions) opts.serializeFunctions = options.serializeFunctions;
	  // Execute command
	  topology.command(f("%s.$cmd", d), writeCommand, opts, callback);    
	}
	
	//
	// Needs to support legacy mass insert as well as ordered/unordered legacy
	// emulation
	//
	LegacySupport.prototype.insert = function(topology, ismaster, ns, bson, pool, callbacks, ops, options, callback) {
	  executeWrite(topology, 'insert', 'documents', ns, ops, options, callback);
	}
	
	LegacySupport.prototype.update = function(topology, ismaster, ns, bson, pool, callbacks, ops, options, callback) {    
	  executeWrite(topology, 'update', 'updates', ns, ops, options, callback);
	}  
	
	LegacySupport.prototype.remove = function(topology, ismaster, ns, bson, pool, callbacks, ops, options, callback) {
	  executeWrite(topology, 'delete', 'deletes', ns, ops, options, callback);
	}
	
	LegacySupport.prototype.killCursor = function(bson, cursorId, connection, callback) {
	  // Create a kill cursor command
	  var killCursor = new KillCursor(bson, [cursorId]);
	  // Execute the kill cursor command
	  if(connection && connection.isConnected()) connection.write(killCursor.toBin());
	  // Set cursor to 0
	  cursorId = Long.ZERO;
	  // Return to caller
	  if(callback) callback(null, null);
	}
	
	LegacySupport.prototype.getMore = function(bson, ns, cursorState, batchSize, raw, connection, callbacks, options, callback) {
	  // Create getMore command
	  var getMore = new GetMore(bson, ns, cursorState.cursorId, {numberToReturn: batchSize});
	
	  // Query callback
	  var queryCallback = function(err, r) {
	    if(err) return callback(err);
	
	    // If we have a timed out query or a cursor that was killed
	    if((r.responseFlags & (1 << 0)) != 0) {
	      return callback(new MongoError("cursor killed or timed out"), null);
	    }
	
	    // Set all the values
	    cursorState.documents = r.documents;
	    cursorState.cursorId = r.cursorId;
	    // Return
	    callback(null);
	  }
	
	  // If we have a raw query decorate the function
	  if(raw) {
	    queryCallback.raw = raw;
	  }
	  
	  // Register a callback
	  callbacks.register(getMore.requestId, queryCallback);
	  // Write out the getMore command
	  connection.write(getMore.toBin());
	}
	
	LegacySupport.prototype.command = function(bson, ns, cmd, cursorState, topology, options) {
	  // Establish type of command
	  if(cmd.find) {
	    return setupClassicFind(bson, ns, cmd, cursorState, topology, options)
	  } else if(cursorState.cursorId != null) {
	  } else if(cmd) {
	    return setupCommand(bson, ns, cmd, cursorState, topology, options);
	  } else {
	    throw new MongoError(f("command %s does not return a cursor", JSON.stringify(cmd)));
	  }
	}
	
	//
	// Execute a find command
	var setupClassicFind = function(bson, ns, cmd, cursorState, topology, options) {
	  var readPreference = options.readPreference || new ReadPreference('primary');
	  if(typeof readPreference == 'string') readPreference = new ReadPreference(readPreference);
	  if(!(readPreference instanceof ReadPreference)) throw new MongoError('readPreference must be a ReadPreference instance');
	
	  // Ensure we have at least some options
	  options = options || {};
	  // Set the optional batchSize
	  cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
	  var numberToReturn = 0;
	  
	  // Unpack the limit and batchSize values
	  if(cursorState.limit == 0) {
	    numberToReturn = cursorState.batchSize;
	  } else if(cursorState.limit < 0 || cursorState.limit < cursorState.batchSize || (cursorState.limit > 0 && cursorState.batchSize == 0)) {
	    numberToReturn = cursorState.limit;
	  } else {
	    numberToReturn = cursorState.batchSize;
	  }
	
	  var numberToSkip = cursorState.skip || 0;
	  // Build actual find command
	  var findCmd = {};
	  // Using special modifier
	  var usesSpecialModifier = false;
	
	  // We have a Mongos topology, check if we need to add a readPreference
	  if(topology.type == 'mongos' && readPreference) {
	    findCmd['$readPreference'] = readPreference.toJSON();
	    usesSpecialModifier = true;
	  }
	
	  // Add special modifiers to the query
	  if(cmd.sort) findCmd['orderby'] = cmd.sort, usesSpecialModifier = true;
	  if(cmd.hint) findCmd['$hint'] = cmd.hint, usesSpecialModifier = true;
	  if(cmd.snapshot) findCmd['$snapshot'] = cmd.snapshot, usesSpecialModifier = true;
	  if(cmd.returnKey) findCmd['$returnKey'] = cmd.returnKey, usesSpecialModifier = true;
	  if(cmd.maxScan) findCmd['$maxScan'] = cmd.maxScan, usesSpecialModifier = true;
	  if(cmd.min) findCmd['$min'] = cmd.min, usesSpecialModifier = true;
	  if(cmd.max) findCmd['$max'] = cmd.max, usesSpecialModifier = true;
	  if(cmd.showDiskLoc) findCmd['$showDiskLoc'] = cmd.showDiskLoc, usesSpecialModifier = true;
	  if(cmd.comment) findCmd['$comment'] = cmd.comment, usesSpecialModifier = true;
	  if(cmd.maxTimeMS) findCmd['$maxTimeMS'] = cmd.maxTimeMS, usesSpecialModifier = true;
	
	  // If we have explain, return a single document and close cursor
	  if(cmd.explain) {
	    numberToReturn = -1;
	    usesSpecialModifier = true;
	    findCmd['$explain'] = true;
	  }
	
	  // If we have a special modifier
	  if(usesSpecialModifier) {      
	    findCmd['$query'] = cmd.query;
	  } else {
	    findCmd = cmd.query;
	  }
	
	  // Build Query object
	  var query = new Query(bson, ns, findCmd, {
	      numberToSkip: numberToSkip, numberToReturn: numberToReturn
	    , checkKeys: false, returnFieldSelector: cmd.fields
	  });
	
	  // Set query flags
	  query.slaveOk = readPreference.slaveOk();
	
	  // Set up the option bits for wire protocol
	  if(typeof cmd.tailable == 'boolean') query.tailable = cmd.tailable;
	  if(typeof cmd.oplogReplay == 'boolean') query.oplogReplay = cmd.oplogReplay;
	  if(typeof cmd.noCursorTimeout == 'boolean') query.noCursorTimeout = cmd.noCursorTimeout;
	  if(typeof cmd.awaitData == 'boolean') query.awaitData = cmd.awaitData;
	  if(typeof cmd.exhaust == 'boolean') query.exhaust = cmd.exhaust;
	  if(typeof cmd.partial == 'boolean') query.partial = cmd.partial;
	  // Return the query
	  return query;
	}  
	
	//
	// Set up a command cursor
	var setupCommand = function(bson, ns, cmd, cursorState, topology, options) {
	  var readPreference = options.readPreference || new ReadPreference('primary');
	  if(typeof readPreference == 'string') readPreference = new ReadPreference(readPreference);
	  if(!(readPreference instanceof ReadPreference)) throw new MongoError('readPreference must be a ReadPreference instance');
	
	  // Set empty options object
	  options = options || {}
	
	  // Final query
	  var finalCmd = {};
	  for(var name in cmd) {
	    finalCmd[name] = cmd[name];
	  }
	
	  // Build command namespace
	  var parts = ns.split(/\./);
	
	  // We have a Mongos topology, check if we need to add a readPreference
	  if(topology.type == 'mongos' && readPreference) {
	    finalCmd['$readPreference'] = readPreference.toJSON();
	  }
	
	  // Build Query object
	  var query = new Query(bson, f('%s.$cmd', parts.shift()), finalCmd, {
	      numberToSkip: 0, numberToReturn: -1
	    , checkKeys: false
	  });
	
	  // Set query flags
	  query.slaveOk = readPreference.slaveOk();
	
	  // Return the query
	  return query;
	}
	
	/**
	 * @ignore
	 */
	var bindToCurrentDomain = function(callback) {
	  var domain = process.domain;
	  if(domain == null || callback == null) {
	    return callback;
	  } else {
	    return domain.bind(callback);
	  }
	}
	
	module.exports = LegacySupport;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 92 */
/*!***********************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/topologies/session.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var inherits = __webpack_require__(/*! util */ 57).inherits
	  , f = __webpack_require__(/*! util */ 57).format
	  , EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter;
	
	/**
	 * Creates a new Authentication Session
	 * @class
	 * @param {object} [options] Options for the session
	 * @param {{Server}|{ReplSet}|{Mongos}} topology The topology instance underpinning the session
	 */
	var Session = function(options, topology) {
	  this.options = options;
	  this.topology = topology;
	  
	  // Add event listener
	  EventEmitter.call(this);
	}
	
	inherits(Session, EventEmitter);
	
	/**
	 * Execute a command
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {object} cmd The command hash
	 * @param {object} [options.readPreference] Specify read preference if command supports it
	 * @param {object} [options.connection] Specify connection object to execute command against
	 * @param {opResultCallback} callback A callback function
	 */
	Session.prototype.command = function(ns, cmd, options, callback) {
	  this.topology.command(ns, cmd, options, callback);
	}
	
	/**
	 * Insert one or more documents
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of documents to insert
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {opResultCallback} callback A callback function
	 */
	Session.prototype.insert = function(ns, ops, options, callback) {
	  this.topology.insert(ns, ops, options, callback);
	}
	
	/**
	 * Perform one or more update operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of updates
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {opResultCallback} callback A callback function
	 */
	Session.prototype.update = function(ns, ops, options, callback) {
	  this.topology.update(ns, ops, options, callback);
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of removes
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {opResultCallback} callback A callback function
	 */
	Session.prototype.remove = function(ns, ops, options, callback) {
	  this.topology.remove(ns, ops, options, callback);
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {{object}|{Long}} cmd Can be either a command returning a cursor or a cursorId
	 * @param {object} [options.batchSize=0] Batchsize for the operation
	 * @param {array} [options.documents=[]] Initial documents list for cursor
	 * @param {boolean} [options.tailable=false] Tailable flag set
	 * @param {boolean} [options.oplogReply=false] oplogReply flag set
	 * @param {boolean} [options.awaitdata=false] awaitdata flag set
	 * @param {boolean} [options.exhaust=false] exhaust flag set
	 * @param {boolean} [options.partial=false] partial flag set
	 * @param {opResultCallback} callback A callback function
	 */
	Session.prototype.cursor = function(ns, cmd, options) {
	  return this.topology.cursor(ns, cmd, options);
	}  
	
	module.exports = Session;

/***/ },
/* 93 */
/*!*****************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/auth/mongocr.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var f = __webpack_require__(/*! util */ 57).format
	  , crypto = __webpack_require__(/*! crypto */ 94)
	  , MongoError = __webpack_require__(/*! ../error */ 77);
	
	var AuthSession = function(db, username, password) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	}
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db 
	    && session.username == this.username
	    && session.password == this.password;  
	}
	
	/**
	 * Creates a new MongoCR authentication mechanism
	 * @class
	 * @return {MongoCR} A cursor instance
	 */
	var MongoCR = function() {
	  this.authStore = [];
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {Pool} pool Connection pool for this topology
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	MongoCR.prototype.auth = function(server, pool, db, username, password, callback) {
	  var self = this;
	  // Get all the connections
	  var connections = pool.getAll();
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var credentialsValid = false;
	  var errorObject = null;
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {    
	    // Execute MongoCR
	    var executeMongoCR = function(connection) {
	      // Let's start the process
	      server.command(f("%s.$cmd", db)
	        , { getnonce: 1 }
	        , { connection: connection }, function(err, r) {
	          var nonce = null;
	          var key = null;
	          
	          // Adjust the number of connections left
	          // Get nonce
	          if(err == null) {
	            nonce = r.result.nonce;
	            // Use node md5 generator
	            var md5 = crypto.createHash('md5');
	            // Generate keys used for authentication
	            md5.update(username + ":mongo:" + password);
	            var hash_password = md5.digest('hex');
	            // Final key
	            md5 = crypto.createHash('md5');
	            md5.update(nonce + username + hash_password);
	            key = md5.digest('hex');
	          }
	
	          // Execute command
	          server.command(f("%s.$cmd", db)
	            , { authenticate: 1, user: username, nonce: nonce, key:key}
	            , { connection: connection }, function(err, r) {
	              count = count - 1;
	
	              // If we have an error
	              if(err) {
	                errorObject = err;
	              } else if(r.result['$err']) {
	                errorObject = r.result;
	              } else if(r.result['errmsg']) {
	                errorObject = r.result;
	              } else {
	                credentialsValid = true;
	                numberOfValidConnections = numberOfValidConnections + 1;
	              }
	
	              // We have authenticated all connections
	              if(count == 0 && numberOfValidConnections > 0) {
	                // Store the auth details
	                addAuthSession(self.authStore, new AuthSession(db, username, password));
	                // Return correct authentication
	                callback(null, true);
	              } else if(count == 0) {
	                if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
	                callback(errorObject, false);
	              }
	          });
	      });
	    }
	
	    // Get the connection
	    executeMongoCR(connections.shift());
	  }
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {Pool} pool Connection pool for this topology
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	MongoCR.prototype.reauthenticate = function(server, pool, callback) {
	  var count = this.authStore.length;
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < this.authStore.length; i++) {
	    this.auth(server, pool, this.authStore[i].db, this.authStore[i].username, this.authStore[i].password, function(err, r) {
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(null, null);
	      }
	    });
	  }
	}
	
	/**
	 * This is a result from a authentication strategy
	 *
	 * @callback authResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {boolean} result The result of the authentication process
	 */
	
	module.exports = MongoCR;

/***/ },
/* 94 */
/*!**********************************************************!*\
  !*** ./~/node-libs-browser/~/crypto-browserify/index.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var rng = __webpack_require__(/*! ./rng */ 95)
	
	function error () {
	  var m = [].slice.call(arguments).join(' ')
	  throw new Error([
	    m,
	    'we accept pull requests',
	    'http://github.com/dominictarr/crypto-browserify'
	    ].join('\n'))
	}
	
	exports.createHash = __webpack_require__(/*! ./create-hash */ 97)
	
	exports.createHmac = __webpack_require__(/*! ./create-hmac */ 106)
	
	exports.randomBytes = function(size, callback) {
	  if (callback && callback.call) {
	    try {
	      callback.call(this, undefined, new Buffer(rng(size)))
	    } catch (err) { callback(err) }
	  } else {
	    return new Buffer(rng(size))
	  }
	}
	
	function each(a, f) {
	  for(var i in a)
	    f(a[i], i)
	}
	
	exports.getHashes = function () {
	  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160']
	}
	
	var p = __webpack_require__(/*! ./pbkdf2 */ 107)(exports)
	exports.pbkdf2 = p.pbkdf2
	exports.pbkdf2Sync = p.pbkdf2Sync
	
	
	// the least I can do is make error messages for the rest of the node.js/crypto api.
	each(['createCredentials'
	, 'createCipher'
	, 'createCipheriv'
	, 'createDecipher'
	, 'createDecipheriv'
	, 'createSign'
	, 'createVerify'
	, 'createDiffieHellman'
	], function (name) {
	  exports[name] = function () {
	    error('sorry,', name, 'is not implemented yet')
	  }
	})
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 95 */
/*!********************************************************!*\
  !*** ./~/node-libs-browser/~/crypto-browserify/rng.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {(function() {
	  var g = ('undefined' === typeof window ? global : window) || {}
	  _crypto = (
	    g.crypto || g.msCrypto || __webpack_require__(/*! crypto */ 96)
	  )
	  module.exports = function(size) {
	    // Modern Browsers
	    if(_crypto.getRandomValues) {
	      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
	      /* This will not work in older browsers.
	       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	       */
	    
	      _crypto.getRandomValues(bytes);
	      return bytes;
	    }
	    else if (_crypto.randomBytes) {
	      return _crypto.randomBytes(size)
	    }
	    else
	      throw new Error(
	        'secure random number generation not supported by this browser\n'+
	        'use chrome, FireFox or Internet Explorer 11'
	      )
	  }
	}())
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 96 */
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	/* (ignored) */

/***/ },
/* 97 */
/*!****************************************************************!*\
  !*** ./~/node-libs-browser/~/crypto-browserify/create-hash.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(/*! sha.js */ 98)
	
	var md5 = toConstructor(__webpack_require__(/*! ./md5 */ 103))
	var rmd160 = toConstructor(__webpack_require__(/*! ripemd160 */ 105))
	
	function toConstructor (fn) {
	  return function () {
	    var buffers = []
	    var m= {
	      update: function (data, enc) {
	        if(!Buffer.isBuffer(data)) data = new Buffer(data, enc)
	        buffers.push(data)
	        return this
	      },
	      digest: function (enc) {
	        var buf = Buffer.concat(buffers)
	        var r = fn(buf)
	        buffers = null
	        return enc ? r.toString(enc) : r
	      }
	    }
	    return m
	  }
	}
	
	module.exports = function (alg) {
	  if('md5' === alg) return new md5()
	  if('rmd160' === alg) return new rmd160()
	  return createHash(alg)
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 98 */
/*!*******************************************************************!*\
  !*** ./~/node-libs-browser/~/crypto-browserify/~/sha.js/index.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var exports = module.exports = function (alg) {
	  var Alg = exports[alg]
	  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')
	  return new Alg()
	}
	
	var Buffer = __webpack_require__(/*! buffer */ 28).Buffer
	var Hash   = __webpack_require__(/*! ./hash */ 99)(Buffer)
	
	exports.sha1 = __webpack_require__(/*! ./sha1 */ 100)(Buffer, Hash)
	exports.sha256 = __webpack_require__(/*! ./sha256 */ 101)(Buffer, Hash)
	exports.sha512 = __webpack_require__(/*! ./sha512 */ 102)(Buffer, Hash)


/***/ },
/* 99 */
/*!******************************************************************!*\
  !*** ./~/node-libs-browser/~/crypto-browserify/~/sha.js/hash.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = function (Buffer) {
	
	  //prototype class for hash functions
	  function Hash (blockSize, finalSize) {
	    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)
	    this._finalSize = finalSize
	    this._blockSize = blockSize
	    this._len = 0
	    this._s = 0
	  }
	
	  Hash.prototype.init = function () {
	    this._s = 0
	    this._len = 0
	  }
	
	  Hash.prototype.update = function (data, enc) {
	    if ("string" === typeof data) {
	      enc = enc || "utf8"
	      data = new Buffer(data, enc)
	    }
	
	    var l = this._len += data.length
	    var s = this._s = (this._s || 0)
	    var f = 0
	    var buffer = this._block
	
	    while (s < l) {
	      var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
	      var ch = (t - f)
	
	      for (var i = 0; i < ch; i++) {
	        buffer[(s % this._blockSize) + i] = data[i + f]
	      }
	
	      s += ch
	      f += ch
	
	      if ((s % this._blockSize) === 0) {
	        this._update(buffer)
	      }
	    }
	    this._s = s
	
	    return this
	  }
	
	  Hash.prototype.digest = function (enc) {
	    // Suppose the length of the message M, in bits, is l
	    var l = this._len * 8
	
	    // Append the bit 1 to the end of the message
	    this._block[this._len % this._blockSize] = 0x80
	
	    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	    this._block.fill(0, this._len % this._blockSize + 1)
	
	    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	      this._update(this._block)
	      this._block.fill(0)
	    }
	
	    // to this append the block which is equal to the number l written in binary
	    // TODO: handle case where l is > Math.pow(2, 29)
	    this._block.writeInt32BE(l, this._blockSize - 4)
	
	    var hash = this._update(this._block) || this._hash()
	
	    return enc ? hash.toString(enc) : hash
	  }
	
	  Hash.prototype._update = function () {
	    throw new Error('_update must be implemented by subclass')
	  }
	
	  return Hash
	}


/***/ },
/* 100 */
/*!******************************************************************!*\
  !*** ./~/node-libs-browser/~/crypto-browserify/~/sha.js/sha1.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */
	
	var inherits = __webpack_require__(/*! util */ 57).inherits
	
	module.exports = function (Buffer, Hash) {
	
	  var A = 0|0
	  var B = 4|0
	  var C = 8|0
	  var D = 12|0
	  var E = 16|0
	
	  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80)
	
	  var POOL = []
	
	  function Sha1 () {
	    if(POOL.length)
	      return POOL.pop().init()
	
	    if(!(this instanceof Sha1)) return new Sha1()
	    this._w = W
	    Hash.call(this, 16*4, 14*4)
	
	    this._h = null
	    this.init()
	  }
	
	  inherits(Sha1, Hash)
	
	  Sha1.prototype.init = function () {
	    this._a = 0x67452301
	    this._b = 0xefcdab89
	    this._c = 0x98badcfe
	    this._d = 0x10325476
	    this._e = 0xc3d2e1f0
	
	    Hash.prototype.init.call(this)
	    return this
	  }
	
	  Sha1.prototype._POOL = POOL
	  Sha1.prototype._update = function (X) {
	
	    var a, b, c, d, e, _a, _b, _c, _d, _e
	
	    a = _a = this._a
	    b = _b = this._b
	    c = _c = this._c
	    d = _d = this._d
	    e = _e = this._e
	
	    var w = this._w
	
	    for(var j = 0; j < 80; j++) {
	      var W = w[j] = j < 16 ? X.readInt32BE(j*4)
	        : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)
	
	      var t = add(
	        add(rol(a, 5), sha1_ft(j, b, c, d)),
	        add(add(e, W), sha1_kt(j))
	      )
	
	      e = d
	      d = c
	      c = rol(b, 30)
	      b = a
	      a = t
	    }
	
	    this._a = add(a, _a)
	    this._b = add(b, _b)
	    this._c = add(c, _c)
	    this._d = add(d, _d)
	    this._e = add(e, _e)
	  }
	
	  Sha1.prototype._hash = function () {
	    if(POOL.length < 100) POOL.push(this)
	    var H = new Buffer(20)
	    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
	    H.writeInt32BE(this._a|0, A)
	    H.writeInt32BE(this._b|0, B)
	    H.writeInt32BE(this._c|0, C)
	    H.writeInt32BE(this._d|0, D)
	    H.writeInt32BE(this._e|0, E)
	    return H
	  }
	
	  /*
	   * Perform the appropriate triplet combination function for the current
	   * iteration
	   */
	  function sha1_ft(t, b, c, d) {
	    if(t < 20) return (b & c) | ((~b) & d);
	    if(t < 40) return b ^ c ^ d;
	    if(t < 60) return (b & c) | (b & d) | (c & d);
	    return b ^ c ^ d;
	  }
	
	  /*
	   * Determine the appropriate additive constant for the current iteration
	   */
	  function sha1_kt(t) {
	    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
	           (t < 60) ? -1894007588 : -899497514;
	  }
	
	  /*
	   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	   * to work around bugs in some JS interpreters.
	   * //dominictarr: this is 10 years old, so maybe this can be dropped?)
	   *
	   */
	  function add(x, y) {
	    return (x + y ) | 0
	  //lets see how this goes on testling.
	  //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  //  return (msw << 16) | (lsw & 0xFFFF);
	  }
	
	  /*
	   * Bitwise rotate a 32-bit number to the left.
	   */
	  function rol(num, cnt) {
	    return (num << cnt) | (num >>> (32 - cnt));
	  }
	
	  return Sha1
	}


/***/ },
/* 101 */
/*!********************************************************************!*\
  !*** ./~/node-libs-browser/~/crypto-browserify/~/sha.js/sha256.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */
	
	var inherits = __webpack_require__(/*! util */ 57).inherits
	
	module.exports = function (Buffer, Hash) {
	
	  var K = [
	      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	    ]
	
	  var W = new Array(64)
	
	  function Sha256() {
	    this.init()
	
	    this._w = W //new Array(64)
	
	    Hash.call(this, 16*4, 14*4)
	  }
	
	  inherits(Sha256, Hash)
	
	  Sha256.prototype.init = function () {
	
	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0
	
	    this._len = this._s = 0
	
	    return this
	  }
	
	  function S (X, n) {
	    return (X >>> n) | (X << (32 - n));
	  }
	
	  function R (X, n) {
	    return (X >>> n);
	  }
	
	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }
	
	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }
	
	  function Sigma0256 (x) {
	    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
	  }
	
	  function Sigma1256 (x) {
	    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
	  }
	
	  function Gamma0256 (x) {
	    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
	  }
	
	  function Gamma1256 (x) {
	    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
	  }
	
	  Sha256.prototype._update = function(M) {
	
	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var T1, T2
	
	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0
	
	    for (var j = 0; j < 64; j++) {
	      var w = W[j] = j < 16
	        ? M.readInt32BE(j * 4)
	        : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]
	
	      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w
	
	      T2 = Sigma0256(a) + Maj(a, b, c);
	      h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;
	    }
	
	    this._a = (a + this._a) | 0
	    this._b = (b + this._b) | 0
	    this._c = (c + this._c) | 0
	    this._d = (d + this._d) | 0
	    this._e = (e + this._e) | 0
	    this._f = (f + this._f) | 0
	    this._g = (g + this._g) | 0
	    this._h = (h + this._h) | 0
	
	  };
	
	  Sha256.prototype._hash = function () {
	    var H = new Buffer(32)
	
	    H.writeInt32BE(this._a,  0)
	    H.writeInt32BE(this._b,  4)
	    H.writeInt32BE(this._c,  8)
	    H.writeInt32BE(this._d, 12)
	    H.writeInt32BE(this._e, 16)
	    H.writeInt32BE(this._f, 20)
	    H.writeInt32BE(this._g, 24)
	    H.writeInt32BE(this._h, 28)
	
	    return H
	  }
	
	  return Sha256
	
	}


/***/ },
/* 102 */
/*!********************************************************************!*\
  !*** ./~/node-libs-browser/~/crypto-browserify/~/sha.js/sha512.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(/*! util */ 57).inherits
	
	module.exports = function (Buffer, Hash) {
	  var K = [
	    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	  ]
	
	  var W = new Array(160)
	
	  function Sha512() {
	    this.init()
	    this._w = W
	
	    Hash.call(this, 128, 112)
	  }
	
	  inherits(Sha512, Hash)
	
	  Sha512.prototype.init = function () {
	
	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0
	
	    this._al = 0xf3bcc908|0
	    this._bl = 0x84caa73b|0
	    this._cl = 0xfe94f82b|0
	    this._dl = 0x5f1d36f1|0
	    this._el = 0xade682d1|0
	    this._fl = 0x2b3e6c1f|0
	    this._gl = 0xfb41bd6b|0
	    this._hl = 0x137e2179|0
	
	    this._len = this._s = 0
	
	    return this
	  }
	
	  function S (X, Xl, n) {
	    return (X >>> n) | (Xl << (32 - n))
	  }
	
	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }
	
	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }
	
	  Sha512.prototype._update = function(M) {
	
	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var al, bl, cl, dl, el, fl, gl, hl
	
	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0
	
	    al = this._al | 0
	    bl = this._bl | 0
	    cl = this._cl | 0
	    dl = this._dl | 0
	    el = this._el | 0
	    fl = this._fl | 0
	    gl = this._gl | 0
	    hl = this._hl | 0
	
	    for (var i = 0; i < 80; i++) {
	      var j = i * 2
	
	      var Wi, Wil
	
	      if (i < 16) {
	        Wi = W[j] = M.readInt32BE(j * 4)
	        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4)
	
	      } else {
	        var x  = W[j - 15*2]
	        var xl = W[j - 15*2 + 1]
	        var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
	        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)
	
	        x  = W[j - 2*2]
	        xl = W[j - 2*2 + 1]
	        var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
	        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)
	
	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7  = W[j - 7*2]
	        var Wi7l = W[j - 7*2 + 1]
	
	        var Wi16  = W[j - 16*2]
	        var Wi16l = W[j - 16*2 + 1]
	
	        Wil = gamma0l + Wi7l
	        Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
	        Wil = Wil + gamma1l
	        Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
	        Wil = Wil + Wi16l
	        Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)
	
	        W[j] = Wi
	        W[j + 1] = Wil
	      }
	
	      var maj = Maj(a, b, c)
	      var majl = Maj(al, bl, cl)
	
	      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
	      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
	      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
	      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)
	
	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki = K[j]
	      var Kil = K[j + 1]
	
	      var ch = Ch(e, f, g)
	      var chl = Ch(el, fl, gl)
	
	      var t1l = hl + sigma1l
	      var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
	      t1l = t1l + chl
	      t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
	      t1l = t1l + Kil
	      t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
	      t1l = t1l + Wil
	      t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)
	
	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl
	      var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)
	
	      h  = g
	      hl = gl
	      g  = f
	      gl = fl
	      f  = e
	      fl = el
	      el = (dl + t1l) | 0
	      e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	      d  = c
	      dl = cl
	      c  = b
	      cl = bl
	      b  = a
	      bl = al
	      al = (t1l + t2l) | 0
	      a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0
	    }
	
	    this._al = (this._al + al) | 0
	    this._bl = (this._bl + bl) | 0
	    this._cl = (this._cl + cl) | 0
	    this._dl = (this._dl + dl) | 0
	    this._el = (this._el + el) | 0
	    this._fl = (this._fl + fl) | 0
	    this._gl = (this._gl + gl) | 0
	    this._hl = (this._hl + hl) | 0
	
	    this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
	    this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
	    this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
	    this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	    this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
	    this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
	    this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
	    this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
	  }
	
	  Sha512.prototype._hash = function () {
	    var H = new Buffer(64)
	
	    function writeInt64BE(h, l, offset) {
	      H.writeInt32BE(h, offset)
	      H.writeInt32BE(l, offset + 4)
	    }
	
	    writeInt64BE(this._a, this._al, 0)
	    writeInt64BE(this._b, this._bl, 8)
	    writeInt64BE(this._c, this._cl, 16)
	    writeInt64BE(this._d, this._dl, 24)
	    writeInt64BE(this._e, this._el, 32)
	    writeInt64BE(this._f, this._fl, 40)
	    writeInt64BE(this._g, this._gl, 48)
	    writeInt64BE(this._h, this._hl, 56)
	
	    return H
	  }
	
	  return Sha512
	
	}


/***/ },
/* 103 */
/*!********************************************************!*\
  !*** ./~/node-libs-browser/~/crypto-browserify/md5.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */
	
	var helpers = __webpack_require__(/*! ./helpers */ 104);
	
	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len)
	{
	  /* append padding */
	  x[len >> 5] |= 0x80 << ((len) % 32);
	  x[(((len + 64) >>> 9) << 4) + 14] = len;
	
	  var a =  1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d =  271733878;
	
	  for(var i = 0; i < x.length; i += 16)
	  {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;
	
	    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
	    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
	    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
	    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
	    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
	    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
	    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);
	
	    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
	    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
	    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
	    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
	    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
	    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
	    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
	    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
	    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
	    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
	    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
	    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);
	
	    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
	    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
	    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
	    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
	    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
	    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
	    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
	    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
	    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);
	
	    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
	    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
	    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
	    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
	    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
	    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
	    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
	    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);
	
	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);
	
	}
	
	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}
	
	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return (msw << 16) | (lsw & 0xFFFF);
	}
	
	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	  return (num << cnt) | (num >>> (32 - cnt));
	}
	
	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};


/***/ },
/* 104 */
/*!************************************************************!*\
  !*** ./~/node-libs-browser/~/crypto-browserify/helpers.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var intSize = 4;
	var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
	var chrsz = 8;
	
	function toArray(buf, bigEndian) {
	  if ((buf.length % intSize) !== 0) {
	    var len = buf.length + (intSize - (buf.length % intSize));
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }
	
	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}
	
	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}
	
	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}
	
	module.exports = { hash: hash };
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 105 */
/*!******************************************************************************!*\
  !*** ./~/node-libs-browser/~/crypto-browserify/~/ripemd160/lib/ripemd160.js ***!
  \******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = ripemd160
	
	
	
	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.
	
	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
	
	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	// Constants table
	var zl = [
	    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];
	var zr = [
	    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];
	var sl = [
	     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];
	var sr = [
	    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];
	
	var hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
	var hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];
	
	var bytesToWords = function (bytes) {
	  var words = [];
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << (24 - b % 32);
	  }
	  return words;
	};
	
	var wordsToBytes = function (words) {
	  var bytes = [];
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	  }
	  return bytes;
	};
	
	var processBlock = function (H, M, offset) {
	
	  // Swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i;
	    var M_offset_i = M[offset_i];
	
	    // Swap
	    M[offset_i] = (
	        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	    );
	  }
	
	  // Working variables
	  var al, bl, cl, dl, el;
	  var ar, br, cr, dr, er;
	
	  ar = al = H[0];
	  br = bl = H[1];
	  cr = cl = H[2];
	  dr = dl = H[3];
	  er = el = H[4];
	  // Computation
	  var t;
	  for (var i = 0; i < 80; i += 1) {
	    t = (al +  M[offset+zl[i]])|0;
	    if (i<16){
	        t +=  f1(bl,cl,dl) + hl[0];
	    } else if (i<32) {
	        t +=  f2(bl,cl,dl) + hl[1];
	    } else if (i<48) {
	        t +=  f3(bl,cl,dl) + hl[2];
	    } else if (i<64) {
	        t +=  f4(bl,cl,dl) + hl[3];
	    } else {// if (i<80) {
	        t +=  f5(bl,cl,dl) + hl[4];
	    }
	    t = t|0;
	    t =  rotl(t,sl[i]);
	    t = (t+el)|0;
	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = t;
	
	    t = (ar + M[offset+zr[i]])|0;
	    if (i<16){
	        t +=  f5(br,cr,dr) + hr[0];
	    } else if (i<32) {
	        t +=  f4(br,cr,dr) + hr[1];
	    } else if (i<48) {
	        t +=  f3(br,cr,dr) + hr[2];
	    } else if (i<64) {
	        t +=  f2(br,cr,dr) + hr[3];
	    } else {// if (i<80) {
	        t +=  f1(br,cr,dr) + hr[4];
	    }
	    t = t|0;
	    t =  rotl(t,sr[i]) ;
	    t = (t+er)|0;
	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = t;
	  }
	  // Intermediate hash value
	  t    = (H[1] + cl + dr)|0;
	  H[1] = (H[2] + dl + er)|0;
	  H[2] = (H[3] + el + ar)|0;
	  H[3] = (H[4] + al + br)|0;
	  H[4] = (H[0] + bl + cr)|0;
	  H[0] =  t;
	};
	
	function f1(x, y, z) {
	  return ((x) ^ (y) ^ (z));
	}
	
	function f2(x, y, z) {
	  return (((x)&(y)) | ((~x)&(z)));
	}
	
	function f3(x, y, z) {
	  return (((x) | (~(y))) ^ (z));
	}
	
	function f4(x, y, z) {
	  return (((x) & (z)) | ((y)&(~(z))));
	}
	
	function f5(x, y, z) {
	  return ((x) ^ ((y) |(~(z))));
	}
	
	function rotl(x,n) {
	  return (x<<n) | (x>>>(32-n));
	}
	
	function ripemd160(message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
	
	  if (typeof message == 'string')
	    message = new Buffer(message, 'utf8');
	
	  var m = bytesToWords(message);
	
	  var nBitsLeft = message.length * 8;
	  var nBitsTotal = message.length * 8;
	
	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	  );
	
	  for (var i=0 ; i<m.length; i += 16) {
	    processBlock(H, m, i);
	  }
	
	  // Swap endian
	  for (var i = 0; i < 5; i++) {
	      // Shortcut
	    var H_i = H[i];
	
	    // Swap
	    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	  }
	
	  var digestbytes = wordsToBytes(H);
	  return new Buffer(digestbytes);
	}
	
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 106 */
/*!****************************************************************!*\
  !*** ./~/node-libs-browser/~/crypto-browserify/create-hmac.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(/*! ./create-hash */ 97)
	
	var zeroBuffer = new Buffer(128)
	zeroBuffer.fill(0)
	
	module.exports = Hmac
	
	function Hmac (alg, key) {
	  if(!(this instanceof Hmac)) return new Hmac(alg, key)
	  this._opad = opad
	  this._alg = alg
	
	  var blocksize = (alg === 'sha512') ? 128 : 64
	
	  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key
	
	  if(key.length > blocksize) {
	    key = createHash(alg).update(key).digest()
	  } else if(key.length < blocksize) {
	    key = Buffer.concat([key, zeroBuffer], blocksize)
	  }
	
	  var ipad = this._ipad = new Buffer(blocksize)
	  var opad = this._opad = new Buffer(blocksize)
	
	  for(var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36
	    opad[i] = key[i] ^ 0x5C
	  }
	
	  this._hash = createHash(alg).update(ipad)
	}
	
	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc)
	  return this
	}
	
	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest()
	  return createHash(this._alg).update(this._opad).update(h).digest(enc)
	}
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 107 */
/*!***********************************************************!*\
  !*** ./~/node-libs-browser/~/crypto-browserify/pbkdf2.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var pbkdf2Export = __webpack_require__(/*! pbkdf2-compat/pbkdf2 */ 108)
	
	module.exports = function (crypto, exports) {
	  exports = exports || {}
	
	  var exported = pbkdf2Export(crypto)
	
	  exports.pbkdf2 = exported.pbkdf2
	  exports.pbkdf2Sync = exported.pbkdf2Sync
	
	  return exports
	}


/***/ },
/* 108 */
/*!***************************************************************************!*\
  !*** ./~/node-libs-browser/~/crypto-browserify/~/pbkdf2-compat/pbkdf2.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function(crypto) {
	  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
	    if ('function' === typeof digest) {
	      callback = digest
	      digest = undefined
	    }
	
	    if ('function' !== typeof callback)
	      throw new Error('No callback provided to pbkdf2')
	
	    setTimeout(function() {
	      var result
	
	      try {
	        result = pbkdf2Sync(password, salt, iterations, keylen, digest)
	      } catch (e) {
	        return callback(e)
	      }
	
	      callback(undefined, result)
	    })
	  }
	
	  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
	    if ('number' !== typeof iterations)
	      throw new TypeError('Iterations not a number')
	
	    if (iterations < 0)
	      throw new TypeError('Bad iterations')
	
	    if ('number' !== typeof keylen)
	      throw new TypeError('Key length not a number')
	
	    if (keylen < 0)
	      throw new TypeError('Bad key length')
	
	    digest = digest || 'sha1'
	
	    if (!Buffer.isBuffer(password)) password = new Buffer(password)
	    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)
	
	    var hLen, l = 1, r, T
	    var DK = new Buffer(keylen)
	    var block1 = new Buffer(salt.length + 4)
	    salt.copy(block1, 0, 0, salt.length)
	
	    for (var i = 1; i <= l; i++) {
	      block1.writeUInt32BE(i, salt.length)
	
	      var U = crypto.createHmac(digest, password).update(block1).digest()
	
	      if (!hLen) {
	        hLen = U.length
	        T = new Buffer(hLen)
	        l = Math.ceil(keylen / hLen)
	        r = keylen - (l - 1) * hLen
	
	        if (keylen > (Math.pow(2, 32) - 1) * hLen)
	          throw new TypeError('keylen exceeds maximum length')
	      }
	
	      U.copy(T, 0, 0, hLen)
	
	      for (var j = 1; j < iterations; j++) {
	        U = crypto.createHmac(digest, password).update(U).digest()
	
	        for (var k = 0; k < hLen; k++) {
	          T[k] ^= U[k]
	        }
	      }
	
	      var destPos = (i - 1) * hLen
	      var len = (i == l ? r : hLen)
	      T.copy(DK, destPos, 0, len)
	    }
	
	    return DK
	  }
	
	  return {
	    pbkdf2: pbkdf2,
	    pbkdf2Sync: pbkdf2Sync
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 109 */
/*!**************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/auth/x509.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var f = __webpack_require__(/*! util */ 57).format
	  , crypto = __webpack_require__(/*! crypto */ 94)
	  , MongoError = __webpack_require__(/*! ../error */ 77);
	
	var AuthSession = function(db, username, password) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	}
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db 
	    && session.username == this.username
	    && session.password == this.password;
	}
	
	/**
	 * Creates a new X509 authentication mechanism
	 * @class
	 * @return {X509} A cursor instance
	 */
	var X509 = function() {
	  this.authStore = [];
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {Pool} pool Connection pool for this topology
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	X509.prototype.auth = function(server, pool, db, username, password, callback) {
	  var self = this;
	  // Get all the connections
	  var connections = pool.getAll();
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var credentialsValid = false;
	  var errorObject = null;
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {    
	    // Execute MongoCR
	    var execute = function(connection) {
	      // Let's start the sasl process
	      var command = {
	          authenticate: 1
	        , mechanism: 'MONGODB-X509'
	        , user: username
	      };
	
	      // Let's start the process
	      server.command("$external.$cmd"
	        , command
	        , { connection: connection }, function(err, r) {
	        // Adjust count
	        count = count - 1;
	
	        // If we have an error
	        if(err) {
	          errorObject = err;
	        } else if(r.result['$err']) {
	          errorObject = r.result;
	        } else if(r.result['errmsg']) {
	          errorObject = r.result;
	        } else {
	          credentialsValid = true;
	          numberOfValidConnections = numberOfValidConnections + 1;
	        }
	
	        // We have authenticated all connections
	        if(count == 0 && numberOfValidConnections > 0) {
	          // Store the auth details
	          addAuthSession(self.authStore, new AuthSession(db, username, password));
	          // Return correct authentication
	          callback(null, true);
	        } else if(count == 0) {
	          if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
	          callback(errorObject, false);
	        }
	      });
	    }
	
	    // Get the connection
	    execute(connections.shift());
	  }
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {Pool} pool Connection pool for this topology
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	X509.prototype.reauthenticate = function(server, pool, callback) {
	  var count = this.authStore.length;
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < this.authStore.length; i++) {
	    this.auth(server, pool, this.authStore[i].db, this.authStore[i].username, this.authStore[i].password, function(err, r) {
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(null, null);
	      }
	    });
	  }
	}
	
	/**
	 * This is a result from a authentication strategy
	 *
	 * @callback authResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {boolean} result The result of the authentication process
	 */
	
	module.exports = X509;

/***/ },
/* 110 */
/*!***************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/auth/plain.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var f = __webpack_require__(/*! util */ 57).format
	  , crypto = __webpack_require__(/*! crypto */ 94)
	  , Binary = __webpack_require__(/*! bson */ 51).Binary
	  , MongoError = __webpack_require__(/*! ../error */ 77);
	
	var AuthSession = function(db, username, password) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	}
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db 
	    && session.username == this.username
	    && session.password == this.password;
	}
	
	/**
	 * Creates a new Plain authentication mechanism
	 * @class
	 * @return {Plain} A cursor instance
	 */
	var Plain = function() {
	  this.authStore = [];
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {Pool} pool Connection pool for this topology
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	Plain.prototype.auth = function(server, pool, db, username, password, callback) {
	  var self = this;
	  // Get all the connections
	  var connections = pool.getAll();
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var credentialsValid = false;
	  var errorObject = null;
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {    
	    // Execute MongoCR
	    var execute = function(connection) {
	      // Create payload
	      var payload = new Binary(f("\x00%s\x00%s", username, password));
	
	      // Let's start the sasl process
	      var command = {
	          saslStart: 1
	        , mechanism: 'PLAIN'
	        , payload: payload
	        , autoAuthorize: 1
	      };
	
	      // Let's start the process
	      server.command("$external.$cmd"
	        , command
	        , { connection: connection }, function(err, r) {
	        // Adjust count
	        count = count - 1;
	
	        // If we have an error
	        if(err) {
	          errorObject = err;
	        } else if(r.result['$err']) {
	          errorObject = r.result;
	        } else if(r.result['errmsg']) {
	          errorObject = r.result;
	        } else {
	          credentialsValid = true;
	          numberOfValidConnections = numberOfValidConnections + 1;
	        }
	
	        // We have authenticated all connections
	        if(count == 0 && numberOfValidConnections > 0) {
	          // Store the auth details
	          addAuthSession(self.authStore, new AuthSession(db, username, password));
	          // Return correct authentication
	          callback(null, true);
	        } else if(count == 0) {
	          if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
	          callback(errorObject, false);
	        }
	      });
	    }
	
	    // Get the connection
	    execute(connections.shift());
	  }
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {Pool} pool Connection pool for this topology
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	Plain.prototype.reauthenticate = function(server, pool, callback) {
	  var count = this.authStore.length;
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < this.authStore.length; i++) {
	    this.auth(server, pool, this.authStore[i].db, this.authStore[i].username, this.authStore[i].password, function(err, r) {
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(null, null);
	      }
	    });
	  }
	}
	
	/**
	 * This is a result from a authentication strategy
	 *
	 * @callback authResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {boolean} result The result of the authentication process
	 */
	
	module.exports = Plain;

/***/ },
/* 111 */
/*!****************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/auth/gssapi.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var f = __webpack_require__(/*! util */ 57).format
	  , crypto = __webpack_require__(/*! crypto */ 94)
	  , MongoError = __webpack_require__(/*! ../error */ 77);
	
	var AuthSession = function(db, username, password, options) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	  this.options = options;
	}
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db 
	    && session.username == this.username
	    && session.password == this.password;
	}
	
	// Kerberos class
	var Kerberos = null;
	var MongoAuthProcess = null;
	
	// Try to grab the Kerberos class
	try {
	  Kerberos = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"kerberos\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).Kerberos
	  // Authentication process for Mongo
	  MongoAuthProcess = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"kerberos\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).processes.MongoAuthProcess
	} catch(err) {}
	
	/**
	 * Creates a new GSSAPI authentication mechanism
	 * @class
	 * @return {GSSAPI} A cursor instance
	 */
	var GSSAPI = function() {
	  this.authStore = [];
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {Pool} pool Connection pool for this topology
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	GSSAPI.prototype.auth = function(server, pool, db, username, password, options, callback) {
	  var self = this;
	  // We don't have the Kerberos library
	  if(Kerberos == null) return callback(new Error("Kerberos library is not installed"));  
	  var gssapiServiceName = options['gssapiServiceName'] || 'mongodb';
	  // Get all the connections
	  var connections = pool.getAll();
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var credentialsValid = false;
	  var errorObject = null;
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {    
	    // Execute MongoCR
	    var execute = function(connection) {
	      // Start Auth process for a connection
	      GSSAPIInitialize(db, username, password, db, gssapiServiceName, server, connection, function(err, r) {
	        // Adjust count
	        count = count - 1;
	
	        // If we have an error
	        if(err) {
	          errorObject = err;
	        } else if(r.result['$err']) {
	          errorObject = r.result;
	        } else if(r.result['errmsg']) {
	          errorObject = r.result;
	        } else {
	          credentialsValid = true;
	          numberOfValidConnections = numberOfValidConnections + 1;
	        }
	
	        // We have authenticated all connections
	        if(count == 0 && numberOfValidConnections > 0) {
	          // Store the auth details
	          addAuthSession(self.authStore, new AuthSession(db, username, password, options));
	          // Return correct authentication
	          callback(null, true);
	        } else if(count == 0) {
	          if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
	          callback(errorObject, false);
	        }
	      });
	    }
	
	    // Get the connection
	    execute(connections.shift());
	  }
	}
	
	//
	// Initialize step
	var GSSAPIInitialize = function(db, username, password, authdb, gssapiServiceName, server, connection, callback) {
	  // Create authenticator
	  var mongo_auth_process = new MongoAuthProcess(connection.host, connection.port, gssapiServiceName);
	
	  // Perform initialization
	  mongo_auth_process.init(username, password, function(err, context) {
	    if(err) return callback(err, false);
	
	    // Perform the first step
	    mongo_auth_process.transition('', function(err, payload) {
	      if(err) return callback(err, false);
	
	      // Call the next db step
	      MongoDBGSSAPIFirstStep(mongo_auth_process, payload, db, username, password, authdb, server, connection, callback);
	    });
	  });
	}
	
	//
	// Perform first step against mongodb
	var MongoDBGSSAPIFirstStep = function(mongo_auth_process, payload, db, username, password, authdb, server, connection, callback) {
	  // Build the sasl start command
	  var command = {
	      saslStart: 1
	    , mechanism: 'GSSAPI'
	    , payload: payload
	    , autoAuthorize: 1
	  };
	
	  // Execute first sasl step
	  server.command("$external.$cmd"
	    , command
	    , { connection: connection }, function(err, r) {
	    if(err) return callback(err, false);    
	    var doc = r.result;
	    // Execute mongodb transition
	    mongo_auth_process.transition(r.result.payload, function(err, payload) {
	      if(err) return callback(err, false);
	
	      // MongoDB API Second Step
	      MongoDBGSSAPISecondStep(mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback);
	    });
	  });
	}
	
	//
	// Perform first step against mongodb
	var MongoDBGSSAPISecondStep = function(mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback) {
	  // Build Authentication command to send to MongoDB
	  var command = {
	      saslContinue: 1
	    , conversationId: doc.conversationId
	    , payload: payload
	  };
	
	  // Execute the command
	  server.command("$external.$cmd"
	    , command
	    , { connection: connection }, function(err, r) {
	    if(err) return callback(err, false);
	    var doc = r.result;
	    // Call next transition for kerberos
	    mongo_auth_process.transition(doc.payload, function(err, payload) {
	      if(err) return callback(err, false);
	
	      // Call the last and third step
	      MongoDBGSSAPIThirdStep(mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback);
	    });    
	  });
	}
	
	var MongoDBGSSAPIThirdStep = function(mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback) {
	  // Build final command
	  var command = {
	      saslContinue: 1
	    , conversationId: doc.conversationId
	    , payload: payload
	  };
	
	  // Execute the command
	  server.command("$external.$cmd"
	    , command
	    , { connection: connection }, function(err, r) {
	    if(err) return callback(err, false);
	    mongo_auth_process.transition(null, function(err, payload) {
	      if(err) return callback(err, null);
	      callback(null, r);
	    });
	  });
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {Pool} pool Connection pool for this topology
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	GSSAPI.prototype.reauthenticate = function(server, pool, callback) {
	  var count = this.authStore.length;
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < this.authStore.length; i++) {
	    this.auth(server, pool, this.authStore[i].db, this.authStore[i].username, this.authStore[i].password, this.authStore[i].options, function(err, r) {
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(null, null);
	      }
	    });
	  }
	}
	
	/**
	 * This is a result from a authentication strategy
	 *
	 * @callback authResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {boolean} result The result of the authentication process
	 */
	
	module.exports = GSSAPI;

/***/ },
/* 112 */
/*!**************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/auth/sspi.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var f = __webpack_require__(/*! util */ 57).format
	  , crypto = __webpack_require__(/*! crypto */ 94)
	  , MongoError = __webpack_require__(/*! ../error */ 77);
	
	var AuthSession = function(db, username, password, options) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	  this.options = options;
	}
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db 
	    && session.username == this.username
	    && session.password == this.password;
	}
	
	// Kerberos class
	var Kerberos = null;
	var MongoAuthProcess = null;
	
	// Try to grab the Kerberos class
	try {
	  Kerberos = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"kerberos\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).Kerberos
	  // Authentication process for Mongo
	  MongoAuthProcess = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"kerberos\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).processes.MongoAuthProcess
	} catch(err) {}
	
	/**
	 * Creates a new SSPI authentication mechanism
	 * @class
	 * @return {SSPI} A cursor instance
	 */
	var SSPI = function() {
	  this.authStore = [];
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {Pool} pool Connection pool for this topology
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	SSPI.prototype.auth = function(server, pool, db, username, password, options, callback) {
	  var self = this;
	  // We don't have the Kerberos library
	  if(Kerberos == null) return callback(new Error("Kerberos library is not installed"));  
	  var gssapiServiceName = options['gssapiServiceName'] || 'mongodb';
	  // Get all the connections
	  var connections = pool.getAll();
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var credentialsValid = false;
	  var errorObject = null;
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {    
	    // Execute MongoCR
	    var execute = function(connection) {
	      // Start Auth process for a connection
	      SSIPAuthenticate(username, password, gssapiServiceName, server, connection, function(err, r) {
	        // Adjust count
	        count = count - 1;
	
	        // If we have an error
	        if(err) {
	          errorObject = err;
	        } else if(r && typeof r == 'object' && r.result['$err']) {
	          errorObject = r.result;
	        } else if(r && typeof r == 'object' && r.result['errmsg']) {
	          errorObject = r.result;
	        } else {
	          credentialsValid = true;
	          numberOfValidConnections = numberOfValidConnections + 1;
	        }
	
	        // We have authenticated all connections
	        if(count == 0 && numberOfValidConnections > 0) {
	          // Store the auth details
	          addAuthSession(self.authStore, new AuthSession(db, username, password, options));
	          // Return correct authentication
	          callback(null, true);
	        } else if(count == 0) {
	          if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
	          callback(errorObject, false);
	        }
	      });
	    }
	
	    // Get the connection
	    execute(connections.shift());
	  }
	}
	
	var SSIPAuthenticate = function(username, password, gssapiServiceName, server, connection, callback) {
	  // Build Authentication command to send to MongoDB
	  var command = {
	      saslStart: 1
	    , mechanism: 'GSSAPI'
	    , payload: ''
	    , autoAuthorize: 1
	  };
	
	  // Create authenticator
	  var mongo_auth_process = new MongoAuthProcess(connection.host, connection.port, gssapiServiceName);
	
	  // Execute first sasl step
	  server.command("$external.$cmd"
	    , command
	    , { connection: connection }, function(err, r) {
	    if(err) return callback(err, false);    
	    var doc = r.result;
	
	    mongo_auth_process.init(username, password, function(err) {
	      if(err) return callback(err);
	
	      mongo_auth_process.transition(doc.payload, function(err, payload) {
	        if(err) return callback(err);
	
	        // Perform the next step against mongod
	        var command = {
	            saslContinue: 1
	          , conversationId: doc.conversationId
	          , payload: payload
	        };
	
	        // Execute the command
	        server.command("$external.$cmd"
	          , command
	          , { connection: connection }, function(err, r) {
	          if(err) return callback(err, false);
	          var doc = r.result;
	
	          mongo_auth_process.transition(doc.payload, function(err, payload) {
	            if(err) return callback(err);
	
	            // Perform the next step against mongod
	            var command = {
	                saslContinue: 1
	              , conversationId: doc.conversationId
	              , payload: payload
	            };
	
	            // Execute the command
	            server.command("$external.$cmd"
	              , command
	              , { connection: connection }, function(err, r) {
	              if(err) return callback(err, false);
	              var doc = r.result;
	              
	              mongo_auth_process.transition(doc.payload, function(err, payload) {
	                // Perform the next step against mongod
	                var command = {
	                    saslContinue: 1
	                  , conversationId: doc.conversationId
	                  , payload: payload
	                };
	
	                // Execute the command
	                server.command("$external.$cmd"
	                  , command
	                  , { connection: connection }, function(err, r) {
	                  if(err) return callback(err, false);
	                  var doc = r.result;
	
	                  if(doc.done) return callback(null, true);
	                  callback(new Error("Authentication failed"), false);
	                });        
	              });
	            });
	          });
	        });
	      });
	    });
	  });  
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {Pool} pool Connection pool for this topology
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	SSPI.prototype.reauthenticate = function(server, pool, callback) {
	  var count = this.authStore.length;
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < this.authStore.length; i++) {
	    this.auth(server, pool, this.authStore[i].db, this.authStore[i].username, this.authStore[i].password, this.authStore[i].options, function(err, r) {
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(null, null);
	      }
	    });
	  }
	}
	
	/**
	 * This is a result from a authentication strategy
	 *
	 * @callback authResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {boolean} result The result of the authentication process
	 */
	
	module.exports = SSPI;

/***/ },
/* 113 */
/*!***************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/auth/scram.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";
	
	var f = __webpack_require__(/*! util */ 57).format
	  , crypto = __webpack_require__(/*! crypto */ 94)
	  , Binary = __webpack_require__(/*! bson */ 51).Binary
	  , MongoError = __webpack_require__(/*! ../error */ 77);
	
	var AuthSession = function(db, username, password) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	} 
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db 
	    && session.username == this.username
	    && session.password == this.password;
	}
	
	/**
	 * Creates a new ScramSHA1 authentication mechanism
	 * @class
	 * @return {ScramSHA1} A cursor instance
	 */
	var ScramSHA1 = function() {
	  this.authStore = [];
	}
	
	var parsePayload = function(payload) {
	  var dict = {};
	  var parts = payload.split(',');
	
	  for(var i = 0; i < parts.length; i++) {
	    var valueParts = parts[i].split('=');
	    dict[valueParts[0]] = valueParts[1];
	  }
	
	  return dict;
	}
	
	var passwordDigest = function(username, password) {
	  if(typeof username != 'string') throw new MongoError("username must be a string");
	  if(typeof password != 'string') throw new MongoError("password must be a string");
	  if(password.length == 0) throw new MongoError("password cannot be empty");
	  // Use node md5 generator
	  var md5 = crypto.createHash('md5');
	  // Generate keys used for authentication
	  md5.update(username + ":mongo:" + password);
	  return md5.digest('hex');
	}
	
	// XOR two buffers
	var xor = function(a, b) {
	  if (!Buffer.isBuffer(a)) a = new Buffer(a)
	  if (!Buffer.isBuffer(b)) b = new Buffer(b)
	  var res = []
	  if (a.length > b.length) {
	    for (var i = 0; i < b.length; i++) {
	      res.push(a[i] ^ b[i])
	    }
	  } else {
	    for (var i = 0; i < a.length; i++) {
	      res.push(a[i] ^ b[i])
	    }
	  }
	  return new Buffer(res);
	}
	
	// Create a final digest
	var hi = function(data, salt, iterations) {
	  // Create digest
	  var digest = function(msg) {
	    var hmac = crypto.createHmac('sha1', data);
	    hmac.update(msg);
	    return new Buffer(hmac.digest('base64'), 'base64');
	  }
	
	  // Create variables
	  salt = Buffer.concat([salt, new Buffer('\x00\x00\x00\x01')])
	  var ui = digest(salt);
	  var u1 = ui;
	  
	  for(var i = 0; i < iterations - 1; i++) {
	    u1 = digest(u1);
	    ui = xor(ui, u1);
	  }
	
	  return ui;
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {Pool} pool Connection pool for this topology
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	ScramSHA1.prototype.auth = function(server, pool, db, username, password, callback) {
	  var self = this;
	  // Get all the connections
	  var connections = pool.getAll();
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var credentialsValid = false;
	  var errorObject = null;
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {    
	    // Execute MongoCR
	    var executeScram = function(connection) {
	      // Clean up the user
	      username = username.replace('=', "=3D").replace(',', '=2C');
	
	      // Create a random nonce
	      var nonce = crypto.randomBytes(24).toString('base64');
	      // var nonce = 'MsQUY9iw0T9fx2MUEz6LZPwGuhVvWAhc'
	      var firstBare = f("n=%s,r=%s", username, nonce);
	
	      // Build command structure
	      var cmd = {
	          saslStart: 1
	        , mechanism: 'SCRAM-SHA-1'
	        , payload: new Binary(f("n,,%s", firstBare))
	        , autoAuthorize: 1
	      }
	
	      // Handle the error
	      var handleError = function(err, r) {
	        if(err) {
	          errorObject = err; return false;
	        } else if(r.result['$err']) {
	          errorObject = r.result; return false;
	        } else if(r.result['errmsg']) {
	          errorObject = r.result; return false;
	        } else {
	          credentialsValid = true;
	          numberOfValidConnections = numberOfValidConnections + 1;            
	        }
	
	        return true
	      }
	
	      // Finish up
	      var finish = function(_count, _numberOfValidConnections) {
	        if(_count == 0 && _numberOfValidConnections > 0) {
	          // Store the auth details
	          addAuthSession(self.authStore, new AuthSession(db, username, password));
	          // Return correct authentication
	          return callback(null, true);
	        } else if(_count == 0) {
	          if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using scram"));
	          return callback(errorObject, false);
	        }
	      }
	
	      var handleEnd = function(_err, _r) {
	        // Handle any error
	        handleError(_err, _r)
	        // Adjust the number of connections
	        count = count - 1;
	        // Execute the finish
	        finish(count, numberOfValidConnections);                
	      }
	
	      // Execute start sasl command
	      server.command(f("%s.$cmd", db)
	        , cmd, { connection: connection }, function(err, r) {
	        
	        // Do we have an error, handle it
	        if(handleError(err, r) == false) {
	          count = count - 1;
	
	          if(count == 0 && numberOfValidConnections > 0) {
	            // Store the auth details
	            addAuthSession(self.authStore, new AuthSession(db, username, password));
	            // Return correct authentication
	            return callback(null, true);
	          } else if(count == 0) {
	            if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using scram"));
	            return callback(errorObject, false);
	          }
	
	          return;
	        }
	
	        // Get the dictionary
	        var dict = parsePayload(r.result.payload.value())
	
	        // Unpack dictionary
	        var iterations = parseInt(dict.i, 10);
	        var salt = dict.s;
	        var rnonce = dict.r;
	
	        // Set up start of proof
	        var withoutProof = f("c=biws,r=%s", rnonce);
	        var passwordDig = passwordDigest(username, password);
	        var saltedPassword = hi(passwordDig
	            , new Buffer(salt, 'base64')
	            , iterations);
	        
	        // Create the client key
	        var hmac = crypto.createHmac('sha1', saltedPassword);
	        hmac.update(new Buffer("Client Key"));
	        var clientKey = new Buffer(hmac.digest('base64'), 'base64');
	
	        // Create the stored key
	        var hash = crypto.createHash('sha1');
	        hash.update(clientKey);
	        var storedKey = new Buffer(hash.digest('base64'), 'base64');
	
	        // Create the authentication message
	        var authMsg = [firstBare, r.result.payload.value().toString('base64'), withoutProof].join(',');
	
	        // Create client signature
	        var hmac = crypto.createHmac('sha1', storedKey);
	        hmac.update(new Buffer(authMsg));          
	        var clientSig = new Buffer(hmac.digest('base64'), 'base64');
	
	        // Create client proof
	        var clientProof = f("p=%s", new Buffer(xor(clientKey, clientSig)).toString('base64'));
	
	        // Create client final
	        var clientFinal = [withoutProof, clientProof].join(',');
	
	        // Generate server key
	        var hmac = crypto.createHmac('sha1', saltedPassword);
	        hmac.update(new Buffer('Server Key'))
	        var serverKey = new Buffer(hmac.digest('base64'), 'base64');
	
	        // Generate server signature
	        var hmac = crypto.createHmac('sha1', serverKey);
	        hmac.update(new Buffer(authMsg))
	        var serverSig = new Buffer(hmac.digest('base64'), 'base64');
	
	        //
	        // Create continue message
	        var cmd = {
	            saslContinue: 1
	          , conversationId: r.result.conversationId
	          , payload: new Binary(new Buffer(clientFinal))
	        }
	
	        //
	        // Execute sasl continue
	        server.command(f("%s.$cmd", db)
	          , cmd, { connection: connection }, function(err, r) {
	            if(r && r.result.done == false) {
	              var cmd = {
	                  saslContinue: 1
	                , conversationId: r.result.conversationId
	                , payload: new Buffer(0)
	              }
	
	              server.command(f("%s.$cmd", db)
	                , cmd, { connection: connection }, function(err, r) {
	                  handleEnd(err, r);
	              });
	            } else {
	              handleEnd(err, r);
	            }
	        });
	      });
	    }
	
	    // Get the connection
	    executeScram(connections.shift());
	  }
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {Pool} pool Connection pool for this topology
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	ScramSHA1.prototype.reauthenticate = function(server, pool, callback) {
	  var count = this.authStore.length;
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < this.authStore.length; i++) {
	    this.auth(server, pool, this.authStore[i].db, this.authStore[i].username, this.authStore[i].password, function(err, r) {
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(null, null);
	      }
	    });
	  }
	}
	
	
	module.exports = ScramSHA1;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 114 */
/*!***********************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/topologies/replset.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var inherits = __webpack_require__(/*! util */ 57).inherits
	  , f = __webpack_require__(/*! util */ 57).format
	  , b = __webpack_require__(/*! bson */ 51)
	  , bindToCurrentDomain = __webpack_require__(/*! ../connection/utils */ 79).bindToCurrentDomain
	  , debugOptions = __webpack_require__(/*! ../connection/utils */ 79).debugOptions
	  , EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter
	  , Server = __webpack_require__(/*! ./server */ 78)
	  , ReadPreference = __webpack_require__(/*! ./read_preference */ 86)
	  , MongoError = __webpack_require__(/*! ../error */ 77)
	  , Ping = __webpack_require__(/*! ./strategies/ping */ 115)
	  , Session = __webpack_require__(/*! ./session */ 92)
	  , BasicCursor = __webpack_require__(/*! ../cursor */ 87)
	  , BSON = __webpack_require__(/*! bson */ 51).native().BSON
	  , State = __webpack_require__(/*! ./replset_state */ 116)
	  , Logger = __webpack_require__(/*! ../connection/logger */ 85);
	
	/**
	 * @fileOverview The **ReplSet** class is a class that represents a Replicaset topology and is
	 * used to construct connecctions.
	 *
	 * @example
	 * var ReplSet = require('mongodb-core').ReplSet
	 *   , ReadPreference = require('mongodb-core').ReadPreference
	 *   , assert = require('assert');
	 *
	 * var server = new ReplSet([{host: 'localhost', port: 30000}], {setName: 'rs'});
	 * // Wait for the connection event
	 * server.on('connect', function(server) {
	 *   server.destroy();
	 * });
	 *
	 * // Start connecting
	 * server.connect();
	 */
	
	var DISCONNECTED = 'disconnected';
	var CONNECTING = 'connecting';
	var CONNECTED = 'connected';
	var DESTROYED = 'destroyed';
	
	//
	// ReplSet instance id
	var replSetId = 1;
	
	//
	// Clone the options
	var cloneOptions = function(options) {
	  var opts = {};
	  for(var name in options) {
	    opts[name] = options[name];
	  }
	  return opts;
	}
	
	// All bson types
	var bsonTypes = [b.Long, b.ObjectID, b.Binary, b.Code, b.DBRef, b.Symbol, b.Double, b.Timestamp, b.MaxKey, b.MinKey];
	// BSON parser
	var bsonInstance = null;
	
	/**
	 * Creates a new Replset instance
	 * @class
	 * @param {array} seedlist A list of seeds for the replicaset
	 * @param {boolean} options.setName The Replicaset set name
	 * @param {boolean} [options.secondaryOnlyConnectionAllowed=false] Allow connection to a secondary only replicaset
	 * @param {number} [options.haInterval=5000] The High availability period for replicaset inquiry
	 * @param {boolean} [options.emitError=false] Server will emit errors events
	 * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors
	 * @param {number} [options.size=5] Server connection pool size
	 * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled
	 * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled
	 * @param {boolean} [options.noDelay=true] TCP Connection no delay
	 * @param {number} [options.connectionTimeout=0] TCP Connection timeout setting
	 * @param {number} [options.socketTimeout=0] TCP Socket timeout setting
	 * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed
	 * @param {boolean} [options.ssl=false] Use SSL for connection
	 * @param {Buffer} [options.ca] SSL Certificate store binary buffer
	 * @param {Buffer} [options.cert] SSL Certificate binary buffer
	 * @param {Buffer} [options.key] SSL Key file binary buffer
	 * @param {string} [options.passphrase] SSL Certificate pass phrase
	 * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates
	 * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
	 * @param {number} [options.pingInterval=5000] Ping interval to check the response time to the different servers
	 * @param {number} [options.acceptableLatency=250] Acceptable latency for selecting a server for reading (in milliseconds)
	 * @return {ReplSet} A cursor instance
	 * @fires ReplSet#connect
	 * @fires ReplSet#ha
	 * @fires ReplSet#joined
	 * @fires ReplSet#left
	 */
	var ReplSet = function(seedlist, options) {
	  var self = this;
	  options = options || {};
	
	  // Validate seedlist
	  if(!Array.isArray(seedlist)) throw new MongoError("seedlist must be an array");
	  // Validate list
	  if(seedlist.length == 0) throw new MongoError("seedlist must contain at least one entry");
	  // Validate entries
	  seedlist.forEach(function(e) {
	    if(typeof e.host != 'string' || typeof e.port != 'number')
	      throw new MongoError("seedlist entry must contain a host and port");
	  });
	
	  // Add event listener
	  EventEmitter.call(this);
	
	  // Set the bson instance
	  bsonInstance = bsonInstance == null ? new BSON(bsonTypes) : bsonInstance;
	
	  // Internal state hash for the object
	  this.s = {
	      options: options
	    // Logger instance
	    , logger: Logger('ReplSet', options)
	    // Uniquely identify the replicaset instance
	    , id: replSetId++
	    // Index
	    , index: 0
	    // Ha Index
	    , haId: 0
	    // Current credentials used for auth
	    , credentials: []
	    // Factory overrides
	    , Cursor: options.cursorFactory || BasicCursor
	    // BSON Parser, ensure we have a single instance
	    , bsonInstance: bsonInstance
	    // Pick the right bson parser
	    , bson: options.bson ? options.bson : bsonInstance
	    // Special replicaset options
	    , secondaryOnlyConnectionAllowed: typeof options.secondaryOnlyConnectionAllowed == 'boolean'
	    ? options.secondaryOnlyConnectionAllowed : false
	    , haInterval: options.haInterval || 10000
	    // Are we running in debug mode
	    , debug: typeof options.debug == 'boolean' ? options.debug : false
	    // The replicaset name
	    , setName: options.setName
	    // Swallow or emit errors
	    , emitError: typeof options.emitError == 'boolean' ? options.emitError : false
	    // Grouping tag used for debugging purposes
	    , tag: options.tag
	    // Do we have a not connected handler
	    , disconnectHandler: options.disconnectHandler
	    // Currently connecting servers
	    , connectingServers: {}
	    // Contains any alternate strategies for picking
	    , readPreferenceStrategies: {}
	    // Auth providers
	    , authProviders: {}
	    // All the servers
	    , disconnectedServers: []
	    // Initial connection servers
	    , initialConnectionServers: []
	    // High availability process running
	    , highAvailabilityProcessRunning: false
	    // Full setup
	    , fullsetup: false
	    // All servers accounted for (used for testing)
	    , all: false
	    // Seedlist
	    , seedlist: seedlist
	    // Authentication in progress
	    , authInProgress: false
	    // Servers added while auth in progress
	    , authInProgressServers: []
	    // Minimum heartbeat frequency used if we detect a server close
	    , minHeartbeatFrequencyMS: 500
	  }
	
	  // Add bson parser to options
	  options.bson = this.s.bson;
	  // Set up the connection timeout for the options
	  options.connectionTimeout = options.connectionTimeout || 10000;
	
	  // Replicaset state
	  var replState = new State(this, {
	      id: this.s.id, setName: this.s.setName
	    , connectingServers: this.s.connectingServers
	    , secondaryOnlyConnectionAllowed: this.s.secondaryOnlyConnectionAllowed
	  });
	
	  // Add Replicaset state to our internal state
	  this.s.replState = replState;
	
	  // BSON property (find a server and pass it along)
	  Object.defineProperty(this, 'bson', {
	    enumerable: true, get: function() {
	      var servers = self.s.replState.getAll();
	      return servers.length > 0 ? servers[0].bson : null;
	    }
	  });
	
	  Object.defineProperty(this, 'id', {
	    enumerable:true, get: function() { return self.s.id; }
	  });
	
	  Object.defineProperty(this, 'haInterval', {
	    enumerable:true, get: function() { return self.s.haInterval; }
	  });
	
	  Object.defineProperty(this, 'state', {
	    enumerable:true, get: function() { return self.s.replState; }
	  });
	
	  //
	  // Debug options
	  if(self.s.debug) {
	    // Add access to the read Preference Strategies
	    Object.defineProperty(this, 'readPreferenceStrategies', {
	      enumerable: true, get: function() { return self.s.readPreferenceStrategies; }
	    });
	  }
	
	  Object.defineProperty(this, 'type', {
	    enumerable:true, get: function() { return 'replset'; }
	  });
	
	  // Add the ping strategy for nearest
	  this.addReadPreferenceStrategy('nearest', new Ping(options));
	}
	
	inherits(ReplSet, EventEmitter);
	
	//
	// Plugin methods
	//
	
	/**
	 * Add custom read preference strategy
	 * @method
	 * @param {string} name Name of the read preference strategy
	 * @param {object} strategy Strategy object instance
	 */
	ReplSet.prototype.addReadPreferenceStrategy = function(name, func) {
	  this.s.readPreferenceStrategies[name] = func;
	}
	
	/**
	 * Add custom authentication mechanism
	 * @method
	 * @param {string} name Name of the authentication mechanism
	 * @param {object} provider Authentication object instance
	 */
	ReplSet.prototype.addAuthProvider = function(name, provider) {
	  if(this.s.authProviders == null) this.s.authProviders = {};
	  this.s.authProviders[name] = provider;
	}
	
	/**
	 * Name of BSON parser currently used
	 * @method
	 * @return {string}
	 */
	ReplSet.prototype.parserType = function() {
	  if(this.s.bson.serialize.toString().indexOf('[native code]') != -1)
	    return 'c++';
	  return 'js';
	}
	
	/**
	 * Execute a command
	 * @method
	 * @param {string} type Type of BSON parser to use (c++ or js)
	 */
	ReplSet.prototype.setBSONParserType = function(type) {
	  var nBSON = null;
	
	  if(type == 'c++') {
	    nBSON = __webpack_require__(/*! bson */ 51).native().BSON;
	  } else if(type == 'js') {
	    nBSON = __webpack_require__(/*! bson */ 51).pure().BSON;
	  } else {
	    throw new MongoError(f("% parser not supported", type));
	  }
	
	  this.s.options.bson = new nBSON(bsonTypes);
	}
	
	/**
	 * Returns the last known ismaster document for this server
	 * @method
	 * @return {object}
	 */
	ReplSet.prototype.lastIsMaster = function() {
	  return this.s.replState.lastIsMaster();
	}
	
	/**
	 * Get connection
	 * @method
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @return {Connection}
	 */
	ReplSet.prototype.getConnection = function(options) {
	  // Ensure we have no options
	  options = options || {};
	  // Pick the right server based on readPreference
	  var server = pickServer(this, this.s, options.readPreference);
	  if(server == null) return null;
	  // Return connection
	  return server.getConnection();
	}
	
	/**
	 * All raw connections
	 * @method
	 * @return {Connection[]}
	 */
	ReplSet.prototype.connections = function() {
	  return this.s.replState.getAllConnections();
	}
	
	/**
	 * Get server
	 * @method
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @return {Server}
	 */
	ReplSet.prototype.getServer = function(options) {
	  // Ensure we have no options
	  options = options || {};
	  // Pick the right server based on readPreference
	  return pickServer(this, this.s, options.readPreference);
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {{object}|{Long}} cmd Can be either a command returning a cursor or a cursorId
	 * @param {object} [options.batchSize=0] Batchsize for the operation
	 * @param {array} [options.documents=[]] Initial documents list for cursor
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {opResultCallback} callback A callback function
	 */
	ReplSet.prototype.cursor = function(ns, cmd, cursorOptions) {
	  cursorOptions = cursorOptions || {};
	  var FinalCursor = cursorOptions.cursorFactory || this.s.Cursor;
	  return new FinalCursor(this.s.bson, ns, cmd, cursorOptions, this, this.s.options);
	}
	
	//
	// Execute write operation
	var executeWriteOperation = function(self, op, ns, ops, options, callback) {
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  var server = null;
	  // Ensure we have no options
	  options = options || {};
	  // Get a primary
	  try {
	    server = pickServer(self, self.s, ReadPreference.primary);
	    if(self.s.debug) self.emit('pickedServer', ReadPreference.primary, server);
	  } catch(err) {
	    return callback(err);
	  }
	
	  // No server returned we had an error
	  if(server == null) return callback(new MongoError("no server found"));
	
	  // Execute the command
	  server[op](ns, ops, options, function(err, r) {
	    // We have a no master error, immediately refresh the view of the replicaset
	    if(notMasterError(r) || notMasterError(err)) replicasetInquirer(self, self.s, true)();
	    // Return the result
	    callback(err, r);
	  });
	}
	
	/**
	 * Execute a command
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {object} cmd The command hash
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {Connection} [options.connection] Specify connection object to execute command against
	 * @param {opResultCallback} callback A callback function
	 */
	ReplSet.prototype.command = function(ns, cmd, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(this.s.replState.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	
	  var server = null;
	  var self = this;
	  // Ensure we have no options
	  options = options || {};
	
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!this.isConnected(options) && this.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);
	  }
	
	  // We need to execute the command on all servers
	  if(options.onAll) {
	    var servers = this.s.replState.getAll();
	    var count = servers.length;
	    var cmdErr = null;
	
	    for(var i = 0; i < servers.length; i++) {
	      servers[i].command(ns, cmd, options, function(err, r) {
	        count = count - 1;
	        // Finished executing command
	        if(count == 0) {
	          // Was it a logout command clear any credentials
	          if(cmd.logout) clearCredentials(self.s, ns);
	          // We have a no master error, immediately refresh the view of the replicaset
	          if(notMasterError(r) || notMasterError(err)) replicasetInquirer(self, self.s, true)();
	          // Return the error
	          callback(err, r);
	        }
	      });
	    }
	
	    return;
	  }
	
	  // Pick the right server based on readPreference
	  try {
	    server = pickServer(self, self.s, options.writeConcern ? ReadPreference.primary : options.readPreference);
	    if(self.s.debug) self.emit('pickedServer', options.writeConcern ? ReadPreference.primary : options.readPreference, server);
	  } catch(err) {
	    return callback(err);
	  }
	
	  // No server returned we had an error
	  if(server == null) return callback(new MongoError("no server found"));
	  // Execute the command
	  server.command(ns, cmd, options, function(err, r) {
	    // Was it a logout command clear any credentials
	    if(cmd.logout) clearCredentials(self.s, ns);
	    // We have a no master error, immediately refresh the view of the replicaset
	    if(notMasterError(r) || notMasterError(err)) {
	      replicasetInquirer(self, self.s, true)();
	    }
	    // Return the error
	    callback(err, r);
	  });
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of removes
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {opResultCallback} callback A callback function
	 */
	ReplSet.prototype.remove = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(this.s.replState.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!this.isConnected() && this.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return this.s.disconnectHandler.add('remove', ns, ops, options, callback);
	  }
	
	  executeWriteOperation(this, 'remove', ns, ops, options, callback);
	}
	
	/**
	 * Insert one or more documents
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of documents to insert
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {opResultCallback} callback A callback function
	 */
	ReplSet.prototype.insert = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(this.s.replState.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!this.isConnected() && this.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return this.s.disconnectHandler.add('insert', ns, ops, options, callback);
	  }
	
	  executeWriteOperation(this, 'insert', ns, ops, options, callback);
	}
	
	/**
	 * Perform one or more update operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of updates
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {opResultCallback} callback A callback function
	 */
	ReplSet.prototype.update = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(this.s.replState.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!this.isConnected() && this.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return this.s.disconnectHandler.add('update', ns, ops, options, callback);
	  }
	
	  executeWriteOperation(this, 'update', ns, ops, options, callback);
	}
	
	/**
	 * Authenticate using a specified mechanism
	 * @method
	 * @param {string} mechanism The Auth mechanism we are invoking
	 * @param {string} db The db we are invoking the mechanism against
	 * @param {...object} param Parameters for the specific mechanism
	 * @param {authResultCallback} callback A callback function
	 */
	ReplSet.prototype.auth = function(mechanism, db) {
	  var allArgs = Array.prototype.slice.call(arguments, 0).slice(0);
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  var callback = args.pop();
	
	  // If we don't have the mechanism fail
	  if(this.s.authProviders[mechanism] == null && mechanism != 'default')
	    throw new MongoError(f("auth provider %s does not exist", mechanism));
	
	  // Authenticate against all the servers
	  var servers = this.s.replState.getAll().slice(0);
	  var count = servers.length;
	  // Correct authentication
	  var authenticated = true;
	  var authErr = null;
	  // Set auth in progress
	  this.s.authInProgress = true;
	
	  // Authenticate against all servers
	  while(servers.length > 0) {
	    var server = servers.shift();
	
	    // Arguments without a callback
	    var argsWithoutCallback = [mechanism, db].concat(args.slice(0));
	    // Create arguments
	    var finalArguments = argsWithoutCallback.concat([function(err, r) {
	      count = count - 1;
	      if(err) authErr = err;
	      if(!r) authenticated = false;
	
	      // We are done
	      if(count == 0) {
	        // We have more servers that are not authenticated, let's authenticate
	        if(self.s.authInProgressServers.length > 0) {
	          self.s.authInProgressServers = [];
	          return self.auth.apply(self, [mechanism, db].concat(args).concat([callback]));
	        }
	
	        // Auth is done
	        self.s.authInProgress = false;
	        // Add successful credentials
	        if(authErr == null) addCredentials(self.s, db, argsWithoutCallback);
	        // Return the auth error
	        if(authErr) return callback(authErr, false);
	        // Successfully authenticated session
	        callback(null, new Session({}, self));
	      }
	    }]);
	
	    // Execute the auth
	    server.auth.apply(server, finalArguments);
	  }
	}
	
	ReplSet.prototype.state = function() {
	  return this.s.replState.state;
	}
	  
	/**
	 * Ensure single socket connections to arbiters and hidden servers
	 * @method
	 */
	var handleIsmaster = function(self) {
	  return function(ismaster, _server) {
	    if(ismaster.arbiterOnly) {
	      _server.s.options.size = 1;
	    } else if(ismaster.hidden) {
	      _server.s.options.size = 1;
	    }
	  }
	}
	
	/**
	 * Initiate server connect
	 * @method
	 */
	ReplSet.prototype.connect = function(_options) {
	  var self = this;
	  // Start replicaset inquiry process
	  setTimeout(replicasetInquirer(this, this.s, false), this.s.haInterval);
	  // Additional options
	  if(_options) for(var name in _options) this.s.options[name] = _options[name];
	
	  // Set the state as connecting
	  this.s.replState.state = CONNECTING;
	
	  // No fullsetup reached
	  this.s.fullsetup = false;
	
	  // For all entries in the seedlist build a server instance
	  this.s.seedlist.forEach(function(e) {
	    // Clone options
	    var opts = cloneOptions(self.s.options);
	    // Add host and port
	    opts.host = e.host;
	    opts.port = e.port;
	    opts.reconnect = false;
	    opts.readPreferenceStrategies = self.s.readPreferenceStrategies;
	    opts.emitError = true;
	    if(self.s.tag) opts.tag = self.s.tag;
	    // Share the auth store
	    opts.authProviders = self.s.authProviders;
	    // Create a new Server
	    var server = new Server(opts);
	    // Handle the ismaster
	    server.on('ismaster', handleIsmaster(self));
	    // Add to list of disconnected servers
	    self.s.disconnectedServers.push(server);
	    // Add to list of inflight Connections
	    self.s.initialConnectionServers.push(server);
	  });
	
	  // Attempt to connect to all the servers
	  while(this.s.disconnectedServers.length > 0) {
	    // Get the server
	    var server = this.s.disconnectedServers.shift();
	
	    // Set up the event handlers
	    server.once('error', errorHandlerTemp(this, this.s, 'error'));
	    server.once('close', errorHandlerTemp(this, this.s, 'close'));
	    server.once('timeout', errorHandlerTemp(this, this.s, 'timeout'));
	    server.once('connect', connectHandler(this, this.s));
	
	    // Attempt to connect
	    server.connect();
	  }
	}
	
	/**
	 * Figure out if the server is connected
	 * @method
	 * @return {boolean}
	 */
	ReplSet.prototype.isConnected = function(options) {
	  options = options || {};
	  // If we specified a read preference check if we are connected to something
	  // than can satisfy this
	  if(options.readPreference
	    && options.readPreference.equals(ReadPreference.secondary))
	    return this.s.replState.isSecondaryConnected();
	
	  if(options.readPreference
	    && options.readPreference.equals(ReadPreference.primary))
	    return this.s.replState.isSecondaryConnected() || this.s.replState.isPrimaryConnected();
	
	  if(this.s.secondaryOnlyConnectionAllowed) return this.s.replState.isSecondaryConnected();
	  return this.s.replState.isPrimaryConnected();
	}
	
	/**
	 * Figure out if the replicaset instance was destroyed by calling destroy
	 * @method
	 * @return {boolean}
	 */
	ReplSet.prototype.isDestroyed = function() {
	  return this.s.replState.state == DESTROYED;
	}
	
	/**
	 * Destroy the server connection
	 * @method
	 */
	ReplSet.prototype.destroy = function(emitClose) {
	  var self = this;
	  if(this.s.logger.isInfo()) this.s.logger.info(f('[%s] destroyed', this.s.id));
	  this.s.replState.state = DESTROYED;
	
	  // Emit close
	  if(emitClose && self.listeners('close').length > 0) self.emit('close', self);
	
	  // Destroy state
	  this.s.replState.destroy();
	
	  // Clear out any listeners
	  var events = ['timeout', 'error', 'close', 'joined', 'left'];
	  events.forEach(function(e) {
	    self.removeAllListeners(e);
	  });
	}
	
	/**
	 * A replset connect event, used to verify that the connection is up and running
	 *
	 * @event ReplSet#connect
	 * @type {ReplSet}
	 */
	
	/**
	 * The replset high availability event
	 *
	 * @event ReplSet#ha
	 * @type {function}
	 * @param {string} type The stage in the high availability event (start|end)
	 * @param {boolean} data.norepeat This is a repeating high availability process or a single execution only
	 * @param {number} data.id The id for this high availability request
	 * @param {object} data.state An object containing the information about the current replicaset
	 */
	
	/**
	 * A server member left the replicaset
	 *
	 * @event ReplSet#left
	 * @type {function}
	 * @param {string} type The type of member that left (primary|secondary|arbiter)
	 * @param {Server} server The server object that left
	 */
	
	/**
	 * A server member joined the replicaset
	 *
	 * @event ReplSet#joined
	 * @type {function}
	 * @param {string} type The type of member that joined (primary|secondary|arbiter)
	 * @param {Server} server The server object that joined
	 */
	
	//
	// Inquires about state changes
	//
	
	// Add the new credential for a db, removing the old
	// credential from the cache
	var addCredentials = function(s, db, argsWithoutCallback) {
	  // Remove any credentials for the db
	  clearCredentials(s, db + ".dummy");
	  // Add new credentials to list
	  s.credentials.push(argsWithoutCallback);
	}
	
	// Clear out credentials for a namespace
	var clearCredentials = function(s, ns) {
	  var db = ns.split('.')[0];
	  var filteredCredentials = [];
	
	  // Filter out all credentials for the db the user is logging out off
	  for(var i = 0; i < s.credentials.length; i++) {
	    if(s.credentials[i][1] != db) filteredCredentials.push(s.credentials[i]);
	  }
	
	  // Set new list of credentials
	  s.credentials = filteredCredentials;
	}
	
	//
	// Filter serves by tags
	var filterByTags = function(readPreference, servers) {
	  if(readPreference.tags == null) return servers;
	  var filteredServers = [];
	  var tags = readPreference.tags;
	
	  // Iterate over all the servers
	  for(var i = 0; i < servers.length; i++) {
	    var serverTag = servers[i].lastIsMaster().tags || {};
	    // Did we find the a matching server
	    var found = true;
	    // Check if the server is valid
	    for(var name in tags) {
	      if(serverTag[name] != tags[name]) found = false;
	    }
	
	    // Add to candidate list
	    if(found) filteredServers.push(servers[i]);
	  }
	
	  // Returned filtered servers
	  return filteredServers;
	}
	
	//
	// Pick a server based on readPreference
	var pickServer = function(self, s, readPreference) {
	  // If no read Preference set to primary by default
	  readPreference = readPreference || ReadPreference.primary;
	
	  // Do we have a custom readPreference strategy, use it
	  if(s.readPreferenceStrategies != null && s.readPreferenceStrategies[readPreference.preference] != null) {
	    if(s.readPreferenceStrategies[readPreference.preference] == null) throw new MongoError(f("cannot locate read preference handler for %s", readPreference.preference));
	    var server = s.readPreferenceStrategies[readPreference.preference].pickServer(s.replState, readPreference);
	    if(s.debug) self.emit('pickedServer', readPreference, server);
	    return server;
	  }
	
	  // Filter out any hidden secondaries
	  var secondaries = s.replState.secondaries.filter(function(server) {
	    if(server.lastIsMaster().hidden) return false;
	    return true;
	  });
	
	  // Check if we can satisfy and of the basic read Preferences
	  if(readPreference.equals(ReadPreference.secondary)
	    && secondaries.length == 0)
	      throw new MongoError("no secondary server available");
	
	  if(readPreference.equals(ReadPreference.secondaryPreferred)
	      && secondaries.length == 0
	      && s.replState.primary == null)
	    throw new MongoError("no secondary or primary server available");
	
	  if(readPreference.equals(ReadPreference.primary)
	    && s.replState.primary == null)
	      throw new MongoError("no primary server available");
	
	  // Secondary
	  if(readPreference.equals(ReadPreference.secondary)) {
	    s.index = (s.index + 1) % secondaries.length;
	    return secondaries[s.index];
	  }
	
	  // Secondary preferred
	  if(readPreference.equals(ReadPreference.secondaryPreferred)) {
	    if(secondaries.length > 0) {
	      // Apply tags if present
	      var servers = filterByTags(readPreference, secondaries);
	      // If have a matching server pick one otherwise fall through to primary
	      if(servers.length > 0) {
	        s.index = (s.index + 1) % servers.length;
	        return servers[s.index];  
	      }
	    }
	
	    return s.replState.primary;
	  }
	
	  // Primary preferred
	  if(readPreference.equals(ReadPreference.primaryPreferred)) {
	    if(s.replState.primary) return s.replState.primary;
	
	    if(secondaries.length > 0) {
	      // Apply tags if present
	      var servers = filterByTags(readPreference, secondaries);
	      // If have a matching server pick one otherwise fall through to primary
	      if(servers.length > 0) {
	        s.index = (s.index + 1) % servers.length;
	        return servers[s.index];  
	      }
	
	      // Throw error a we have not valid secondary or primary servers
	      throw new MongoError("no secondary or primary server available");
	    }
	  }
	
	  // Return the primary
	  return s.replState.primary;
	}
	
	var replicasetInquirer = function(self, state, norepeat) {
	  return function() {
	    if(state.replState.state == DESTROYED) return
	    // Process already running don't rerun
	    if(state.highAvailabilityProcessRunning) return;
	    // Started processes
	    state.highAvailabilityProcessRunning = true;
	    if(state.logger.isInfo()) state.logger.info(f('[%s] monitoring process running %s', state.id, JSON.stringify(state.replState)));
	
	    // Unique HA id to identify the current look running
	    var localHaId = state.haId++;
	
	    // Clean out any failed connection attempts
	    state.connectingServers = {};
	
	    // Controls if we are doing a single inquiry or repeating
	    norepeat = typeof norepeat == 'boolean' ? norepeat : false;
	
	    // If we have a primary and a disconnect handler, execute
	    // buffered operations
	    if(state.replState.isPrimaryConnected() && state.replState.isSecondaryConnected() && state.disconnectHandler) {
	      state.disconnectHandler.execute();
	    }
	
	    // Emit replicasetInquirer
	    self.emit('ha', 'start', {norepeat: norepeat, id: localHaId, state: state.replState ? state.replState.toJSON() : {}});
	
	    // Let's process all the disconnected servers
	    while(state.disconnectedServers.length > 0) {
	      // Get the first disconnected server
	      var server = state.disconnectedServers.shift();
	      if(state.logger.isInfo()) state.logger.info(f('[%s] monitoring attempting to connect to %s', state.id, server.lastIsMaster() ? server.lastIsMaster().me : server.name));
	      // Set up the event handlers
	      server.once('error', errorHandlerTemp(self, state, 'error'));
	      server.once('close', errorHandlerTemp(self, state, 'close'));
	      server.once('timeout', errorHandlerTemp(self, state, 'timeout'));
	      server.once('connect', connectHandler(self, state));
	      // Attempt to connect
	      server.connect();
	    }
	
	    // Cleanup state (removed disconnected servers)
	    state.replState.clean();
	
	    // We need to query all servers
	    var servers = state.replState.getAll();
	    var serversLeft = servers.length;
	
	    // If no servers and we are not destroyed keep pinging
	    if(servers.length == 0 && state.replState.state == CONNECTED) {
	      // Emit ha process end
	      self.emit('ha', 'end', {norepeat: norepeat, id: localHaId, state: state.replState ? state.replState.toJSON() : {}});
	      // Ended highAvailabilityProcessRunning
	      state.highAvailabilityProcessRunning = false;
	      // Restart ha process
	      if(!norepeat) setTimeout(replicasetInquirer(self, state, false), state.haInterval);
	      return;
	    }
	
	    //
	    // ismaster for Master server
	    var primaryIsMaster = null;
	
	    //
	    // Inspect a specific servers ismaster
	    var inspectServer = function(server) {
	      if(state.replState.state == DESTROYED) return;
	      // Did we get a server
	      if(server && server.isConnected()) {
	        // Execute ismaster
	        server.command('system.$cmd', {ismaster:true}, function(err, r) {
	          if(state.replState.state == DESTROYED) return;
	          // Count down the number of servers left
	          serversLeft = serversLeft - 1;
	          // If we have an error but still outstanding server request return
	          if(err && serversLeft > 0) return;
	          // We had an error and have no more servers to inspect, schedule a new check
	          if(err && serversLeft == 0) {
	            self.emit('ha', 'end', {norepeat: norepeat, id: localHaId, state: state.replState ? state.replState.toJSON() : {}});
	            // Ended highAvailabilityProcessRunnfing
	            state.highAvailabilityProcessRunning = false;
	            // Return the replicasetInquirer
	            if(!norepeat) setTimeout(replicasetInquirer(self, state, false), state.haInterval);
	            return;
	          }
	
	          // Let all the read Preferences do things to the servers
	          var rPreferencesCount = Object.keys(state.readPreferenceStrategies).length;
	
	          // Handle the primary
	          var ismaster = r.result;
	          if(state.logger.isDebug()) state.logger.debug(f('[%s] monitoring process ismaster %s', state.id, JSON.stringify(ismaster)));
	
	          // Update the replicaset state
	          state.replState.update(ismaster, server);
	
	          // Add any new servers
	          if(err == null && ismaster.ismaster && Array.isArray(ismaster.hosts)) {
	            // Hosts to process
	            var hosts = ismaster.hosts;
	            // Add arbiters to list of hosts if we have any
	            if(Array.isArray(ismaster.arbiters)) hosts = hosts.concat(ismaster.arbiters);
	            if(Array.isArray(ismaster.passives)) hosts = hosts.concat(ismaster.passives);
	            // Process all the hsots
	            processHosts(self, state, hosts);
	          }
	
	          // No read Preferences strategies
	          if(rPreferencesCount == 0) {
	            // Don't schedule a new inquiry
	            if(serversLeft > 0) return;
	            // Emit ha process end
	            self.emit('ha', 'end', {norepeat: norepeat, id: localHaId, state: state.replState ? state.replState.toJSON() : {}});
	            // Ended highAvailabilityProcessRunning
	            state.highAvailabilityProcessRunning = false;
	            // Let's keep monitoring
	            if(!norepeat) setTimeout(replicasetInquirer(self, state, false), state.haInterval);
	            return;
	          }
	
	          // No servers left to query, execute read preference strategies
	          if(serversLeft == 0) {
	            // Go over all the read preferences
	            for(var name in state.readPreferenceStrategies) {
	              state.readPreferenceStrategies[name].ha(self, state.replState, function() {
	                rPreferencesCount = rPreferencesCount - 1;
	
	                if(rPreferencesCount == 0) {
	                  // Add any new servers in primary ismaster
	                  if(err == null
	                    && ismaster.ismaster
	                    && Array.isArray(ismaster.hosts)) {
	                      processHosts(self, state, ismaster.hosts);
	                  }
	
	                  // Emit ha process end
	                  self.emit('ha', 'end', {norepeat: norepeat, id: localHaId, state: state.replState ? state.replState.toJSON() : {}});
	                  // Ended highAvailabilityProcessRunning
	                  state.highAvailabilityProcessRunning = false;
	                  // Let's keep monitoring
	                  if(!norepeat) setTimeout(replicasetInquirer(self, state, false), state.haInterval);
	                  return;
	                }
	              });
	            }
	          }
	        });
	      }
	    }
	
	    // Call ismaster on all servers
	    for(var i = 0; i < servers.length; i++) {
	      inspectServer(servers[i]);
	    }
	
	    // If no more initial servers and new scheduled servers to connect
	    if(state.replState.secondaries.length >= 1 && state.replState.primary != null && !state.fullsetup) {
	      state.fullsetup = true;
	      self.emit('fullsetup', self);
	    }
	
	    // If all servers are accounted for and we have not sent the all event
	    if(state.replState.primary != null && self.lastIsMaster()
	      && Array.isArray(self.lastIsMaster().hosts) && !state.all) {
	      var length = 1 + state.replState.secondaries.length;
	      // If we have all secondaries + primary
	      if(length == self.lastIsMaster().hosts.length + 1) {
	        state.all = true;
	        self.emit('all', self);
	      }
	    }
	  }
	}
	
	// Error handler for initial connect
	var errorHandlerTemp = function(self, state, event) {
	  return function(err, server) {
	    // Log the information
	    if(state.logger.isInfo()) state.logger.info(f('[%s] server %s disconnected', state.id, server.lastIsMaster() ? server.lastIsMaster().me : server.name));
	    // Filter out any connection servers
	    state.initialConnectionServers = state.initialConnectionServers.filter(function(_server) {
	      return server.name != _server.name;
	    });
	
	    // Connection is destroyed, ignore
	    if(state.replState.state == DESTROYED) return;
	
	    // Remove any non used handlers
	    ['error', 'close', 'timeout', 'connect'].forEach(function(e) {
	      server.removeAllListeners(e);
	    })
	
	    // Push to list of disconnected servers
	    addToListIfNotExist(state.disconnectedServers, server);
	
	    // End connection operation if we have no legal replicaset state
	    if(state.initialConnectionServers == 0 && state.replState.state == CONNECTING) {
	       if((state.secondaryOnlyConnectionAllowed && !state.replState.isSecondaryConnected() && !state.replState.isPrimaryConnected())
	        || (!state.secondaryOnlyConnectionAllowed && !state.replState.isPrimaryConnected())) {
	          if(state.logger.isInfo()) state.logger.info(f('[%s] no valid seed servers in list', state.id));
	
	          if(self.listeners('error').length > 0)
	            return self.emit('error', new MongoError('no valid seed servers in list'));
	       }
	    }
	
	    // If the number of disconnected servers is equal to
	    // the number of seed servers we cannot connect
	    if(state.disconnectedServers.length == state.seedlist.length && state.replState.state == CONNECTING) {
	      if(state.emitError && self.listeners('error').length > 0) {
	        if(state.logger.isInfo()) state.logger.info(f('[%s] no valid seed servers in list', state.id));
	
	        if(self.listeners('error').length > 0)
	          self.emit('error', new MongoError('no valid seed servers in list'));
	      }
	    }
	  }
	}
	
	// Connect handler
	var connectHandler = function(self, state) {
	  return function(server) {
	    if(state.logger.isInfo()) state.logger.info(f('[%s] connected to %s', state.id, server.name));
	    // Destroyed connection
	    if(state.replState.state == DESTROYED) {
	      server.destroy(false, false);
	      return;
	    }
	
	    // Filter out any connection servers
	    state.initialConnectionServers = state.initialConnectionServers.filter(function(_server) {
	      return server.name != _server.name;
	    });
	
	    // Process the new server
	    var processNewServer = function() {
	      // Discover any additional servers
	      var ismaster = server.lastIsMaster();
	
	      var events = ['error', 'close', 'timeout', 'connect', 'message'];
	      // Remove any non used handlers
	      events.forEach(function(e) {
	        server.removeAllListeners(e);
	      })
	
	      // Clean up
	      delete state.connectingServers[server.name];
	      // Update the replicaset state, destroy if not added
	      if(!state.replState.update(ismaster, server)) {
	        return server.destroy();
	      }
	
	      // Add the server handling code
	      if(server.isConnected()) {
	        server.on('error', errorHandler(self, state));
	        server.on('close', closeHandler(self, state));
	        server.on('timeout', timeoutHandler(self, state));
	      }
	
	      // Hosts to process
	      var hosts = ismaster.hosts;
	      // Add arbiters to list of hosts if we have any
	      if(Array.isArray(ismaster.arbiters)) hosts = hosts.concat(ismaster.arbiters);
	      if(Array.isArray(ismaster.passives)) hosts = hosts.concat(ismaster.passives);
	
	      // Add any new servers
	      processHosts(self, state, hosts);
	
	      // If have the server instance already destroy it
	      if(state.initialConnectionServers.length == 0 && Object.keys(state.connectingServers).length == 0
	        && !state.replState.isPrimaryConnected() && !state.secondaryOnlyConnectionAllowed && state.replState.state == CONNECTING) {
	        if(state.logger.isInfo()) state.logger.info(f('[%s] no primary found in replicaset', state.id));
	        self.emit('error', new MongoError("no primary found in replicaset"));
	        return self.destroy();
	      }
	
	      // If no more initial servers and new scheduled servers to connect
	      if(state.replState.secondaries.length >= 1 && state.replState.primary != null && !state.fullsetup) {
	        state.fullsetup = true;
	        self.emit('fullsetup', self);
	      }
	    }
	
	    // Save up new members to be authenticated against
	    if(self.s.authInProgress) {
	      self.s.authInProgressServers.push(server);
	    }
	
	    // No credentials just process server
	    if(state.credentials.length == 0) return processNewServer();
	    // Do we have credentials, let's apply them all
	    var count = state.credentials.length;
	    // Apply the credentials
	    for(var i = 0; i < state.credentials.length; i++) {
	      server.auth.apply(server, state.credentials[i].concat([function(err, r) {
	        count = count - 1;
	        if(count == 0) processNewServer();
	      }]));
	    }
	  }
	}
	
	//
	// Detect if we need to add new servers
	var processHosts = function(self, state, hosts) {
	  if(state.replState.state == DESTROYED) return;
	  if(Array.isArray(hosts)) {
	    // Check any hosts exposed by ismaster
	    for(var i = 0; i < hosts.length; i++) {
	      // If not found we need to create a new connection
	      if(!state.replState.contains(hosts[i])) {
	        if(state.connectingServers[hosts[i]] == null && !inInitialConnectingServers(self, state, hosts[i])) {
	          if(state.logger.isInfo()) state.logger.info(f('[%s] scheduled server %s for connection', state.id, hosts[i]));
	          // Make sure we know what is trying to connect
	          state.connectingServers[hosts[i]] = hosts[i];
	          // Connect the server
	          connectToServer(self, state, hosts[i].split(':')[0], parseInt(hosts[i].split(':')[1], 10));
	        }
	      }
	    }
	  }
	}
	
	var inInitialConnectingServers = function(self, state, address) {
	  for(var i = 0; i < state.initialConnectionServers.length; i++) {
	    if(state.initialConnectionServers[i].name == address) return true;
	  }
	  return false;
	}
	
	// Connect to a new server
	var connectToServer = function(self, state, host, port) {
	  var opts = cloneOptions(state.options);
	  opts.host = host;
	  opts.port = port;
	  opts.reconnect = false;
	  opts.readPreferenceStrategies = state.readPreferenceStrategies;
	  if(state.tag) opts.tag = state.tag;
	  // Share the auth store
	  opts.authProviders = state.authProviders;
	  opts.emitError = true;
	  // Create a new server instance
	  var server = new Server(opts);
	  // Handle the ismaster
	  server.on('ismaster', handleIsmaster(self));
	  // Set up the event handlers
	  server.once('error', errorHandlerTemp(self, state, 'error'));
	  server.once('close', errorHandlerTemp(self, state, 'close'));
	  server.once('timeout', errorHandlerTemp(self, state, 'timeout'));
	  server.once('connect', connectHandler(self, state));
	  // Attempt to connect
	  server.connect();
	}
	
	//
	// Add server to the list if it does not exist
	var addToListIfNotExist = function(list, server) {
	  var found = false;
	
	  // Remove any non used handlers
	  ['error', 'close', 'timeout', 'connect'].forEach(function(e) {
	    server.removeAllListeners(e);
	  })
	
	  // Check if the server already exists
	  for(var i = 0; i < list.length; i++) {
	    if(list[i].equals(server)) found = true;
	  }
	
	  if(!found) {
	    list.push(server);
	  }
	
	  return found;
	}
	
	var errorHandler = function(self, state) {
	  return function(err, server) {
	    if(state.replState.state == DESTROYED) return;
	    if(state.logger.isInfo()) state.logger.info(f('[%s] server %s errored out with %s', state.id, server.lastIsMaster() ? server.lastIsMaster().me : server.name, JSON.stringify(err)));
	    var found = addToListIfNotExist(state.disconnectedServers, server);
	    if(!found) self.emit('left', state.replState.remove(server), server);
	    if(found && state.emitError && self.listeners('error').length > 0) self.emit('error', err, server);
	
	    // Fire off a detection of missing server using minHeartbeatFrequencyMS
	    setTimeout(function() {
	      replicasetInquirer(self, self.s, true)();
	    }, self.s.minHeartbeatFrequencyMS);
	  }
	}
	
	var timeoutHandler = function(self, state) {
	  return function(err, server) {
	    if(state.replState.state == DESTROYED) return;
	    if(state.logger.isInfo()) state.logger.info(f('[%s] server %s timed out', state.id, server.lastIsMaster() ? server.lastIsMaster().me : server.name));
	    var found = addToListIfNotExist(state.disconnectedServers, server);
	    if(!found) self.emit('left', state.replState.remove(server), server);
	
	    // Fire off a detection of missing server using minHeartbeatFrequencyMS
	    setTimeout(function() {
	      replicasetInquirer(self, self.s, true)();
	    }, self.s.minHeartbeatFrequencyMS);
	  }
	}
	
	var closeHandler = function(self, state) {
	  return function(err, server) {
	    if(state.replState.state == DESTROYED) return;
	    if(state.logger.isInfo()) state.logger.info(f('[%s] server %s closed', state.id, server.lastIsMaster() ? server.lastIsMaster().me : server.name));
	    var found = addToListIfNotExist(state.disconnectedServers, server);
	    if(!found) self.emit('left', state.replState.remove(server), server);
	
	    // Fire off a detection of missing server using minHeartbeatFrequencyMS
	    setTimeout(function() {
	      replicasetInquirer(self, self.s, true)();
	    }, self.s.minHeartbeatFrequencyMS);
	  }
	}
	
	//
	// Validate if a non-master or recovering error
	var notMasterError = function(r) {
	  // Get result of any
	  var result = r && r.result ? r.result : r;
	
	  // Explore if we have a not master error
	  if(result && (result.err == 'not master'
	    || result.errmsg == 'not master' || (result['$err'] && result['$err'].indexOf('not master or secondary') != -1)
	    || (result['$err'] && result['$err'].indexOf("not master and slaveOk=false") != -1)
	    || result.errmsg == 'node is recovering')) {
	    return true;
	  }
	
	  return false;
	}
	
	module.exports = ReplSet;


/***/ },
/* 115 */
/*!*******************************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/topologies/strategies/ping.js ***!
  \*******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var Logger = __webpack_require__(/*! ../../connection/logger */ 85)
	  , EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter
	  , inherits = __webpack_require__(/*! util */ 57).inherits
	  , f = __webpack_require__(/*! util */ 57).format;
	
	/**
	 * Creates a new Ping read preference strategy instance
	 * @class
	 * @param {number} [options.pingInterval=5000] Ping interval to check the response time to the different servers
	 * @param {number} [options.acceptableLatency=250] Acceptable latency for selecting a server for reading (in milliseconds)
	 * @return {Ping} A cursor instance
	 */
	var Ping = function(options) {
	  // Add event listener
	  EventEmitter.call(this);
	
	  // Contains the ping state
	  this.s = {
	    // Contains all the ping data
	      pings: {}
	    // Set no options if none provided
	    , options: options || {}
	    // Logger
	    , logger: Logger('Ping', options)
	    // Ping interval
	    , pingInterval: options.pingInterval || 10000
	    , acceptableLatency: options.acceptableLatency || 15
	    // Debug options
	    , debug: typeof options.debug == 'boolean' ? options.debug : false
	    // Index
	    , index: 0
	    // Current ping time
	    , lastPing: null
	
	  }
	
	  // Log the options set
	  if(this.s.logger.isDebug()) this.s.logger.debug(f('ping strategy interval [%s], acceptableLatency [%s]', this.s.pingInterval, this.s.acceptableLatency));
	
	  // If we have enabled debug 
	  if(this.s.debug) {
	    // Add access to the read Preference Strategies
	    Object.defineProperty(this, 'data', {
	      enumerable: true, get: function() { return this.s.pings; }
	    });    
	  }
	}
	
	inherits(Ping, EventEmitter);
	
	/**
	 * @ignore
	 */
	var filterByTags = function(readPreference, servers) {
	  if(readPreference.tags == null) return servers;
	  var filteredServers = [];
	  var tags = readPreference.tags;
	
	  // Iterate over all the servers
	  for(var i = 0; i < servers.length; i++) {
	    var serverTag = servers[i].lastIsMaster().tags || {};
	    // Did we find the a matching server
	    var found = true;
	    // Check if the server is valid
	    for(var name in tags) {
	      if(serverTag[name] != tags[name]) found = false;
	    }
	
	    // Add to candidate list
	    if(found) filteredServers.push(servers[i]);
	  }
	
	  // Returned filtered servers
	  return filteredServers;
	}
	
	/**
	 * Pick a server
	 * @method
	 * @param {State} set The current replicaset state object 
	 * @param {ReadPreference} readPreference The current readPreference object
	 * @param {readPreferenceResultCallback} callback The callback to return the result from the function
	 * @return {object}
	 */
	Ping.prototype.pickServer = function(set, readPreference) {
	  var self = this;
	  // Only get primary and secondaries as seeds
	  var seeds = {};
	  var servers = [];
	  if(set.primary) {
	    servers.push(set.primary);
	  }
	
	  for(var i = 0; i < set.secondaries.length; i++) {
	    servers.push(set.secondaries[i]);
	  }
	
	  // Filter by tags
	  servers = filterByTags(readPreference, servers);
	
	  // Transform the list
	  var serverList = [];
	  // for(var name in seeds) {
	  for(var i = 0; i < servers.length; i++) {
	    serverList.push({name: servers[i].name, time: self.s.pings[servers[i].name] || 0});
	  }
	
	  // Sort by time
	  serverList.sort(function(a, b) {
	    return a.time > b.time;
	  });
	
	  // Locate lowest time (picked servers are lowest time + acceptable Latency margin)
	  var lowest = serverList.length > 0 ? serverList[0].time : 0;
	
	  // Filter by latency
	  serverList = serverList.filter(function(s) {
	    return s.time <= lowest + self.s.acceptableLatency;
	  });
	
	  // No servers, default to primary
	  if(serverList.length == 0 && set.primary) {
	    if(self.s.logger.isInfo()) self.s.logger.info(f('picked primary server [%s]', set.primary.name));
	    return set.primary;
	  } else if(serverList.length == 0) {
	    return null
	  }
	
	  // We picked first server
	  if(self.s.logger.isInfo()) self.s.logger.info(f('picked server [%s] with ping latency [%s]', serverList[0].name, serverList[0].time));
	
	  // Add to the index
	  self.s.index = self.s.index + 1;
	  // Select the index
	  self.s.index = self.s.index % serverList.length;
	  // Return the first server of the sorted and filtered list
	  return set.get(serverList[self.s.index].name);
	}
	
	/**
	 * Start of an operation
	 * @method
	 * @param {Server} server The server the operation is running against
	 * @param {object} query The operation running
	 * @param {Date} date The start time of the operation
	 * @return {object}
	 */
	Ping.prototype.startOperation = function(server, query, date) {
	}
	
	/**
	 * End of an operation
	 * @method
	 * @param {Server} server The server the operation is running against
	 * @param {error} err An error from the operation
	 * @param {object} result The result from the operation
	 * @param {Date} date The start time of the operation
	 * @return {object}
	 */
	Ping.prototype.endOperation = function(server, err, result, date) {
	}
	
	/**
	 * High availability process running
	 * @method
	 * @param {State} set The current replicaset state object 
	 * @param {resultCallback} callback The callback to return the result from the function
	 * @return {object}
	 */
	Ping.prototype.ha = function(topology, state, callback) {
	  var self = this;
	  var servers = state.getAll();
	  var count = servers.length;
	
	  // No servers return
	  if(servers.length == 0) return callback(null, null);
	
	  // Return if we have not yet reached the ping interval
	  if(self.s.lastPing != null) {
	    var diff = new Date().getTime() - self.s.lastPing.getTime();
	    if(diff < self.s.pingInterval) return callback(null, null);
	  }
	
	  // Execute operation
	  var operation = function(_server) {
	    var start = new Date();      
	    // Execute ping against server
	    _server.command('system.$cmd', {ismaster:1}, function(err, r) {
	      count = count - 1;
	      var time = new Date().getTime() - start.getTime();
	      self.s.pings[_server.name] = time;
	      // Log info for debug
	      if(self.s.logger.isDebug()) self.s.logger.debug(f('ha latency for server [%s] is [%s] ms', _server.name, time));
	      // We are done with all the servers
	      if(count == 0) {
	        // Emit ping event
	        topology.emit('ping', err, r ? r.result : null);
	        // Update the last ping time
	        self.s.lastPing = new Date();
	        // Return
	        callback(null, null);
	      }
	    });
	  }
	
	  // Let's ping all servers
	  while(servers.length > 0) {
	    operation(servers.shift());
	  }
	}
	
	var removeServer = function(self, server) {
	  delete self.s.pings[server.name];
	}
	
	/**
	 * Server connection closed
	 * @method
	 * @param {Server} server The server that closed
	 */
	Ping.prototype.close = function(server) {
	  removeServer(this, server);
	}
	
	/**
	 * Server connection errored out
	 * @method
	 * @param {Server} server The server that errored out
	 */
	Ping.prototype.error = function(server) {
	  removeServer(this, server);
	}
	
	/**
	 * Server connection timeout
	 * @method
	 * @param {Server} server The server that timed out
	 */
	Ping.prototype.timeout = function(server) {
	  removeServer(this, server);
	}
	
	/**
	 * Server connection happened
	 * @method
	 * @param {Server} server The server that connected
	 * @param {resultCallback} callback The callback to return the result from the function
	 */
	Ping.prototype.connect = function(server, callback) {
	  var self = this;
	  // Get the command start date
	  var start = new Date();
	  // Execute ping against server
	  server.command('system.$cmd', {ismaster:1}, function(err, r) {
	    var time = new Date().getTime() - start.getTime();
	    self.s.pings[server.name] = time;
	    // Log info for debug
	    if(self.s.logger.isDebug()) self.s.logger.debug(f('connect latency for server [%s] is [%s] ms', server.name, time));
	    // Set last ping
	    self.s.lastPing = new Date();
	    // Done, return
	    callback(null, null);
	  });    
	}
	
	/**
	 * This is a result from a readPreference strategy
	 *
	 * @callback readPreferenceResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {Server} server The server picked by the strategy
	 */
	
	module.exports = Ping;

/***/ },
/* 116 */
/*!*****************************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/topologies/replset_state.js ***!
  \*****************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";
	
	var Logger = __webpack_require__(/*! ../connection/logger */ 85)
	  , f = __webpack_require__(/*! util */ 57).format
	  , ObjectId = __webpack_require__(/*! bson */ 51).ObjectId
	  , MongoError = __webpack_require__(/*! ../error */ 77);
	
	var DISCONNECTED = 'disconnected';
	var CONNECTING = 'connecting';
	var CONNECTED = 'connected';
	var DESTROYED = 'destroyed';
	
	/**
	 * Creates a new Replicaset State object
	 * @class
	 * @property {object} primary Primary property
	 * @property {array} secondaries List of secondaries
	 * @property {array} arbiters List of arbiters
	 * @return {State} A cursor instance
	 */
	var State = function(replSet, options) {
	  this.replSet = replSet;
	  this.options = options;
	  this.secondaries = [];
	  this.arbiters = [];
	  this.passives = [];
	  this.primary = null;
	  // Initial state is disconnected
	  this.state = DISCONNECTED;
	  // Current electionId
	  this.electionId = null;
	  // Get a logger instance
	  this.logger = Logger('ReplSet', options);
	  // Unpacked options
	  this.id = options.id;
	  this.setName = options.setName;
	  this.connectingServers = options.connectingServers;
	  this.secondaryOnlyConnectionAllowed = options.secondaryOnlyConnectionAllowed;
	}
	
	/**
	 * Is there a secondary connected
	 * @method
	 * @return {boolean}
	 */
	State.prototype.isSecondaryConnected = function() {
	  for(var i = 0; i < this.secondaries.length; i++) {
	    if(this.secondaries[i].isConnected()) return true;
	  }
	
	  return false;
	}
	
	/**
	 * Is there a primary connection
	 * @method
	 * @return {boolean}
	 */
	State.prototype.isPrimaryConnected = function() {
	  return this.primary != null && this.primary.isConnected();
	}
	
	/**
	 * Is the given address the primary
	 * @method
	 * @param {string} address Server address
	 * @return {boolean}
	 */
	State.prototype.isPrimary = function(address) {
	  if(this.primary == null) return false;
	  return this.primary && this.primary.equals(address);
	}
	
	/**
	 * Is the given address a secondary
	 * @method
	 * @param {string} address Server address
	 * @return {boolean}
	 */
	State.prototype.isSecondary = function(address) {
	  // Check if the server is a secondary at the moment
	  for(var i = 0; i < this.secondaries.length; i++) {
	    if(this.secondaries[i].equals(address)) {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Is the given address a secondary
	 * @method
	 * @param {string} address Server address
	 * @return {boolean}
	 */
	State.prototype.isPassive = function(address) {
	  // Check if the server is a secondary at the moment
	  for(var i = 0; i < this.passives.length; i++) {
	    if(this.passives[i].equals(address)) {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Does the replicaset contain this server
	 * @method
	 * @param {string} address Server address
	 * @return {boolean}
	 */
	State.prototype.contains = function(address) {
	  if(this.primary && this.primary.equals(address)) return true;
	  for(var i = 0; i < this.secondaries.length; i++) {
	    if(this.secondaries[i].equals(address)) return true;
	  }
	
	  for(var i = 0; i < this.arbiters.length; i++) {
	    if(this.arbiters[i].equals(address)) return true;
	  }
	
	  for(var i = 0; i < this.passives.length; i++) {
	    if(this.passives[i].equals(address)) return true;
	  }
	
	  return false;
	}
	
	/**
	 * Clean out all dead connections
	 * @method
	 */
	State.prototype.clean = function() {
	  if(this.primary != null && !this.primary.isConnected()) {
	    this.primary = null;
	  }
	
	  // Filter out disconnected servers
	  this.secondaries = this.secondaries.filter(function(s) {
	    return s.isConnected();
	  });
	
	  // Filter out disconnected servers
	  this.arbiters = this.arbiters.filter(function(s) {
	    return s.isConnected();
	  });
	}
	
	/**
	 * Destroy state
	 * @method
	 */
	State.prototype.destroy = function() {
	  this.state = DESTROYED;
	  if(this.primary) this.primary.destroy();
	  this.secondaries.forEach(function(s) {
	    s.destroy();
	  });
	}
	
	/**
	 * Remove server from state
	 * @method
	 * @param {Server} Server to remove
	 * @return {string} Returns type of server removed (primary|secondary)
	 */
	State.prototype.remove = function(server) {
	  if(this.primary && this.primary.equals(server)) {
	    this.primary = null;
	    return 'primary';
	  }
	
	  var length = this.arbiters.length;
	  // Filter out the server from the arbiters
	  this.arbiters = this.arbiters.filter(function(s) {
	    return !s.equals(server);
	  });
	  if(this.arbiters.length < length) return 'arbiter';
	
	  var length = this.passives.length;
	  // Filter out the server from the passives
	  this.passives = this.passives.filter(function(s) {
	    return !s.equals(server);
	  });
	
	  // We have removed a passive
	  if(this.passives.length < length)  {
	    // Ensure we removed it from the list of secondaries as well if it exists
	    this.secondaries = this.secondaries.filter(function(s) {
	      return !s.equals(server);
	    });
	
	    return 'passive';
	  }
	
	  // Filter out the server from the secondaries
	  this.secondaries = this.secondaries.filter(function(s) {
	    return !s.equals(server);
	  });
	
	  return 'secondary';
	}
	
	/**
	 * Get the server by name
	 * @method
	 * @param {string} address Server address
	 * @return {Server}
	 */
	State.prototype.get = function(server) {
	  var found = false;
	  // All servers to search
	  var servers = this.primary ? [this.primary] : [];
	  servers = servers.concat(this.secondaries);
	  // Locate the server
	  for(var i = 0; i < servers.length; i++) {
	    if(servers[i].equals(server)) {
	      return servers[i];
	    }
	  }
	}
	
	/**
	 * Get all the servers in the set
	 * @method
	 * @return {array}
	 */
	State.prototype.getAll = function() {
	  var servers = [];
	  if(this.primary) servers.push(this.primary);
	  return servers.concat(this.secondaries);
	}
	
	/**
	 * All raw connections
	 * @method
	 * @return {array}
	 */
	State.prototype.getAllConnections = function() {
	  var connections = [];
	  if(this.primary) connections = connections.concat(this.primary.connections());
	  this.secondaries.forEach(function(s) {
	    connections = connections.concat(s.connections());
	  })
	
	  return connections;
	}
	
	/**
	 * Return JSON object
	 * @method
	 * @return {object}
	 */
	State.prototype.toJSON = function() {
	  return {
	      primary: this.primary ? this.primary.lastIsMaster().me : null
	    , secondaries: this.secondaries.map(function(s) {
	      return s.lastIsMaster().me
	    })
	  }
	}
	
	/**
	 * Returns the last known ismaster document for this server
	 * @method
	 * @return {object}
	 */
	State.prototype.lastIsMaster = function() {
	  if(this.primary) return this.primary.lastIsMaster();
	  if(this.secondaries.length > 0) return this.secondaries[0].lastIsMaster();
	  return {};
	}
	
	/**
	 * Promote server to primary
	 * @method
	 * @param {Server} server Server we wish to promote
	 */
	State.prototype.promotePrimary = function(server) {
	  var currentServer = this.get(server);
	  // Server does not exist in the state, add it as new primary
	  if(currentServer == null) {
	    this.primary = server;
	    return;
	  }
	
	  // We found a server, make it primary and remove it from the secondaries
	  // Remove the server first
	  this.remove(currentServer);
	  // Set as primary
	  this.primary = currentServer;
	}
	
	var add = function(list, server) {
	  // Check if the server is a secondary at the moment
	  for(var i = 0; i < list.length; i++) {
	    if(list[i].equals(server)) return false;
	  }
	
	  list.push(server);
	  return true;
	}
	
	/**
	 * Add server to list of secondaries
	 * @method
	 * @param {Server} server Server we wish to add
	 */
	State.prototype.addSecondary = function(server) {
	  return add(this.secondaries, server);
	}
	
	/**
	 * Add server to list of arbiters
	 * @method
	 * @param {Server} server Server we wish to add
	 */
	State.prototype.addArbiter = function(server) {
	  return add(this.arbiters, server);
	}
	
	/**
	 * Add server to list of passives
	 * @method
	 * @param {Server} server Server we wish to add
	 */
	State.prototype.addPassive = function(server) {
	  return add(this.passives, server);
	}
	
	var compareObjectIds = function(id1, id2) {
	  var a = new Buffer(id1.toHexString(), 'hex');
	  var b = new Buffer(id2.toHexString(), 'hex');
	
	  if(a === b) {
	    return 0;
	  }
	
	  if(typeof Buffer.compare === 'function') {
	    return Buffer.compare(a, b);
	  }
	
	  var x = a.length;
	  var y = b.length;
	  var len = Math.min(x, y);
	
	  for (var i = 0; i < len; i++) {
	    if (a[i] !== b[i]) {
	      break;
	    }
	  }
	
	  if (i !== len) {
	    x = a[i];
	    y = b[i];
	  }
	
	  return x < y ? -1 : y < x ? 1 : 0;
	}
	
	/**
	 * Update the state given a specific ismaster result
	 * @method
	 * @param {object} ismaster IsMaster result
	 * @param {Server} server IsMaster Server source
	 */
	State.prototype.update = function(ismaster, server) {
	  var self = this;
	  // Not in a known connection valid state
	  if(!ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) {
	    // Remove the state
	    var result = self.remove(server);
	    if(self.state == CONNECTED)  {
	      if(self.logger.isInfo()) self.logger.info(f('[%s] removing %s from set', self.id, ismaster.me));
	      self.replSet.emit('left', self.remove(server), server);
	    }
	
	    return false;
	  }
	
	  // Set the setName if it's not set from the first server
	  if(self.setName == null && ismaster.setName) {
	    if(self.logger.isInfo()) self.logger.info(f('[%s] setting setName to %s', self.id, ismaster.setName));
	    self.setName = ismaster.setName;
	  }
	
	  // Check if the replicaset name matches the provided one
	  if(ismaster.setName && self.setName != ismaster.setName) {
	    if(self.logger.isError()) self.logger.error(f('[%s] server in replset %s is not part of the specified setName %s', self.id, ismaster.setName, self.setName));
	    self.remove(server);
	    self.replSet.emit('error', new MongoError("provided setName for Replicaset Connection does not match setName found in server seedlist"));
	    return false;
	  }
	
	  // Log information
	  if(self.logger.isInfo()) self.logger.info(f('[%s] updating replicaset state %s', self.id, JSON.stringify(this)));
	
	  // It's a master set it
	  if(ismaster.ismaster && self.setName == ismaster.setName && !self.isPrimary(ismaster.me)) {
	    // Check if the electionId is not null
	    if(ismaster.electionId instanceof ObjectId && self.electionId instanceof ObjectId) {
	      if(compareObjectIds(self.electionId, ismaster.electionId) == -1) {
	        self.electionId = ismaster.electionId;
	      } else if(compareObjectIds(self.electionId, ismaster.electionId) == 0) {
	        self.electionId = ismaster.electionId;
	      } else {
	        return false;
	      }
	    }
	
	    // Initial electionId
	    if(ismaster.electionId instanceof ObjectId && self.electionId == null) {
	      self.electionId = ismaster.electionId;
	    }
	
	    // Promote to primary
	    self.promotePrimary(server);
	    // Log change of primary
	    if(self.logger.isInfo()) self.logger.info(f('[%s] promoting %s to primary', self.id, ismaster.me));
	    // Emit primary
	    self.replSet.emit('joined', 'primary', this.primary);
	
	    // We are connected
	    if(self.state == CONNECTING) {
	      self.state = CONNECTED;
	      self.replSet.emit('connect', self.replSet);
	    } else {
	      self.state = CONNECTED;
	      self.replSet.emit('reconnect', server);
	    }
	  } else if(!ismaster.ismaster && self.setName == ismaster.setName
	    && ismaster.arbiterOnly) {
	      if(self.addArbiter(server)) {
	        if(self.logger.isInfo()) self.logger.info(f('[%s] promoting %s to arbiter', self.id, ismaster.me));
	        self.replSet.emit('joined', 'arbiter', server);
	        return true;
	      };
	
	      return false;
	  } else if(!ismaster.ismaster && self.setName == ismaster.setName
	    && ismaster.secondary && ismaster.passive) {
	      if(self.addPassive(server) && self.addSecondary(server)) {
	        if(self.logger.isInfo()) self.logger.info(f('[%s] promoting %s to passive', self.id, ismaster.me));
	        self.replSet.emit('joined', 'passive', server);
	        return true;
	      };
	
	      return false;
	  } else if(!ismaster.ismaster && self.setName == ismaster.setName
	    && ismaster.secondary) {
	      if(self.addSecondary(server)) {
	        if(self.logger.isInfo()) self.logger.info(f('[%s] promoting %s to passive', self.id, ismaster.me));
	        self.replSet.emit('joined', 'secondary', server);
	
	        if(self.secondaryOnlyConnectionAllowed && self.state == CONNECTING) {
	          self.state = CONNECTED;
	          self.replSet.emit('connect', self.replSet);
	        }
	
	        return true;
	      };
	
	      return false;
	  }
	
	  // Return update applied
	  return true;
	}
	
	module.exports = State;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 117 */
/*!**********************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/mongodb-core/lib/topologies/mongos.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var inherits = __webpack_require__(/*! util */ 57).inherits
	  , f = __webpack_require__(/*! util */ 57).format
	  , b = __webpack_require__(/*! bson */ 51)
	  , bindToCurrentDomain = __webpack_require__(/*! ../connection/utils */ 79).bindToCurrentDomain
	  , EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter
	  , BasicCursor = __webpack_require__(/*! ../cursor */ 87)
	  , BSON = __webpack_require__(/*! bson */ 51).native().BSON
	  , BasicCursor = __webpack_require__(/*! ../cursor */ 87)
	  , Server = __webpack_require__(/*! ./server */ 78)
	  , Logger = __webpack_require__(/*! ../connection/logger */ 85)
	  , ReadPreference = __webpack_require__(/*! ./read_preference */ 86)
	  , Session = __webpack_require__(/*! ./session */ 92)
	  , MongoError = __webpack_require__(/*! ../error */ 77);
	
	/**
	 * @fileOverview The **Mongos** class is a class that represents a Mongos Proxy topology and is
	 * used to construct connections.
	 * 
	 * @example
	 * var Mongos = require('mongodb-core').Mongos
	 *   , ReadPreference = require('mongodb-core').ReadPreference
	 *   , assert = require('assert');
	 * 
	 * var server = new Mongos([{host: 'localhost', port: 30000}]);
	 * // Wait for the connection event
	 * server.on('connect', function(server) {
	 *   server.destroy();
	 * });
	 * 
	 * // Start connecting
	 * server.connect();
	 */
	
	var DISCONNECTED = 'disconnected';
	var CONNECTING = 'connecting';
	var CONNECTED = 'connected';
	var DESTROYED = 'destroyed';
	
	// All bson types
	var bsonTypes = [b.Long, b.ObjectID, b.Binary, b.Code, b.DBRef, b.Symbol, b.Double, b.Timestamp, b.MaxKey, b.MinKey];
	// BSON parser
	var bsonInstance = null;
	
	// Instance id
	var mongosId = 0;
	
	//
	// Clone the options
	var cloneOptions = function(options) {
	  var opts = {};
	  for(var name in options) {
	    opts[name] = options[name];
	  }
	  return opts;
	}
	
	var State = function(readPreferenceStrategies) {
	  // Internal state
	  this.s = {
	      connectedServers: []
	    , disconnectedServers: []
	    , readPreferenceStrategies: readPreferenceStrategies
	  }
	}
	
	//
	// A Mongos connected
	State.prototype.connected = function(server) {
	  // Locate in disconnected servers and remove
	  this.s.disconnectedServers = this.s.disconnectedServers.filter(function(s) {
	    return !s.equals(server);
	  });
	
	  var found = false;
	  // Check if the server exists
	  this.s.connectedServers.forEach(function(s) {
	    if(s.equals(server)) found = true;
	  });
	
	  // Add to disconnected list if it does not already exist
	  if(!found) this.s.connectedServers.push(server);
	}
	
	//
	// A Mongos disconnected
	State.prototype.disconnected = function(server) {
	  // Locate in disconnected servers and remove
	  this.s.connectedServers = this.s.connectedServers.filter(function(s) {
	    return !s.equals(server);
	  });
	
	  var found = false;
	  // Check if the server exists
	  this.s.disconnectedServers.forEach(function(s) {
	    if(s.equals(server)) found = true;
	  });
	
	  // Add to disconnected list if it does not already exist
	  if(!found) this.s.disconnectedServers.push(server);
	}
	
	//
	// Return the list of disconnected servers
	State.prototype.disconnectedServers = function() {
	  return this.s.disconnectedServers.slice(0);
	}
	
	//
	// Get connectedServers
	State.prototype.connectedServers = function() {
	  return this.s.connectedServers.slice(0)
	}
	
	//
	// Get all servers
	State.prototype.getAll = function() {
	  return this.s.connectedServers.slice(0).concat(this.s.disconnectedServers);
	}
	
	//
	// Get all connections
	State.prototype.getAllConnections = function() {
	  var connections = [];
	  this.s.connectedServers.forEach(function(e) {
	    connections = connections.concat(e.connections());
	  });
	  return connections;
	}
	
	//
	// Destroy the state
	State.prototype.destroy = function() {
	  // Destroy any connected servers
	  while(this.s.connectedServers.length > 0) {
	    var server = this.s.connectedServers.shift();
	
	    // Remove any non used handlers
	    ['error', 'close', 'timeout', 'connect'].forEach(function(e) {
	      server.removeAllListeners(e);
	    })
	
	    // Server destroy
	    server.destroy();
	    // Add to list of disconnected servers
	    this.s.disconnectedServers.push(server);
	  }        
	}
	
	//
	// Are we connected
	State.prototype.isConnected = function() {
	  return this.s.connectedServers.length > 0;
	}
	
	//
	// Pick a server
	State.prototype.pickServer = function(readPreference) {
	  readPreference = readPreference || ReadPreference.primary;
	
	  // Do we have a custom readPreference strategy, use it
	  if(this.s.readPreferenceStrategies != null && this.s.readPreferenceStrategies[readPreference] != null) {
	    return this.s.readPreferenceStrategies[readPreference].pickServer(connectedServers, readPreference);
	  }
	
	  // No valid connections
	  if(this.s.connectedServers.length == 0) throw new MongoError("no mongos proxy available");
	  // Pick first one
	  return this.s.connectedServers[0];
	}
	
	/**
	 * Creates a new Mongos instance
	 * @class
	 * @param {array} seedlist A list of seeds for the replicaset
	 * @param {number} [options.reconnectTries=30] Reconnect retries for HA if no servers available
	 * @param {number} [options.haInterval=5000] The High availability period for replicaset inquiry
	 * @param {boolean} [options.emitError=false] Server will emit errors events
	 * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors
	 * @param {number} [options.size=5] Server connection pool size
	 * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled
	 * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled
	 * @param {boolean} [options.noDelay=true] TCP Connection no delay
	 * @param {number} [options.connectionTimeout=1000] TCP Connection timeout setting
	 * @param {number} [options.socketTimeout=0] TCP Socket timeout setting
	 * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed
	 * @param {boolean} [options.ssl=false] Use SSL for connection
	 * @param {Buffer} [options.ca] SSL Certificate store binary buffer
	 * @param {Buffer} [options.cert] SSL Certificate binary buffer
	 * @param {Buffer} [options.key] SSL Key file binary buffer
	 * @param {string} [options.passphrase] SSL Certificate pass phrase
	 * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates
	 * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
	 * @return {Mongos} A cursor instance
	 * @fires Mongos#connect
	 * @fires Mongos#joined
	 * @fires Mongos#left
	 */
	var Mongos = function(seedlist, options) {  
	  var self = this;
	  options = options || {};
	  
	  // Add event listener
	  EventEmitter.call(this);
	
	  // Validate seedlist
	  if(!Array.isArray(seedlist)) throw new MongoError("seedlist must be an array");
	  // Validate list
	  if(seedlist.length == 0) throw new MongoError("seedlist must contain at least one entry");
	  // Validate entries
	  seedlist.forEach(function(e) {
	    if(typeof e.host != 'string' || typeof e.port != 'number') 
	      throw new MongoError("seedlist entry must contain a host and port");
	  });
	
	  // BSON Parser, ensure we have a single instance
	  bsonInstance = bsonInstance == null ? new BSON(bsonTypes) : bsonInstance;
	  // Pick the right bson parser
	  var bson = options.bson ? options.bson : bsonInstance;
	  // Add bson parser to options
	  options.bson = bson;
	
	  // The Mongos state
	  this.s = {
	    // Seed list for sharding passed in
	      seedlist: seedlist
	    // Passed in options
	    , options: options
	    // Logger
	    , logger: Logger('Mongos', options)
	    // Reconnect tries
	    , reconnectTries: options.reconnectTries || 30
	    // Ha interval
	    , haInterval: options.haInterval || 5000
	    // Have omitted fullsetup
	    , fullsetup: false
	    // Cursor factory
	    , Cursor: options.cursorFactory || BasicCursor
	    // Current credentials used for auth
	    , credentials: []
	    // BSON Parser
	    , bsonInstance: bsonInstance
	    , bson: bson
	    // Default state
	    , state: DISCONNECTED
	    // Swallow or emit errors
	    , emitError: typeof options.emitError == 'boolean' ? options.emitError : false
	    // Contains any alternate strategies for picking
	    , readPreferenceStrategies: {}
	    // Auth providers
	    , authProviders: {}
	    // Unique instance id
	    , id: mongosId++
	    // Authentication in progress
	    , authInProgress: false
	    // Servers added while auth in progress
	    , authInProgressServers: []
	    // Current retries left
	    , retriesLeft: options.reconnectTries || 30
	    // Do we have a not connected handler
	    , disconnectHandler: options.disconnectHandler
	  }
	
	  // Set up the connection timeout for the options
	  options.connectionTimeout = options.connectionTimeout || 1000;
	
	  // Create a new state for the mongos
	  this.s.mongosState = new State(this.s.readPreferenceStrategies);
	
	  // BSON property (find a server and pass it along)
	  Object.defineProperty(this, 'bson', {
	    enumerable: true, get: function() { 
	      var servers = self.s.mongosState.getAll();
	      return servers.length > 0 ? servers[0].bson : null; 
	    }
	  });
	
	  Object.defineProperty(this, 'id', {
	    enumerable:true, get: function() { return self.s.id; }
	  });
	
	  Object.defineProperty(this, 'type', {
	    enumerable:true, get: function() { return 'mongos'; }
	  });
	
	  Object.defineProperty(this, 'haInterval', {
	    enumerable:true, get: function() { return self.s.haInterval; }
	  });
	
	  Object.defineProperty(this, 'state', {
	    enumerable:true, get: function() { return self.s.mongosState; }
	  });
	}
	
	inherits(Mongos, EventEmitter);
	
	/**
	 * Execute a command
	 * @method
	 * @param {string} type Type of BSON parser to use (c++ or js)
	 */
	Mongos.prototype.setBSONParserType = function(type) {
	  var nBSON = null;
	
	  if(type == 'c++') {
	    nBSON = __webpack_require__(/*! bson */ 51).native().BSON;
	  } else if(type == 'js') {
	    nBSON = __webpack_require__(/*! bson */ 51).pure().BSON;
	  } else {
	    throw new MongoError(f("% parser not supported", type));
	  }
	
	  this.s.options.bson = new nBSON(bsonTypes);
	}  
	
	/**
	 * Returns the last known ismaster document for this server
	 * @method
	 * @return {object}
	 */
	Mongos.prototype.lastIsMaster = function() {
	  var connectedServers = this.s.mongosState.connectedServers();
	  if(connectedServers.length > 0) return connectedServers[0].lastIsMaster();
	  return null; 
	}
	
	/**
	 * Initiate server connect
	 * @method
	 */
	Mongos.prototype.connect = function(_options) {
	  var self = this;
	  // Start replicaset inquiry process
	  setTimeout(mongosInquirer(self, self.s), self.s.haInterval);
	  // Additional options
	  if(_options) for(var name in _options) self.s.options[name] = _options[name];
	  // For all entries in the seedlist build a server instance
	  self.s.seedlist.forEach(function(e) {
	    // Clone options
	    var opts = cloneOptions(self.s.options);
	    // Add host and port
	    opts.host = e.host;
	    opts.port = e.port;
	    opts.reconnect = false;
	    opts.readPreferenceStrategies = self.s.readPreferenceStrategies;
	    // Share the auth store
	    opts.authProviders = self.s.authProviders;
	    // Don't emit errors
	    opts.emitError = true;
	    // Create a new Server
	    self.s.mongosState.disconnected(new Server(opts));
	  });
	
	  // Get the disconnected servers
	  var servers = self.s.mongosState.disconnectedServers();
	
	  // Attempt to connect to all the servers
	  while(servers.length > 0) {
	    // Get the server
	    var server = servers.shift();      
	
	    // Remove any non used handlers
	    ['error', 'close', 'timeout', 'connect', 'message', 'parseError'].forEach(function(e) {
	      server.removeAllListeners(e);
	    });
	
	    // Set up the event handlers
	    server.once('error', errorHandlerTemp(self, self.s, server));
	    server.once('close', errorHandlerTemp(self, self.s, server));
	    server.once('timeout', errorHandlerTemp(self, self.s, server));
	    server.once('parseError', errorHandlerTemp(self, self.s, server));
	    server.once('connect', connectHandler(self, self.s, 'connect'));
	
	    if(self.s.logger.isInfo()) self.s.logger.info(f('connecting to server %s', server.name));
	    // Attempt to connect
	    server.connect();
	  }
	}
	
	/**
	 * Destroy the server connection
	 * @method
	 */
	Mongos.prototype.destroy = function(emitClose) {
	  this.s.state = DESTROYED;
	  // Emit close
	  if(emitClose && self.listeners('close').length > 0) self.emit('close', self);
	  // Destroy the state
	  this.s.mongosState.destroy();
	}
	
	/**
	 * Figure out if the server is connected
	 * @method
	 * @return {boolean}
	 */
	Mongos.prototype.isConnected = function() {
	  return this.s.mongosState.isConnected();
	}
	
	/**
	 * Figure out if the server instance was destroyed by calling destroy
	 * @method
	 * @return {boolean}
	 */
	Mongos.prototype.isDestroyed = function() {
	  return this.s.state  == DESTROYED;
	}
	
	//
	// Operations
	//
	
	/**
	 * Insert one or more documents
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of documents to insert
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {opResultCallback} callback A callback function
	 */
	Mongos.prototype.insert = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!this.isConnected() && this.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return this.s.disconnectHandler.add('insert', ns, ops, options, callback);
	  }
	
	  executeWriteOperation(this.s, 'insert', ns, ops, options, callback);
	}
	
	/**
	 * Perform one or more update operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of updates
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {opResultCallback} callback A callback function
	 */
	Mongos.prototype.update = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!this.isConnected() && this.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return this.s.disconnectHandler.add('update', ns, ops, options, callback);
	  }
	
	  executeWriteOperation(this.s, 'update', ns, ops, options, callback);
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of removes
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {opResultCallback} callback A callback function
	 */
	Mongos.prototype.remove = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!this.isConnected() && this.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return this.s.disconnectHandler.add('remove', ns, ops, options, callback);
	  }
	
	  executeWriteOperation(this.s, 'remove', ns, ops, options, callback);
	}    
	
	/**
	 * Execute a command
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {object} cmd The command hash
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {Connection} [options.connection] Specify connection object to execute command against
	 * @param {opResultCallback} callback A callback function
	 */
	Mongos.prototype.command = function(ns, cmd, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  var self = this;
	
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!self.isConnected() && self.s.disconnectHandler != null) {
	    callback = bindToCurrentDomain(callback);
	    return self.s.disconnectHandler.add('command', ns, cmd, options, callback);
	  }
	
	  var server = null;
	  // Ensure we have no options
	  options = options || {};
	
	  // We need to execute the command on all servers
	  if(options.onAll) {
	    var servers = self.s.mongosState.getAll();
	    var count = servers.length;
	    var cmdErr = null;
	
	    for(var i = 0; i < servers.length; i++) {
	      servers[i].command(ns, cmd, options, function(err, r) {
	        count = count - 1;
	        // Finished executing command
	        if(count == 0) {
	          // Was it a logout command clear any credentials      
	          if(cmd.logout) clearCredentials(state, ns);
	          // Return the error
	          callback(err, r);
	        }
	      });
	    }
	
	    return;
	  }
	
	
	  try {
	    // Get a primary      
	    server = self.s.mongosState.pickServer(options.writeConcern ? ReadPreference.primary : options.readPreference);
	  } catch(err) {
	    return callback(err);
	  }
	
	  // No server returned we had an error
	  if(server == null) return callback(new MongoError("no mongos found"));
	  server.command(ns, cmd, options, function(err, r) {
	    // Was it a logout command clear any credentials      
	    if(cmd.logout) clearCredentials(self.s, ns);
	    callback(err, r);      
	  });
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {{object}|{Long}} cmd Can be either a command returning a cursor or a cursorId
	 * @param {object} [options.batchSize=0] Batchsize for the operation
	 * @param {array} [options.documents=[]] Initial documents list for cursor
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {opResultCallback} callback A callback function
	 */
	Mongos.prototype.cursor = function(ns, cmd, cursorOptions) {
	  cursorOptions = cursorOptions || {};
	  var FinalCursor = cursorOptions.cursorFactory || this.s.Cursor;
	  return new FinalCursor(this.s.bson, ns, cmd, cursorOptions, this, this.s.options);
	}
	
	/**
	 * Authenticate using a specified mechanism
	 * @method
	 * @param {string} mechanism The Auth mechanism we are invoking
	 * @param {string} db The db we are invoking the mechanism against
	 * @param {...object} param Parameters for the specific mechanism
	 * @param {authResultCallback} callback A callback function
	 */
	Mongos.prototype.auth = function(mechanism, db) {
	  var allArgs = Array.prototype.slice.call(arguments, 0).slice(0);
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  var callback = args.pop();
	
	  // If we don't have the mechanism fail
	  if(this.s.authProviders[mechanism] == null && mechanism != 'default')
	    throw new MongoError(f("auth provider %s does not exist", mechanism));
	
	  // Authenticate against all the servers
	  var servers = this.s.mongosState.getAll().slice(0);
	  var count = servers.length;
	  // Correct authentication
	  var authenticated = true;
	  var authErr = null;
	  // Set auth in progress
	  this.s.authInProgress = true;
	
	  // Authenticate against all servers
	  while(servers.length > 0) {
	    var server = servers.shift();
	
	    // Arguments without a callback
	    var argsWithoutCallback = [mechanism, db].concat(args.slice(0));
	    // Create arguments
	    var finalArguments = argsWithoutCallback.concat([function(err, r) {
	      count = count - 1;
	      if(err) authErr = err;
	      if(!r) authenticated = false;
	
	      // We are done
	      if(count == 0) {
	        // We have more servers that are not authenticated, let's authenticate
	        if(self.s.authInProgressServers.length > 0) {
	          self.s.authInProgressServers = [];
	          return self.auth.apply(self, [mechanism, db].concat(args).concat([callback]));
	        }
	
	        // Auth is done
	        self.s.authInProgress = false;
	        // Add successful credentials
	        if(authErr == null) addCredentials(self.s, db, argsWithoutCallback);
	        // Return the auth error
	        if(authErr) return callback(authErr, false);
	        // Successfully authenticated session
	        callback(null, new Session({}, self));
	      }
	    }]);
	
	    // Execute the auth
	    server.auth.apply(server, finalArguments);
	  }
	}  
	
	//
	// Plugin methods
	//
	
	/**
	 * Add custom read preference strategy
	 * @method
	 * @param {string} name Name of the read preference strategy
	 * @param {object} strategy Strategy object instance
	 */
	Mongos.prototype.addReadPreferenceStrategy = function(name, strategy) {
	  if(this.s.readPreferenceStrategies == null) this.s.readPreferenceStrategies = {};
	  this.s.readPreferenceStrategies[name] = strategy;
	}
	
	/**
	 * Add custom authentication mechanism
	 * @method
	 * @param {string} name Name of the authentication mechanism
	 * @param {object} provider Authentication object instance
	 */
	Mongos.prototype.addAuthProvider = function(name, provider) {
	  this.s.authProviders[name] = provider;
	}
	
	/**
	 * Get connection
	 * @method
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @return {Connection}
	 */
	Mongos.prototype.getConnection = function(options) {
	  // Ensure we have no options
	  options = options || {};
	  // Pick the right server based on readPreference
	  var server = this.s.mongosState.pickServer(options.readPreference);
	  if(server == null) return null;
	  // Return connection
	  return server.getConnection();
	}
	
	/**
	 * Get server
	 * @method
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @return {Server}
	 */
	Mongos.prototype.getServer = function(options) {
	  // Ensure we have no options
	  options = options || {};
	  // Pick the right server based on readPreference
	  return this.s.mongosState.pickServer(options.readPreference);
	}
	
	/**
	 * All raw connections
	 * @method
	 * @return {Connection[]}
	 */
	Mongos.prototype.connections = function() {
	  return this.s.mongosState.getAllConnections();
	}
	
	//
	// Inquires about state changes
	//
	var mongosInquirer = function(self, state) {    
	  return function() {
	    if(state.state == DESTROYED) return
	    if(state.state == CONNECTED) state.retriesLeft = state.reconnectTries;
	
	    // If we have a disconnected site
	    if(state.state == DISCONNECTED && state.retriesLeft == 0) {
	      self.destroy();
	      return self.emit('error', new MongoError(f('failed to reconnect after %s', state.reconnectTries)));
	    } else if(state == DISCONNECTED) {
	      state.retriesLeft = state.retriesLeft - 1;
	    }
	
	    // If we have a primary and a disconnect handler, execute
	    // buffered operations
	    if(state.mongosState.isConnected() && state.disconnectHandler) {
	      state.disconnectHandler.execute();
	    }
	
	    // Log the information
	    if(state.logger.isDebug()) state.logger.debug(f('mongos ha proceess running'));
	    
	    // Let's query any disconnected proxies
	    var disconnectedServers = state.mongosState.disconnectedServers();
	    if(disconnectedServers.length == 0) return setTimeout(mongosInquirer(self, state), state.haInterval);
	    
	    // Count of connections waiting to be connected
	    var connectionCount = disconnectedServers.length;
	    if(state.logger.isDebug()) state.logger.debug(f('mongos ha proceess found %d disconnected proxies', connectionCount));
	    
	    // Let's attempt to reconnect
	    while(disconnectedServers.length > 0) {
	      var server = disconnectedServers.shift();
	      if(state.logger.isDebug()) state.logger.debug(f('attempting to connect to server %s', server.name));
	
	      // Remove any listeners
	      ['error', 'close', 'timeout', 'connect', 'message', 'parseError'].forEach(function(e) {
	        server.removeAllListeners(e);
	      });
	  
	      // Set up the event handlers
	      server.once('error', errorHandlerTemp(self, state, server));
	      server.once('close', errorHandlerTemp(self, state, server));
	      server.once('timeout', errorHandlerTemp(self, state, server));
	      server.once('connect', connectHandler(self, state, 'ha'));
	      // Start connect
	      server.connect();
	    }
	
	    // Let's keep monitoring but wait for possible timeout to happen
	    return setTimeout(mongosInquirer(self, state), state.options.connectionTimeout + state.haInterval);      
	  }
	}
	
	//
	// Error handler for initial connect
	var errorHandlerTemp = function(self, state, server) {
	  return function(err, server) {
	    // Log the information
	    if(state.logger.isInfo()) state.logger.info(f('server %s disconnected with error %s',  server.name, JSON.stringify(err)));
	
	    // Remove any non used handlers
	    ['error', 'close', 'timeout', 'connect'].forEach(function(e) {
	      server.removeAllListeners(e);
	    })
	
	    // Signal disconnect of server
	    state.mongosState.disconnected(server);
	  }
	}
	
	//
	// Handlers
	var errorHandler = function(self, state) {
	  return function(err, server) {
	    if(state.logger.isInfo()) state.logger.info(f('server %s errored out with %s', server.name, JSON.stringify(err)));
	    state.mongosState.disconnected(server);
	    // No more servers left emit close
	    if(state.mongosState.connectedServers().length == 0) {
	      state.state = DISCONNECTED;
	    }
	
	    // Signal server left
	    self.emit('left', 'mongos', server);    
	    if(state.emitError) self.emit('error', err, server);
	  }
	}
	
	var timeoutHandler = function(self, state) {
	  return function(err, server) {
	    if(state.logger.isInfo()) state.logger.info(f('server %s timed out', server.name));
	    state.mongosState.disconnected(server);
	
	    // No more servers emit close event if no entries left
	    if(state.mongosState.connectedServers().length == 0) {
	      state.state = DISCONNECTED;
	    }
	
	    // Signal server left
	    self.emit('left', 'mongos', server);
	  }
	}
	
	var closeHandler = function(self, state) {
	  return function(err, server) {
	    if(state.logger.isInfo()) state.logger.info(f('server %s closed', server.name));
	    state.mongosState.disconnected(server);
	
	    // No more servers left emit close
	    if(state.mongosState.connectedServers().length == 0) {
	      state.state = DISCONNECTED;
	    }
	
	    // Signal server left
	    self.emit('left', 'mongos', server);
	  }
	}
	
	// Connect handler
	var connectHandler = function(self, state, e) {
	  return function(server) {
	    if(state.logger.isInfo()) state.logger.info(f('connected to %s', server.name));
	
	    // Remove any non used handlers
	    ['error', 'close', 'timeout', 'connect', 'message', 'parseError'].forEach(function(e) {
	      server.removeAllListeners(e);
	    });
	
	    // finish processing the server
	    var processNewServer = function(_server) {
	      // Add the server handling code
	      if(_server.isConnected()) {
	        _server.once('error', errorHandler(self, state));
	        _server.once('close', closeHandler(self, state));
	        _server.once('timeout', timeoutHandler(self, state));
	        _server.once('parseError', timeoutHandler(self, state));
	      }
	
	      // Emit joined event
	      self.emit('joined', 'mongos', _server);
	
	      // Add to list connected servers
	      state.mongosState.connected(_server);
	
	      // Do we have a reconnect event
	      if('ha' == e && state.mongosState.connectedServers().length == 1) {
	        self.emit('reconnect', _server);
	      }
	
	      // Full setup
	      if(state.mongosState.disconnectedServers().length == 0 && 
	        state.mongosState.connectedServers().length > 0 &&
	        !state.fullsetup) {
	        state.fullsetup = true;
	        self.emit('fullsetup');
	      }
	
	      // all connected
	      if(state.mongosState.disconnectedServers().length == 0 && 
	        state.mongosState.connectedServers().length == state.seedlist.length &&
	        !state.all) {
	        state.all = true;
	        self.emit('all');
	      }
	
	      // Set connected
	      if(state.state == DISCONNECTED) {
	        state.state = CONNECTED;
	        self.emit('connect', self);
	      }
	    }
	
	    // No credentials just process server
	    if(state.credentials.length == 0) return processNewServer(server);
	
	    // Do we have credentials, let's apply them all
	    var count = state.credentials.length;
	    // Apply the credentials
	    for(var i = 0; i < state.credentials.length; i++) {
	      server.auth.apply(server, state.credentials[i].concat([function(err, r) {        
	        count = count - 1;
	        if(count == 0) processNewServer(server);
	      }]));
	    }
	  }
	}
	
	//
	// Add server to the list if it does not exist
	var addToListIfNotExist = function(list, server) {
	  var found = false;
	
	  // Remove any non used handlers
	  ['error', 'close', 'timeout', 'connect'].forEach(function(e) {
	    server.removeAllListeners(e);
	  })
	
	  // Check if the server already exists
	  for(var i = 0; i < list.length; i++) {
	    if(list[i].equals(server)) found = true;
	  }
	
	  if(!found) {
	    list.push(server);
	  }
	}
	
	// Add the new credential for a db, removing the old
	// credential from the cache
	var addCredentials = function(state, db, argsWithoutCallback) {
	  // Remove any credentials for the db
	  clearCredentials(state, db + ".dummy");
	  // Add new credentials to list
	  state.credentials.push(argsWithoutCallback);
	}
	
	// Clear out credentials for a namespace
	var clearCredentials = function(state, ns) {
	  var db = ns.split('.')[0];
	  var filteredCredentials = [];
	
	  // Filter out all credentials for the db the user is logging out off
	  for(var i = 0; i < state.credentials.length; i++) {
	    if(state.credentials[i][1] != db) filteredCredentials.push(state.credentials[i]);
	  }
	
	  // Set new list of credentials
	  state.credentials = filteredCredentials;
	}
	
	var processReadPreference = function(cmd, options) {
	  options = options || {}
	  // No read preference specified
	  if(options.readPreference == null) return cmd;
	}
	
	//
	// Execute write operation
	var executeWriteOperation = function(state, op, ns, ops, options, callback) {
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  var server = null;
	  // Ensure we have no options
	  options = options || {};
	  try {
	    // Get a primary   
	    server = state.mongosState.pickServer();
	  } catch(err) {
	    return callback(err);
	  }
	
	  // No server returned we had an error
	  if(server == null) return callback(new MongoError("no mongos found"));
	  // Execute the command
	  server[op](ns, ops, options, callback);          
	}
	
	/**
	 * A mongos connect event, used to verify that the connection is up and running
	 *
	 * @event Mongos#connect
	 * @type {Mongos}
	 */
	
	/**
	 * A server member left the mongos list
	 *
	 * @event Mongos#left
	 * @type {Mongos}
	 * @param {string} type The type of member that left (mongos)
	 * @param {Server} server The server object that left
	 */
	
	/**
	 * A server member joined the mongos list
	 *
	 * @event Mongos#joined
	 * @type {Mongos}
	 * @param {string} type The type of member that left (mongos)
	 * @param {Server} server The server object that joined
	 */
	
	module.exports = Mongos;

/***/ },
/* 118 */
/*!********************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/cursor.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var inherits = __webpack_require__(/*! util */ 57).inherits
	  , f = __webpack_require__(/*! util */ 57).format
	  , toError = __webpack_require__(/*! ./utils */ 119).toError
	  , getSingleProperty = __webpack_require__(/*! ./utils */ 119).getSingleProperty
	  , formattedOrderClause = __webpack_require__(/*! ./utils */ 119).formattedOrderClause
	  , handleCallback = __webpack_require__(/*! ./utils */ 119).handleCallback
	  , Logger = __webpack_require__(/*! mongodb-core */ 76).Logger
	  , EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter
	  , ReadPreference = __webpack_require__(/*! ./read_preference */ 120)
	  , MongoError = __webpack_require__(/*! mongodb-core */ 76).MongoError
	  , Readable = __webpack_require__(/*! stream */ 121).Readable || __webpack_require__(/*! readable-stream */ 138).Readable
	  , CoreCursor = __webpack_require__(/*! mongodb-core */ 76).Cursor
	  , Query = __webpack_require__(/*! mongodb-core */ 76).Query
	  , CoreReadPreference = __webpack_require__(/*! mongodb-core */ 76).ReadPreference;
	
	/**
	 * @fileOverview The **Cursor** class is an internal class that embodies a cursor on MongoDB
	 * allowing for iteration over the results returned from the underlying query. It supports
	 * one by one document iteration, conversion to an array or can be iterated as a Node 0.10.X
	 * or higher stream
	 *
	 * **CURSORS Cannot directly be instantiated**
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Create a collection we want to drop later
	 *   var col = db.collection('createIndexExample1');
	 *   // Insert a bunch of documents
	 *   col.insert([{a:1, b:1}
	 *     , {a:2, b:2}, {a:3, b:3}
	 *     , {a:4, b:4}], {w:1}, function(err, result) {
	 *     test.equal(null, err);
	 *
	 *     // Show that duplicate records got dropped
	 *     col.find({}).toArray(function(err, items) {
	 *       test.equal(null, err);
	 *       test.equal(4, items.length);
	 *       db.close();
	 *     });
	 *   });
	 * });
	 */
	
	/**
	 * Namespace provided by the mongodb-core and node.js
	 * @external CoreCursor
	 * @external Readable
	 */
	
	// Flags allowed for cursor
	var flags = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];
	var fields = ['numberOfRetries', 'tailableRetryInterval'];
	
	/**
	 * Creates a new Cursor instance (INTERNAL TYPE, do not instantiate directly)
	 * @class Cursor
	 * @extends external:CoreCursor
	 * @extends external:Readable
	 * @property {string} sortValue Cursor query sort setting.
	 * @property {boolean} timeout Is Cursor able to time out.
	 * @property {ReadPreference} readPreference Get cursor ReadPreference.
	 * @fires Cursor#data
	 * @fires Cursor#end
	 * @fires Cursor#close
	 * @fires Cursor#readable
	 * @return {Cursor} a Cursor instance.
	 * @example
	 * Some example
	 */
	var Cursor = function(bson, ns, cmd, options, topology, topologyOptions) {
	  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));
	  var self = this;
	  var state = Cursor.INIT;
	  var streamOptions = {};
	
	  // Tailable cursor options
	  var numberOfRetries = options.numberOfRetries || 5;
	  var tailableRetryInterval = options.tailableRetryInterval || 500;
	  var currentNumberOfRetries = numberOfRetries;
	
	  // Set up
	  Readable.call(this, {objectMode: true});
	
	  // Internal cursor state
	  this.s = {
	    // Tailable cursor options
	      numberOfRetries: numberOfRetries
	    , tailableRetryInterval: tailableRetryInterval
	    , currentNumberOfRetries: currentNumberOfRetries
	    // State
	    , state: state
	    // Stream options
	    , streamOptions: streamOptions
	    // BSON
	    , bson: bson
	    // Namespace
	    , ns: ns
	    // Command
	    , cmd: cmd
	    // Options
	    , options: options
	    // Topology
	    , topology: topology
	    // Topology options
	    , topologyOptions: topologyOptions
	  }
	
	  // Legacy fields
	  this.timeout = self.s.options.noCursorTimeout == true;
	  this.sortValue = self.s.cmd.sort;
	  this.readPreference = self.s.options.readPreference;
	}
	
	/**
	 * Cursor stream data event, fired for each document in the cursor.
	 *
	 * @event Cursor#data
	 * @type {object}
	 */
	
	/**
	 * Cursor stream end event
	 *
	 * @event Cursor#end
	 * @type {null}
	 */
	
	/**
	 * Cursor stream close event
	 *
	 * @event Cursor#close
	 * @type {null}
	 */
	
	/**
	 * Cursor stream readable event
	 *
	 * @event Cursor#readable
	 * @type {null}
	 */
	
	// Inherit from Readable
	inherits(Cursor, Readable);
	
	// Map core cursor _next method so we can apply mapping
	CoreCursor.prototype._next = CoreCursor.prototype.next;
	
	for(var name in CoreCursor.prototype) {
	  Cursor.prototype[name] = CoreCursor.prototype[name];
	}
	
	Cursor.prototype.mister = function() {}
	
	/**
	 * Set the cursor query
	 * @method
	 * @param {object} filter The filter object used for the cursor.
	 * @return {Cursor}
	 */
	Cursor.prototype.filter = function(filter) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw new MongoError("Cursor is closed");
	  this.s.cmd.query = filter;
	  return this;
	}
	
	/**
	 * Set a node.js specific cursor option
	 * @method
	 * @param {string} field The cursor option to set ['numberOfRetries', 'tailableRetryInterval'].
	 * @param {object} value The field value.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.setCursorOption = function(field, value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw new MongoError("Cursor is closed");
	  if(fields.indexOf(field) == -1) throw new MongoError(f("option %s not a supported option %s", field, fields));
	  this.s[field] = value;
	  if(field == 'numberOfRetries') 
	    this.s.currentNumberOfRetries = value;
	  return this;
	}
	
	/**
	 * Add a cursor flag to the cursor
	 * @method
	 * @param {string} flag The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'].
	 * @param {boolean} value The flag boolean value.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.addCursorFlag = function(flag, value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw new MongoError("Cursor is closed");
	  if(flags.indexOf(flag) == -1) throw new MongoError(f("flag %s not a supported flag %s", flag, flags));
	  if(typeof value != 'boolean') throw new MongoError(f("flag %s must be a boolean value", flag));
	  this.s.cmd[flag] = value;
	  return this;
	}
	
	/**
	 * Add a query modifier to the cursor query
	 * @method
	 * @param {string} name The query modifier (must start with $, such as $orderby etc)
	 * @param {boolean} value The flag boolean value.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.addQueryModifier = function(name, value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw new MongoError("Cursor is closed");
	  if(name[0] != '$') throw new MongoError(f("%s is not a valid query modifier"));
	  // Strip of the $
	  var field = name.substr(1);
	  // Set on the command
	  this.s.cmd[field] = value;
	  // Deal with the special case for sort
	  if(field == 'orderby') this.s.cmd.sort = this.s.cmd[field];
	  return this;
	}
	
	/**
	 * Add a comment to the cursor query allowing for tracking the comment in the log.
	 * @method
	 * @param {string} value The comment attached to this query.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.comment = function(value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw new MongoError("Cursor is closed");
	  this.s.cmd.comment = value;
	  return this;
	}
	
	/**
	 * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
	 * @method
	 * @param {number} value Number of milliseconds to wait before aborting the query.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.maxTimeMS = function(value) {
	  if(typeof value != 'number') throw new MongoError("maxTimeMS must be a number");
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw new MongoError("Cursor is closed");
	  this.s.cmd.maxTimeMS = value;
	  return this;
	}
	
	Cursor.prototype.maxTimeMs = Cursor.prototype.maxTimeMS;
	
	/**
	 * Sets a field projection for the query.
	 * @method
	 * @param {object} value The field projection object.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.project = function(value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw new MongoError("Cursor is closed");
	  this.s.cmd.fields = value;
	  return this;
	}
	
	/**
	 * Sets the sort order of the cursor query.
	 * @method
	 * @param {(string|array|object)} keyOrList The key or keys set for the sort.
	 * @param {number} [direction] The direction of the sorting (1 or -1).
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.sort = function(keyOrList, direction) {
	  if(this.s.options.tailable) throw new MongoError("Tailable cursor doesn't support sorting");
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw new MongoError("Cursor is closed");
	  var order = keyOrList;
	
	  if(direction != null) {
	    order = [[keyOrList, direction]];
	  }
	
	  this.s.cmd.sort = order;
	  this.sortValue = order;
	  return this;
	}
	
	/**
	 * Set the batch size for the cursor.
	 * @method
	 * @param {number} value The batchSize for the cursor.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.batchSize = function(value) {
	  if(this.s.options.tailable) throw new MongoError("Tailable cursor doesn't support limit");
	  if(this.s.state == Cursor.CLOSED || this.isDead()) throw new MongoError("Cursor is closed");
	  if(typeof value != 'number') throw new MongoError("batchSize requires an integer");
	  this.s.cmd.batchSize = value;
	  this.setCursorBatchSize(value);
	  return this;
	}
	
	/**
	 * Set the limit for the cursor.
	 * @method
	 * @param {number} value The limit for the cursor query.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.limit = function(value) {
	  if(this.s.options.tailable) throw new MongoError("Tailable cursor doesn't support limit");
	  if(this.s.state == Cursor.OPEN || this.s.state == Cursor.CLOSED || this.isDead()) throw new MongoError("Cursor is closed");
	  if(typeof value != 'number') throw new MongoError("limit requires an integer");
	  this.s.cmd.limit = value;
	  // this.cursorLimit = value;
	  this.setCursorLimit(value);
	  return this;
	}
	
	/**
	 * Set the skip for the cursor.
	 * @method
	 * @param {number} value The skip for the cursor query.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.skip = function(value) {
	  if(this.s.options.tailable) throw new MongoError("Tailable cursor doesn't support skip");
	  if(this.s.state == Cursor.OPEN || this.s.state == Cursor.CLOSED || this.isDead()) throw new MongoError("Cursor is closed");
	  if(typeof value != 'number') throw new MongoError("skip requires an integer");
	  this.s.cmd.skip = value;
	  this.setCursorSkip(value);
	  return this;
	}
	
	/**
	 * The callback format for results
	 * @callback Cursor~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {(object|null)} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Get the next available document from the cursor, returns null if no more documents are available.
	 * @function external:CoreCursor#next
	 * @param {Cursor~resultCallback} callback The result callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	
	/**
	 * Set the new batchSize of the cursor
	 * @function Cursor.prototype.setBatchSize
	 * @param {number} value The new batchSize for the cursor
	 * @return {null}
	 */
	
	/**
	 * Get the batchSize of the cursor
	 * @function Cursor.prototype.batchSize
	 * @param {number} value The current batchSize for the cursor
	 * @return {null}
	 */
	
	/**
	 * Set the new skip value of the cursor
	 * @function Cursor.prototype.setCursorSkip
	 * @param {number} value The new skip for the cursor
	 * @return {null}
	 */
	
	/**
	 * Get the skip value of the cursor
	 * @function Cursor.prototype.cursorSkip
	 * @param {number} value The current skip value for the cursor
	 * @return {null}
	 */
	
	/**
	 * Set the new limit value of the cursor
	 * @function Cursor.prototype.setCursorLimit
	 * @param {number} value The new limit for the cursor
	 * @return {null}
	 */
	
	/**
	 * Get the limit value of the cursor
	 * @function Cursor.prototype.cursorLimit
	 * @param {number} value The current limit value for the cursor
	 * @return {null}
	 */
	
	/**
	 * Clone the cursor
	 * @function external:CoreCursor#clone
	 * @return {Cursor}
	 */
	
	/**
	 * Resets the cursor
	 * @function external:CoreCursor#rewind
	 * @return {null}
	 */
	
	/**
	 * Get the next available document from the cursor, returns null if no more documents are available.
	 * @method
	 * @param {Cursor~resultCallback} callback The result callback.
	 * @throws {MongoError}
	 * @deprecated
	 * @return {null}
	 */
	Cursor.prototype.nextObject = function(callback) {
	  var self = this;
	  if(this.s.state == Cursor.CLOSED || self.isDead()) return handleCallback(callback, new MongoError("Cursor is closed"));
	  if(this.s.state == Cursor.INIT && this.s.cmd.sort) {
	    try {
	      this.s.cmd.sort = formattedOrderClause(this.s.cmd.sort);
	    } catch(err) {
	      return handleCallback(callback, err);
	    }
	  }
	
	  // Get the next object
	  self._next(function(err, doc) {
	    if(err && err.tailable && self.s.currentNumberOfRetries == 0) return callback(err);
	    if(err && err.tailable && self.s.currentNumberOfRetries > 0) {
	      self.s.currentNumberOfRetries = self.s.currentNumberOfRetries - 1;
	      return setTimeout(function() {
	        self.nextObject(callback);
	      }, self.s.tailableRetryInterval);
	    }
	
	    self.s.state = Cursor.OPEN;
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, null, doc);
	  });
	}
	
	// Trampoline emptying the number of retrieved items
	// without incurring a nextTick operation
	var loop = function(self, callback) {
	  // No more items we are done
	  if(self.bufferedCount() == 0) return;
	  // Get the next document
	  self._next(callback);
	  // Loop
	  return loop;
	}
	
	/**
	 * Iterates over all the documents for this cursor. As with **{cursor.toArray}**,
	 * not all of the elements will be iterated if this cursor had been previouly accessed.
	 * In that case, **{cursor.rewind}** can be used to reset the cursor. However, unlike
	 * **{cursor.toArray}**, the cursor will only hold a maximum of batch size elements
	 * at any given time if batch size is specified. Otherwise, the caller is responsible
	 * for making sure that the entire result can fit the memory.
	 * @method
	 * @deprecated
	 * @param {Cursor~resultCallback} callback The result callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	Cursor.prototype.each = function(callback) {
	  // Rewind cursor state
	  this.rewind();
	  // Set current cursor to INIT
	  this.s.state = Cursor.INIT;
	  // Run the query
	  _each(this, callback);
	};
	
	// Run the each loop
	var _each = function(self, callback) {
	  if(!callback) throw new MongoError('callback is mandatory');
	  if(self.isNotified()) return;
	  if(self.s.state == Cursor.CLOSED || self.isDead()) {
	    return handleCallback(callback, new MongoError("Cursor is closed"), null);
	  }
	
	  if(self.s.state == Cursor.INIT) self.s.state = Cursor.OPEN;
	
	  // Define function to avoid global scope escape
	  var fn = null;
	  // Trampoline all the entries
	  if(self.bufferedCount() > 0) {
	    while(fn = loop(self, callback)) fn(self, callback);
	    _each(self, callback);
	  } else {
	    self._next(function(err, item) {
	      if(err) return handleCallback(callback, err);
	      if(item == null) {
	        self.s.state = Cursor.CLOSED;
	        return handleCallback(callback, null, null);
	      }
	
	      if(handleCallback(callback, null, item) == false) return;
	      _each(self, callback);
	    })
	  }
	}
	
	/**
	 * The callback format for the forEach iterator method
	 * @callback Cursor~iteratorCallback
	 * @param {Object} doc An emitted document for the iterator
	 */
	
	/**
	 * The callback error format for the forEach iterator method
	 * @callback Cursor~endCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 */
	
	/**
	 * Iterates over all the documents for this cursor using the iterator, callback pattern.
	 * @method
	 * @param {Cursor~iteratorCallback} iterator The iteration callback.
	 * @param {Cursor~endCallback} callback The end callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	Cursor.prototype.forEach = function(iterator, callback) {
	  this.each(function(err, doc){
	    if(err) { callback(err); return false; }
	    if(doc != null) { iterator(doc); return true; }
	    if(doc == null && callback) {
	      var internalCallback = callback;
	      callback = null;
	      internalCallback(null);
	      return false;
	    }
	  });
	}
	
	/**
	 * Set the ReadPreference for the cursor.
	 * @method
	 * @param {(string|ReadPreference)} readPreference The new read preference for the cursor.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.setReadPreference = function(r) {
	  if(this.s.state != Cursor.INIT) throw new MongoError('cannot change cursor readPreference after cursor has been accessed');
	  if(r instanceof ReadPreference) {
	    this.s.options.readPreference = new CoreReadPreference(r.mode, r.tags);
	  } else {
	    this.s.options.readPreference = new CoreReadPreference(r);
	  }
	
	  return this;
	}
	
	/**
	 * The callback format for results
	 * @callback Cursor~toArrayResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object[]} documents All the documents the satisfy the cursor.
	 */
	
	/**
	 * Returns an array of documents. The caller is responsible for making sure that there
	 * is enough memory to store the results. Note that the array only contain partial
	 * results when this cursor had been previouly accessed. In that case,
	 * cursor.rewind() can be used to reset the cursor.
	 * @method
	 * @param {Cursor~toArrayResultCallback} callback The result callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	Cursor.prototype.toArray = function(callback) {
	  var self = this;
	  if(!callback) throw new MongoError('callback is mandatory');
	  if(self.s.options.tailable) return handleCallback(callback, new MongoError("Tailable cursor cannot be converted to array"), null);
	  var items = [];
	
	  // Reset cursor
	  this.rewind();
	  self.s.state = Cursor.INIT;
	
	
	  // Fetch all the documents
	  var fetchDocs = function() {
	    self._next(function(err, doc) {
	      if(err) return handleCallback(callback, err);
	      if(doc == null) {
	        self.s.state = Cursor.CLOSED;
	        return handleCallback(callback, null, items);
	      }
	
	      // Add doc to items
	      items.push(doc)
	      // Get all buffered objects
	      if(self.bufferedCount() > 0) {
	        var docs = self.readBufferedDocuments(self.bufferedCount())
	
	        // Transform the doc if transform method added
	        if(self.s.transforms && typeof self.s.transforms.doc == 'function') {
	          docs = docs.map(self.s.transforms.doc);
	        }
	
	        items = items.concat(docs);
	      }
	
	      // Attempt a fetch
	      fetchDocs();
	    })
	  }
	
	  fetchDocs();
	}
	
	/**
	 * The callback format for results
	 * @callback Cursor~countResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {number} count The count of documents.
	 */
	
	/**
	 * Get the count of documents for this cursor
	 * @method
	 * @param {boolean} applySkipLimit Should the count command apply limit and skip settings on the cursor or in the passed in options.
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.skip=null] The number of documents to skip.
	 * @param {number} [options.limit=null] The maximum amounts to count before aborting.
	 * @param {number} [options.maxTimeMS=null] Number of miliseconds to wait before aborting the query.
	 * @param {string} [options.hint=null] An index name hint for the query.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {Cursor~countResultCallback} callback The result callback.
	 * @return {null}
	 */
	Cursor.prototype.count = function(applySkipLimit, opts, callback) {
	  var self = this;
	  if(typeof opts == 'function') callback = opts, opts = {};
	  opts = opts || {};
	  if(self.s.cmd.query == null) callback(new MongoError("count can only be used with find command"));
	  if(typeof applySkipLimit == 'function') {
	    callback = applySkipLimit;
	    applySkipLimit = true;
	  }
	
	  if(applySkipLimit) {
	    if(typeof this.cursorSkip() == 'number') opts.skip = this.cursorSkip();
	    if(typeof this.cursorLimit() == 'number') opts.limit = this.cursorLimit();
	  }
	
	  // Command
	  var delimiter = self.s.ns.indexOf('.');
	
	  var command = {
	    'count': self.s.ns.substr(delimiter+1), 'query': self.s.cmd.query
	  }
	
	  if(typeof opts.maxTimeMS == 'number') {
	    command.maxTimeMS = opts.maxTimeMS;
	  } else if(typeof self.s.maxTimeMS == 'number') {
	    command.maxTimeMS = self.s.maxTimeMS;
	  }
	
	  // Get a server
	  var server = self.s.topology.getServer(opts);
	  // Get a connection
	  var connection = self.s.topology.getConnection(opts);
	  // Get the callbacks
	  var callbacks = server.getCallbacks();
	
	  // Merge in any options
	  if(opts.skip) command.skip = opts.skip;
	  if(opts.limit) command.limit = opts.limit;
	  if(self.s.options.hint) command.hint = self.s.options.hint;
	
	  // Build Query object
	  var query = new Query(self.s.bson, f("%s.$cmd", self.s.ns.substr(0, delimiter)), command, {
	      numberToSkip: 0, numberToReturn: -1
	    , checkKeys: false
	  });
	
	  // Set up callback
	  callbacks.register(query.requestId, function(err, result) {
	    if(err) return handleCallback(callback, err);
	    if(result.documents.length == 1
	      && (result.documents[0].errmsg
	      || result.documents[0].err
	      || result.documents[0]['$err'])) return callback(MongoError.create(result.documents[0]));
	    handleCallback(callback, null, result.documents[0].n);
	  });
	
	  // Write the initial command out
	  connection.write(query.toBin());
	};
	
	/**
	 * Close the cursor, sending a KillCursor command and emitting close.
	 * @method
	 * @param {Cursor~resultCallback} [callback] The result callback.
	 * @return {null}
	 */
	Cursor.prototype.close = function(callback) {
	  this.s.state = Cursor.CLOSED;
	  // Kill the cursor
	  this.kill();
	  // Emit the close event for the cursor
	  this.emit('close');
	  // Callback if provided
	  if(callback) return handleCallback(callback, null, this);
	}
	
	/**
	 * Map all documents using the provided function
	 * @method
	 * @param {function} [transform] The mapping transformation method.
	 * @return {null}
	 */
	Cursor.prototype.map = function(transform) {
	  this.cursorState.transforms = { doc: transform };
	  return this;
	}
	
	/**
	 * Is the cursor closed
	 * @method
	 * @return {boolean}
	 */
	Cursor.prototype.isClosed = function() {
	  return this.isDead();
	}
	
	Cursor.prototype.destroy = function(err) {
	  this.pause();
	  this.close();
	  if(err) this.emit('error', err);
	}
	
	/**
	 * Return a modified Readable stream including a possible transform method.
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {function} [options.transform=null] A transformation method applied to each document emitted by the stream.
	 * @return {Cursor}
	 */
	Cursor.prototype.stream = function(options) {
	  this.s.streamOptions = options || {};
	  return this;
	}
	
	/**
	 * Execute the explain for the cursor
	 * @method
	 * @param {Cursor~resultCallback} [callback] The result callback.
	 * @return {null}
	 */
	Cursor.prototype.explain = function(callback) {
	  this.s.cmd.explain = true;
	  this._next(callback);
	}
	
	Cursor.prototype._read = function(n) {
	  var self = this;
	  if(self.s.state == Cursor.CLOSED || self.isDead()) {
	    return self.push(null);
	  }
	
	  // Get the next item
	  self.nextObject(function(err, result) {
	    if(err) {
	      if(!self.isDead()) self.close();
	      if(self.listeners('error') && self.listeners('error').length > 0) {
	        self.emit('error', err);
	      }
	
	      // Emit end event
	      return self.emit('end');
	    }
	
	    // If we provided a transformation method
	    if(typeof self.s.streamOptions.transform == 'function' && result != null) {
	      return self.push(self.s.streamOptions.transform(result));
	    }
	
	    // If we provided a map function
	    if(self.cursorState.transforms && typeof self.cursorState.transforms.doc == 'function' && result != null) {
	      return self.push(self.cursorState.transforms.doc(result));
	    }
	
	    // Return the result
	    self.push(result);
	  });
	}
	
	Object.defineProperty(Cursor.prototype, 'namespace', {
	  enumerable: true,
	  get: function() {
	    if (!this || !this.s) {
	      return null;
	    }
	
	    // TODO: refactor this logic into core
	    var ns = this.s.ns || '';
	    var firstDot = ns.indexOf('.');
	    if (firstDot < 0) {
	      return {
	        database: this.s.ns,
	        collection: ''
	      };
	    }
	    return {
	      database: ns.substr(0, firstDot),
	      collection: ns.substr(firstDot + 1)
	    };
	  }
	});
	
	/**
	 * The read() method pulls some data out of the internal buffer and returns it. If there is no data available, then it will return null.
	 * @function external:Readable#read
	 * @param {number} size Optional argument to specify how much data to read.
	 * @return {(String | Buffer | null)}
	 */
	
	/**
	 * Call this function to cause the stream to return strings of the specified encoding instead of Buffer objects.
	 * @function external:Readable#setEncoding
	 * @param {string} encoding The encoding to use.
	 * @return {null}
	 */
	
	/**
	 * This method will cause the readable stream to resume emitting data events.
	 * @function external:Readable#resume
	 * @return {null}
	 */
	
	/**
	 * This method will cause a stream in flowing-mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.
	 * @function external:Readable#pause
	 * @return {null}
	 */
	
	/**
	 * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.
	 * @function external:Readable#pipe
	 * @param {Writable} destination The destination for writing data
	 * @param {object} [options] Pipe options
	 * @return {null}
	 */
	
	/**
	 * This method will remove the hooks set up for a previous pipe() call.
	 * @function external:Readable#unpipe
	 * @param {Writable} [destination] The destination for writing data
	 * @return {null}
	 */
	
	/**
	 * This is useful in certain cases where a stream is being consumed by a parser, which needs to "un-consume" some data that it has optimistically pulled out of the source, so that the stream can be passed on to some other party.
	 * @function external:Readable#unshift
	 * @param {(Buffer|string)} chunk Chunk of data to unshift onto the read queue.
	 * @return {null}
	 */
	
	/**
	 * Versions of Node prior to v0.10 had streams that did not implement the entire Streams API as it is today. (See "Compatibility" below for more information.)
	 * @function external:Readable#wrap
	 * @param {Stream} stream An "old style" readable stream.
	 * @return {null}
	 */
	
	Cursor.INIT = 0;
	Cursor.OPEN = 1;
	Cursor.CLOSED = 2;
	Cursor.GET_MORE = 3;
	
	module.exports = Cursor;


/***/ },
/* 119 */
/*!*******************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/utils.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var MongoError = __webpack_require__(/*! mongodb-core */ 76).MongoError
	
	var shallowClone = function(obj) {
	  var copy = {};
	  for(var name in obj) copy[name] = obj[name];
	  return copy;
	}
	
	// Set simple property
	var getSingleProperty = function(obj, name, value) {
	  Object.defineProperty(obj, name, {
	    enumerable:true,
	    get: function() {
	      return value 
	    }
	  });  
	}
	
	var formatSortValue = exports.formatSortValue = function(sortDirection) {
	  var value = ("" + sortDirection).toLowerCase();
	
	  switch (value) {
	    case 'ascending':
	    case 'asc':
	    case '1':
	      return 1;
	    case 'descending':
	    case 'desc':
	    case '-1':
	      return -1;
	    default:
	      throw new Error("Illegal sort clause, must be of the form "
	                    + "[['field1', '(ascending|descending)'], "
	                    + "['field2', '(ascending|descending)']]");
	  }
	};
	
	var formattedOrderClause = exports.formattedOrderClause = function(sortValue) {
	  var orderBy = {};
	  if(sortValue == null) return null;
	  if (Array.isArray(sortValue)) {
	    if(sortValue.length === 0) {
	      return null;
	    }
	
	    for(var i = 0; i < sortValue.length; i++) {
	      if(sortValue[i].constructor == String) {
	        orderBy[sortValue[i]] = 1;
	      } else {
	        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);
	      }      
	    }
	  } else if(sortValue != null && typeof sortValue == 'object') {
	    orderBy = sortValue;
	  } else if (typeof sortValue == 'string') {
	    orderBy[sortValue] = 1;
	  } else {
	    throw new Error("Illegal sort clause, must be of the form " +
	      "[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
	  }
	
	  return orderBy;
	};
	
	var checkCollectionName = function checkCollectionName (collectionName) {
	  if('string' !== typeof collectionName) {
	    throw Error("collection name must be a String");
	  }
	
	  if(!collectionName || collectionName.indexOf('..') != -1) {
	    throw Error("collection names cannot be empty");
	  }
	
	  if(collectionName.indexOf('$') != -1 &&
	      collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) {
	    throw Error("collection names must not contain '$'");
	  }
	
	  if(collectionName.match(/^\.|\.$/) != null) {
	    throw Error("collection names must not start or end with '.'");
	  }
	
	  // Validate that we are not passing 0x00 in the colletion name
	  if(!!~collectionName.indexOf("\x00")) {
	    throw new Error("collection names cannot contain a null character");
	  }
	};
	
	var handleCallback = function(callback, err, value1, value2) {
	  try {
	    if(callback == null) return;
	    if(value2) return callback(err, value1, value2);
	    return callback(err, value1);
	  } catch(err) {
	    process.nextTick(function() { throw err; });
	    return false;
	  }
	
	  return true;
	}
	
	/**
	 * Wrap a Mongo error document in an Error instance
	 * @ignore
	 * @api private
	 */
	var toError = function(error) {
	  if (error instanceof Error) return error;
	
	  var msg = error.err || error.errmsg || error.errMessage || error;
	  var e = new MongoError(msg);
	
	  // Get all object keys
	  var keys = typeof error == 'object'
	    ? Object.keys(error)
	    : [];
	
	  for(var i = 0; i < keys.length; i++) {
	    e[keys[i]] = error[keys[i]];
	  }
	
	  return e;
	}
	
	/**
	 * @ignore
	 */
	var normalizeHintField = function normalizeHintField(hint) {
	  var finalHint = null;
	
	  if(typeof hint == 'string') {
	    finalHint = hint;
	  } else if(Array.isArray(hint)) {
	    finalHint = {};
	
	    hint.forEach(function(param) {
	      finalHint[param] = 1;
	    });  
	  } else if(hint != null && typeof hint == 'object') {
	    finalHint = {};
	    for (var name in hint) {
	      finalHint[name] = hint[name];
	    }    
	  }
	
	  return finalHint;
	};
	
	/**
	 * Create index name based on field spec
	 *
	 * @ignore
	 * @api private
	 */
	var parseIndexOptions = function(fieldOrSpec) {
	  var fieldHash = {};
	  var indexes = [];
	  var keys;
	
	  // Get all the fields accordingly
	  if('string' == typeof fieldOrSpec) {
	    // 'type'
	    indexes.push(fieldOrSpec + '_' + 1);
	    fieldHash[fieldOrSpec] = 1;
	  } else if(Array.isArray(fieldOrSpec)) {
	    fieldOrSpec.forEach(function(f) {
	      if('string' == typeof f) {
	        // [{location:'2d'}, 'type']
	        indexes.push(f + '_' + 1);
	        fieldHash[f] = 1;
	      } else if(Array.isArray(f)) {
	        // [['location', '2d'],['type', 1]]
	        indexes.push(f[0] + '_' + (f[1] || 1));
	        fieldHash[f[0]] = f[1] || 1;
	      } else if(isObject(f)) {
	        // [{location:'2d'}, {type:1}]
	        keys = Object.keys(f);
	        keys.forEach(function(k) {
	          indexes.push(k + '_' + f[k]);
	          fieldHash[k] = f[k];
	        });
	      } else {
	        // undefined (ignore)
	      }
	    });
	  } else if(isObject(fieldOrSpec)) {
	    // {location:'2d', type:1}
	    keys = Object.keys(fieldOrSpec);
	    keys.forEach(function(key) {
	      indexes.push(key + '_' + fieldOrSpec[key]);
	      fieldHash[key] = fieldOrSpec[key];
	    });
	  }
	
	  return {
	    name: indexes.join("_"), keys: keys, fieldHash: fieldHash
	  }
	}
	
	var isObject = exports.isObject = function (arg) {
	  return '[object Object]' == toString.call(arg)
	}
	
	var debugOptions = function(debugFields, options) {
	  var finaloptions = {};
	  debugFields.forEach(function(n) {
	    finaloptions[n] = options[n];
	  });
	
	  return finaloptions;
	}
	
	var decorateCommand = function(command, options, exclude) {
	  for(var name in options) {
	    if(exclude[name] == null) command[name] = options[name];
	  }
	
	  return command;
	}
	
	exports.shallowClone = shallowClone;
	exports.getSingleProperty = getSingleProperty;
	exports.checkCollectionName = checkCollectionName;
	exports.toError = toError;
	exports.formattedOrderClause = formattedOrderClause;
	exports.parseIndexOptions = parseIndexOptions;
	exports.normalizeHintField = normalizeHintField;
	exports.handleCallback = handleCallback;
	exports.decorateCommand = decorateCommand;
	exports.isObject = isObject;
	exports.debugOptions = debugOptions;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 120 */
/*!*****************************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/read_preference.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	/**
	 * @fileOverview The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is
	 * used to construct connections.
	 * 
	 * @example
	 * var Db = require('mongodb').Db,
	 *   ReplSet = require('mongodb').ReplSet,
	 *   Server = require('mongodb').Server,
	 *   ReadPreference = require('mongodb').ReadPreference,
	 *   test = require('assert');
	 * // Connect using ReplSet
	 * var server = new Server('localhost', 27017);
	 * var db = new Db('test', new ReplSet([server]));
	 * db.open(function(err, db) {
	 *   test.equal(null, err);
	 *   // Perform a read
	 *   var cursor = db.collection('t').find({});
	 *   cursor.setReadPreference(ReadPreference.PRIMARY);
	 *   cursor.toArray(function(err, docs) {
	 *     test.equal(null, err);
	 *     db.close();
	 *   });
	 * });
	 */
	
	/**
	 * Creates a new ReadPreference instance
	 * 
	 * Read Preferences
	 *  - **ReadPreference.PRIMARY**, Read from primary only. All operations produce an error (throw an exception where applicable) if primary is unavailable. Cannot be combined with tags (This is the default.).
	 *  - **ReadPreference.PRIMARY_PREFERRED**, Read from primary if available, otherwise a secondary.
	 *  - **ReadPreference.SECONDARY**, Read from secondary if available, otherwise error.
	 *  - **ReadPreference.SECONDARY_PREFERRED**, Read from a secondary if available, otherwise read from the primary.
	 *  - **ReadPreference.NEAREST**, All modes read from among the nearest candidates, but unlike other modes, NEAREST will include both the primary and all secondaries in the random selection.
	 *
	 * @class
	 * @param {string} mode The ReadPreference mode as listed above.
	 * @param {object} tags An object representing read preference tags.
	 * @property {string} mode The ReadPreference mode.
	 * @property {object} tags The ReadPreference tags.
	 * @return {ReadPreference} a ReadPreference instance.
	 */ 
	var ReadPreference = function(mode, tags) {
	  if(!(this instanceof ReadPreference))
	    return new ReadPreference(mode, tags);
	  this._type = 'ReadPreference';
	  this.mode = mode;
	  this.tags = tags;
	}
	
	/**
	 * Validate if a mode is legal
	 *
	 * @method
	 * @param {string} mode The string representing the read preference mode.
	 * @return {boolean}
	 */  
	ReadPreference.isValid = function(_mode) {
	  return (_mode == ReadPreference.PRIMARY || _mode == ReadPreference.PRIMARY_PREFERRED
	    || _mode == ReadPreference.SECONDARY || _mode == ReadPreference.SECONDARY_PREFERRED
	    || _mode == ReadPreference.NEAREST
	    || _mode == true || _mode == false || _mode == null);
	}
	
	/**
	 * Validate if a mode is legal
	 *
	 * @method
	 * @param {string} mode The string representing the read preference mode.
	 * @return {boolean}
	 */  
	ReadPreference.prototype.isValid = function(mode) {
	  var _mode = typeof mode == 'string' ? mode : this.mode;
	  return ReadPreference.isValid(_mode);
	}
	
	/**
	 * @ignore
	 */
	ReadPreference.prototype.toObject = function() {
	  var object = {mode:this.mode};
	
	  if(this.tags != null) {
	    object['tags'] = this.tags;
	  }
	
	  return object;
	}
	
	/**
	 * @ignore
	 */
	ReadPreference.PRIMARY = 'primary';
	ReadPreference.PRIMARY_PREFERRED = 'primaryPreferred';
	ReadPreference.SECONDARY = 'secondary';
	ReadPreference.SECONDARY_PREFERRED = 'secondaryPreferred';
	ReadPreference.NEAREST = 'nearest'
	
	/**
	 * @ignore
	 */
	module.exports = ReadPreference;

/***/ },
/* 121 */
/*!**********************************************************!*\
  !*** ./~/node-libs-browser/~/stream-browserify/index.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Stream;
	
	var EE = __webpack_require__(/*! events */ 74).EventEmitter;
	var inherits = __webpack_require__(/*! inherits */ 122);
	
	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(/*! readable-stream/readable.js */ 123);
	Stream.Writable = __webpack_require__(/*! readable-stream/writable.js */ 134);
	Stream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ 135);
	Stream.Transform = __webpack_require__(/*! readable-stream/transform.js */ 136);
	Stream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ 137);
	
	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;
	
	
	
	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.
	
	function Stream() {
	  EE.call(this);
	}
	
	Stream.prototype.pipe = function(dest, options) {
	  var source = this;
	
	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }
	
	  source.on('data', ondata);
	
	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }
	
	  dest.on('drain', ondrain);
	
	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }
	
	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    dest.end();
	  }
	
	
	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    if (typeof dest.destroy === 'function') dest.destroy();
	  }
	
	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }
	
	  source.on('error', onerror);
	  dest.on('error', onerror);
	
	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);
	
	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);
	
	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);
	
	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);
	
	    dest.removeListener('close', cleanup);
	  }
	
	  source.on('end', cleanup);
	  source.on('close', cleanup);
	
	  dest.on('close', cleanup);
	
	  dest.emit('pipe', source);
	
	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 122 */
/*!********************************************************************************!*\
  !*** ./~/node-libs-browser/~/stream-browserify/~/inherits/inherits_browser.js ***!
  \********************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 123 */
/*!***********************************************************!*\
  !*** ./~/node-libs-browser/~/readable-stream/readable.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ 127);
	exports.Stream = __webpack_require__(/*! stream */ 121);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ 131);
	exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ 124);
	exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ 132);
	exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ 133);


/***/ },
/* 124 */
/*!*********************************************************************!*\
  !*** ./~/node-libs-browser/~/readable-stream/lib/_stream_duplex.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/
	
	
	/*<replacement>*/
	var util = __webpack_require__(/*! core-util-is */ 125);
	util.inherits = __webpack_require__(/*! inherits */ 126);
	/*</replacement>*/
	
	var Readable = __webpack_require__(/*! ./_stream_readable */ 127);
	var Writable = __webpack_require__(/*! ./_stream_writable */ 131);
	
	util.inherits(Duplex, Readable);
	
	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});
	
	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false)
	    this.readable = false;
	
	  if (options && options.writable === false)
	    this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 125 */
/*!**************************************************************************!*\
  !*** ./~/node-libs-browser/~/readable-stream/~/core-util-is/lib/util.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	function isBuffer(arg) {
	  return Buffer.isBuffer(arg);
	}
	exports.isBuffer = isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 126 */
/*!******************************************************************************!*\
  !*** ./~/node-libs-browser/~/readable-stream/~/inherits/inherits_browser.js ***!
  \******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 127 */
/*!***********************************************************************!*\
  !*** ./~/node-libs-browser/~/readable-stream/lib/_stream_readable.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Readable;
	
	/*<replacement>*/
	var isArray = __webpack_require__(/*! isarray */ 128);
	/*</replacement>*/
	
	
	/*<replacement>*/
	var Buffer = __webpack_require__(/*! buffer */ 28).Buffer;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	var EE = __webpack_require__(/*! events */ 74).EventEmitter;
	
	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	var Stream = __webpack_require__(/*! stream */ 121);
	
	/*<replacement>*/
	var util = __webpack_require__(/*! core-util-is */ 125);
	util.inherits = __webpack_require__(/*! inherits */ 126);
	/*</replacement>*/
	
	var StringDecoder;
	
	
	/*<replacement>*/
	var debug = __webpack_require__(/*! util */ 129);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/
	
	
	util.inherits(Readable, Stream);
	
	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(/*! ./_stream_duplex */ 124);
	
	  options = options || {};
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(/*! string_decoder/ */ 130).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  var Duplex = __webpack_require__(/*! ./_stream_duplex */ 124);
	
	  if (!(this instanceof Readable))
	    return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;
	
	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);
	
	      if (!addToFront)
	        state.reading = false;
	
	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);
	
	        if (state.needReadable)
	          emitReadable(stream);
	      }
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(/*! string_decoder/ */ 130).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};
	
	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}
	
	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;
	
	  if (state.objectMode)
	    return n === 0 ? 0 : 1;
	
	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }
	
	  if (n <= 0)
	    return 0;
	
	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);
	
	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }
	
	  return n;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;
	
	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }
	
	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }
	
	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);
	
	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;
	
	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }
	
	  state.length -= n;
	
	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;
	
	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);
	
	  if (!util.isNull(ret))
	    this.emit('data', ret);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	
	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}
	
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}
	
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};
	
	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }
	
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }
	
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];
	
	
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	
	
	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;
	
	    if (!dest)
	      dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }
	
	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;
	
	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }
	
	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};
	
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}
	
	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}
	
	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;
	
	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;
	
	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);
	
	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);
	
	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);
	
	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();
	
	        c += cpy;
	      }
	    }
	  }
	
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');
	
	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 128 */
/*!******************************************************************!*\
  !*** ./~/node-libs-browser/~/readable-stream/~/isarray/index.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 129 */
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ function(module, exports, __webpack_require__) {

	/* (ignored) */

/***/ },
/* 130 */
/*!*******************************************************!*\
  !*** ./~/node-libs-browser/~/string_decoder/index.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(/*! buffer */ 28).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 131 */
/*!***********************************************************************!*\
  !*** ./~/node-libs-browser/~/readable-stream/lib/_stream_writable.js ***!
  \***********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.
	
	module.exports = Writable;
	
	/*<replacement>*/
	var Buffer = __webpack_require__(/*! buffer */ 28).Buffer;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	
	/*<replacement>*/
	var util = __webpack_require__(/*! core-util-is */ 125);
	util.inherits = __webpack_require__(/*! inherits */ 126);
	/*</replacement>*/
	
	var Stream = __webpack_require__(/*! stream */ 121);
	
	util.inherits(Writable, Stream);
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}
	
	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(/*! ./_stream_duplex */ 124);
	
	  options = options || {};
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.buffer = [];
	
	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;
	
	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}
	
	function Writable(options) {
	  var Duplex = __webpack_require__(/*! ./_stream_duplex */ 124);
	
	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};
	
	
	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;
	
	  if (!util.isFunction(cb))
	    cb = function() {};
	
	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }
	
	  return ret;
	};
	
	Writable.prototype.cork = function() {
	  var state = this._writableState;
	
	  state.corked++;
	};
	
	Writable.prototype.uncork = function() {
	  var state = this._writableState;
	
	  if (state.corked) {
	    state.corked--;
	
	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;
	
	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	
	  return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);
	
	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }
	
	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	
	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);
	
	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });
	
	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }
	
	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }
	
	  state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);
	
	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};
	
	
	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}
	
	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 132 */
/*!************************************************************************!*\
  !*** ./~/node-libs-browser/~/readable-stream/lib/_stream_transform.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	
	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(/*! ./_stream_duplex */ 124);
	
	/*<replacement>*/
	var util = __webpack_require__(/*! core-util-is */ 125);
	util.inherits = __webpack_require__(/*! inherits */ 126);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	
	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (!util.isNullOrUndefined(data))
	    stream.push(data);
	
	  if (cb)
	    cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	
	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);
	
	  Duplex.call(this, options);
	
	  this._transformState = new TransformState(options, this);
	
	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}
	
	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};
	
	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;
	
	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	
	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;
	
	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');
	
	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');
	
	  return stream.push(null);
	}


/***/ },
/* 133 */
/*!**************************************************************************!*\
  !*** ./~/node-libs-browser/~/readable-stream/lib/_stream_passthrough.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(/*! ./_stream_transform */ 132);
	
	/*<replacement>*/
	var util = __webpack_require__(/*! core-util-is */ 125);
	util.inherits = __webpack_require__(/*! inherits */ 126);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 134 */
/*!***********************************************************!*\
  !*** ./~/node-libs-browser/~/readable-stream/writable.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ 131)


/***/ },
/* 135 */
/*!*********************************************************!*\
  !*** ./~/node-libs-browser/~/readable-stream/duplex.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ 124)


/***/ },
/* 136 */
/*!************************************************************!*\
  !*** ./~/node-libs-browser/~/readable-stream/transform.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./lib/_stream_transform.js */ 132)


/***/ },
/* 137 */
/*!**************************************************************!*\
  !*** ./~/node-libs-browser/~/readable-stream/passthrough.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./lib/_stream_passthrough.js */ 133)


/***/ },
/* 138 */
/*!************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/readable-stream/readable.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ 139);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ 144);
	exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ 145);
	exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ 146);
	exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ 147);


/***/ },
/* 139 */
/*!************************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/readable-stream/lib/_stream_readable.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Readable;
	
	/*<replacement>*/
	var isArray = __webpack_require__(/*! isarray */ 141);
	/*</replacement>*/
	
	
	/*<replacement>*/
	var Buffer = __webpack_require__(/*! buffer */ 28).Buffer;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	var EE = __webpack_require__(/*! events */ 74).EventEmitter;
	
	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	var Stream = __webpack_require__(/*! stream */ 121);
	
	/*<replacement>*/
	var util = __webpack_require__(/*! core-util-is */ 140);
	util.inherits = __webpack_require__(/*! inherits */ 142);
	/*</replacement>*/
	
	var StringDecoder;
	
	util.inherits(Readable, Stream);
	
	function ReadableState(options, stream) {
	  options = options || {};
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = false;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // In streams that never have any data, and do push(null) right away,
	  // the consumer can miss the 'end' event if they do some I/O before
	  // consuming the stream.  So, we don't emit('end') until some reading
	  // happens.
	  this.calledRead = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(/*! string_decoder/ */ 143).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  if (!(this instanceof Readable))
	    return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;
	
	  if (typeof chunk === 'string' && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null || chunk === undefined) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);
	
	      // update the buffer info.
	      state.length += state.objectMode ? 1 : chunk.length;
	      if (addToFront) {
	        state.buffer.unshift(chunk);
	      } else {
	        state.reading = false;
	        state.buffer.push(chunk);
	      }
	
	      if (state.needReadable)
	        emitReadable(stream);
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(/*! string_decoder/ */ 143).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	};
	
	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}
	
	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;
	
	  if (state.objectMode)
	    return n === 0 ? 0 : 1;
	
	  if (n === null || isNaN(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }
	
	  if (n <= 0)
	    return 0;
	
	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);
	
	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }
	
	  return n;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  var state = this._readableState;
	  state.calledRead = true;
	  var nOrig = n;
	  var ret;
	
	  if (typeof n !== 'number' || n > 0)
	    state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    ret = null;
	
	    // In cases where the decoder did not receive enough data
	    // to produce a full chunk, then immediately received an
	    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
	    // howMuchToRead will see this and coerce the amount to
	    // read to zero (because it's looking at the length of the
	    // first <Buffer > in state.buffer), and we'll end up here.
	    //
	    // This can only happen via state.decoder -- no other venue
	    // exists for pushing a zero-length chunk into state.buffer
	    // and triggering this behavior. In this case, we return our
	    // remaining data and end the stream, if appropriate.
	    if (state.length > 0 && state.decoder) {
	      ret = fromList(n, state);
	      state.length -= ret.length;
	    }
	
	    if (state.length === 0)
	      endReadable(this);
	
	    return ret;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length - n <= state.highWaterMark)
	    doRead = true;
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading)
	    doRead = false;
	
	  if (doRead) {
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }
	
	  // If _read called its callback synchronously, then `reading`
	  // will be false, and we need to re-evaluate how much data we
	  // can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);
	
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;
	
	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  }
	
	  state.length -= n;
	
	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;
	
	  // If we happened to read() exactly the remaining amount in the
	  // buffer, and the EOF has been seen at this point, then make sure
	  // that we emit 'end' on the very next tick.
	  if (state.ended && !state.endEmitted && state.length === 0)
	    endReadable(this);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	
	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // if we've ended and we have some data left, then emit
	  // 'readable' now to make sure it gets picked up.
	  if (state.length > 0)
	    emitReadable(stream);
	  else
	    endReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (state.emittedReadable)
	    return;
	
	  state.emittedReadable = true;
	  if (state.sync)
	    process.nextTick(function() {
	      emitReadable_(stream);
	    });
	  else
	    emitReadable_(stream);
	}
	
	function emitReadable_(stream) {
	  stream.emit('readable');
	}
	
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};
	
	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    if (readable !== src) return;
	    cleanup();
	  }
	
	  function onend() {
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  function cleanup() {
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (!dest._writableState || dest._writableState.needDrain)
	      ondrain();
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];
	
	
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    // the handler that waits for readable events after all
	    // the data gets sucked out in flow.
	    // This would be easier to follow with a .once() handler
	    // in flow(), but that is too slow.
	    this.on('readable', pipeOnReadable);
	
	    state.flowing = true;
	    process.nextTick(function() {
	      flow(src);
	    });
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function() {
	    var dest = this;
	    var state = src._readableState;
	    state.awaitDrain--;
	    if (state.awaitDrain === 0)
	      flow(src);
	  };
	}
	
	function flow(src) {
	  var state = src._readableState;
	  var chunk;
	  state.awaitDrain = 0;
	
	  function write(dest, i, list) {
	    var written = dest.write(chunk);
	    if (false === written) {
	      state.awaitDrain++;
	    }
	  }
	
	  while (state.pipesCount && null !== (chunk = src.read())) {
	
	    if (state.pipesCount === 1)
	      write(state.pipes, 0, null);
	    else
	      forEach(state.pipes, write);
	
	    src.emit('data', chunk);
	
	    // if anyone needs a drain, then we have to wait for that.
	    if (state.awaitDrain > 0)
	      return;
	  }
	
	  // if every destination was unpiped, either before entering this
	  // function, or in the while loop, then stop flowing.
	  //
	  // NB: This is a pretty rare edge case.
	  if (state.pipesCount === 0) {
	    state.flowing = false;
	
	    // if there were data event listeners added, then switch to old mode.
	    if (EE.listenerCount(src, 'data') > 0)
	      emitDataEvents(src);
	    return;
	  }
	
	  // at this point, no one needed a drain, so we just ran out of data
	  // on the next readable event, start it over again.
	  state.ranOut = true;
	}
	
	function pipeOnReadable() {
	  if (this._readableState.ranOut) {
	    this._readableState.ranOut = false;
	    flow(this);
	  }
	}
	
	
	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;
	
	    if (!dest)
	      dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }
	
	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;
	
	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  if (ev === 'data' && !this._readableState.flowing)
	    emitDataEvents(this);
	
	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        this.read(0);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  emitDataEvents(this);
	  this.read(0);
	  this.emit('resume');
	};
	
	Readable.prototype.pause = function() {
	  emitDataEvents(this, true);
	  this.emit('pause');
	};
	
	function emitDataEvents(stream, startPaused) {
	  var state = stream._readableState;
	
	  if (state.flowing) {
	    // https://github.com/isaacs/readable-stream/issues/16
	    throw new Error('Cannot switch to old mode now.');
	  }
	
	  var paused = startPaused || false;
	  var readable = false;
	
	  // convert to an old-style stream.
	  stream.readable = true;
	  stream.pipe = Stream.prototype.pipe;
	  stream.on = stream.addListener = Stream.prototype.on;
	
	  stream.on('readable', function() {
	    readable = true;
	
	    var c;
	    while (!paused && (null !== (c = stream.read())))
	      stream.emit('data', c);
	
	    if (c === null) {
	      readable = false;
	      stream._readableState.needReadable = true;
	    }
	  });
	
	  stream.pause = function() {
	    paused = true;
	    this.emit('pause');
	  };
	
	  stream.resume = function() {
	    paused = false;
	    if (readable)
	      process.nextTick(function() {
	        stream.emit('readable');
	      });
	    else
	      this.read(0);
	    this.emit('resume');
	  };
	
	  // now make it start, just in case it hadn't already.
	  stream.emit('readable');
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function() {
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function(chunk) {
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	
	    // don't skip over falsy values in objectMode
	    //if (state.objectMode && util.isNullOrUndefined(chunk))
	    if (state.objectMode && (chunk === null || chunk === undefined))
	      return;
	    else if (!state.objectMode && (!chunk || !chunk.length))
	      return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (typeof stream[i] === 'function' &&
	        typeof this[i] === 'undefined') {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;
	
	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;
	
	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);
	
	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);
	
	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);
	
	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();
	
	        c += cpy;
	      }
	    }
	  }
	
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');
	
	  if (!state.endEmitted && state.calledRead) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 140 */
/*!***************************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/readable-stream/~/core-util-is/lib/util.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	function isBuffer(arg) {
	  return Buffer.isBuffer(arg);
	}
	exports.isBuffer = isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 141 */
/*!*******************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/readable-stream/~/isarray/index.js ***!
  \*******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 142 */
/*!*******************************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/readable-stream/~/inherits/inherits_browser.js ***!
  \*******************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 143 */
/*!**************************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/readable-stream/~/string_decoder/index.js ***!
  \**************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(/*! buffer */ 28).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 144 */
/*!************************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/readable-stream/lib/_stream_writable.js ***!
  \************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.
	
	module.exports = Writable;
	
	/*<replacement>*/
	var Buffer = __webpack_require__(/*! buffer */ 28).Buffer;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	
	/*<replacement>*/
	var util = __webpack_require__(/*! core-util-is */ 140);
	util.inherits = __webpack_require__(/*! inherits */ 142);
	/*</replacement>*/
	
	var Stream = __webpack_require__(/*! stream */ 121);
	
	util.inherits(Writable, Stream);
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}
	
	function WritableState(options, stream) {
	  options = options || {};
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.buffer = [];
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}
	
	function Writable(options) {
	  var Duplex = __webpack_require__(/*! ./_stream_duplex */ 145);
	
	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};
	
	
	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;
	
	  if (typeof cb !== 'function')
	    cb = function() {};
	
	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb))
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	
	  return ret;
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      typeof chunk === 'string') {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;
	
	  if (state.writing)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, len, chunk, encoding, cb);
	
	  return ret;
	}
	
	function doWrite(stream, state, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      cb(er);
	    });
	  else
	    cb(er);
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);
	
	    if (!finished && !state.bufferProcessing && state.buffer.length)
	      clearBuffer(stream, state);
	
	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  cb();
	  if (finished)
	    finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	
	  for (var c = 0; c < state.buffer.length; c++) {
	    var entry = state.buffer[c];
	    var chunk = entry.chunk;
	    var encoding = entry.encoding;
	    var cb = entry.callback;
	    var len = state.objectMode ? 1 : chunk.length;
	
	    doWrite(stream, state, len, chunk, encoding, cb);
	
	    // if we didn't call the onwrite immediately, then
	    // it means that we need to wait until it does.
	    // also, that means that the chunk and cb are currently
	    // being processed, so move the buffer counter past them.
	    if (state.writing) {
	      c++;
	      break;
	    }
	  }
	
	  state.bufferProcessing = false;
	  if (c < state.buffer.length)
	    state.buffer = state.buffer.slice(c);
	  else
	    state.buffer.length = 0;
	}
	
	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};
	
	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (typeof chunk !== 'undefined' && chunk !== null)
	    this.write(chunk, encoding);
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};
	
	
	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    state.finished = true;
	    stream.emit('finish');
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 145 */
/*!**********************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/readable-stream/lib/_stream_duplex.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/
	
	
	/*<replacement>*/
	var util = __webpack_require__(/*! core-util-is */ 140);
	util.inherits = __webpack_require__(/*! inherits */ 142);
	/*</replacement>*/
	
	var Readable = __webpack_require__(/*! ./_stream_readable */ 139);
	var Writable = __webpack_require__(/*! ./_stream_writable */ 144);
	
	util.inherits(Duplex, Readable);
	
	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});
	
	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false)
	    this.readable = false;
	
	  if (options && options.writable === false)
	    this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 146 */
/*!*************************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/readable-stream/lib/_stream_transform.js ***!
  \*************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	
	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(/*! ./_stream_duplex */ 145);
	
	/*<replacement>*/
	var util = __webpack_require__(/*! core-util-is */ 140);
	util.inherits = __webpack_require__(/*! inherits */ 142);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	
	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (data !== null && data !== undefined)
	    stream.push(data);
	
	  if (cb)
	    cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	
	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);
	
	  Duplex.call(this, options);
	
	  var ts = this._transformState = new TransformState(options, this);
	
	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  this.once('finish', function() {
	    if ('function' === typeof this._flush)
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}
	
	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};
	
	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;
	
	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	
	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var rs = stream._readableState;
	  var ts = stream._transformState;
	
	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');
	
	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');
	
	  return stream.push(null);
	}


/***/ },
/* 147 */
/*!***************************************************************************!*\
  !*** ./~/mongoose/~/mongodb/~/readable-stream/lib/_stream_passthrough.js ***!
  \***************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(/*! ./_stream_transform */ 146);
	
	/*<replacement>*/
	var util = __webpack_require__(/*! core-util-is */ 140);
	util.inherits = __webpack_require__(/*! inherits */ 142);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 148 */
/*!***************************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/topology_base.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var MongoError = __webpack_require__(/*! mongodb-core */ 76).MongoError
	  , f = __webpack_require__(/*! util */ 57).format;
	
	// The store of ops
	var Store = function(topology, storeOptions) {
	  var self = this;
	  var storedOps = [];
	  storeOptions = storeOptions || {force:false, bufferMaxEntries: -1}
	
	  // Internal state
	  this.s = {
	      storedOps: storedOps
	    , storeOptions: storeOptions
	    , topology: topology
	  }
	
	  Object.defineProperty(this, 'length', {
	    enumerable:true, get: function() { return self.s.storedOps.length; }
	  });
	}
	
	Store.prototype.add = function(opType, ns, ops, options, callback) {
	  if(this.s.storeOptions.force) return callback(new MongoError("db closed by application"));
	  if(this.s.storeOptions.bufferMaxEntries == 0) return callback(new MongoError(f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries)));
	  if(this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
	    while(this.s.storedOps.length > 0) {
	      var op = this.s.storedOps.shift();
	      op.c(new MongoError(f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries)));
	    }
	
	    return;
	  }
	
	  this.s.storedOps.push({t: opType, n: ns, o: ops, op: options, c: callback})
	}
	
	Store.prototype.addObjectAndMethod = function(opType, object, method, params, callback) {
	  if(this.s.storeOptions.force) return callback(new MongoError("db closed by application"));
	  if(this.s.storeOptions.bufferMaxEntries == 0) return callback(new MongoError(f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries)));
	  if(this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
	    while(this.s.storedOps.length > 0) {
	      var op = this.s.storedOps.shift();
	      op.c(new MongoError(f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries)));
	    }
	
	    return;
	  }
	
	  this.s.storedOps.push({t: opType, m: method, o: object, p: params, c: callback})
	}
	
	Store.prototype.flush = function() {
	  while(this.s.storedOps.length > 0) {
	    this.s.storedOps.shift().c(new MongoError(f("no connection available for operation")));
	  }
	}
	
	Store.prototype.execute = function() {
	  // Get current ops
	  var ops = this.s.storedOps;
	  // Reset the ops
	  this.s.storedOps = [];
	
	  // Execute all the stored ops
	  while(ops.length > 0) {
	    var op = ops.shift();
	
	    if(op.t == 'cursor') {
	      op.o[op.m].apply(op.o, op.p);
	    } else {
	      this.s.topology[op.t](op.n, op.o, op.op, op.c);
	    }
	  }    
	}
	
	Store.prototype.all = function() {
	  return this.s.storedOps;
	}
	
	// Server capabilities
	var ServerCapabilities = function(ismaster) {
	  var setup_get_property = function(object, name, value) {
	    Object.defineProperty(object, name, {
	        enumerable: true
	      , get: function () { return value; }
	    });  
	  }
	
	  // Capabilities
	  var aggregationCursor = false;
	  var writeCommands = false;
	  var textSearch = false;
	  var authCommands = false;
	  var listCollections = false;
	  var listIndexes = false;
	  var maxNumberOfDocsInBatch = ismaster.maxWriteBatchSize || 1000;
	
	  if(ismaster.minWireVersion >= 0) {
	    textSearch = true;
	  }
	
	  if(ismaster.maxWireVersion >= 1) {
	    aggregationCursor = true;
	    authCommands = true;
	  }
	
	  if(ismaster.maxWireVersion >= 2) {
	    writeCommands = true;
	  }
	
	  if(ismaster.maxWireVersion >= 3) {
	    listCollections = true;
	    listIndexes = true;
	  }
	
	  // If no min or max wire version set to 0
	  if(ismaster.minWireVersion == null) {
	    ismaster.minWireVersion = 0;
	  }
	
	  if(ismaster.maxWireVersion == null) {
	    ismaster.maxWireVersion = 0;
	  }
	
	  // Map up read only parameters
	  setup_get_property(this, "hasAggregationCursor", aggregationCursor);
	  setup_get_property(this, "hasWriteCommands", writeCommands);
	  setup_get_property(this, "hasTextSearch", textSearch);
	  setup_get_property(this, "hasAuthCommands", authCommands);
	  setup_get_property(this, "hasListCollectionsCommand", listCollections);
	  setup_get_property(this, "hasListIndexesCommand", listIndexes);
	  setup_get_property(this, "minWireVersion", ismaster.minWireVersion);
	  setup_get_property(this, "maxWireVersion", ismaster.maxWireVersion);
	  setup_get_property(this, "maxNumberOfDocsInBatch", maxNumberOfDocsInBatch);
	}
	
	exports.Store = Store;
	exports.ServerCapabilities = ServerCapabilities;

/***/ },
/* 149 */
/*!********************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/mongos.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter
	  , inherits = __webpack_require__(/*! util */ 57).inherits
	  , f = __webpack_require__(/*! util */ 57).format
	  , ServerCapabilities = __webpack_require__(/*! ./topology_base */ 148).ServerCapabilities
	  , MongoCR = __webpack_require__(/*! mongodb-core */ 76).MongoCR
	  , CMongos = __webpack_require__(/*! mongodb-core */ 76).Mongos
	  , Cursor = __webpack_require__(/*! ./cursor */ 118)
	  , Server = __webpack_require__(/*! ./server */ 75)
	  , Store = __webpack_require__(/*! ./topology_base */ 148).Store
	  , shallowClone = __webpack_require__(/*! ./utils */ 119).shallowClone;
	
	/**
	 * @fileOverview The **Mongos** class is a class that represents a Mongos Proxy topology and is
	 * used to construct connections.
	 * 
	 * **Mongos Should not be used, use MongoClient.connect**
	 * @example
	 * var Db = require('mongodb').Db,
	 *   Mongos = require('mongodb').Mongos,
	 *   Server = require('mongodb').Server,
	 *   test = require('assert');
	 * // Connect using Mongos
	 * var server = new Server('localhost', 27017);
	 * var db = new Db('test', new Mongos([server]));
	 * db.open(function(err, db) {
	 *   // Get an additional db
	 *   db.close();
	 * });
	 */
	
	/**
	 * Creates a new Mongos instance
	 * @class
	 * @deprecated
	 * @param {Server[]} servers A seedlist of servers participating in the replicaset.
	 * @param {object} [options=null] Optional settings.
	 * @param {booelan} [options.ha=true] Turn on high availability monitoring.
	 * @param {number} [options.haInterval=5000] Time between each replicaset status check.
	 * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.
	 * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support) 
	 * @param {object} [options.sslValidate=true] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {array} [options.sslCA=null] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslCert=null] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslKey=null] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslPass=null] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {object} [options.socketOptions=null] Socket options 
	 * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option. 
	 * @param {number} [options.socketOptions.keepAlive=0] TCP KeepAlive on the socket with a X ms delay before start. 
	 * @param {number} [options.socketOptions.connectTimeoutMS=0] TCP Connection timeout setting 
	 * @param {number} [options.socketOptions.socketTimeoutMS=0] TCP Socket timeout setting 
	 * @fires Mongos#connect
	 * @fires Mongos#ha
	 * @fires Mongos#joined
	 * @fires Mongos#left
	 * @fires Mongos#fullsetup
	 * @fires Mongos#open
	 * @fires Mongos#close
	 * @fires Mongos#error
	 * @fires Mongos#timeout
	 * @fires Mongos#parseError
	 * @return {Mongos} a Mongos instance.
	 */
	var Mongos = function(servers, options) {
	  if(!(this instanceof Mongos)) return new Mongos(servers, options);
	  options = options || {};
	  var self = this;
	
	  // Ensure all the instances are Server
	  for(var i = 0; i < servers.length; i++) {
	    if(!(servers[i] instanceof Server)) {
	      throw new MongoError("all seed list instances must be of the Server type");
	    }
	  }
	
	  // Store option defaults
	  var storeOptions = {
	      force: false
	    , bufferMaxEntries: -1
	  }
	
	  // Shared global store
	  var store = options.store || new Store(self, storeOptions);
	
	  // Set up event emitter
	  EventEmitter.call(this);
	
	  // Debug tag
	  var tag = options.tag;
	
	  // Build seed list
	  var seedlist = servers.map(function(x) {
	    return {host: x.host, port: x.port}
	  });
	
	  // Final options
	  var finalOptions = shallowClone(options);
	
	  // Default values
	  finalOptions.size = typeof options.poolSize == 'number' ? options.poolSize : 5;  
	  finalOptions.reconnect = typeof options.auto_reconnect == 'boolean' ? options.auto_reconnect : true;
	  finalOptions.emitError = typeof options.emitError == 'boolean' ? options.emitError : true;
	  finalOptions.cursorFactory = Cursor;
	
	  // Add the store
	  finalOptions.disconnectHandler = store;
	
	  // Socket options passed down
	  if(options.socketOptions) {
	    if(options.socketOptions.connectTimeoutMS) {
	      this.connectTimeoutMS = options.socketOptions.connectTimeoutMS;
	      finalOptions.connectionTimeout = options.socketOptions.connectTimeoutMS;
	    }
	    if(options.socketOptions.socketTimeoutMS)
	      finalOptions.socketTimeout = options.socketOptions.socketTimeoutMS;
	  } 
	
	  // Are we running in debug mode
	  var debug = typeof options.debug == 'boolean' ? options.debug : false;
	  if(debug) {
	    finalOptions.debug = debug;
	  }
	
	  // Map keep alive setting
	  if(options.socketOptions && typeof options.socketOptions.keepAlive == 'number') {
	    finalOptions.keepAlive = true;
	    if(typeof options.socketOptions.keepAlive == 'number') {
	      finalOptions.keepAliveInitialDelay = options.socketOptions.keepAlive;
	    }
	  }
	
	  // Connection timeout
	  if(options.socketOptions && typeof options.socketOptions.connectionTimeout == 'number') {
	    finalOptions.connectionTimeout = options.socketOptions.connectionTimeout;
	  }
	
	  // Socket timeout
	  if(options.socketOptions && typeof options.socketOptions.socketTimeout == 'number') {
	    finalOptions.socketTimeout = options.socketOptions.socketTimeout;
	  }
	
	  // noDelay
	  if(options.socketOptions && typeof options.socketOptions.noDelay == 'boolean') {
	    finalOptions.noDelay = options.socketOptions.noDelay;
	  }
	
	  if(typeof options.secondaryAcceptableLatencyMS == 'number') {
	    finalOptions.acceptableLatency = options.secondaryAcceptableLatencyMS;
	  }
	
	  // Add the non connection store
	  finalOptions.disconnectHandler = store;
	
	  // Create the Mongos
	  var mongos = new CMongos(seedlist, finalOptions)
	  // Server capabilities
	  var sCapabilities = null;
	  // Add auth prbufferMaxEntriesoviders
	  mongos.addAuthProvider('mongocr', new MongoCR());
	
	  // Internal state
	  this.s = {
	    // Create the Mongos
	      mongos: mongos
	    // Server capabilities
	    , sCapabilities: sCapabilities
	    // Debug turned on
	    , debug: debug
	    // Store option defaults
	    , storeOptions: storeOptions
	    // Cloned options
	    , clonedOptions: finalOptions
	    // Actual store of callbacks
	    , store: store
	    // Options
	    , options: options
	  }
	
	
	  // Last ismaster
	  Object.defineProperty(this, 'isMasterDoc', {
	    enumerable:true, get: function() { return self.s.mongos.lastIsMaster(); }
	  });
	
	  // Last ismaster
	  Object.defineProperty(this, 'numberOfConnectedServers', {
	    enumerable:true, get: function() { return self.s.mongos.connectedServers().length; }
	  });
	
	  // BSON property
	  Object.defineProperty(this, 'bson', { 
	    enumerable: true, get: function() { 
	      return self.s.mongos.bson; 
	    }
	  });
	
	  Object.defineProperty(this, 'haInterval', {
	    enumerable:true, get: function() { return self.s.mongos.haInterval; }
	  });
	}
	
	/**
	 * @ignore
	 */
	inherits(Mongos, EventEmitter);
	
	// Connect
	Mongos.prototype.connect = function(db, _options, callback) {
	  var self = this;
	  if('function' === typeof _options) callback = _options, _options = {};
	  if(_options == null) _options = {};
	  if(!('function' === typeof callback)) callback = null;
	  self.s.options = _options;
	
	  // Update bufferMaxEntries
	  self.s.storeOptions.bufferMaxEntries = db.bufferMaxEntries;
	
	  // Error handler
	  var connectErrorHandler = function(event) {
	    return function(err) {
	      // Remove all event handlers
	      var events = ['timeout', 'error', 'close'];
	      events.forEach(function(e) {
	        self.removeListener(e, connectErrorHandler);
	      });
	
	      self.s.mongos.removeListener('connect', connectErrorHandler);
	
	      // Try to callback
	      try {
	        callback(err);
	      } catch(err) { 
	        process.nextTick(function() { throw err; })
	      }
	    }
	  }
	
	  // Actual handler
	  var errorHandler = function(event) {
	    return function(err) {
	      if(event != 'error') {
	        self.emit(event, err);
	      }
	    }
	  }
	
	  // Error handler
	  var reconnectHandler = function(err) {
	    self.emit('reconnect');
	    self.s.store.execute();
	  }
	
	  // Connect handler
	  var connectHandler = function() {
	    // Clear out all the current handlers left over
	    ["timeout", "error", "close"].forEach(function(e) {
	      self.s.mongos.removeAllListeners(e);
	    });
	
	    // Set up listeners
	    self.s.mongos.once('timeout', errorHandler('timeout'));
	    self.s.mongos.once('error', errorHandler('error'));
	    self.s.mongos.once('close', errorHandler('close'));
	
	    // relay the event
	    var relay = function(event) {
	      return function(t, server) {
	        self.emit(event, t, server);
	      }
	    }
	
	    // Set up serverConfig listeners
	    self.s.mongos.on('joined', relay('joined'));
	    self.s.mongos.on('left', relay('left'));
	    self.s.mongos.on('fullsetup', relay('fullsetup'));
	
	    // Emit open event
	    self.emit('open', null, self);      
	
	    // Return correctly
	    try {
	      callback(null, self);
	    } catch(err) { 
	      process.nextTick(function() { throw err; })
	    }      
	  }
	
	  // Set up listeners
	  self.s.mongos.once('timeout', connectErrorHandler('timeout'));
	  self.s.mongos.once('error', connectErrorHandler('error'));
	  self.s.mongos.once('close', connectErrorHandler('close'));
	  self.s.mongos.once('connect', connectHandler);
	  // Reconnect server
	  self.s.mongos.on('reconnect', reconnectHandler);
	
	  // Start connection
	  self.s.mongos.connect(_options);
	}
	
	Mongos.prototype.parserType = function() {
	  return this.s.mongos.parserType();
	}
	
	// Server capabilities
	Mongos.prototype.capabilities = function() {
	  if(this.s.sCapabilities) return this.s.sCapabilities;
	  this.s.sCapabilities = new ServerCapabilities(this.s.mongos.lastIsMaster());
	  return this.s.sCapabilities;
	}
	
	// Command
	Mongos.prototype.command = function(ns, cmd, options, callback) {
	  this.s.mongos.command(ns, cmd, options, callback);
	}
	
	// Insert
	Mongos.prototype.insert = function(ns, ops, options, callback) {
	  this.s.mongos.insert(ns, ops, options, function(e, m) {
	    callback(e, m)
	  });
	}
	
	// Update
	Mongos.prototype.update = function(ns, ops, options, callback) {
	  this.s.mongos.update(ns, ops, options, callback);
	}
	
	// Remove
	Mongos.prototype.remove = function(ns, ops, options, callback) {
	  this.s.mongos.remove(ns, ops, options, callback);
	}
	
	// IsConnected
	Mongos.prototype.isConnected = function() {
	  return this.s.mongos.isConnected();
	}
	
	// Insert
	Mongos.prototype.cursor = function(ns, cmd, options) {
	  options.disconnectHandler = this.s.store;
	  return this.s.mongos.cursor(ns, cmd, options);
	}
	
	Mongos.prototype.setBSONParserType = function(type) {
	  return this.s.mongos.setBSONParserType(type);
	}  
	
	Mongos.prototype.lastIsMaster = function() {
	  return this.s.mongos.lastIsMaster();
	}
	
	Mongos.prototype.close = function(forceClosed) {
	  this.s.mongos.destroy();
	  // We need to wash out all stored processes
	  if(forceClosed == true) {
	    this.s.storeOptions.force = forceClosed;
	    this.s.store.flush();
	  }
	}
	
	Mongos.prototype.auth = function() {
	  var args = Array.prototype.slice.call(arguments, 0);
	  this.s.mongos.auth.apply(this.s.mongos, args);
	}
	
	/**
	 * All raw connections
	 * @method
	 * @return {array}
	 */
	Mongos.prototype.connections = function() {
	  return this.s.mongos.connections();
	}      
	
	/**
	 * A mongos connect event, used to verify that the connection is up and running
	 *
	 * @event Mongos#connect
	 * @type {Mongos}
	 */
	
	/**
	 * The mongos high availability event
	 *
	 * @event Mongos#ha
	 * @type {function}
	 * @param {string} type The stage in the high availability event (start|end)
	 * @param {boolean} data.norepeat This is a repeating high availability process or a single execution only
	 * @param {number} data.id The id for this high availability request
	 * @param {object} data.state An object containing the information about the current replicaset
	 */
	
	/**
	 * A server member left the mongos set
	 *
	 * @event Mongos#left
	 * @type {function}
	 * @param {string} type The type of member that left (primary|secondary|arbiter)
	 * @param {Server} server The server object that left
	 */
	
	/**
	 * A server member joined the mongos set
	 *
	 * @event Mongos#joined
	 * @type {function}
	 * @param {string} type The type of member that joined (primary|secondary|arbiter)
	 * @param {Server} server The server object that joined
	 */
	
	/**
	 * Mongos fullsetup event, emitted when all proxies in the topology have been connected to.
	 *
	 * @event Mongos#fullsetup
	 * @type {Mongos}
	 */
	
	/**
	 * Mongos open event, emitted when mongos can start processing commands.
	 *
	 * @event Mongos#open
	 * @type {Mongos}
	 */
	
	/**
	 * Mongos close event
	 *
	 * @event Mongos#close
	 * @type {object}
	 */
	
	/**
	 * Mongos error event, emitted if there is an error listener.
	 *
	 * @event Mongos#error
	 * @type {MongoError}
	 */
	
	/**
	 * Mongos timeout event
	 *
	 * @event Mongos#timeout
	 * @type {object}
	 */
	
	/**
	 * Mongos parseError event
	 *
	 * @event Mongos#parseError
	 * @type {object}
	 */
	
	module.exports = Mongos;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 150 */
/*!**************************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/mongo_client.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var parse = __webpack_require__(/*! ./url_parser */ 151)
	  , Server = __webpack_require__(/*! ./server */ 75)
	  , Mongos = __webpack_require__(/*! ./mongos */ 149)
	  , ReplSet = __webpack_require__(/*! ./replset */ 73)
	  , ReadPreference = __webpack_require__(/*! ./read_preference */ 120)
	  , Db = __webpack_require__(/*! ./db */ 152);
	
	/**
	 * @fileOverview The **MongoClient** class is a class that allows for making Connections to MongoDB.
	 * 
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Get an additional db
	 *   db.close();
	 * });
	 */
	
	/**
	 * Creates a new MongoClient instance
	 * @class
	 * @return {MongoClient} a MongoClient instance.
	 */
	function MongoClient() {
	  /**
	   * The callback format for results
	   * @callback MongoClient~connectCallback
	   * @param {MongoError} error An error instance representing the error during the execution.
	   * @param {Db} db The connected database.
	   */
	
	  /**
	   * Connect to MongoDB using a url as documented at
	   *
	   *  docs.mongodb.org/manual/reference/connection-string/
	   *
	   * Note that for replicasets the replicaSet query parameter is required in the 2.0 driver
	   *
	   * @method
	   * @param {string} url The connection URI string
	   * @param {object} [options=null] Optional settings.
	   * @param {boolean} [options.uri_decode_auth=false] Uri decode the user name and password for authentication
	   * @param {object} [options.db=null] A hash of options to set on the db object, see **Db constructor**
	   * @param {object} [options.server=null] A hash of options to set on the server objects, see **Server** constructor**
	   * @param {object} [options.replSet=null] A hash of options to set on the replSet object, see **ReplSet** constructor**
	   * @param {object} [options.mongos=null] A hash of options to set on the mongos object, see **Mongos** constructor**
	   * @param {MongoClient~connectCallback} callback The command result callback
	   * @return {null}
	   */  
	  this.connect = MongoClient.connect;
	}
	
	/**
	 * Connect to MongoDB using a url as documented at
	 *
	 *  docs.mongodb.org/manual/reference/connection-string/
	 *
	 * Note that for replicasets the replicaSet query parameter is required in the 2.0 driver
	 *
	 * @method
	 * @static
	 * @param {string} url The connection URI string
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.uri_decode_auth=false] Uri decode the user name and password for authentication
	 * @param {object} [options.db=null] A hash of options to set on the db object, see **Db constructor**
	 * @param {object} [options.server=null] A hash of options to set on the server objects, see **Server** constructor**
	 * @param {object} [options.replSet=null] A hash of options to set on the replSet object, see **ReplSet** constructor**
	 * @param {object} [options.mongos=null] A hash of options to set on the mongos object, see **Mongos** constructor**
	 * @param {MongoClient~connectCallback} callback The command result callback
	 * @return {null}
	 */  
	MongoClient.connect = function(url, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = typeof args[args.length - 1] == 'function' ? args.pop() : null;
	  options = args.length ? args.shift() : null;
	  options = options || {};
	
	  // Set default empty server options  
	  var serverOptions = options.server || {};
	  var mongosOptions = options.mongos || {};
	  var replSetServersOptions = options.replSet || options.replSetServers || {};
	  var dbOptions = options.db || {};
	
	  // If callback is null throw an exception
	  if(callback == null) 
	    throw new Error("no callback function provided");
	
	  // Parse the string
	  var object = parse(url, options);
	
	  // Merge in any options for db in options object
	  if(dbOptions) {
	    for(var name in dbOptions) object.db_options[name] = dbOptions[name];
	  }
	
	  // Added the url to the options
	  object.db_options.url = url;
	
	  // Merge in any options for server in options object
	  if(serverOptions) {
	    for(var name in serverOptions) object.server_options[name] = serverOptions[name];
	  }
	
	  // Merge in any replicaset server options
	  if(replSetServersOptions) {
	    for(var name in replSetServersOptions) object.rs_options[name] = replSetServersOptions[name];    
	  }
	
	  if(replSetServersOptions.ssl 
	    || replSetServersOptions.sslValidate
	    || replSetServersOptions.sslCA
	    || replSetServersOptions.sslCert
	    || replSetServersOptions.sslKey
	    || replSetServersOptions.sslPass) {
	    object.server_options.ssl = replSetServersOptions.ssl;
	    object.server_options.sslValidate = replSetServersOptions.sslValidate;
	    object.server_options.sslCA = replSetServersOptions.sslCA;
	    object.server_options.sslCert = replSetServersOptions.sslCert;
	    object.server_options.sslKey = replSetServersOptions.sslKey;
	    object.server_options.sslPass = replSetServersOptions.sslPass;
	  }
	
	  // Merge in any replicaset server options
	  if(mongosOptions) {
	    for(var name in mongosOptions) object.mongos_options[name] = mongosOptions[name];    
	  }
	
	  if(typeof object.server_options.poolSize == 'number') {
	    if(!object.mongos_options.poolSize) object.mongos_options.poolSize = object.server_options.poolSize;
	    if(!object.rs_options.poolSize) object.rs_options.poolSize = object.server_options.poolSize;
	  }
	
	  if(mongosOptions.ssl 
	    || mongosOptions.sslValidate
	    || mongosOptions.sslCA
	    || mongosOptions.sslCert
	    || mongosOptions.sslKey
	    || mongosOptions.sslPass) {
	    object.server_options.ssl = mongosOptions.ssl;
	    object.server_options.sslValidate = mongosOptions.sslValidate;
	    object.server_options.sslCA = mongosOptions.sslCA;
	    object.server_options.sslCert = mongosOptions.sslCert;
	    object.server_options.sslKey = mongosOptions.sslKey;
	    object.server_options.sslPass = mongosOptions.sslPass;
	  }
	
	  // We need to ensure that the list of servers are only either direct members or mongos
	  // they cannot be a mix of monogs and mongod's
	  var totalNumberOfServers = object.servers.length;
	  var totalNumberOfMongosServers = 0;
	  var totalNumberOfMongodServers = 0;
	  var serverConfig = null;
	  var errorServers = {};
	
	  // Failure modes
	  if(object.servers.length == 0) throw new Error("connection string must contain at least one seed host");
	
	  // If we have no db setting for the native parser try to set the c++ one first
	  object.db_options.native_parser = _setNativeParser(object.db_options);
	  // If no auto_reconnect is set, set it to true as default for single servers
	  if(typeof object.server_options.auto_reconnect != 'boolean') {
	    object.server_options.auto_reconnect = true;
	  }
	
	  // If we have more than a server, it could be replicaset or mongos list
	  // need to verify that it's one or the other and fail if it's a mix
	  // Connect to all servers and run ismaster
	  for(var i = 0; i < object.servers.length; i++) {
	    // Set up socket options
	    var providedSocketOptions = object.server_options.socketOptions || {};
	
	    var _server_options = {
	        poolSize:1
	      , socketOptions: {
	          connectTimeoutMS: providedSocketOptions.connectTimeoutMS || 30000
	        , socketTimeoutMS:  providedSocketOptions.socketTimeoutMS || 30000
	      }
	      , auto_reconnect:false};
	
	    // Ensure we have ssl setup for the servers
	    if(object.server_options.ssl) {
	      _server_options.ssl = object.server_options.ssl;
	      _server_options.sslValidate = object.server_options.sslValidate;
	      _server_options.sslCA = object.server_options.sslCA;
	      _server_options.sslCert = object.server_options.sslCert;
	      _server_options.sslKey = object.server_options.sslKey;
	      _server_options.sslPass = object.server_options.sslPass;
	    } else if(object.rs_options.ssl) {
	      _server_options.ssl = object.rs_options.ssl;
	      _server_options.sslValidate = object.rs_options.sslValidate;
	      _server_options.sslCA = object.rs_options.sslCA;
	      _server_options.sslCert = object.rs_options.sslCert;
	      _server_options.sslKey = object.rs_options.sslKey;
	      _server_options.sslPass = object.rs_options.sslPass;
	    }
	
	    // Error
	    var error = null;
	    // Set up the Server object
	    var _server = object.servers[i].domain_socket 
	        ? new Server(object.servers[i].domain_socket, _server_options)
	        : new Server(object.servers[i].host, object.servers[i].port, _server_options);
	        
	    var setName;
	
	    var connectFunction = function(__server) { 
	      // Attempt connect
	      new Db(object.dbName, __server, {w:1, native_parser:false}).open(function(err, db) {
	        // Update number of servers
	        totalNumberOfServers = totalNumberOfServers - 1;          
	        // If no error do the correct checks
	        if(!err) {
	          // Close the connection
	          db.close();
	          var isMasterDoc = db.serverConfig.isMasterDoc;
	          // Check what type of server we have
	          if(isMasterDoc.setName) {
	            totalNumberOfMongodServers++;
	            setName = isMasterDoc.setName;
	          }
	          if(isMasterDoc.msg && isMasterDoc.msg == "isdbgrid") totalNumberOfMongosServers++;
	        } else {
	          error = err;
	          errorServers[__server.host + ":" + __server.port] = __server;
	        }
	
	        if(totalNumberOfServers == 0) {
	          // Error out
	          if(totalNumberOfMongodServers == 0 && totalNumberOfMongosServers == 0 && error) {
	            return callback(error, null);
	          }
	
	          // If we have a mix of mongod and mongos, throw an error
	          if(totalNumberOfMongosServers > 0 && totalNumberOfMongodServers > 0) {
	            if(db) db.close();
	            return process.nextTick(function() {
	              try {
	                callback(new Error("cannot combine a list of replicaset seeds and mongos seeds"));
	              } catch (err) {
	                throw err
	              }              
	            })
	          }
	          
	          if(totalNumberOfMongodServers == 0 
	            && totalNumberOfMongosServers == 0 
	            && object.servers.length == 1) {
	            var obj = object.servers[0];
	            serverConfig = obj.domain_socket ? 
	                new Server(obj.domain_socket, object.server_options)
	              : new Server(obj.host, obj.port, object.server_options);            
	          } else if(totalNumberOfMongodServers > 0 || totalNumberOfMongosServers > 0) {
	            var finalServers = object.servers
	              .filter(function(serverObj) {
	                return errorServers[serverObj.host + ":" + serverObj.port] == null;
	              })
	              .map(function(serverObj) {
	                return new Server(serverObj.host, serverObj.port, object.server_options);
	              });
	            // Clean out any error servers
	            errorServers = {};
	            // Set up the final configuration
	            if(totalNumberOfMongodServers > 0) {
	              try {
	                if (totalNumberOfMongodServers == 1) {
	                  object.rs_options.replicaSet = object.rs_options.replicaSet || setName;
	                }
	                serverConfig = new ReplSet(finalServers, object.rs_options);
	              } catch(err) {
	                return callback(err, null);
	              }
	            } else {
	              serverConfig = new Mongos(finalServers, object.mongos_options);                         
	            }
	          }
	
	          if(serverConfig == null) {
	            return process.nextTick(function() {
	              try {
	                callback(new Error("Could not locate any valid servers in initial seed list"));
	              } catch (err) {
	                if(db) db.close();
	                throw err
	              }
	            });
	          }
	
	          // Ensure no firing of open event before we are ready
	          serverConfig.emitOpen = false;
	          // Set up all options etc and connect to the database
	          _finishConnecting(serverConfig, object, options, callback)
	        }
	      });        
	    }
	
	    // Wrap the context of the call
	    connectFunction(_server);    
	  }    
	}
	
	var _setNativeParser = function(db_options) {
	  if(typeof db_options.native_parser == 'boolean') return db_options.native_parser;
	
	  try {
	    __webpack_require__(/*! mongodb-core */ 76).BSON.BSONNative.BSON;
	    return true;
	  } catch(err) {
	    return false;
	  }
	}
	
	var _finishConnecting = function(serverConfig, object, options, callback) {
	  // If we have a readPreference passed in by the db options
	  if(typeof object.db_options.readPreference == 'string') {
	    object.db_options.readPreference = new ReadPreference(object.db_options.readPreference);
	  } else if(typeof object.db_options.read_preference == 'string') {
	    object.db_options.readPreference = new ReadPreference(object.db_options.read_preference);
	  }
	
	  // Do we have readPreference tags
	  if(object.db_options.readPreference && object.db_options.readPreferenceTags) {
	    object.db_options.readPreference.tags = object.db_options.readPreferenceTags;
	  } else if(object.db_options.readPreference && object.db_options.read_preference_tags) {
	    object.db_options.readPreference.tags = object.db_options.read_preference_tags;
	  }
	
	  // Get the socketTimeoutMS
	  var socketTimeoutMS = object.server_options.socketOptions.socketTimeoutMS || 0;
	
	  // If we have a replset, override with replicaset socket timeout option if available
	  if(serverConfig instanceof ReplSet) {
	    socketTimeoutMS = object.rs_options.socketOptions.socketTimeoutMS || socketTimeoutMS;
	  }
	
	  // Set socketTimeout to the same as the connectTimeoutMS or 30 sec
	  serverConfig.connectTimeoutMS = serverConfig.connectTimeoutMS || 30000;
	  serverConfig.socketTimeoutMS = serverConfig.connectTimeoutMS;
	
	  // Set up the db options
	  var db = new Db(object.dbName, serverConfig, object.db_options);
	  // Open the db
	  db.open(function(err, db){    
	
	    if(err) {
	      return process.nextTick(function() {
	        try {
	          callback(err, null);
	        } catch (err) {
	          if(db) db.close();
	          throw err
	        }
	      });
	    }
	
	    // Reset the socket timeout
	    serverConfig.socketTimeoutMS = socketTimeoutMS || 0;
	
	    // Return object
	    if(err == null && object.auth){
	      // What db to authenticate against
	      var authentication_db = db;
	      if(object.db_options && object.db_options.authSource) {
	        authentication_db = db.db(object.db_options.authSource);
	      }
	
	      // Build options object
	      var options = {};
	      if(object.db_options.authMechanism) options.authMechanism = object.db_options.authMechanism;
	      if(object.db_options.gssapiServiceName) options.gssapiServiceName = object.db_options.gssapiServiceName;
	
	      // Authenticate
	      authentication_db.authenticate(object.auth.user, object.auth.password, options, function(err, success){
	        if(success){
	          process.nextTick(function() {
	            try {
	              callback(null, db);            
	            } catch (err) {
	              if(db) db.close();
	              throw err
	            }
	          });
	        } else {
	          if(db) db.close();
	          process.nextTick(function() {
	            try {
	              callback(err ? err : new Error('Could not authenticate user ' + object.auth[0]), null);
	            } catch (err) {
	              if(db) db.close();
	              throw err
	            }
	          });
	        }
	      });
	    } else {
	      process.nextTick(function() {
	        try {
	          callback(err, db);            
	        } catch (err) {
	          if(db) db.close();
	          throw err
	        }
	      })
	    }
	  });
	}
	
	module.exports = MongoClient
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 151 */
/*!************************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/url_parser.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var ReadPreference = __webpack_require__(/*! ./read_preference */ 120);
	
	module.exports = function(url, options) {
	  // Ensure we have a default options object if none set
	  options = options || {};
	  // Variables
	  var connection_part = '';
	  var auth_part = '';
	  var query_string_part = '';
	  var dbName = 'admin';
	
	  // Must start with mongodb
	  if(url.indexOf("mongodb://") != 0)
	    throw Error("URL must be in the format mongodb://user:pass@host:port/dbname");
	  // If we have a ? mark cut the query elements off
	  if(url.indexOf("?") != -1) {
	    query_string_part = url.substr(url.indexOf("?") + 1);
	    connection_part = url.substring("mongodb://".length, url.indexOf("?"))
	  } else {
	    connection_part = url.substring("mongodb://".length);
	  }
	
	  // Check if we have auth params
	  if(connection_part.indexOf("@") != -1) {
	    auth_part = connection_part.split("@")[0];
	    connection_part = connection_part.split("@")[1];
	  }
	
	  // Check if the connection string has a db
	  if(connection_part.indexOf(".sock") != -1) {
	    if(connection_part.indexOf(".sock/") != -1) {
	      dbName = connection_part.split(".sock/")[1];
	      connection_part = connection_part.split("/", connection_part.indexOf(".sock") + ".sock".length);
	    } 
	  } else if(connection_part.indexOf("/") != -1) {
	    dbName = connection_part.split("/")[1];
	    connection_part = connection_part.split("/")[0];
	  }
	
	  // Result object
	  var object = {};
	
	  // Pick apart the authentication part of the string
	  var authPart = auth_part || '';
	  var auth = authPart.split(':', 2);
	
	  // Decode the URI components
	  auth[0] = decodeURIComponent(auth[0]);
	  if(auth[1]){
	    auth[1] = decodeURIComponent(auth[1]);
	  }
	
	  // Add auth to final object if we have 2 elements
	  if(auth.length == 2) object.auth = {user: auth[0], password: auth[1]};
	
	  // Variables used for temporary storage
	  var hostPart;
	  var urlOptions;
	  var servers;
	  var serverOptions = {socketOptions: {}};
	  var dbOptions = {read_preference_tags: []};
	  var replSetServersOptions = {socketOptions: {}};
	  // Add server options to final object
	  object.server_options = serverOptions;
	  object.db_options = dbOptions;
	  object.rs_options = replSetServersOptions;
	  object.mongos_options = {};
	
	  // Let's check if we are using a domain socket
	  if(url.match(/\.sock/)) {
	    // Split out the socket part
	    var domainSocket = url.substring(
	        url.indexOf("mongodb://") + "mongodb://".length
	      , url.lastIndexOf(".sock") + ".sock".length);
	    // Clean out any auth stuff if any
	    if(domainSocket.indexOf("@") != -1) domainSocket = domainSocket.split("@")[1];
	    servers = [{domain_socket: domainSocket}];
	  } else {
	    // Split up the db
	    hostPart = connection_part;
	    // Parse all server results
	    servers = hostPart.split(',').map(function(h) {
	      var _host, _port, ipv6match;
	      //check if it matches [IPv6]:port, where the port number is optional
	      if ((ipv6match = /\[([^\]]+)\](?:\:(.+))?/.exec(h))) {
	        _host = ipv6match[1];
	        _port = parseInt(ipv6match[2], 10) || 27017;
	      } else {
	        //otherwise assume it's IPv4, or plain hostname
	        var hostPort = h.split(':', 2);
	        _host = hostPort[0] || 'localhost';
	        _port = hostPort[1] != null ? parseInt(hostPort[1], 10) : 27017;
	        // Check for localhost?safe=true style case
	        if(_host.indexOf("?") != -1) _host = _host.split(/\?/)[0];
	      }
	      // Return the mapped object
	      return {host: _host, port: _port};
	    });
	  }
	
	  // Get the db name
	  object.dbName = dbName || 'admin';
	  // Split up all the options
	  urlOptions = (query_string_part || '').split(/[&;]/);    
	  // Ugh, we have to figure out which options go to which constructor manually.
	  urlOptions.forEach(function(opt) {
	    if(!opt) return;
	    var splitOpt = opt.split('='), name = splitOpt[0], value = splitOpt[1];
	    // Options implementations
	    switch(name) {
	      case 'slaveOk':
	      case 'slave_ok':
	        serverOptions.slave_ok = (value == 'true');
	        dbOptions.slaveOk = (value == 'true');
	        break;
	      case 'maxPoolSize':
	      case 'poolSize':
	        serverOptions.poolSize = parseInt(value, 10);
	        replSetServersOptions.poolSize = parseInt(value, 10);
	        break;
	      case 'autoReconnect':
	      case 'auto_reconnect':
	        serverOptions.auto_reconnect = (value == 'true');
	        break;
	      case 'minPoolSize':
	        throw new Error("minPoolSize not supported");
	      case 'maxIdleTimeMS':
	        throw new Error("maxIdleTimeMS not supported");
	      case 'waitQueueMultiple':
	        throw new Error("waitQueueMultiple not supported");
	      case 'waitQueueTimeoutMS':
	        throw new Error("waitQueueTimeoutMS not supported");
	      case 'uuidRepresentation':
	        throw new Error("uuidRepresentation not supported");
	      case 'ssl':
	        if(value == 'prefer') {
	          serverOptions.ssl = value;
	          replSetServersOptions.ssl = value;
	          break;
	        }
	        serverOptions.ssl = (value == 'true');
	        replSetServersOptions.ssl = (value == 'true');
	        break;
	      case 'replicaSet':
	      case 'rs_name':
	        replSetServersOptions.rs_name = value;
	        break;
	      case 'reconnectWait':
	        replSetServersOptions.reconnectWait = parseInt(value, 10);
	        break;
	      case 'retries':
	        replSetServersOptions.retries = parseInt(value, 10);
	        break;
	      case 'readSecondary':
	      case 'read_secondary':
	        replSetServersOptions.read_secondary = (value == 'true');
	        break;
	      case 'fsync':
	        dbOptions.fsync = (value == 'true');
	        break;
	      case 'journal':
	        dbOptions.j = (value == 'true');
	        break;
	      case 'safe':
	        dbOptions.safe = (value == 'true');
	        break;
	      case 'nativeParser':
	      case 'native_parser':
	        dbOptions.native_parser = (value == 'true');
	        break;
	      case 'connectTimeoutMS':
	        serverOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
	        replSetServersOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
	        break;
	      case 'socketTimeoutMS':
	        serverOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
	        replSetServersOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
	        break;
	      case 'w':
	        dbOptions.w = parseInt(value, 10);
	        if(isNaN(dbOptions.w)) dbOptions.w = value;
	        break;
	      case 'authSource':
	        dbOptions.authSource = value;
	        break;
	      case 'gssapiServiceName':
	        dbOptions.gssapiServiceName = value;
	        break;
	      case 'authMechanism':
	        if(value == 'GSSAPI') {
	          // If no password provided decode only the principal
	          if(object.auth == null) {
	            var urlDecodeAuthPart = decodeURIComponent(authPart);
	            if(urlDecodeAuthPart.indexOf("@") == -1) throw new Error("GSSAPI requires a provided principal");
	            object.auth = {user: urlDecodeAuthPart, password: null};
	          } else {
	            object.auth.user = decodeURIComponent(object.auth.user);
	          }
	        } else if(value == 'MONGODB-X509') {
	          object.auth = {user: decodeURIComponent(authPart)};
	        }
	        
	        // Only support GSSAPI or MONGODB-CR for now
	        if(value != 'GSSAPI' 
	          && value != 'MONGODB-X509'
	          && value != 'MONGODB-CR'
	          && value != 'SCRAM-SHA-1'
	          && value != 'PLAIN') 
	            throw new Error("only GSSAPI, PLAIN, MONGODB-X509, SCRAM-SHA-1 or MONGODB-CR is supported by authMechanism");
	        
	        // Authentication mechanism
	        dbOptions.authMechanism = value;
	        break;
	      case 'authMechanismProperties':
	        // Split up into key, value pairs
	        var values = value.split(',');
	        var o = {};
	        // For each value split into key, value
	        values.forEach(function(x) {
	          var v = x.split(':');
	          o[v[0]] = v[1];
	        });
	
	        // Set all authMechanismProperties
	        dbOptions.authMechanismProperties = o;
	        // Set the service name value
	        if(typeof o.SERVICE_NAME == 'string') dbOptions.gssapiServiceName = o.SERVICE_NAME;
	        break;
	      case 'wtimeoutMS':
	        dbOptions.wtimeout = parseInt(value, 10);
	        break;
	      case 'readPreference':
	        if(!ReadPreference.isValid(value)) throw new Error("readPreference must be either primary/primaryPreferred/secondary/secondaryPreferred/nearest");
	        dbOptions.read_preference = value;
	        break;
	      case 'readPreferenceTags':
	        // Decode the value
	        value = decodeURIComponent(value);
	        // Contains the tag object
	        var tagObject = {};
	        if(value == null || value == '') {
	          dbOptions.read_preference_tags.push(tagObject);
	          break;
	        }
	
	        // Split up the tags
	        var tags = value.split(/\,/);
	        for(var i = 0; i < tags.length; i++) {
	          var parts = tags[i].trim().split(/\:/);
	          tagObject[parts[0]] = parts[1];
	        }
	
	        // Set the preferences tags
	        dbOptions.read_preference_tags.push(tagObject);
	        break;
	      default:
	        break;
	    }
	  });
	
	  // No tags: should be null (not [])
	  if(dbOptions.read_preference_tags.length === 0) {
	    dbOptions.read_preference_tags = null;
	  }
	
	  // Validate if there are an invalid write concern combinations
	  if((dbOptions.w == -1 || dbOptions.w == 0) && (
	      dbOptions.journal == true
	      || dbOptions.fsync == true
	      || dbOptions.safe == true)) throw new Error("w set to -1 or 0 cannot be combined with safe/w/journal/fsync")
	
	  // If no read preference set it to primary
	  if(!dbOptions.read_preference) dbOptions.read_preference = 'primary';
	
	  // Add servers to result
	  object.servers = servers;
	  // Returned parsed object
	  return object;
	}


/***/ },
/* 152 */
/*!****************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/db.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	var EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter
	  , inherits = __webpack_require__(/*! util */ 57).inherits
	  , getSingleProperty = __webpack_require__(/*! ./utils */ 119).getSingleProperty
	  , shallowClone = __webpack_require__(/*! ./utils */ 119).shallowClone
	  , parseIndexOptions = __webpack_require__(/*! ./utils */ 119).parseIndexOptions
	  , debugOptions = __webpack_require__(/*! ./utils */ 119).debugOptions
	  , CommandCursor = __webpack_require__(/*! ./command_cursor */ 153)
	  , handleCallback = __webpack_require__(/*! ./utils */ 119).handleCallback
	  , toError = __webpack_require__(/*! ./utils */ 119).toError
	  , ReadPreference = __webpack_require__(/*! ./read_preference */ 120)
	  , f = __webpack_require__(/*! util */ 57).format
	  , Admin = __webpack_require__(/*! ./admin */ 154)
	  , Code = __webpack_require__(/*! mongodb-core */ 76).BSON.Code
	  , CoreReadPreference = __webpack_require__(/*! mongodb-core */ 76).ReadPreference
	  , MongoError = __webpack_require__(/*! mongodb-core */ 76).MongoError
	  , ObjectID = __webpack_require__(/*! mongodb-core */ 76).ObjectID
	  , Logger = __webpack_require__(/*! mongodb-core */ 76).Logger
	  , Collection = __webpack_require__(/*! ./collection */ 155)
	  , crypto = __webpack_require__(/*! crypto */ 94);
	
	var debugFields = ['authSource', 'w', 'wtimeout', 'j', 'native_parser', 'forceServerObjectId'
	  , 'serializeFunctions', 'raw', 'promoteLongs', 'bufferMaxEntries', 'numberOfRetries', 'retryMiliSeconds'
	  , 'readPreference', 'pkFactory'];
	
	/**
	 * @fileOverview The **Db** class is a class that represents a MongoDB Database.
	 *
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Get an additional db
	 *   var testDb = db.db('test');
	 *   db.close();
	 * });
	 */
	
	/**
	 * Creates a new Db instance
	 * @class
	 * @param {string} databaseName The name of the database this instance represents.
	 * @param {(Server|ReplSet|Mongos)} topology The server topology for the database.
	 * @param {object} [options=null] Optional settings.
	 * @param {string} [options.authSource=null] If the database authentication is dependent on another databaseName.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.native_parser=true] Select C++ bson parser instead of JavaScript parser.
	 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
	 * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
	 * @param {number} [options.bufferMaxEntries=-1] Sets a cap on how many operations the driver will buffer up before giving up on getting a working connection, default is -1 which is unlimited.
	 * @param {number} [options.numberOfRetries=5] Number of retries off connection.
	 * @param {number} [options.retryMiliSeconds=500] Number of milliseconds between retries.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {object} [options.pkFactory=null] A primary key factory object for generation of custom _id keys.
	 * @property {(Server|ReplSet|Mongos)} serverConfig Get the current db topology.
	 * @property {number} bufferMaxEntries Current bufferMaxEntries value for the database
	 * @property {string} databaseName The name of the database this instance represents.
	 * @property {object} options The options associated with the db instance.
	 * @property {boolean} native_parser The current value of the parameter native_parser.
	 * @property {boolean} slaveOk The current slaveOk value for the db instance.
	 * @property {object} writeConcern The current write concern values.
	 * @fires Db#close
	 * @fires Db#authenticated
	 * @fires Db#reconnect
	 * @fires Db#error
	 * @fires Db#timeout
	 * @fires Db#parseError
	 * @fires Db#fullsetup
	 * @return {Db} a Db instance.
	 */
	var Db = function(databaseName, topology, options) {
	  options = options || {};
	  if(!(this instanceof Db)) return new Db(databaseName, topology, options);
	  EventEmitter.call(this);
	  var self = this;
	  // var self = this;  // Internal state of the db object
	  this.s = {
	    // Database name
	      databaseName: databaseName
	    // Children db's
	    , children: []
	    // Topology
	    , topology: topology
	    // Options
	    , options: options
	    // Logger instance
	    , logger: Logger('Db', options)
	    // Get the bson parser
	    , bson: topology ? topology.bson : null
	    // Authsource if any
	    , authSource: options.authSource
	    // Unpack read preference
	    , readPreference: options.readPreference
	    // Set buffermaxEntries
	    , bufferMaxEntries: typeof options.bufferMaxEntries == 'number' ? options.bufferMaxEntries : -1
	    // Parent db (if chained)
	    , parentDb: options.parentDb || null
	    // Set up the primary key factory or fallback to ObjectID
	    , pkFactory: options.pkFactory || ObjectID
	    // Get native parser
	    , nativeParser: options.nativeParser || options.native_parser
	  }
	
	  // Ensure we have a valid db name
	  validateDatabaseName(self.s.databaseName);
	
	  // If we have specified the type of parser
	  if(typeof self.s.nativeParser == 'boolean') {
	    if(self.s.nativeParser) {
	      topology.setBSONParserType("c++");
	    } else {
	      topology.setBSONParserType("js");
	    }
	  }
	
	  // Add a read Only property
	  getSingleProperty(this, 'serverConfig', self.s.topology);
	  getSingleProperty(this, 'bufferMaxEntries', self.s.bufferMaxEntries);
	  getSingleProperty(this, 'databaseName', self.s.databaseName);
	
	  // Last ismaster
	  Object.defineProperty(this, 'options', {
	    enumerable:true,
	    get: function() { return self.s.options; }
	  });
	
	  // Last ismaster
	  Object.defineProperty(this, 'native_parser', {
	    enumerable:true,
	    get: function() { return self.s.topology.parserType() == 'c++'; }
	  });
	
	  // Last ismaster
	  Object.defineProperty(this, 'slaveOk', {
	    enumerable:true,
	    get: function() {
	      if(self.s.options.readPreference != null
	        && (self.s.options.readPreference != 'primary' || self.s.options.readPreference.mode != 'primary')) {
	        return true;
	      }
	      return false;
	    }
	  });
	
	  Object.defineProperty(this, 'writeConcern', {
	    enumerable:true,
	    get: function() {
	      var ops = {};
	      if(self.s.options.w != null) ops.w = self.s.options.w;
	      if(self.s.options.j != null) ops.j = self.s.options.j;
	      if(self.s.options.fsync != null) ops.fsync = self.s.options.fsync;
	      if(self.s.options.wtimeout != null) ops.wtimeout = self.s.options.wtimeout;
	      return ops;
	    }
	  });
	
	  // This is a child db, do not register any listeners
	  if(options.parentDb) return;
	
	  // Add listeners
	  topology.once('error', createListener(self, 'error', self));
	  topology.once('timeout', createListener(self, 'timeout', self));
	  topology.on('close', createListener(self, 'close', self));
	  topology.once('parseError', createListener(self, 'parseError', self));
	  topology.once('open', createListener(self, 'open', self));
	  topology.once('fullsetup', createListener(self, 'fullsetup', self));
	  topology.once('all', createListener(self, 'all', self));
	  topology.on('reconnect', createListener(self, 'reconnect', self));
	}
	
	inherits(Db, EventEmitter);
	
	/**
	 * The callback format for the Db.open method
	 * @callback Db~openCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Db} db The Db instance if the open method was successful.
	 */
	
	/**
	 * Open the database
	 * @method
	 * @param {Db~openCallback} callback Callback
	 * @return {null}
	 */
	Db.prototype.open = function(callback) {
	  var self = this;
	  self.s.topology.connect(self, self.s.options, function(err, topology) {
	    if(callback == null) return;
	    var internalCallback = callback;
	    callback == null;
	
	    if(err) {
	      self.close();
	      return internalCallback(err);
	    }
	
	    internalCallback(null, self);
	  });
	}
	
	/**
	 * The callback format for results
	 * @callback Db~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Execute a command
	 * @method
	 * @param {object} command The command hash
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {number} [options.maxTimeMS=null] Number of milliseconds to wait before aborting the query.
	 * @param {Db~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Db.prototype.command = function(command, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  var dbName = options.dbName || options.authdb || self.s.databaseName;
	  // Clone the options
	  options = shallowClone(options);
	  // If we have a readPreference set
	  if(options.readPreference == null && self.s.readPreference) {
	    options.readPreference = self.s.readPreference;
	  }
	
	  // Convert the readPreference
	  if(options.readPreference && typeof options.readPreference == 'string') {
	    options.readPreference = new CoreReadPreference(options.readPreference);
	  } else if(options.readPreference instanceof ReadPreference) {
	    options.readPreference = new CoreReadPreference(options.readPreference.mode
	      , options.readPreference.tags);
	  }
	
	  // Debug information
	  if(self.s.logger.isDebug()) self.s.logger.debug(f('executing command %s against %s with options [%s]'
	    , JSON.stringify(command), f('%s.$cmd', dbName), JSON.stringify(debugOptions(debugFields, options))));
	
	  // Execute command
	  self.s.topology.command(f('%s.$cmd', dbName), command, options, function(err, result) {
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, null, result.result);
	  });
	}
	
	/**
	 * The callback format for results
	 * @callback Db~noResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {null} result Is not set to a value
	 */
	
	/**
	 * Close the db and it's underlying connections
	 * @method
	 * @param {boolean} force Force close, emitting no events
	 * @param {Db~noResultCallback} callback The result callback
	 * @return {null}
	 */
	Db.prototype.close = function(force, callback) {
	  if(typeof force == 'function') callback = force, force = false;
	  this.s.topology.close(force);
	  var self = this;
	
	  // Fire close event if any listeners
	  if(this.listeners('close').length > 0) {
	    this.emit('close');
	
	    // If it's the top level db emit close on all children
	    if(this.parentDb == null) {
	      // Fire close on all children
	      for(var i = 0; i < this.s.children.length; i++) {
	        this.s.children[i].emit('close');
	      }      
	    }
	
	    // Remove listeners after emit
	    self.removeAllListeners('close');    
	  }
	  
	  // Close parent db if set
	  if(this.s.parentDb) this.s.parentDb.close();
	  // Callback after next event loop tick
	  if(typeof callback == 'function') process.nextTick(function() {
	    handleCallback(callback, null);
	  });
	}
	
	/**
	 * Return the Admin db instance
	 * @method
	 * @return {Admin} return the new Admin db instance
	 */
	Db.prototype.admin = function() {
	  return new Admin(this, this.s.topology);
	};
	
	/**
	 * The callback format for the collection method, must be used if strict is specified
	 * @callback Db~collectionResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection} collection The collection instance.
	 */
	
	/**
	 * Fetch a specific collection (containing the actual collection information). If the application does not use strict mode you can
	 * can use it without a callback in the following way. var collection = db.collection('mycollection');
	 *
	 * @method
	 * @param {string} name the collection name we wish to access.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
	 * @param {object} [options.pkFactory=null] A primary key factory object for generation of custom _id keys.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.strict=false] Returns an error if the collection does not exist
	 * @param {Db~collectionResultCallback} callback The collection result callback
	 * @return {Collection} return the new Collection instance if not in strict mode
	 */
	Db.prototype.collection = function(name, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  if(options == null || !options.strict) {
	    try {
	      var collection = new Collection(this, this.s.topology, this.s.databaseName, name, this.s.pkFactory, options);
	      if(callback) callback(null, collection);
	      return collection;
	    } catch(err) {
	      if(callback) return callback(err);
	      throw err;
	    }
	  }
	
	  // Strict mode
	  if(typeof callback != 'function') {
	    throw toError(f("A callback is required in strict mode. While getting collection %s.", name));
	  }
	
	  // Strict mode
	  this.listCollections({name:name}).toArray(function(err, collections) {
	    if(err != null) return handleCallback(callback, err, null);
	    if(collections.length == 0) return handleCallback(callback, toError(f("Collection %s does not exist. Currently in strict mode.", name)), null);
	
	    try {
	      return handleCallback(callback, null, new Collection(self, self.s.topology, self.s.databaseName, name, self.s.pkFactory, options));
	    } catch(err) {
	      return handleCallback(callback, err, null);
	    }
	  });
	}
	
	/**
	 * Creates a collection on a server pre-allocating space, need to create f.ex capped collections.
	 *
	 * @method
	 * @param {string} name the collection name we wish to access.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
	 * @param {object} [options.pkFactory=null] A primary key factory object for generation of custom _id keys.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.strict=false] Returns an error if the collection does not exist
	 * @param {boolean} [options.capped=false] Create a capped collection.
	 * @param {number} [options.size=null] The size of the capped collection in bytes.
	 * @param {number} [options.max=null] The maximum number of documents in the capped collection.
	 * @param {boolean} [options.autoIndexId=true] Create an index on the _id field of the document, True by default on MongoDB 2.2 or higher off for version < 2.2.
	 * @param {Db~collectionResultCallback} callback The results callback
	 * @return {null}
	 */
	Db.prototype.createCollection = function(name, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  name = args.length ? args.shift() : null;
	  options = args.length ? args.shift() || {} : {};
	
	  // Get the write concern options
	  var finalOptions = writeConcern(shallowClone(options), this, options);
	
	  // Check if we have the name
	  this.listCollections({name: name}).toArray(function(err, collections) {
	    if(err != null) return handleCallback(callback, err, null);
	    if(collections.length > 0 && finalOptions.strict) {
	      return handleCallback(callback, new MongoError(f("Collection %s already exists. Currently in strict mode.", name)), null);
	    } else if (collections.length > 0) {
	      try { return handleCallback(callback, null, new Collection(self, self.s.topology, self.s.databaseName, name, self.s.pkFactory, options)); }
	      catch(err) { return handleCallback(callback, err); }
	    }
	
	    // Create collection command
	    var cmd = {'create':name};
	
	    // Add all optional parameters
	    for(var n in options) {
	      if(options[n] != null && typeof options[n] != 'function')
	        cmd[n] = options[n];
	    }
	
	    // Execute command
	    self.command(cmd, finalOptions, function(err, result) {
	      if(err) return handleCallback(callback, err);
	      handleCallback(callback, null, new Collection(self, self.s.topology, self.s.databaseName, name, self.s.pkFactory, options));
	    });
	  });
	}
	
	/**
	 * Get all the db statistics.
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.scale=null] Divide the returned sizes by scale value.
	 * @param {Db~resultCallback} callback The collection result callback
	 * @return {null}
	 */
	Db.prototype.stats = function(options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	  // Build command object
	  var commandObject = { dbStats:true };
	  // Check if we have the scale value
	  if(options['scale'] != null) commandObject['scale'] = options['scale'];
	  // Execute the command
	  this.command(commandObject, options, callback);
	}
	
	// Transformation methods for cursor results
	var listCollectionsTranforms = function(databaseName) {
	  var matching = f('%s.', databaseName);
	
	  return {
	    doc: function(doc) {
	      var index = doc.name.indexOf(matching);
	      // Remove database name if available
	      if(doc.name && index == 0) {
	        doc.name = doc.name.substr(index + matching.length);
	      }
	
	      return doc;
	    }
	  }
	}
	
	/**
	 * Get the list of all collection information for the specified db.
	 *
	 * @method
	 * @param {object} filter Query to filter collections by
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.batchSize=null] The batchSize for the returned command cursor or if pre 2.8 the systems batch collection
	 * @return {CommandCursor}
	 */
	Db.prototype.listCollections = function(filter, options) {
	  filter = filter || {};
	  options = options || {};
	
	  // We have a list collections command
	  if(this.serverConfig.capabilities().hasListCollectionsCommand) {
	    // Cursor options
	    var cursor = options.batchSize ? {batchSize: options.batchSize} : {}
	    // Build the command
	    var command = { listCollections : true, filter: filter, cursor: cursor };
	    // Set the AggregationCursor constructor
	    options.cursorFactory = CommandCursor;
	    // Filter out the correct field values
	    options.transforms = listCollectionsTranforms(this.s.databaseName);
	    // Execute the cursor
	    return this.s.topology.cursor(f('%s.$cmd', this.s.databaseName), command, options);
	  }
	
	  // We cannot use the listCollectionsCommand
	  if(!this.serverConfig.capabilities().hasListCollectionsCommand) {
	    // If we have legacy mode and have not provided a full db name filter it
	    if(typeof filter.name == 'string' && !(new RegExp('^' + this.databaseName + '\\.').test(filter.name))) {
	      filter = shallowClone(filter);
	      filter.name = f('%s.%s', this.s.databaseName, filter.name);
	    }
	  }
	
	  // No filter, filter by current database
	  if(filter == null) {
	    filter.name = f('/%s/', this.s.databaseName);
	  }
	
	  // Rewrite the filter to use $and to filter out indexes
	  if(filter.name) {
	    filter = {$and: [{name: filter.name}, {name:/^((?!\$).)*$/}]};
	  } else {
	    filter = {name:/^((?!\$).)*$/};
	  }
	
	  // Return options
	  var options = {transforms: listCollectionsTranforms(this.s.databaseName)}
	  // Get the cursor
	  var cursor = this.collection(Db.SYSTEM_NAMESPACE_COLLECTION).find(filter, options);
	  // Set the passed in batch size if one was provided
	  if(options.batchSize) cursor = cursor.batchSize(options.batchSize);
	  // We have a fallback mode using legacy systems collections
	  return cursor;
	};
	
	/**
	 * Evaluate JavaScript on the server
	 *
	 * @method
	 * @param {Code} code JavaScript to execute on server.
	 * @param {(object|array)} parameters The parameters for the call.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.nolock=false] Tell MongoDB not to block on the evaulation of the javascript.
	 * @param {Db~resultCallback} callback The results callback
	 * @return {null}
	 */
	Db.prototype.eval = function(code, parameters, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  parameters = args.length ? args.shift() : parameters;
	  options = args.length ? args.shift() || {} : {};
	
	  var finalCode = code;
	  var finalParameters = [];
	
	  // If not a code object translate to one
	  if(!(finalCode instanceof Code)) finalCode = new Code(finalCode);
	  // Ensure the parameters are correct
	  if(parameters != null && !Array.isArray(parameters) && typeof parameters !== 'function') {
	    finalParameters = [parameters];
	  } else if(parameters != null && Array.isArray(parameters) && typeof parameters !== 'function') {
	    finalParameters = parameters;
	  }
	
	  // Create execution selector
	  var cmd = {'$eval':finalCode, 'args':finalParameters};
	  // Check if the nolock parameter is passed in
	  if(options['nolock']) {
	    cmd['nolock'] = options['nolock'];
	  }
	
	  // Set primary read preference
	  options.readPreference = new CoreReadPreference(ReadPreference.PRIMARY);
	
	  // Execute the command
	  self.command(cmd, options, function(err, result) {
	    if(err) return handleCallback(callback, err, null);
	    if(result && result.ok == 1) return handleCallback(callback, null, result.retval);
	    if(result) return handleCallback(callback, new MongoError(f("eval failed: %s", result.errmsg)), null);
	    handleCallback(callback, err, result);
	  });
	};
	
	/**
	 * Rename a collection.
	 *
	 * @method
	 * @param {string} fromCollection Name of current collection to rename.
	 * @param {string} toCollection New name of of the collection.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.dropTarget=false] Drop the target name collection if it previously exists.
	 * @param {Db~collectionResultCallback} callback The results callback
	 * @return {null}
	 */
	Db.prototype.renameCollection = function(fromCollection, toCollection, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  // Add return new collection
	  options.new_collection = true;
	  // Execute using the collection method
	  this.collection(fromCollection).rename(toCollection, options, callback);
	};
	
	/**
	 * Drop a collection from the database, removing it permanently. New accesses will create a new collection.
	 *
	 * @method
	 * @param {string} name Name of collection to drop
	 * @param {Db~resultCallback} callback The results callback
	 * @return {null}
	 */
	Db.prototype.dropCollection = function(name, callback) {
	  callback || (callback = function(){});
	
	  // Command to execute
	  var cmd = {'drop':name}
	
	  // Execute command
	  this.command(cmd, this.s.options, function(err, result) {
	    if(err) return handleCallback(callback, err);
	    if(result.ok) return handleCallback(callback, null, true);
	    handleCallback(callback, null, false);
	  });
	};
	
	/**
	 * Drop a database.
	 *
	 * @method
	 * @param {Db~resultCallback} [callback] The results callback
	 * @return {null}
	 */
	Db.prototype.dropDatabase = function(callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  // Drop database command
	  var cmd = {'dropDatabase':1};
	
	  // Execute the command
	  this.command(cmd, this.s.options, function(err, result) {
	    if(callback == null) return;
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, null, result.ok ? true : false);
	  });
	}
	
	/**
	 * The callback format for the collections method.
	 * @callback Db~collectionsResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection[]} collections An array of all the collections objects for the db instance.
	 */
	
	/**
	 * Fetch all collections for the current db.
	 *
	 * @method
	 * @param {Db~collectionsResultCallback} [callback] The results callback
	 * @return {null}
	 */
	Db.prototype.collections = function(callback) {
	  var self = this;
	  // Let's get the collection names
	  this.listCollections().toArray(function(err, documents) {
	    if(err != null) return handleCallback(callback, err, null);
	    // Filter collections removing any illegal ones
	    documents = documents.filter(function(doc) {
	      return doc.name.indexOf('$') == -1;
	    });
	
	    // Return the collection objects
	    handleCallback(callback, null, documents.map(function(d) {
	      return new Collection(self, self.s.topology, self.s.databaseName, d.name.replace(self.s.databaseName + ".", ''), self.s.pkFactory, self.s.options);
	    }));
	  });
	};
	
	/**
	 * Runs a command on the database as admin.
	 * @method
	 * @param {object} command The command hash
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {number} [options.maxTimeMS=null] Number of milliseconds to wait before aborting the query.
	 * @param {Db~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Db.prototype.executeDbAdminCommand = function(selector, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(options.readPreference) {
	    options.readPreference = options.readPreference;
	  }
	
	  // Execute command
	  this.s.topology.command('admin.$cmd', selector, options, function(err, result) {
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, null, result.result);
	  });
	};
	
	/**
	 * Creates an index on the db and collection collection.
	 * @method
	 * @param {string} name Name of the collection to create the index on.
	 * @param {(string|object)} fieldOrSpec Defines the index.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.unique=false] Creates an unique index.
	 * @param {boolean} [options.sparse=false] Creates a sparse index.
	 * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.
	 * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
	 * @param {number} [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
	 * @param {number} [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
	 * @param {number} [options.v=null] Specify the format version of the indexes.
	 * @param {number} [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
	 * @param {number} [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
	 * @param {Db~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Db.prototype.createIndex = function(name, fieldOrSpec, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  options = args.length ? args.shift() || {} : {};
	  options = typeof callback === 'function' ? options : callback;
	  options = options == null ? {} : options;
	
	  // Get the write concern options
	  var finalOptions = writeConcern({}, self, options);
	  // Ensure we have a callback
	  if(finalOptions.writeConcern && typeof callback != 'function') {
	    throw new MongoError("Cannot use a writeConcern without a provided callback");
	  }
	
	  // Shallow clone the options
	  options = shallowClone(options);
	
	  // Always set read preference to primary
	  options.readPreference = ReadPreference.PRIMARY;
	
	  // Attempt to run using createIndexes command
	  createIndexUsingCreateIndexes(self, name, fieldOrSpec, options, function(err, result) {
	    if(err == null) return handleCallback(callback, err, result);
	    // Create command
	    var doc = createCreateIndexCommand(self, name, fieldOrSpec, options);
	    // Set no key checking
	    finalOptions.checkKeys = false;
	    // Insert document
	    self.s.topology.insert(f("%s.%s", self.s.databaseName, Db.SYSTEM_INDEX_COLLECTION), doc, finalOptions, function(err, result) {
	      if(callback == null) return;
	      if(err) return handleCallback(callback, err);
	      if(result == null) return handleCallback(callback, null, null);
	      if(result.result.writeErrors) return handleCallback(callback, MongoError.create(result.result.writeErrors[0]), null);
	      handleCallback(callback, null, doc.name);
	    });
	  });
	};
	
	/**
	 * Ensures that an index exists, if it does not it creates it
	 * @method
	 * @deprecated since version 2.0
	 * @param {string} name The index name
	 * @param {(string|object)} fieldOrSpec Defines the index.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.unique=false] Creates an unique index.
	 * @param {boolean} [options.sparse=false] Creates a sparse index.
	 * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.
	 * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
	 * @param {number} [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
	 * @param {number} [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
	 * @param {number} [options.v=null] Specify the format version of the indexes.
	 * @param {number} [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
	 * @param {number} [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
	 * @param {Db~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Db.prototype.ensureIndex = function(name, fieldOrSpec, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Get the write concern options
	  var finalOptions = writeConcern({}, self, options);
	  // Create command
	  var selector = createCreateIndexCommand(self, name, fieldOrSpec, options);
	  var index_name = selector.name;
	
	  // Default command options
	  var commandOptions = {};
	  // Check if the index allready exists
	  this.indexInformation(name, finalOptions, function(err, indexInformation) {
	    if(err != null && err.code != 26) return handleCallback(callback, err, null);
	    // If the index does not exist, create it
	    if(indexInformation == null || !indexInformation[index_name])  {
	      self.createIndex(name, fieldOrSpec, options, callback);
	    } else {
	      if(typeof callback === 'function') return handleCallback(callback, null, index_name);
	    }
	  });
	};
	
	Db.prototype.addChild = function(db) {
	  if(this.s.parentDb) return this.s.parentDb.addChild(db);
	  this.s.children.push(db);
	}
	
	/**
	 * Create a new Db instance sharing the current socket connections.
	 * @method
	 * @param {string} name The name of the database we want to use.
	 * @return {Db}
	 */
	Db.prototype.db = function(dbName) {
	  // Copy the options and add out internal override of the not shared flag
	  var options = {};
	  for(var key in this.options) {
	    options[key] = this.options[key];
	  }
	
	  // Add current db as parentDb
	  options.parentDb = this;
	
	  // Return the db object
	  var db = new Db(dbName, this.s.topology, options)
	
	  // Keep reference to the object
	  // if(this.s.parentDb) {
	    // this.s.parentDb.s.children.push(db); 
	    this.addChild(db);    
	  // } 
	  // this.s.children.push(db);
	
	  // // Add listeners to the parent database
	  // this.once('error', createListener(this, 'error', db));
	  // this.once('timeout', createListener(this, 'timeout', db));
	  // this.once('close', createListener(this, 'close', db));
	  // this.once('parseError', createListener(this, 'parseError', db));
	  
	  // Return the database
	  return db;
	};
	
	var _executeAuthCreateUserCommand = function(self, username, password, options, callback) {
	  // Special case where there is no password ($external users)
	  if(typeof username == 'string'
	    && password != null && typeof password == 'object') {
	    options = password;
	    password = null;
	  }
	
	  // Unpack all options
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  // Error out if we digestPassword set
	  if(options.digestPassword != null) {
	    throw toError("The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option.");
	  }
	
	  // Get additional values
	  var customData = options.customData != null ? options.customData : {};
	  var roles = Array.isArray(options.roles) ? options.roles : [];
	  var maxTimeMS = typeof options.maxTimeMS == 'number' ? options.maxTimeMS : null;
	
	  // If not roles defined print deprecated message
	  if(roles.length == 0) {
	    console.log("Creating a user without roles is deprecated in MongoDB >= 2.6");
	  }
	
	  // Get the error options
	  var commandOptions = {writeCommand:true};
	  if(options['dbName']) commandOptions.dbName = options['dbName'];
	
	  // Add maxTimeMS to options if set
	  if(maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;
	
	  // Check the db name and add roles if needed
	  if((self.databaseName.toLowerCase() == 'admin' || options.dbName == 'admin') && !Array.isArray(options.roles)) {
	    roles = ['root']
	  } else if(!Array.isArray(options.roles)) {
	    roles = ['dbOwner']
	  }
	
	  // Build the command to execute
	  var command = {
	      createUser: username
	    , customData: customData
	    , roles: roles
	    , digestPassword:false
	  }
	
	  // Apply write concern to command
	  command = writeConcern(command, self, options);
	
	  // Use node md5 generator
	  var md5 = crypto.createHash('md5');
	  // Generate keys used for authentication
	  md5.update(username + ":mongo:" + password);
	  var userPassword = md5.digest('hex');
	
	  // No password
	  if(typeof password == 'string') {
	    command.pwd = userPassword;
	  }
	
	  // Force write using primary
	  commandOptions.readPreference = CoreReadPreference.primary;
	
	  // Execute the command
	  self.command(command, commandOptions, function(err, result) {
	    if(err && err.ok == 0 && err.code == undefined) return handleCallback(callback, {code: -5000}, null);
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, !result.ok ? toError(result) : null
	      , result.ok ? [{user: username, pwd: ''}] : null);
	  })
	}
	
	/**
	 * Add a user to the database.
	 * @method
	 * @param {string} username The username.
	 * @param {string} password The password.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {object} [options.customData=null] Custom data associated with the user (only Mongodb 2.6 or higher)
	 * @param {object[]} [options.roles=null] Roles associated with the created user (only Mongodb 2.6 or higher)
	 * @param {Db~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Db.prototype.addUser = function(username, password, options, callback) {
	  // Unpack the parameters
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  options = args.length ? args.shift() || {} : {};
	
	  // Attempt to execute auth command
	  _executeAuthCreateUserCommand(this, username, password, options, function(err, r) {
	    // We need to perform the backward compatible insert operation
	    if(err && err.code == -5000) {
	      var finalOptions = writeConcern(shallowClone(options), self, options);
	      // Use node md5 generator
	      var md5 = crypto.createHash('md5');
	      // Generate keys used for authentication
	      md5.update(username + ":mongo:" + password);
	      var userPassword = md5.digest('hex');
	
	      // If we have another db set
	      var db = options.dbName ? self.db(options.dbName) : self;
	
	      // Fetch a user collection
	      var collection = db.collection(Db.SYSTEM_USER_COLLECTION);
	
	      // Check if we are inserting the first user
	      collection.count({}, function(err, count) {
	        // We got an error (f.ex not authorized)
	        if(err != null) return handleCallback(callback, err, null);
	        // Check if the user exists and update i
	        collection.find({user: username}, {dbName: options['dbName']}).toArray(function(err, documents) {
	          // We got an error (f.ex not authorized)
	          if(err != null) return handleCallback(callback, err, null);
	          // Add command keys
	          finalOptions.upsert = true;
	
	          // We have a user, let's update the password or upsert if not
	          collection.update({user: username},{$set: {user: username, pwd: userPassword}}, finalOptions, function(err, results, full) {
	            if(count == 0 && err) return handleCallback(callback, null, [{user:username, pwd:userPassword}]);
	            if(err) return handleCallback(callback, err, null)
	            handleCallback(callback, null, [{user:username, pwd:userPassword}]);
	          });
	        });
	      });
	
	      return;
	    }
	
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, err, r);
	  });
	};
	
	var _executeAuthRemoveUserCommand = function(self, username, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  // Get the error options
	  var commandOptions = {writeCommand:true};
	  if(options['dbName']) commandOptions.dbName = options['dbName'];
	
	  // Get additional values
	  var maxTimeMS = typeof options.maxTimeMS == 'number' ? options.maxTimeMS : null;
	
	  // Add maxTimeMS to options if set
	  if(maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;
	
	  // Build the command to execute
	  var command = {
	    dropUser: username
	  }
	
	  // Apply write concern to command
	  command = writeConcern(command, self, options);
	
	  // Force write using primary
	  commandOptions.readPreference = CoreReadPreference.primary;
	
	  // Execute the command
	  self.command(command, commandOptions, function(err, result) {
	    if(err && !err.ok && err.code == undefined) return handleCallback(callback, {code: -5000});
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, null, result.ok ? true : false);
	  })
	}
	
	/**
	 * Remove a user from a database
	 * @method
	 * @param {string} username The username.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Db~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Db.prototype.removeUser = function(username, options, callback) {
	  // Unpack the parameters
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  options = args.length ? args.shift() || {} : {};
	
	  // Attempt to execute command
	  _executeAuthRemoveUserCommand(this, username, options, function(err, result) {
	    if(err && err.code == -5000) {
	      var finalOptions = writeConcern(shallowClone(options), self, options);
	      // If we have another db set
	      var db = options.dbName ? self.db(options.dbName) : self;
	
	      // Fetch a user collection
	      var collection = db.collection(Db.SYSTEM_USER_COLLECTION);
	
	      // Locate the user
	      collection.findOne({user: username}, {}, function(err, user) {
	        if(user == null) return handleCallback(callback, err, false);
	        collection.remove({user: username}, finalOptions, function(err, result) {
	          handleCallback(callback, err, true);
	        });
	      });
	
	      return;
	    }
	
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, err, result);
	  });
	};
	
	/**
	 * Authenticate a user against the server.
	 * @method
	 * @param {string} username The username.
	 * @param {string} [password] The password.
	 * @param {object} [options=null] Optional settings.
	 * @param {string} [options.authMechanism=MONGODB-CR] The authentication mechanism to use, GSSAPI, MONGODB-CR, MONGODB-X509, PLAIN
	 * @param {Db~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Db.prototype.authenticate = function(username, password, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  var self = this;
	  // Shallow copy the options
	  options = shallowClone(options);
	
	  // Set default mechanism
	  if(!options.authMechanism) {
	    options.authMechanism = 'DEFAULT';
	  } else if(options.authMechanism != 'GSSAPI'
	    && options.authMechanism != 'MONGODB-CR'
	    && options.authMechanism != 'MONGODB-X509'
	    && options.authMechanism != 'SCRAM-SHA-1'
	    && options.authMechanism != 'PLAIN') {
	      return handleCallback(callback, new MongoError("only GSSAPI, PLAIN, MONGODB-X509, SCRAM-SHA-1 or MONGODB-CR is supported by authMechanism"));
	  }
	
	  // the default db to authenticate against is 'this'
	  // if authententicate is called from a retry context, it may be another one, like admin
	  var authdb = options.authdb ? options.authdb : options.dbName;
	  authdb = options.authSource ? options.authSource : authdb;
	  authdb = authdb ? authdb : this.databaseName;
	
	  // Callback
	  var _callback = function(err, result) {
	    if(self.listeners('authenticated').length > 0) {
	      self.emit('authenticated', err, result);
	    }
	
	    // Return to caller
	    handleCallback(callback, err, result);
	  }
	
	  // authMechanism
	  var authMechanism = options.authMechanism || '';
	  authMechanism = authMechanism.toUpperCase();
	
	  // If classic auth delegate to auth command
	  if(authMechanism == 'MONGODB-CR') {
	    this.s.topology.auth('mongocr', authdb, username, password, function(err, result) {
	      if(err) return handleCallback(callback, err, false);
	      _callback(null, true);
	    });
	  } else if(authMechanism == 'PLAIN') {
	    this.s.topology.auth('plain', authdb, username, password, function(err, result) {
	      if(err) return handleCallback(callback, err, false);
	      _callback(null, true);
	    });
	  } else if(authMechanism == 'MONGODB-X509') {
	    this.s.topology.auth('x509', authdb, username, password, function(err, result) {
	      if(err) return handleCallback(callback, err, false);
	      _callback(null, true);
	    });
	  } else if(authMechanism == 'SCRAM-SHA-1') {
	    this.s.topology.auth('scram-sha-1', authdb, username, password, function(err, result) {
	      if(err) return handleCallback(callback, err, false);
	      _callback(null, true);
	    });
	  } else if(authMechanism == 'GSSAPI') {
	    if(process.platform == 'win32') {
	      this.s.topology.auth('sspi', authdb, username, password, options, function(err, result) {
	        if(err) return handleCallback(callback, err, false);
	        _callback(null, true);
	      });
	    } else {
	      this.s.topology.auth('gssapi', authdb, username, password, options, function(err, result) {
	        if(err) return handleCallback(callback, err, false);
	        _callback(null, true);
	      });
	    }
	  } else if(authMechanism == 'DEFAULT') {
	    this.s.topology.auth('default', authdb, username, password, function(err, result) {
	      if(err) return handleCallback(callback, err, false);
	      _callback(null, true);
	    });
	  } else {
	    handleCallback(callback, new MongoError(f("authentication mechanism %s not supported", options.authMechanism), false));
	  }
	};
	
	/**
	 * Logout user from server, fire off on all connections and remove all auth info
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {string} [options.dbName=null] Logout against different database than current.
	 * @param {Db~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Db.prototype.logout = function(options, callback) {
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  options = args.length ? args.shift() || {} : {};
	
	  // logout command
	  var cmd = {'logout':1};
	
	  // Add onAll to login to ensure all connection are logged out
	  options.onAll = true;
	
	  // We authenticated against a different db use that
	  if(this.s.authSource) options.dbName = this.s.authSource;
	
	  // Execute the command
	  this.command(cmd, options, function(err, result) {
	    if(err) return handleCallback(callback, err, false);
	    handleCallback(callback, null, true)
	  });
	}
	
	// Figure out the read preference
	var getReadPreference = function(options, db) {
	  if(options.readPreference) return options;
	  if(db.readPreference) options.readPreference = db.readPreference;
	  return options;
	}
	
	/**
	 * Retrieves this collections index info.
	 * @method
	 * @param {string} name The name of the collection.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.full=false] Returns the full raw index information.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {Db~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Db.prototype.indexInformation = function(name, options, callback) {
	  if(typeof callback === 'undefined') {
	    if(typeof options === 'undefined') {
	      callback = name;
	      name = null;
	    } else {
	      callback = options;
	    }
	    options = {};
	  }
	
	  // If we specified full information
	  var full = options['full'] == null ? false : options['full'];
	  var self = this;
	
	  // Process all the results from the index command and collection
	  var processResults = function(indexes) {
	    // Contains all the information
	    var info = {};
	    // Process all the indexes
	    for(var i = 0; i < indexes.length; i++) {
	      var index = indexes[i];
	      // Let's unpack the object
	      info[index.name] = [];
	      for(var name in index.key) {
	        info[index.name].push([name, index.key[name]]);
	      }
	    }
	
	    return info;
	  }
	
	  // Get the list of indexes of the specified collection
	  this.collection(name).listIndexes().toArray(function(err, indexes) {
	    if(err) return callback(toError(err));
	    if(!Array.isArray(indexes)) return handleCallback(callback, null, []);
	    if(full) return handleCallback(callback, null, indexes);
	    handleCallback(callback, null, processResults(indexes));
	  });
	};
	
	var createCreateIndexCommand = function(db, name, fieldOrSpec, options) {
	  var indexParameters = parseIndexOptions(fieldOrSpec);
	  var fieldHash = indexParameters.fieldHash;
	  var keys = indexParameters.keys;
	
	  // Generate the index name
	  var indexName = typeof options.name == 'string' ? options.name : indexParameters.name;
	  var selector = {
	    'ns': db.databaseName + "." + name, 'key': fieldHash, 'name': indexName
	  }
	
	  // Ensure we have a correct finalUnique
	  var finalUnique = options == null || 'object' === typeof options ? false : options;
	  // Set up options
	  options = options == null || typeof options == 'boolean' ? {} : options;
	
	  // Add all the options
	  var keysToOmit = Object.keys(selector);
	  for(var optionName in options) {
	    if(keysToOmit.indexOf(optionName) == -1) {
	      selector[optionName] = options[optionName];
	    }
	  }
	
	  if(selector['unique'] == null) selector['unique'] = finalUnique;
	
	  // Remove any write concern operations
	  var removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference'];
	  for(var i = 0; i < removeKeys.length; i++) {
	    delete selector[removeKeys[i]];
	  }
	
	  // Return the command creation selector
	  return selector;
	}
	
	var createIndexUsingCreateIndexes = function(self, name, fieldOrSpec, options, callback) {
	  // Build the index
	  var indexParameters = parseIndexOptions(fieldOrSpec);
	  // Generate the index name
	  var indexName = typeof options.name == 'string' ? options.name : indexParameters.name;
	  // Set up the index
	  var indexes = [{ name: indexName, key: indexParameters.fieldHash }];
	  // merge all the options
	  var keysToOmit = Object.keys(indexes[0]);
	  for(var optionName in options) {
	    if(keysToOmit.indexOf(optionName) == -1) {
	      indexes[0][optionName] = options[optionName];
	    }
	
	    // Remove any write concern operations
	    var removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference'];
	    for(var i = 0; i < removeKeys.length; i++) {
	      delete indexes[0][removeKeys[i]];
	    }
	  }
	
	  // Create command
	  var cmd = {createIndexes: name, indexes: indexes};
	
	  // Apply write concern to command
	  cmd = writeConcern(cmd, self, options);
	
	  // Build the command
	  self.command(cmd, options, function(err, result) {
	    if(err) return handleCallback(callback, err, null);
	    if(result.ok == 0) return handleCallback(callback, toError(result), null);
	    // Return the indexName for backward compatibility
	    handleCallback(callback, null, indexName);
	  });
	}
	
	// Validate the database name
	var validateDatabaseName = function(databaseName) {
	  if(typeof databaseName !== 'string') throw new MongoError("database name must be a string");
	  if(databaseName.length === 0) throw new MongoError("database name cannot be the empty string");
	  if(databaseName == '$external') return;
	
	  var invalidChars = [" ", ".", "$", "/", "\\"];
	  for(var i = 0; i < invalidChars.length; i++) {
	    if(databaseName.indexOf(invalidChars[i]) != -1) throw new MongoError("database names cannot contain the character '" + invalidChars[i] + "'");
	  }
	}
	
	// Get write concern
	var writeConcern = function(target, db, options) {
	  if(options.w != null || options.j != null || options.fsync != null) {
	    var opts = {};
	    if(options.w) opts.w = options.w;
	    if(options.wtimeout) opts.wtimeout = options.wtimeout;
	    if(options.j) opts.j = options.j;
	    if(options.fsync) opts.fsync = options.fsync;
	    target.writeConcern = opts;
	  } else if(db.writeConcern.w != null || db.writeConcern.j != null || db.writeConcern.fsync != null) {
	    target.writeConcern = db.writeConcern;
	  }
	
	  return target
	}
	
	// Add listeners to topology
	var createListener = function(self, e, object) {
	  var listener = function(err) {
	    if(e != 'error') {
	      object.emit(e, err, self);
	
	      // Emit on all associated db's if available
	      for(var i = 0; i < self.s.children.length; i++) {
	        self.s.children[i].emit(e, err, self.s.children[i]);
	      }
	    }
	  }
	  return listener;
	}
	
	/**
	 * Db close event
	 *
	 * @event Db#close
	 * @type {object}
	 */
	
	/**
	 * Db authenticated event
	 *
	 * @event Db#authenticated
	 * @type {object}
	 */
	
	/**
	 * Db reconnect event
	 *
	 * @event Db#reconnect
	 * @type {object}
	 */
	
	/**
	 * Db error event
	 *
	 * @event Db#error
	 * @type {MongoError}
	 */
	
	/**
	 * Db timeout event
	 *
	 * @event Db#timeout
	 * @type {object}
	 */
	
	/**
	 * Db parseError event
	 *
	 * @event Db#parseError
	 * @type {object}
	 */
	
	/**
	 * Db fullsetup event, emitted when all servers in the topology have been connected to.
	 *
	 * @event Db#fullsetup
	 * @type {Db}
	 */
	
	// Constants
	Db.SYSTEM_NAMESPACE_COLLECTION = "system.namespaces";
	Db.SYSTEM_INDEX_COLLECTION = "system.indexes";
	Db.SYSTEM_PROFILE_COLLECTION = "system.profile";
	Db.SYSTEM_USER_COLLECTION = "system.users";
	Db.SYSTEM_COMMAND_COLLECTION = "$cmd";
	Db.SYSTEM_JS_COLLECTION = "system.js";
	
	module.exports = Db;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 153 */
/*!****************************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/command_cursor.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var inherits = __webpack_require__(/*! util */ 57).inherits
	  , f = __webpack_require__(/*! util */ 57).format
	  , toError = __webpack_require__(/*! ./utils */ 119).toError
	  , getSingleProperty = __webpack_require__(/*! ./utils */ 119).getSingleProperty
	  , formattedOrderClause = __webpack_require__(/*! ./utils */ 119).formattedOrderClause
	  , handleCallback = __webpack_require__(/*! ./utils */ 119).handleCallback
	  , Logger = __webpack_require__(/*! mongodb-core */ 76).Logger
	  , EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter
	  , ReadPreference = __webpack_require__(/*! ./read_preference */ 120)
	  , MongoError = __webpack_require__(/*! mongodb-core */ 76).MongoError
	  , Readable = __webpack_require__(/*! stream */ 121).Readable || __webpack_require__(/*! readable-stream */ 138).Readable
	  // , CoreCursor = require('mongodb-core').Cursor
	  , CoreCursor = __webpack_require__(/*! ./cursor */ 118)
	  , Query = __webpack_require__(/*! mongodb-core */ 76).Query
	  , CoreReadPreference = __webpack_require__(/*! mongodb-core */ 76).ReadPreference;
	
	/**
	 * @fileOverview The **CommandCursor** class is an internal class that embodies a 
	 * generalized cursor based on a MongoDB command allowing for iteration over the 
	 * results returned. It supports one by one document iteration, conversion to an 
	 * array or can be iterated as a Node 0.10.X or higher stream
	 * 
	 * **CommandCursor Cannot directly be instantiated**
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Create a collection we want to drop later
	 *   var col = db.collection('listCollectionsExample1');
	 *   // Insert a bunch of documents
	 *   col.insert([{a:1, b:1}
	 *     , {a:2, b:2}, {a:3, b:3}
	 *     , {a:4, b:4}], {w:1}, function(err, result) {
	 *     test.equal(null, err);
	 * 
	 *     // List the database collections available
	 *     db.listCollections().toArray(function(err, items) {
	 *       test.equal(null, err);
	 *       db.close();
	 *     });
	 *   });
	 * });
	 */
	
	/**
	 * Namespace provided by the browser.
	 * @external Readable
	 */
	
	/**
	 * Creates a new Command Cursor instance (INTERNAL TYPE, do not instantiate directly)
	 * @class CommandCursor
	 * @extends external:Readable
	 * @fires CommandCursor#data
	 * @fires CommandCursor#end
	 * @fires CommandCursor#close
	 * @fires CommandCursor#readable
	 * @return {CommandCursor} an CommandCursor instance.
	 */
	var CommandCursor = function(bson, ns, cmd, options, topology, topologyOptions) {
	  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));
	  var self = this;
	  var state = CommandCursor.INIT;
	  var streamOptions = {};
	
	  // MaxTimeMS
	  var maxTimeMS = null;
	
	  // Set up
	  Readable.call(this, {objectMode: true});
	
	  // Internal state
	  this.s = {
	    // MaxTimeMS
	      maxTimeMS: maxTimeMS
	    // State
	    , state: state
	    // Stream options
	    , streamOptions: streamOptions
	    // BSON
	    , bson: bson
	    // Namespae
	    , ns: ns
	    // Command
	    , cmd: cmd
	    // Options
	    , options: options
	    // Topology
	    , topology: topology
	    // Topology Options
	    , topologyOptions: topologyOptions
	  }
	}
	
	/**
	 * CommandCursor stream data event, fired for each document in the cursor.
	 *
	 * @event CommandCursor#data
	 * @type {object}
	 */
	
	/**
	 * CommandCursor stream end event
	 *
	 * @event CommandCursor#end
	 * @type {null}
	 */
	
	/**
	 * CommandCursor stream close event
	 *
	 * @event CommandCursor#close
	 * @type {null}
	 */
	
	/**
	 * CommandCursor stream readable event
	 *
	 * @event CommandCursor#readable
	 * @type {null}
	 */
	
	// Inherit from Readable
	inherits(CommandCursor, Readable);  
	
	// Set the methods to inherit from prototype
	var methodsToInherit = ['_next', 'next', 'each', 'forEach', 'toArray'
	  , 'rewind', 'bufferedCount', 'readBufferedDocuments', 'close', 'isClosed'];
	
	// // Map core cursor _next method so we can apply mapping
	// CoreCursor.prototype._next = CoreCursor.prototype.next;
	
	// Only inherit the types we need
	for(var i = 0; i < methodsToInherit.length; i++) {
	  CommandCursor.prototype[methodsToInherit[i]] = CoreCursor.prototype[methodsToInherit[i]];
	}
	
	/**
	 * Set the batch size for the cursor.
	 * @method
	 * @param {number} value The batchSize for the cursor.
	 * @throws {MongoError}
	 * @return {CommandCursor}
	 */
	CommandCursor.prototype.batchSize = function(value) {
	  if(this.s.state == CommandCursor.CLOSED || this.isDead()) throw new MongoError("Cursor is closed");
	  if(typeof value != 'number') throw new MongoError("batchSize requires an integer");
	  if(this.s.cmd.cursor) this.s.cmd.cursor.batchSize = value;
	  this.setCursorBatchSize(value);
	  return this;
	}
	
	/**
	 * Add a maxTimeMS stage to the aggregation pipeline
	 * @method
	 * @param {number} value The state maxTimeMS value.
	 * @return {CommandCursor}
	 */
	CommandCursor.prototype.maxTimeMS = function(value) {
	  if(this.s.topology.lastIsMaster().minWireVersion > 2) {
	    this.s.cmd.maxTimeMS = value;
	  }
	  return this;
	}
	
	CommandCursor.prototype.get = CommandCursor.prototype.toArray;
	
	/**
	 * Get the next available document from the cursor, returns null if no more documents are available.
	 * @function CommandCursor.prototype.next
	 * @param {CommandCursor~resultCallback} callback The result callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	
	/**
	 * Set the new batchSize of the cursor
	 * @function CommandCursor.prototype.setBatchSize
	 * @param {number} value The new batchSize for the cursor
	 * @return {null}
	 */
	
	/**
	 * Get the batchSize of the cursor
	 * @function CommandCursor.prototype.batchSize
	 * @param {number} value The current batchSize for the cursor
	 * @return {null}
	 */
	
	/**
	 * The callback format for results
	 * @callback CommandCursor~toArrayResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object[]} documents All the documents the satisfy the cursor.
	 */
	
	/**
	 * Returns an array of documents. The caller is responsible for making sure that there
	 * is enough memory to store the results. Note that the array only contain partial
	 * results when this cursor had been previouly accessed.
	 * @method CommandCursor.prototype.toArray
	 * @param {CommandCursor~toArrayResultCallback} callback The result callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	
	/**
	 * The callback format for results
	 * @callback CommandCursor~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {(object|null)} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Iterates over all the documents for this cursor. As with **{cursor.toArray}**,
	 * not all of the elements will be iterated if this cursor had been previouly accessed.
	 * In that case, **{cursor.rewind}** can be used to reset the cursor. However, unlike
	 * **{cursor.toArray}**, the cursor will only hold a maximum of batch size elements
	 * at any given time if batch size is specified. Otherwise, the caller is responsible
	 * for making sure that the entire result can fit the memory.
	 * @method CommandCursor.prototype.each
	 * @param {CommandCursor~resultCallback} callback The result callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	
	/**
	 * Close the cursor, sending a KillCursor command and emitting close.
	 * @method CommandCursor.prototype.close
	 * @param {CommandCursor~resultCallback} [callback] The result callback.
	 * @return {null}
	 */   
	
	/**
	 * Is the cursor closed
	 * @method CommandCursor.prototype.isClosed
	 * @return {boolean}
	 */   
	
	/**
	 * Clone the cursor
	 * @function CommandCursor.prototype.clone
	 * @return {CommandCursor}
	 */     
	
	/**
	 * Resets the cursor
	 * @function CommandCursor.prototype.rewind
	 * @return {CommandCursor}
	 */  
	
	/**
	 * The callback format for the forEach iterator method
	 * @callback CommandCursor~iteratorCallback
	 * @param {Object} doc An emitted document for the iterator
	 */
	
	/**
	 * The callback error format for the forEach iterator method
	 * @callback CommandCursor~endCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 */
	
	/*
	 * Iterates over all the documents for this cursor using the iterator, callback pattern.
	 * @method CommandCursor.prototype.forEach
	 * @param {CommandCursor~iteratorCallback} iterator The iteration callback.
	 * @param {CommandCursor~endCallback} callback The end callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	
	CommandCursor.INIT = 0;
	CommandCursor.OPEN = 1;
	CommandCursor.CLOSED = 2;
	
	module.exports = CommandCursor;

/***/ },
/* 154 */
/*!*******************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/admin.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var toError = __webpack_require__(/*! ./utils */ 119).toError;
	
	/**
	 * @fileOverview The **Admin** class is an internal class that allows convenient access to
	 * the admin functionality and commands for MongoDB.
	 * 
	 * **ADMIN Cannot directly be instantiated**
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Use the admin database for the operation
	 *   var adminDb = db.admin();
	 *     
	 *   // List all the available databases
	 *   adminDb.listDatabases(function(err, dbs) {
	 *     test.equal(null, err);
	 *     test.ok(dbs.databases.length > 0);
	 *     db.close();
	 *   });
	 * });
	 */
	
	/**
	 * Create a new Admin instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @return {Admin} a collection instance.
	 */
	var Admin = function(db, topology) {
	  if(!(this instanceof Admin)) return new Admin(db, topology);
	  var self = this;
	
	  // Internal state
	  this.s = {
	      db: db
	    , topology: topology
	  }
	}
	
	/**
	 * The callback format for results
	 * @callback Admin~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Execute a command
	 * @method
	 * @param {object} command The command hash
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {number} [options.maxTimeMS=null] Number of milliseconds to wait before aborting the query.
	 * @param {Admin~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Admin.prototype.command = function(command, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  options = args.length ? args.shift() : {};
	
	  // Execute a command
	  this.s.db.executeDbAdminCommand(command, options, function(err, doc) {
	    return callback != null ? callback(err, doc) : null;
	  });
	} 
	
	/**
	 * Retrieve the server information for the current
	 * instance of the db client
	 *
	 * @param {Admin~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Admin.prototype.buildInfo = function(callback) {
	  this.serverInfo(callback);
	}
	
	/**
	 * Retrieve the server information for the current
	 * instance of the db client
	 *
	 * @param {Admin~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Admin.prototype.serverInfo = function(callback) {
	  this.s.db.executeDbAdminCommand({buildinfo:1}, function(err, doc) {
	    if(err != null) return callback(err, null);
	    return callback(null, doc);
	  });
	}
	
	/**
	 * Retrieve this db's server status.
	 *
	 * @param {Admin~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Admin.prototype.serverStatus = function(callback) {
	  var self = this;
	
	  this.s.db.executeDbAdminCommand({serverStatus: 1}, function(err, doc) {
	    if(err == null && doc.ok === 1) {
	      callback(null, doc);
	    } else {
	      if(err) return callback(err, false);
	      return callback(toError(doc), false);
	    }
	  });
	};
	
	/**
	 * Retrieve the current profiling Level for MongoDB
	 *
	 * @param {Admin~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Admin.prototype.profilingLevel = function(callback) {
	  var self = this;
	
	  this.s.db.executeDbAdminCommand({profile:-1}, function(err, doc) {
	    doc = doc;
	
	    if(err == null && doc.ok === 1) {
	      var was = doc.was;
	      if(was == 0) return callback(null, "off");
	      if(was == 1) return callback(null, "slow_only");
	      if(was == 2) return callback(null, "all");
	        return callback(new Error("Error: illegal profiling level value " + was), null);
	    } else {
	      err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
	    }
	  });
	};
	
	/**
	 * Ping the MongoDB server and retrieve results
	 *
	 * @param {Admin~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Admin.prototype.ping = function(options, callback) {
	  var args = Array.prototype.slice.call(arguments, 0);
	  this.s.db.executeDbAdminCommand({ping: 1}, args.pop());
	}
	
	/**
	 * Authenticate a user against the server.
	 * @method
	 * @param {string} username The username.
	 * @param {string} [password] The password.
	 * @param {Admin~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Admin.prototype.authenticate = function(username, password, callback) {
	  this.s.db.authenticate(username, password, {authdb: 'admin'}, function(err, doc) {
	    return callback(err, doc);
	  })
	}
	
	/**
	 * Logout user from server, fire off on all connections and remove all auth info
	 * @method
	 * @param {Admin~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Admin.prototype.logout = function(callback) {
	  this.s.db.logout({authdb: 'admin'},  function(err, doc) {
	    return callback(err, doc);
	  })
	}
	
	/**
	 * Add a user to the database.
	 * @method
	 * @param {string} username The username.
	 * @param {string} password The password.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.fsync=false] Specify a file sync write concern.
	 * @param {object} [options.customData=null] Custom data associated with the user (only Mongodb 2.6 or higher)
	 * @param {object[]} [options.roles=null] Roles associated with the created user (only Mongodb 2.6 or higher)
	 * @param {Admin~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Admin.prototype.addUser = function(username, password, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  options = args.length ? args.shift() : {};
	  // Set the db name to admin
	  options.dbName = 'admin';
	  // Add user
	  this.s.db.addUser(username, password, options, function(err, doc) {
	    return callback(err, doc);
	  })
	}
	
	/**
	 * Remove a user from a database
	 * @method
	 * @param {string} username The username.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.fsync=false] Specify a file sync write concern.
	 * @param {Admin~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Admin.prototype.removeUser = function(username, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  options = args.length ? args.shift() : {};
	  options.dbName = 'admin';
	
	  this.s.db.removeUser(username, options, function(err, doc) {
	    return callback(err, doc);
	  })
	}
	
	/**
	 * Set the current profiling level of MongoDB
	 *
	 * @param {string} level The new profiling level (off, slow_only, all).
	 * @param {Admin~resultCallback} callback The command result callback.
	 * @return {null}
	 */
	Admin.prototype.setProfilingLevel = function(level, callback) {
	  var self = this;
	  var command = {};
	  var profile = 0;
	
	  if(level == "off") {
	    profile = 0;
	  } else if(level == "slow_only") {
	    profile = 1;
	  } else if(level == "all") {
	    profile = 2;
	  } else {
	    return callback(new Error("Error: illegal profiling level value " + level));
	  }
	
	  // Set up the profile number
	  command['profile'] = profile;
	
	  this.s.db.executeDbAdminCommand(command, function(err, doc) {
	    doc = doc;
	
	    if(err == null && doc.ok === 1)
	      return callback(null, level);
	    return err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
	  });
	};
	
	/**
	 * Retrive the current profiling information for MongoDB
	 *
	 * @param {Admin~resultCallback} callback The command result callback.
	 * @return {null}
	 */
	Admin.prototype.profilingInfo = function(callback) {
	  try {
	    this.s.topology.cursor("admin.system.profile", { find: 'system.profile', query: {}}, {}).toArray(callback);
	  } catch (err) {
	    return callback(err, null);
	  }
	};
	
	/**
	 * Validate an existing collection
	 *
	 * @param {string} collectionName The name of the collection to validate.
	 * @param {object} [options=null] Optional settings.
	 * @param {Admin~resultCallback} callback The command result callback.
	 * @return {null}
	 */
	Admin.prototype.validateCollection = function(collectionName, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  options = args.length ? args.shift() : {};
	
	  var self = this;
	  var command = {validate: collectionName};
	  var keys = Object.keys(options);
	
	  // Decorate command with extra options
	  for(var i = 0; i < keys.length; i++) {
	    if(options.hasOwnProperty(keys[i])) {
	      command[keys[i]] = options[keys[i]];
	    }
	  }
	
	  this.s.db.command(command, function(err, doc) {
	    if(err != null) return callback(err, null);
	
	    if(doc.ok === 0)
	      return callback(new Error("Error with validate command"), null);
	    if(doc.result != null && doc.result.constructor != String)
	      return callback(new Error("Error with validation data"), null);
	    if(doc.result != null && doc.result.match(/exception|corrupt/) != null)
	      return callback(new Error("Error: invalid collection " + collectionName), null);
	    if(doc.valid != null && !doc.valid)
	      return callback(new Error("Error: invalid collection " + collectionName), null);
	
	    return callback(null, doc);
	  });
	};
	
	/**
	 * List the available databases
	 *
	 * @param {Admin~resultCallback} callback The command result callback.
	 * @return {null}
	 */
	Admin.prototype.listDatabases = function(callback) {
	  this.s.db.executeDbAdminCommand({listDatabases:1}, {}, function(err, doc) {
	    if(err != null) return callback(err, null);
	    return callback(null, doc);
	  });
	}
	
	/**
	 * Get ReplicaSet status
	 *
	 * @param {Admin~resultCallback} callback The command result callback.
	 * @return {null}
	 */
	Admin.prototype.replSetGetStatus = function(callback) {
	  var self = this;
	
	  this.s.db.executeDbAdminCommand({replSetGetStatus:1}, function(err, doc) {
	    if(err == null && doc.ok === 1)
	      return callback(null, doc);
	    if(err) return callback(err, false);
	    return callback(toError(doc), false);
	  });
	}; 
	
	module.exports = Admin;

/***/ },
/* 155 */
/*!************************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/collection.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";
	
	var checkCollectionName = __webpack_require__(/*! ./utils */ 119).checkCollectionName
	  , ObjectID = __webpack_require__(/*! mongodb-core */ 76).BSON.ObjectID
	  , Long = __webpack_require__(/*! mongodb-core */ 76).BSON.Long
	  , Code = __webpack_require__(/*! mongodb-core */ 76).BSON.Code
	  , f = __webpack_require__(/*! util */ 57).format
	  , AggregationCursor = __webpack_require__(/*! ./aggregation_cursor */ 156)
	  , MongoError = __webpack_require__(/*! mongodb-core */ 76).MongoError
	  , shallowClone = __webpack_require__(/*! ./utils */ 119).shallowClone
	  , isObject = __webpack_require__(/*! ./utils */ 119).isObject
	  , toError = __webpack_require__(/*! ./utils */ 119).toError
	  , normalizeHintField = __webpack_require__(/*! ./utils */ 119).normalizeHintField
	  , handleCallback = __webpack_require__(/*! ./utils */ 119).handleCallback
	  , decorateCommand = __webpack_require__(/*! ./utils */ 119).decorateCommand
	  , formattedOrderClause = __webpack_require__(/*! ./utils */ 119).formattedOrderClause
	  , ReadPreference = __webpack_require__(/*! ./read_preference */ 120)
	  , CoreReadPreference = __webpack_require__(/*! mongodb-core */ 76).ReadPreference
	  , CommandCursor = __webpack_require__(/*! ./command_cursor */ 153)
	  , Cursor = __webpack_require__(/*! ./cursor */ 118)
	  , unordered = __webpack_require__(/*! ./bulk/unordered */ 157)
	  , ordered = __webpack_require__(/*! ./bulk/ordered */ 159);
	
	/**
	 * @fileOverview The **Collection** class is an internal class that embodies a MongoDB collection
	 * allowing for insert/update/remove/find and other command operation on that MongoDB collection.
	 * 
	 * **COLLECTION Cannot directly be instantiated**
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Create a collection we want to drop later
	 *   var col = db.collection('createIndexExample1');
	 *   // Show that duplicate records got dropped
	 *   col.find({}).toArray(function(err, items) {
	 *     test.equal(null, err);
	 *     test.equal(4, items.length);
	 *     db.close();
	 *   });
	 * });
	 */
	
	/**
	 * Create a new Collection instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @property {string} collectionName Get the collection name.
	 * @property {string} namespace Get the full collection namespace.
	 * @property {object} writeConcern The current write concern values.
	 * @property {object} hint Get current index hint for collection.
	 * @return {Collection} a Collection instance.
	 */
	var Collection = function(db, topology, dbName, name, pkFactory, options) {  
	  checkCollectionName(name);
	  var self = this;
	  // Unpack variables
	  var internalHint = null;
	  var opts = options != null && ('object' === typeof options) ? options : {};
	  var slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;
	  var serializeFunctions = options == null || options.serializeFunctions == null ? db.serializeFunctions : options.serializeFunctions;
	  var raw = options == null || options.raw == null ? db.raw : options.raw;
	  var readPreference = null;
	  var collectionHint = null;
	  var namespace = f("%s.%s", dbName, name);
	
	  // Assign the right collection level readPreference
	  if(options && options.readPreference) {
	    readPreference = options.readPreference;
	  } else if(db.options.readPreference) {
	    readPreference = db.options.readPreference;
	  }
	
	  // Set custom primary key factory if provided
	  pkFactory = pkFactory == null
	    ? ObjectID
	    : pkFactory;
	
	  // Internal state
	  this.s = {
	    // Set custom primary key factory if provided
	      pkFactory: pkFactory
	    // Db
	    , db: db
	    // Topology
	    , topology: topology
	    // dbName
	    , dbName: dbName
	    // Options
	    , options: options
	    // Namespace
	    , namespace: namespace
	    // Read preference
	    , readPreference: readPreference
	    // Raw
	    , raw: raw
	    // SlaveOK
	    , slaveOk: slaveOk
	    // Serialize functions
	    , serializeFunctions: serializeFunctions
	    // internalHint
	    , internalHint: internalHint
	    // collectionHint
	    , collectionHint: collectionHint
	    // Name
	    , name: name
	  }
	}
	
	Object.defineProperty(Collection.prototype, 'collectionName', {
	  enumerable: true, get: function() { return this.s.name; }
	});
	
	Object.defineProperty(Collection.prototype, 'namespace', {
	  enumerable: true, get: function() { return this.s.namespace; }
	});
	
	Object.defineProperty(Collection.prototype, 'writeConcern', {
	  enumerable:true,
	  get: function() { 
	    var ops = {};
	    if(this.s.options.w != null) ops.w = this.s.options.w;
	    if(this.s.options.j != null) ops.j = this.s.options.j;
	    if(this.s.options.fsync != null) ops.fsync = this.s.options.fsync;
	    if(this.s.options.wtimeout != null) ops.wtimeout = this.s.options.wtimeout;
	    return ops;
	  }
	});
	
	/**
	 * @ignore
	 */
	Object.defineProperty(Collection.prototype, "hint", {
	    enumerable: true
	  , get: function () { return this.s.collectionHint; }
	  , set: function (v) { this.s.collectionHint = normalizeHintField(v); }
	});
	
	/**
	 * Creates a cursor for a query that can be used to iterate over results from MongoDB
	 * @method
	 * @param {object} query The cursor query object.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Collection.prototype.find = function() {
	  var options
	    , args = Array.prototype.slice.call(arguments, 0)
	    , has_callback = typeof args[args.length - 1] === 'function'
	    , has_weird_callback = typeof args[0] === 'function'
	    , callback = has_callback ? args.pop() : (has_weird_callback ? args.shift() : null)
	    , len = args.length
	    , selector = len >= 1 ? args[0] : {}
	    , fields = len >= 2 ? args[1] : undefined;
	
	  if(len === 1 && has_weird_callback) {
	    // backwards compat for callback?, options case
	    selector = {};
	    options = args[0];
	  }
	
	  if(len === 2 && !Array.isArray(fields)) {
	    var fieldKeys = Object.keys(fields);
	    var is_option = false;
	
	    for(var i = 0; i < fieldKeys.length; i++) {
	      if(testForFields[fieldKeys[i]] != null) {
	        is_option = true;
	        break;
	      }
	    }
	
	    if(is_option) {
	      options = fields;
	      fields = undefined;
	    } else {
	      options = {};
	    }
	  } else if(len === 2 && Array.isArray(fields) && !Array.isArray(fields[0])) {
	    var newFields = {};
	    // Rewrite the array
	    for(var i = 0; i < fields.length; i++) {
	      newFields[fields[i]] = 1;
	    }
	    // Set the fields
	    fields = newFields;
	  }
	
	  if(3 === len) {
	    options = args[2];
	  }
	
	  // Ensure selector is not null
	  selector = selector == null ? {} : selector;
	  // Validate correctness off the selector
	  var object = selector;
	  if(Buffer.isBuffer(object)) {
	    var object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
	    if(object_size != object.length)  {
	      var error = new Error("query selector raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
	      error.name = 'MongoError';
	      throw error;
	    }
	  }
	
	  // Validate correctness of the field selector
	  var object = fields;
	  if(Buffer.isBuffer(object)) {
	    var object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
	    if(object_size != object.length)  {
	      var error = new Error("query fields raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
	      error.name = 'MongoError';
	      throw error;
	    }
	  }
	
	  // Check special case where we are using an objectId
	  if(selector instanceof ObjectID || (selector != null && selector._bsontype == 'ObjectID')) {
	    selector = {_id:selector};
	  }
	
	  // If it's a serialized fields field we need to just let it through
	  // user be warned it better be good
	  if(options && options.fields && !(Buffer.isBuffer(options.fields))) {
	    fields = {};
	
	    if(Array.isArray(options.fields)) {
	      if(!options.fields.length) {
	        fields['_id'] = 1;
	      } else {
	        for (var i = 0, l = options.fields.length; i < l; i++) {
	          fields[options.fields[i]] = 1;
	        }
	      }
	    } else {
	      fields = options.fields;
	    }
	  }
	
	  if (!options) options = {};
	
	  var newOptions = {};
	  // Make a shallow copy of options
	  for (var key in options) {
	    newOptions[key] = options[key];
	  }
	
	  // Unpack options
	  newOptions.skip = len > 3 ? args[2] : options.skip ? options.skip : 0;
	  newOptions.limit = len > 3 ? args[3] : options.limit ? options.limit : 0;
	  newOptions.raw = options.raw != null && typeof options.raw === 'boolean' ? options.raw : this.s.raw;
	  newOptions.hint = options.hint != null ? normalizeHintField(options.hint) : this.s.collectionHint;
	  newOptions.timeout = len == 5 ? args[4] : typeof options.timeout === 'undefined' ? undefined : options.timeout;
	  // // If we have overridden slaveOk otherwise use the default db setting
	  newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.s.db.slaveOk;
	
	  // Add read preference if needed
	  newOptions = getReadPreference(this, newOptions, this.s.db, this);
	  // Set slave ok to true if read preference different from primary
	  if(newOptions.readPreference != null
	    && (newOptions.readPreference != 'primary' || newOptions.readPreference.mode != 'primary')) {
	    newOptions.slaveOk = true;
	  }
	
	  // Ensure the query is an object
	  if(selector != null && typeof selector != 'object') {
	    throw new MongoError("query selector must be an object");
	  }
	
	  // Build the find command
	  var findCommand = {
	      find: this.s.namespace
	    , limit: newOptions.limit
	    , skip: newOptions.skip
	    , query: selector
	  }
	
	  // Ensure we use the right await data option
	  if(typeof newOptions.awaitdata == 'boolean')  {
	    newOptions.awaitData = newOptions.awaitdata
	  };
	  
	  // Translate to new command option noCursorTimeout
	  if(typeof newOptions.timeout == 'boolean') newOptions.noCursorTimeout = newOptions.timeout;
	
	  // Merge in options to command
	  for(var name in newOptions) {
	    if(newOptions[name] != null) findCommand[name] = newOptions[name];
	  }
	
	  // Format the fields
	  var formatFields = function(fields) {
	    var object = {};
	    if(Array.isArray(fields)) {
	      for(var i = 0; i < fields.length; i++) {
	        if(Array.isArray(fields[i])) {
	          object[fields[i][0]] = fields[i][1];
	        } else {
	          object[fields[i][0]] = 1;
	        }
	      }
	    } else {
	      object = fields;
	    }
	
	    return object;
	  }
	
	  // Special treatment for the fields selector
	  if(fields) findCommand.fields = formatFields(fields);
	
	  // Add db object to the new options
	  newOptions.db = this.s.db;
	
	  // Set raw if available at collection level
	  if(newOptions.raw == null && this.s.raw) newOptions.raw = this.s.raw;
	
	  // Sort options
	  if(findCommand.sort) 
	    findCommand.sort = formattedOrderClause(findCommand.sort);
	
	  // Create the cursor
	  if(typeof callback == 'function') return handleCallback(callback, null, this.s.topology.cursor(this.s.namespace, findCommand, newOptions));
	  return this.s.topology.cursor(this.s.namespace, findCommand, newOptions);
	}
	
	/**
	 * Inserts a single document into MongoDB.
	 * @method
	 * @param {object} doc Document to insert.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
	 * @param {Collection~writeOpCallback} callback The command result callback   
	 * @return {null}
	 */
	Collection.prototype.insertOne = function(doc, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(Array.isArray(doc)) return callback(new MongoError('doc parameter must be an object'));
	  insertDocuments(this, [doc], options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    r.insertedCount = r.result.n;
	    r.insertedId = doc._id;
	    if(callback) callback(null, r);
	  });
	}
	
	/**
	 * Inserts an array of documents into MongoDB.
	 * @method
	 * @param {object[]} docs Documents to insert.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
	 * @param {Collection~writeOpCallback} callback The command result callback   
	 * @return {null}
	 */
	Collection.prototype.insertMany = function(docs, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(!Array.isArray(docs)) return callback(new MongoError('docs parameter must be an array of documents'));    
	  insertDocuments(this, docs, options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    r.insertedCount = r.result.n;
	    var ids = [];
	    for(var i = 0; i < docs.length; i++) {
	      if(docs[i]._id) ids.push(docs[i]._id);
	    }
	    r.insertedIds = ids;
	    if(callback) callback(null, r);
	  });
	}
	
	/**
	 * @typedef {Object} Collection~BulkWriteOpResult
	 * @property {number} insertedCount Number of documents inserted.
	 * @property {number} matchedCount Number of documents matched for update.
	 * @property {number} modifiedCount Number of documents modified.
	 * @property {number} deletedCount Number of documents deleted.
	 * @property {number} upsertedCount Number of documents upserted.
	 * @property {object} insertedIds Inserted document generated Id's, hash key is the index of the originating operation
	 * @property {object} upsertedIds Upserted document generated Id's, hash key is the index of the originating operation
	 * @property {object} result The command result object.
	 */
	
	/**
	 * The callback format for inserts
	 * @callback Collection~bulkWriteOpCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection~BulkWriteOpResult} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Perform a bulkWrite operation without a fluent API
	 *
	 * Legal operation types are
	 *
	 *  { insertOne: { document: { a: 1 } } }
	 *
	 *  { updateOne: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }
	 *
	 *  { updateMany: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }
	 *
	 *  { deleteOne: { filter: {c:1} } }
	 *
	 *  { deleteMany: { filter: {c:1} } }
	 *
	 *  { replaceOne: { filter: {c:3}, replacement: {c:4}, upsert:true}}
	 *
	 * @method
	 * @param {object[]} operations Bulk operations to perform.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {Collection~bulkWriteOpCallback} callback The command result callback   
	 * @return {null}
	 */
	Collection.prototype.bulkWrite = function(operations, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  if(typeof callback != 'function') throw new MongoError("bulkWrite must have a callback function specified");
	  if(!Array.isArray(operations)) throw new MongoError("operations must be an array of documents");
	  var bulk = options.ordered == true || options.ordered == null ? this.initializeOrderedBulkOp() : this.initializeUnorderedBulkOp();
	  
	  // for each op go through and add to the bulk
	  for(var i = 0; i < operations.length; i++) {
	    bulk.raw(operations[i]);
	  }
	
	  // Final options for write concern
	  var finalOptions = writeConcern(shallowClone(options), this.s.db, this, options);
	  var writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};
	
	  // Execute the bulk
	  bulk.execute(writeCon, function(err, r) {
	    r.insertedCount = r.nInserted;
	    r.matchedCount = r.nMatched;
	    r.modifiedCount = r.nModified || 0;
	    r.deletedCount = r.nRemoved;
	    r.upsertedCount = r.getUpsertedIds().length;
	    r.upsertedIds = {};
	    r.insertedIds = {};
	
	    // Inserted documents
	    var inserted = r.getInsertedIds();
	    // Map inserted ids
	    for(var i = 0; i < inserted.length; i++) {
	      r.insertedIds[inserted[i].index] = inserted[i]._id;
	    }
	
	    // Upserted documents
	    var upserted = r.getUpsertedIds();
	    // Map upserted ids
	    for(var i = 0; i < upserted.length; i++) {
	      r.upsertedIds[upserted[i].index] = upserted[i]._id;
	    }    
	
	    // Return the results
	    callback(null, r);
	  });
	}
	
	var insertDocuments = function(self, docs, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	  // Ensure we are operating on an array op docs
	  docs = Array.isArray(docs) ? docs : [docs];
	
	  // Get the write concern options
	  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
	  if(typeof finalOptions.checkKeys != 'boolean') finalOptions.checkKeys = true;
	
	  // If keep going set unordered
	  if(options.keepGoing == true) finalOptions.ordered = false;
	  finalOptions['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;
	
	  // Add _id if not specified
	  for(var i = 0; i < docs.length; i++) {
	    if(docs[i]._id == null) docs[i]._id = self.s.pkFactory.createPk();
	  }
	
	  // File inserts
	  self.s.topology.insert(self.s.namespace, docs, finalOptions, function(err, result) {
	    if(callback == null) return;
	    if(err) return handleCallback(callback, err);
	    if(result == null) return handleCallback(callback, null, null);
	    if(result.result.code) return handleCallback(callback, toError(result.result));
	    if(result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0]));
	    // Add docs to the list
	    result.ops = docs;
	    // Return the results
	    handleCallback(callback, null, result);   
	  });  
	}
	
	/**
	 * @typedef {Object} Collection~WriteOpResult
	 * @property {object[]} ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany
	 * @property {object} connection The connection object used for the operation.
	 * @property {object} result The command result object.
	 */
	
	/**
	 * The callback format for inserts
	 * @callback Collection~writeOpCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection~WriteOpResult} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Inserts a single document or a an array of documents into MongoDB.
	 * @method
	 * @param {(object|object[])} docs Documents to insert.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
	 * @param {Collection~writeOpCallback} callback The command result callback   
	 * @return {null}
	 * @deprecated Use insertOne, insertMany or bulkWrite
	 */
	Collection.prototype.insert = function(docs, options, callback) {
	  return insertDocuments(this, docs, options, callback);
	}
	
	/**
	 * Update a single document on MongoDB
	 * @method
	 * @param {object} filter The Filter used to select the document to update
	 * @param {object} update The update operations to be applied to the document
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.upsert=false] Update operation is an upsert.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~writeOpCallback} callback The command result callback   
	 * @return {null}
	 */
	Collection.prototype.updateOne = function(filter, update, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  options = shallowClone(options)
	  // Set single document update
	  options.multi = false;
	  // Execute update
	  updateDocuments(this, filter, update, options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    r.matchedCount = r.result.n;
	    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
	    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
	    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
	    if(callback) callback(null, r);
	  });
	}
	
	/**
	 * Replace a document on MongoDB
	 * @method
	 * @param {object} filter The Filter used to select the document to update
	 * @param {object} doc The Document that replaces the matching document
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.upsert=false] Update operation is an upsert.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~writeOpCallback} callback The command result callback   
	 * @return {null}
	 */
	Collection.prototype.replaceOne = function(filter, update, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  options = shallowClone(options)
	  // Set single document update
	  options.multi = false;
	  // Execute update
	  updateDocuments(this, filter, update, options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    r.matchedCount = r.result.n;
	    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
	    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
	    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
	    r.ops = [update];
	    if(callback) callback(null, r);
	  });
	}
	
	/**
	 * Update multiple documents on MongoDB
	 * @method
	 * @param {object} filter The Filter used to select the document to update
	 * @param {object} update The update operations to be applied to the document
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.upsert=false] Update operation is an upsert.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~writeOpCallback} callback The command result callback   
	 * @return {null}
	 */
	Collection.prototype.updateMany = function(filter, update, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  options = shallowClone(options)
	  // Set single document update
	  options.multi = true;
	  // Execute update
	  updateDocuments(this, filter, update, options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    r.matchedCount = r.result.n;
	    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
	    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
	    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
	    if(callback) callback(null, r);
	  });
	}
	
	var updateDocuments = function(self, selector, document, options, callback) {
	  if('function' === typeof options) callback = options, options = null;
	  if(options == null) options = {};
	  if(!('function' === typeof callback)) callback = null;
	
	  // If we are not providing a selector or document throw
	  if(selector == null || typeof selector != 'object') return callback(toError("selector must be a valid JavaScript object"));
	  if(document == null || typeof document != 'object') return callback(toError("document must be a valid JavaScript object"));
	
	  // Get the write concern options
	  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
	
	  // Do we return the actual result document
	  // Either use override on the function, or go back to default on either the collection
	  // level or db
	  finalOptions['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;
	
	  // Execute the operation
	  var op = {q: selector, u: document};
	  if(options.upsert) op.upsert = true;
	  if(options.multi) op.multi = true;
	
	  // Update options
	  self.s.topology.update(self.s.namespace, [op], finalOptions, function(err, result) {
	    if(callback == null) return;
	    if(err) return handleCallback(callback, err, null);
	    if(result == null) return handleCallback(callback, null, null);
	    if(result.result.code) return handleCallback(callback, toError(result.result));
	    if(result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0]));
	    // Return the results
	    handleCallback(callback, null, result);   
	  });  
	}
	
	/**
	 * Updates documents.
	 * @method
	 * @param {object} selector The selector for the update operation.
	 * @param {object} document The update document.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.upsert=false] Update operation is an upsert.
	 * @param {boolean} [options.multi=false] Update one/all documents with operation.
	 * @param {Collection~writeOpCallback} callback The command result callback
	 * @throws {MongoError}
	 * @return {null}
	 * @deprecated use updateOne, updateMany or bulkWrite
	 */
	Collection.prototype.update = function(selector, document, options, callback) {
	  return updateDocuments(this, selector, document, options, callback);
	}
	
	/**
	 * Delete a document on MongoDB
	 * @method
	 * @param {object} filter The Filter used to select the document to remove
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~writeOpCallback} callback The command result callback   
	 * @return {null}
	 */
	Collection.prototype.deleteOne = function(filter, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  var options = shallowClone(options);    
	  options.single = true;
	  removeDocuments(this, filter, options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    r.deletedCount = r.result.n;
	    if(callback) callback(null, r);
	  });
	}
	
	Collection.prototype.removeOne = Collection.prototype.deleteOne;
	
	/**
	 * Delete multiple documents on MongoDB
	 * @method
	 * @param {object} filter The Filter used to select the documents to remove
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~writeOpCallback} callback The command result callback   
	 * @return {null}
	 */
	Collection.prototype.deleteMany = function(filter, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  var options = shallowClone(options);    
	  options.single = false;
	  removeDocuments(this, filter, options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    r.deletedCount = r.result.n;
	    if(callback) callback(null, r);
	  });
	}
	
	Collection.prototype.removeMany = Collection.prototype.deleteMany;
	
	var removeDocuments = function(self, selector, options, callback) {
	  if(typeof options == 'function') {
	    callback = options, options = {};
	  } else if (typeof selector === 'function') {
	    callback = selector;
	    options = {};
	    selector = {};
	  }
	
	  // Create an empty options object if the provided one is null
	  options = options || {};
	
	  // Get the write concern options
	  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
	
	  // If selector is null set empty
	  if(selector == null) selector = {};
	
	  // Build the op
	  var op = {q: selector, limit: 0};
	  if(options.single) op.limit = 1;
	
	  // Execute the remove
	  self.s.topology.remove(self.s.namespace, [op], finalOptions, function(err, result) {
	    if(callback == null) return;
	    if(err) return handleCallback(callback, err, null);
	    if(result == null) return handleCallback(callback, null, null);
	    if(result.result.code) return handleCallback(callback, toError(result.result));
	    if(result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0]));
	    // Return the results
	    handleCallback(callback, null, result);   
	  });  
	}
	
	/**
	 * Remove documents.
	 * @method
	 * @param {object} selector The selector for the update operation.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.single=false] Removes the first document found.
	 * @param {Collection~writeOpCallback} callback The command result callback
	 * @return {null}
	 * @deprecated use deleteOne, deleteMany or bulkWrite
	 */
	Collection.prototype.remove = function(selector, options, callback) {
	  return removeDocuments(this, selector, options, callback);
	}
	
	/**
	 * Save a document. Simple full document replacement function. Not recommended for efficiency, use atomic
	 * operators and update instead for more efficient operations.
	 * @method
	 * @param {object} doc Document to save
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~writeOpCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.save = function(doc, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Get the write concern options
	  var finalOptions = writeConcern(shallowClone(options), this.s.db, this, options);
	  // Establish if we need to perform an insert or update
	  if(doc._id != null) {
	    finalOptions.upsert = true;
	    return updateDocuments(this, {_id: doc._id}, doc, finalOptions, callback);
	  }
	
	  // Insert the document
	  insertDocuments(this, [doc], options, function(err, r) {
	    if(callback == null) return;
	    if(doc == null) return handleCallback(callback, null, null);
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, null, r);
	  });
	}
	
	/**
	 * The callback format for results
	 * @callback Collection~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Fetches the first document that matches the query
	 * @method
	 * @param {object} query Query for find Operation
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.limit=0] Sets the limit of documents returned in the query.
	 * @param {(array|object)} [options.sort=null] Set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.
	 * @param {object} [options.fields=null] The fields to return in the query. Object of fields to include or exclude (not both), {'a':1} 
	 * @param {number} [options.skip=0] Set to skip N documents ahead in your query (useful for pagination).
	 * @param {Object} [options.hint=null] Tell the query to use specific indexes in the query. Object of indexes to use, {'_id':1}
	 * @param {boolean} [options.explain=false] Explain the query instead of returning the data.
	 * @param {boolean} [options.snapshot=false] Snapshot query.
	 * @param {boolean} [options.timeout=false] Specify if the cursor can timeout.
	 * @param {boolean} [options.tailable=false] Specify if the cursor is tailable.
	 * @param {number} [options.batchSize=0] Set the batchSize for the getMoreCommand when iterating over the query results.
	 * @param {boolean} [options.returnKey=false] Only return the index key.
	 * @param {number} [options.maxScan=null] Limit the number of items to scan. 
	 * @param {number} [options.min=null] Set index bounds.
	 * @param {number} [options.max=null] Set index bounds.
	 * @param {boolean} [options.showDiskLoc=false] Show disk location of results.
	 * @param {string} [options.comment=null] You can put a $comment field on a query to make looking in the profiler logs simpler.
	 * @param {boolean} [options.raw=false] Return all BSON documents as Raw Buffer documents.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {boolean} [options.partial=false] Specify if the cursor should return partial results when querying against a sharded system
	 * @param {number} [options.maxTimeMS=null] Number of miliseconds to wait before aborting the query.
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.findOne = function() {    
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  var callback = args.pop();
	  var cursor = this.find.apply(this, args).limit(-1).batchSize(1);
	
	  // Return the item
	  cursor.next(function(err, item) {
	    if(err != null) return handleCallback(callback, toError(err), null);
	    handleCallback(callback, null, item);
	  });
	}
	
	/**
	 * The callback format for the collection method, must be used if strict is specified
	 * @callback Collection~collectionResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection} collection The collection instance.
	 */
	
	/**
	 * Rename the collection.
	 *
	 * @method
	 * @param {string} newName New name of of the collection.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.dropTarget=false] Drop the target name collection if it previously exists.
	 * @param {Collection~collectionResultCallback} callback The results callback
	 * @return {null}
	 */
	Collection.prototype.rename = function(newName, opt, callback) {
	  var self = this;
	  if(typeof opt == 'function') callback = opt, opt = {};
	  // Check the collection name
	  checkCollectionName(newName);
	  // Build the command
	  var renameCollection = f("%s.%s", this.s.dbName, this.s.name);
	  var toCollection =  f("%s.%s", this.s.dbName, newName);
	  var dropTarget = typeof opt.dropTarget == 'boolean' ? opt.dropTarget : false;
	  var cmd = {'renameCollection':renameCollection, 'to':toCollection, 'dropTarget':dropTarget};
	
	  // Execute against admin
	  self.s.db.admin().command(cmd, opt, function(err, doc) {
	    if(err) return handleCallback(callback, err, null);
	    // We have an error
	    if(doc.errmsg) return handleCallback(callback, toError(doc), null);
	    try {
	      return handleCallback(callback, null, new Collection(self.s.db, self.s.topology, self.s.dbName, newName, self.s.pkFactory, self.s.options));
	    } catch(err) {
	      return handleCallback(callback, toError(err), null);
	    }
	  });
	}
	
	/**
	 * Drop the collection from the database, removing it permanently. New accesses will create a new collection.
	 *
	 * @method
	 * @param {Collection~resultCallback} callback The results callback
	 * @return {null}
	 */
	Collection.prototype.drop = function(callback) {
	  this.s.db.dropCollection(this.s.name, callback);
	}
	
	/**
	 * Returns the options of the collection.
	 *
	 * @method
	 * @param {Collection~resultCallback} callback The results callback
	 * @return {null}
	 */
	Collection.prototype.options = function(callback) {
	  var self = this;
	  this.s.db.listCollections({name: this.s.name}).toArray(function(err, collections) {
	    if(err) return handleCallback(callback, err);
	    if(collections.length == 0) return handleCallback(callback, new MongoError(f("collection %s not found", self.s.namespace)));
	    handleCallback(callback, err, collections[0].options || null);      
	  });
	}  
	
	/**
	 * Returns if the collection is a capped collection
	 *
	 * @method
	 * @param {Collection~resultCallback} callback The results callback
	 * @return {null}
	 */
	Collection.prototype.isCapped = function(callback) {
	  this.options(function(err, document) {
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, null, document && document.capped);
	  });    
	}
	
	/**
	 * Creates an index on the db and collection collection.
	 * @method
	 * @param {(string|object)} fieldOrSpec Defines the index.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.unique=false] Creates an unique index.
	 * @param {boolean} [options.sparse=false] Creates a sparse index.
	 * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.
	 * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
	 * @param {number} [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
	 * @param {number} [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
	 * @param {number} [options.v=null] Specify the format version of the indexes.
	 * @param {number} [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
	 * @param {number} [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.createIndex = function(fieldOrSpec, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  options = args.length ? args.shift() || {} : {};
	  options = typeof callback === 'function' ? options : callback;
	  options = options == null ? {} : options;
	  // Execute create index
	  this.s.db.createIndex(this.s.name, fieldOrSpec, options, callback);
	}
	
	/**
	 * Creates multiple indexes in the collection, this method is only supported for
	 * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported
	 * error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
	 * @method
	 * @param {array} indexSpecs An array of index specifications to be created 
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.createIndexes = function(indexSpecs, callback) {
	  // Ensure we generate the correct name if the parameter is not set
	  for(var i = 0; i < indexSpecs.length; i++) {
	    if(indexSpecs[i].name == null) {
	      var keys = [];
	
	      for(var name in indexSpecs[i].key) {
	        keys.push(f('%s_%s', name, indexSpecs[i].key[name]));
	      }
	
	      // Set the name
	      indexSpecs[i].name = keys.join('_');
	    }
	  }
	
	  // Execute the index
	  this.s.db.command({ 
	    createIndexes: this.s.name, indexes: indexSpecs
	  }, callback);
	}
	
	/**
	 * Drops an index from this collection.
	 * @method
	 * @param {string} indexName Name of the index to drop.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.dropIndex = function(indexName, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  options = args.length ? args.shift() || {} : {};
	
	  // Delete index command
	  var cmd = {'deleteIndexes':this.s.name, 'index':indexName};  
	
	  // Execute command
	  this.s.db.command(cmd, options, function(err, result) {
	    if(typeof callback != 'function') return;
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, null, result);
	  });
	}
	
	/**
	 * Drops all indexes from this collection.
	 * @method
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.dropIndexes = function(callback) {
	  this.dropIndex('*', function (err, result) {
	    if(err) return handleCallback(callback, err, false);
	    handleCallback(callback, null, true);
	  });  
	}
	
	/**
	 * Drops all indexes from this collection.
	 * @method
	 * @deprecated use dropIndexes
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.dropAllIndexes = Collection.prototype.dropIndexes;
	
	/**
	 * Reindex all indexes on the collection
	 * Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
	 * @method
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.reIndex = function(options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	  
	  // Reindex
	  var cmd = {'reIndex':this.s.name};
	
	  // Execute the command
	  this.s.db.command(cmd, options, function(err, result) {
	    if(callback == null) return;
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, null, result.ok ? true : false);
	  });
	}
	
	/**
	 * Get the list of all indexes information for the collection.
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.batchSize=null] The batchSize for the returned command cursor or if pre 2.8 the systems batch collection
	 * @return {CommandCursor}
	 */
	Collection.prototype.listIndexes = function(options) {
	  options = options || {};
	  // Clone the options
	  options = shallowClone(options);
	  // Set the CommandCursor constructor
	  options.cursorFactory = CommandCursor;
	
	  // We have a list collections command
	  if(this.s.db.serverConfig.capabilities().hasListIndexesCommand) {
	    // Cursor options
	    var cursor = options.batchSize ? {batchSize: options.batchSize} : {}
	    // Build the command
	    var command = { listIndexes: this.s.name, cursor: cursor };
	    // Execute the cursor
	    return this.s.topology.cursor(f('%s.$cmd', this.s.dbName), command, options);
	  }
	
	  // Get the namespace
	  var ns = f('%s.system.indexes', this.s.dbName);
	  // Get the query
	  return this.s.topology.cursor(ns, {find: ns, query: {ns: this.s.namespace}}, options);
	};
	
	/**
	 * Ensures that an index exists, if it does not it creates it
	 * @method
	 * @deprecated use createIndexes instead
	 * @param {(string|object)} fieldOrSpec Defines the index.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.unique=false] Creates an unique index.
	 * @param {boolean} [options.sparse=false] Creates a sparse index.
	 * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.
	 * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
	 * @param {number} [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
	 * @param {number} [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
	 * @param {number} [options.v=null] Specify the format version of the indexes.
	 * @param {number} [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
	 * @param {number} [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.ensureIndex = function(fieldOrSpec, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	  this.s.db.ensureIndex(this.s.name, fieldOrSpec, options, callback);
	}
	
	/**
	 * Checks if one or more indexes exist on the collection, fails on first non-existing index
	 * @method
	 * @param {(string|array)} indexes One or more index names to check.
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.indexExists = function(indexes, callback) {
	  this.indexInformation(function(err, indexInformation) {
	    // If we have an error return
	    if(err != null) return handleCallback(callback, err, null);
	    // Let's check for the index names
	    if(!Array.isArray(indexes)) return handleCallback(callback, null, indexInformation[indexes] != null);
	    // Check in list of indexes
	    for(var i = 0; i < indexes.length; i++) {
	      if(indexInformation[indexes[i]] == null) {
	        return handleCallback(callback, null, false);
	      }
	    }
	
	    // All keys found return true
	    return handleCallback(callback, null, true);
	  });    
	}
	
	/**
	 * Retrieves this collections index info.
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.full=false] Returns the full raw index information.
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.indexInformation = function(options, callback) {
	  // Unpack calls
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  options = args.length ? args.shift() || {} : {};
	  // Call the index information
	  this.s.db.indexInformation(this.s.name, options, callback);    
	}
	
	/**
	 * The callback format for results
	 * @callback Collection~countCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {number} result The count of documents that matched the query.
	 */
	
	/**
	 * Count number of matching documents in the db to a query.
	 * @method
	 * @param {object} query The query for the count.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.limit=null] The limit of documents to count.
	 * @param {boolean} [options.skip=null] The number of documents to skip for the count.
	 * @param {string} [options.hint=null] An index name hint for the query.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {Collection~countCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.count = function(query, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  query = args.length ? args.shift() || {} : {};
	  options = args.length ? args.shift() || {} : {};
	  var skip = options.skip;
	  var limit = options.limit;
	  var hint = options.hint;
	  var maxTimeMS = options.maxTimeMS;
	
	  // Final query
	  var cmd = {
	      'count': this.s.name, 'query': query
	    , 'fields': null
	  };
	
	  // Add limit and skip if defined
	  if(typeof skip == 'number') cmd.skip = skip;
	  if(typeof limit == 'number') cmd.limit = limit;
	  if(hint) options.hint = hint;
	
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(this, options, this.s.db, this);
	
	  // Execute command
	  this.s.db.command(cmd, options, function(err, result) {
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, null, result.n);
	  });
	};
	
	/**
	 * The distinct command returns returns a list of distinct values for the given key across a collection.
	 * @method
	 * @param {string} key Field of the document to find distinct values for.
	 * @param {object} query The query for filtering the set of documents to which we apply the distinct filter.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.distinct = function(key, query, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  query = args.length ? args.shift() || {} : {};
	  options = args.length ? args.shift() || {} : {};
	
	  // maxTimeMS option
	  var maxTimeMS = options.maxTimeMS;
	
	  // Distinct command
	  var cmd = {
	    'distinct': this.s.name, 'key': key, 'query': query
	  };
	
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(this, options, this.s.db, this);
	
	  // Execute the command
	  this.s.db.command(cmd, options, function(err, result) {
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, null, result.values);
	  });
	};
	
	/**
	 * Retrieve all the indexes on the collection.
	 * @method
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.indexes = function(callback) {
	  this.s.db.indexInformation(this.s.name, {full:true}, callback);    
	}
	
	/**
	 * Get all the collection statistics.
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.scale=null] Divide the returned sizes by scale value.
	 * @param {Collection~resultCallback} callback The collection result callback
	 * @return {null}
	 */
	Collection.prototype.stats = function(options, callback) {
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  // Fetch all commands
	  options = args.length ? args.shift() || {} : {};
	
	  // Build command object
	  var commandObject = {
	    collStats:this.s.name
	  }
	
	  // Check if we have the scale value
	  if(options['scale'] != null) commandObject['scale'] = options['scale'];
	
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(this, options, this.s.db, this);
	
	  // Execute the command
	  this.s.db.command(commandObject, options, callback);
	}
	
	/**
	 * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
	 *
	 * @method
	 * @param {object} filter Document selection filter.
	 * @param {object} [options=null] Optional settings.
	 * @param {object} [options.projection=null] Limits the fields to return for all matching documents.
	 * @param {object} [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
	 * @param {number} [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
	 * @param {Collection~resultCallback} callback The collection result callback
	 * @return {null}
	 */
	Collection.prototype.findOneAndDelete = function(filter, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  this.findAndModify(
	      filter
	    , options.sort
	    , null
	    , {
	        fields: options.projection
	      , remove:true
	    }
	    , callback
	  );
	}
	
	/**
	 * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
	 *
	 * @method
	 * @param {object} filter Document selection filter.
	 * @param {object} replacement Document replacing the matching document.
	 * @param {object} [options=null] Optional settings.
	 * @param {object} [options.projection=null] Limits the fields to return for all matching documents.
	 * @param {object} [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
	 * @param {number} [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
	 * @param {boolean} [options.upsert=false] Upsert the document if it does not exist.
	 * @param {boolean} [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.
	 * @param {Collection~resultCallback} callback The collection result callback
	 * @return {null}
	 */
	Collection.prototype.findOneAndReplace = function(filter, replacement, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  this.findAndModify(
	      filter
	    , options.sort
	    , replacement
	    , {
	        fields: options.projection
	      , update: true
	      , new: typeof options.returnOriginal == 'boolean' ? !options.returnOriginal : false
	      , upsert: typeof options.upsert == 'boolean' ? options.upsert : false
	    }
	    , callback
	  );
	}
	
	/**
	 * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
	 *
	 * @method
	 * @param {object} filter Document selection filter.
	 * @param {object} update Update operations to be performed on the document
	 * @param {object} [options=null] Optional settings.
	 * @param {object} [options.projection=null] Limits the fields to return for all matching documents.
	 * @param {object} [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
	 * @param {number} [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
	 * @param {boolean} [options.upsert=false] Upsert the document if it does not exist.
	 * @param {boolean} [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.
	 * @param {Collection~resultCallback} callback The collection result callback
	 * @return {null}
	 */
	Collection.prototype.findOneAndUpdate = function(filter, update, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  this.findAndModify(
	      filter
	    , options.sort
	    , update
	    , {
	        fields: options.projection
	      , update: true
	      , new: typeof options.returnOriginal == 'boolean' ? !options.returnOriginal : false
	      , upsert: typeof options.upsert == 'boolean' ? options.upsert : false
	    }
	    , callback
	  );
	}
	
	/**
	 * Find and update a document.
	 * @method
	 * @param {object} query Query object to locate the object to modify.
	 * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
	 * @param {object} doc The fields/vals to be updated.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.remove=false] Set to true to remove the object before returning.
	 * @param {boolean} [options.upsert=false] Perform an upsert operation.
	 * @param {boolean} [options.new=false] Set to true if you want to return the modified object rather than the original. Ignored for remove.
	 * @param {object} [options.fields=null] Object containing the field projection for the result returned from the operation.
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {null}
	 * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead 
	 */
	Collection.prototype.findAndModify = function(query, sort, doc, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  sort = args.length ? args.shift() || [] : [];
	  doc = args.length ? args.shift() : null;
	  options = args.length ? args.shift() || {} : {};
	
	  // Clone options
	  var options = shallowClone(options);
	  // Force read preference primary
	  options.readPreference = ReadPreference.PRIMARY;
	
	  // Create findAndModify command object
	  var queryObject = {
	     'findandmodify': this.s.name
	   , 'query': query
	  };
	
	  sort = formattedOrderClause(sort);
	  if(sort) {
	    queryObject.sort = sort;
	  }
	
	  queryObject.new = options.new ? true : false;
	  queryObject.remove = options.remove ? true : false;
	  queryObject.upsert = options.upsert ? true : false;
	
	  if(options.fields) {
	    queryObject.fields = options.fields;
	  }
	
	  if(doc && !options.remove) {
	    queryObject.update = doc;
	  }
	
	  // Either use override on the function, or go back to default on either the collection
	  // level or db
	  if(options['serializeFunctions'] != null) {
	    options['serializeFunctions'] = options['serializeFunctions'];
	  } else {
	    options['serializeFunctions'] = this.s.serializeFunctions;
	  }
	
	  // No check on the documents
	  options.checkKeys = false;
	
	  // Execute the command
	  this.s.db.command(queryObject
	    , options, function(err, result) {
	      if(err) return handleCallback(callback, err, null);
	      return handleCallback(callback, null, result);
	  });
	}
	
	/**
	 * Find and remove a document.
	 * @method
	 * @param {object} query Query object to locate the object to modify.
	 * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {null}
	 * @deprecated use findOneAndDelete instead
	 */
	Collection.prototype.findAndRemove = function(query, sort, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  sort = args.length ? args.shift() || [] : [];
	  options = args.length ? args.shift() || {} : {};
	  // Add the remove option
	  options['remove'] = true;
	  // Execute the callback
	  this.findAndModify(query, sort, null, options, callback);
	}
	
	/**
	 * Execute an aggregation framework pipeline against the collection, needs MongoDB >= 2.2
	 * @method
	 * @param {object} pipeline Array containing all the aggregation framework commands for the execution.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {object} [options.cursor=null] Return the query as cursor, on 2.6 > it returns as a real cursor on pre 2.6 it returns as an emulated cursor.
	 * @param {number} [options.cursor.batchSize=null] The batchSize for the cursor
	 * @param {boolean} [options.explain=false] Explain returns the aggregation execution plan (requires mongodb 2.6 >).
	 * @param {boolean} [options.allowDiskUse=false] allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 >).
	 * @param {number} [options.maxTimeMS=null] maxTimeMS specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {(null|AggregationCursor)}
	 */
	Collection.prototype.aggregate = function(pipeline, options, callback) {
	  if(Array.isArray(pipeline)) {
	    // Set up callback if one is provided
	    if(typeof options == 'function') {
	      callback = options;
	      options = {};
	    }
	
	    // If we have no options or callback we are doing
	    // a cursor based aggregation
	    if(options == null && callback == null) {
	      options = {};
	    }      
	  } else {
	    // Aggregation pipeline passed as arguments on the method
	    var args = Array.prototype.slice.call(arguments, 0);
	    // Get the callback
	    callback = args.pop();
	    // Get the possible options object
	    var opts = args[args.length - 1];
	    // If it contains any of the admissible options pop it of the args
	    options = opts && (opts.readPreference 
	      || opts.explain || opts.cursor || opts.out
	      || opts.maxTimeMS || opts.allowDiskUse) ? args.pop() : {};
	      // Left over arguments is the pipeline
	    pipeline = args;
	  }
	
	  // If out was specified
	  if(typeof options.out == 'string') {
	    pipeline.push({$out: options.out});
	  }
	
	  // Build the command
	  var command = { aggregate : this.s.name, pipeline : pipeline};
	  // If we have allowDiskUse defined
	  if(options.allowDiskUse) command.allowDiskUse = options.allowDiskUse;
	  if(typeof options.maxTimeMS == 'number') command.maxTimeMS = options.maxTimeMS;
	
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(this, options, this.s.db, this);
	
	  // If explain has been specified add it
	  if(options.explain) command.explain = options.explain;
	
	  // Validate that cursor options is valid
	  if(options.cursor != null && typeof options.cursor != 'object') {
	    throw toError('cursor options must be an object');
	  }
	
	  // Set the AggregationCursor constructor
	  options.cursorFactory = AggregationCursor;
	  if(typeof callback != 'function') {
	    if(this.s.topology.capabilities().hasAggregationCursor) {
	      options.cursor = options.cursor || { batchSize : 1000 };
	      command.cursor = options.cursor;        
	    }
	
	    // Allow disk usage command
	    if(typeof options.allowDiskUse == 'boolean') command.allowDiskUse = options.allowDiskUse;
	    if(typeof options.maxTimeMS == 'number') command.maxTimeMS = options.maxTimeMS;
	
	    // Execute the cursor
	    return this.s.topology.cursor(this.s.namespace, command, options);
	  }
	
	  var cursor = null;
	  // We do not allow cursor
	  if(options.cursor) {
	    return this.s.topology.cursor(this.s.namespace, command, options);
	  }
	
	  // Execute the command
	  this.s.db.command(command, options, function(err, result) {
	    if(err) {
	      handleCallback(callback, err);
	    } else if(result['err'] || result['errmsg']) {
	      handleCallback(callback, toError(result));
	    } else if(typeof result == 'object' && result['serverPipeline']) {
	      handleCallback(callback, null, result['serverPipeline']);
	    } else if(typeof result == 'object' && result['stages']) {
	      handleCallback(callback, null, result['stages']);
	    } else {
	      handleCallback(callback, null, result.result);
	    }
	  });
	}
	
	/**
	 * The callback format for results
	 * @callback Collection~parallelCollectionScanCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Cursor[]} cursors A list of cursors returned allowing for parallel reading of collection.
	 */
	
	/**
	 * Return N number of parallel cursors for a collection allowing parallel reading of entire collection. There are
	 * no ordering guarantees for returned results.
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {number} [options.batchSize=null] Set the batchSize for the getMoreCommand when iterating over the query results.
	 * @param {number} [options.numCursors=1] The maximum number of parallel command cursors to return (the number of returned cursors will be in the range 1:numCursors)
	 * @param {boolean} [options.raw=false] Return all BSON documents as Raw Buffer documents.
	 * @param {Collection~parallelCollectionScanCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.parallelCollectionScan = function(options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {numCursors: 1};
	  // Set number of cursors to 1
	  options.numCursors = options.numCursors || 1;
	  options.batchSize = options.batchSize || 1000;
	
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(this, options, this.s.db, this);
	  
	  // Create command object
	  var commandObject = {
	      parallelCollectionScan: this.s.name
	    , numCursors: options.numCursors
	  }
	
	  // Execute the command
	  this.s.db.command(commandObject, options, function(err, result) {
	    if(err) return handleCallback(callback, err, null);
	    if(result == null) return handleCallback(callback, new Error("no result returned for parallelCollectionScan"), null);
	
	    var cursors = [];
	    // Create command cursors for each item
	    for(var i = 0; i < result.cursors.length; i++) {
	      var rawId = result.cursors[i].cursor.id
	      // Convert cursorId to Long if needed
	      var cursorId = typeof rawId == 'number' ? Long.fromNumber(rawId) : rawId;
	
	      // Command cursor options
	      var cmd = {
	          batchSize: options.batchSize
	        , cursorId: cursorId
	        , items: result.cursors[i].cursor.firstBatch
	      }
	
	      // Add a command cursor
	      cursors.push(self.s.topology.cursor(self.s.namespace, cursorId, options));
	    }
	
	    handleCallback(callback, null, cursors);
	  });
	}
	
	/**
	 * Execute the geoNear command to search for items in the collection
	 *
	 * @method   
	 * @param {number} x Point to search on the x axis, ensure the indexes are ordered in the same order.
	 * @param {number} y Point to search on the y axis, ensure the indexes are ordered in the same order.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {number} [options.num=null] Max number of results to return.
	 * @param {number} [options.minDistance=null] Include results starting at minDistance from a point (2.6 or higher)
	 * @param {number} [options.maxDistance=null] Include results up to maxDistance from the point.
	 * @param {number} [options.distanceMultiplier=null] Include a value to multiply the distances with allowing for range conversions.
	 * @param {object} [options.query=null] Filter the results by a query.
	 * @param {boolean} [options.spherical=false] Perform query using a spherical model.
	 * @param {boolean} [options.uniqueDocs=false] The closest location in a document to the center of the search region will always be returned MongoDB > 2.X.
	 * @param {boolean} [options.includeLocs=false] Include the location data fields in the top level of the results MongoDB > 2.X. 
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.geoNear = function(x, y, options, callback) {
	  var point = typeof(x) == 'object' && x
	    , args = Array.prototype.slice.call(arguments, point?1:2);
	
	  callback = args.pop();
	  // Fetch all commands
	  options = args.length ? args.shift() || {} : {};
	
	  // Build command object
	  var commandObject = {
	    geoNear:this.s.name,
	    near: point || [x, y]
	  }
	
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(this, options, this.s.db, this);
	
	  // Exclude readPreference and existing options to prevent user from
	  // shooting themselves in the foot
	  var exclude = {
	    readPreference: true, 
	    geoNear: true,
	    near: true  
	  };
	
	  // Filter out any excluded objects
	  commandObject = decorateCommand(commandObject, options, exclude);
	
	  // Execute the command
	  this.s.db.command(commandObject, options, function (err, res) {
	    if(err) return handleCallback(callback, err);
	    if(res.err || res.errmsg) return handleCallback(callback, toError(res));
	    // should we only be returning res.results here? Not sure if the user
	    // should see the other return information
	    handleCallback(callback, null, res);
	  });
	}
	
	/**
	 * Execute a geo search using a geo haystack index on a collection.
	 *
	 * @method   
	 * @param {number} x Point to search on the x axis, ensure the indexes are ordered in the same order.
	 * @param {number} y Point to search on the y axis, ensure the indexes are ordered in the same order.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {number} [options.maxDistance=null] Include results up to maxDistance from the point.
	 * @param {object} [options.search=null] Filter the results by a query.
	 * @param {number} [options.limit=false] Max number of results to return.
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.geoHaystackSearch = function(x, y, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  // Fetch all commands
	  options = args.length ? args.shift() || {} : {};
	
	  // Build command object
	  var commandObject = {
	    geoSearch: this.s.name,
	    near: [x, y]
	  }
	
	  // Remove read preference from hash if it exists
	  commandObject = decorateCommand(commandObject, options, {readPreference: true});
	
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(this, options, this.s.db, this);
	
	  // Execute the command
	  this.s.db.command(commandObject, options, function (err, res) {
	    if(err) return handleCallback(callback, err);
	    if(res.err || res.errmsg) handleCallback(callback, utils.toError(res));
	    // should we only be returning res.results here? Not sure if the user
	    // should see the other return information
	    handleCallback(callback, null, res);
	  });
	}
	
	/**
	 * Group function helper
	 * @ignore
	 */
	var groupFunction = function () {
	  var c = db[ns].find(condition);
	  var map = new Map();
	  var reduce_function = reduce;
	
	  while (c.hasNext()) {
	    var obj = c.next();
	    var key = {};
	
	    for (var i = 0, len = keys.length; i < len; ++i) {
	      var k = keys[i];
	      key[k] = obj[k];
	    }
	
	    var aggObj = map.get(key);
	
	    if (aggObj == null) {
	      var newObj = Object.extend({}, key);
	      aggObj = Object.extend(newObj, initial);
	      map.put(key, aggObj);
	    }
	
	    reduce_function(obj, aggObj);
	  }
	
	  return { "result": map.values() };
	}.toString();
	
	/**
	 * Run a group command across a collection
	 *
	 * @method   
	 * @param {(object|array|function|code)} keys An object, array or function expressing the keys to group by.
	 * @param {object} condition An optional condition that must be true for a row to be considered.
	 * @param {object} initial Initial value of the aggregation counter object.
	 * @param {(function|Code)} reduce The reduce function aggregates (reduces) the objects iterated
	 * @param {(function|Code)} finalize An optional function to be run on each item in the result set just before the item is returned.
	 * @param {boolean} command Specify if you wish to run using the internal group command or using eval, default is true.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.group = function(keys, condition, initial, reduce, finalize, command, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 3);
	  callback = args.pop();
	  // Fetch all commands
	  reduce = args.length ? args.shift() : null;
	  finalize = args.length ? args.shift() : null;
	  command = args.length ? args.shift() : null;
	  options = args.length ? args.shift() || {} : {};
	
	  // Make sure we are backward compatible
	  if(!(typeof finalize == 'function')) {
	    command = finalize;
	    finalize = null;
	  }
	
	  if (!Array.isArray(keys) && keys instanceof Object && typeof(keys) !== 'function' && !(keys instanceof Code)) {
	    keys = Object.keys(keys);
	  }
	
	  if(typeof reduce === 'function') {
	    reduce = reduce.toString();
	  }
	
	  if(typeof finalize === 'function') {
	    finalize = finalize.toString();
	  }
	
	  // Set up the command as default
	  command = command == null ? true : command;
	
	  // Execute using the command
	  if(command) {
	    var reduceFunction = reduce instanceof Code
	        ? reduce
	        : new Code(reduce);
	
	    var selector = {
	      group: {
	          'ns': this.s.name
	        , '$reduce': reduceFunction
	        , 'cond': condition
	        , 'initial': initial
	        , 'out': "inline"
	      }
	    };
	
	    // if finalize is defined
	    if(finalize != null) selector.group['finalize'] = finalize;
	    // Set up group selector
	    if ('function' === typeof keys || keys instanceof Code) {
	      selector.group.$keyf = keys instanceof Code
	        ? keys
	        : new Code(keys);
	    } else {
	      var hash = {};
	      keys.forEach(function (key) {
	        hash[key] = 1;
	      });
	      selector.group.key = hash;
	    }
	
	    // Ensure we have the right read preference inheritance
	    options = getReadPreference(this, options, this.s.db, this);
	    // Execute command
	    this.s.db.command(selector, options, function(err, result) {
	      if(err) return handleCallback(callback, err, null);
	      handleCallback(callback, null, result.retval);
	    });
	  } else {
	    // Create execution scope
	    var scope = reduce != null && reduce instanceof Code
	      ? reduce.scope
	      : {};
	
	    scope.ns = this.s.name;
	    scope.keys = keys;
	    scope.condition = condition;
	    scope.initial = initial;
	
	    // Pass in the function text to execute within mongodb.
	    var groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ';');
	
	    this.s.db.eval(new Code(groupfn, scope), function (err, results) {
	      if (err) return handleCallback(callback, err, null);
	      handleCallback(callback, null, results.result || results);
	    });
	  }
	}
	
	/**
	 * Functions that are passed as scope args must
	 * be converted to Code instances.
	 * @ignore
	 */
	function processScope (scope) {
	  if(!isObject(scope)) {
	    return scope;
	  }
	
	  var keys = Object.keys(scope);
	  var i = keys.length;
	  var key;
	  var new_scope = {};
	
	  while (i--) {
	    key = keys[i];
	    if ('function' == typeof scope[key]) {
	      new_scope[key] = new Code(String(scope[key]));
	    } else {
	      new_scope[key] = processScope(scope[key]);
	    }
	  }
	
	  return new_scope;
	}
	
	/**
	 * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.
	 *
	 * @method   
	 * @param {(function|string)} map The mapping function.
	 * @param {(function|string)} reduce The reduce function.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {object} [options.out=null] Sets the output target for the map reduce job. *{inline:1} | {replace:'collectionName'} | {merge:'collectionName'} | {reduce:'collectionName'}*
	 * @param {object} [options.query=null] Query filter object.
	 * @param {object} [options.sort=null] Sorts the input objects using this key. Useful for optimization, like sorting by the emit key for fewer reduces.
	 * @param {number} [options.limit=null] Number of objects to return from collection.
	 * @param {boolean} [options.keeptemp=false] Keep temporary data.
	 * @param {(function|string)} [options.finalize=null] Finalize function.
	 * @param {object} [options.scope=null] Can pass in variables that can be access from map/reduce/finalize.
	 * @param {boolean} [options.jsMode=false] It is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X.
	 * @param {boolean} [options.verbose=false] Provide statistics on job execution time.
	 * @param {Collection~resultCallback} callback The command result callback
	 * @throws {MongoError}
	 * @return {null}
	 */
	Collection.prototype.mapReduce = function(map, reduce, options, callback) {
	  var self = this;
	  if('function' === typeof options) callback = options, options = {};
	  // Out must allways be defined (make sure we don't break weirdly on pre 1.8+ servers)
	  if(null == options.out) {
	    throw new Error("the out option parameter must be defined, see mongodb docs for possible values");
	  }
	
	  if('function' === typeof map) {
	    map = map.toString();
	  }
	
	  if('function' === typeof reduce) {
	    reduce = reduce.toString();
	  }
	
	  if('function' === typeof options.finalize) {
	    options.finalize = options.finalize.toString();
	  }
	
	  var mapCommandHash = {
	      mapreduce: this.s.name
	    , map: map
	    , reduce: reduce
	  };
	
	  // Add any other options passed in
	  for(var n in options) {
	    if('scope' == n) {
	      mapCommandHash[n] = processScope(options[n]);
	    } else {
	      mapCommandHash[n] = options[n];
	    }
	  }
	
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(this, options, this.s.db, this);
	
	  // If we have a read preference and inline is not set as output fail hard
	  if((options.readPreference != false && options.readPreference != 'primary') 
	    && options['out'] && (options['out'].inline != 1 && options['out'] != 'inline')) {
	      options.readPreference = 'primary';    
	  }
	
	  // Execute command
	  this.s.db.command(mapCommandHash, {readPreference:options.readPreference}, function (err, result) {
	    if(err) return handleCallback(callback, err);
	    // Check if we have an error
	    if(1 != result.ok || result.err || result.errmsg) {
	      return handleCallback(callback, toError(result));
	    }
	
	    // Create statistics value
	    var stats = {};
	    if(result.timeMillis) stats['processtime'] = result.timeMillis;
	    if(result.counts) stats['counts'] = result.counts;
	    if(result.timing) stats['timing'] = result.timing;
	
	    // invoked with inline?
	    if(result.results) {
	      // If we wish for no verbosity
	      if(options['verbose'] == null || !options['verbose']) {
	        return handleCallback(callback, null, result.results);
	      }
	      
	      return handleCallback(callback, null, result.results, stats);
	    }
	
	    // The returned collection
	    var collection = null;
	
	    // If we have an object it's a different db
	    if(result.result != null && typeof result.result == 'object') {
	      var doc = result.result;
	      collection = self.s.db.db(doc.db).collection(doc.collection);
	    } else {
	      // Create a collection object that wraps the result collection
	      collection = self.s.db.collection(result.result)
	    }
	
	    // If we wish for no verbosity
	    if(options['verbose'] == null || !options['verbose']) {
	      return handleCallback(callback, err, collection);
	    }
	
	    // Return stats as third set of values
	    handleCallback(callback, err, collection, stats);
	  });
	}
	
	/**
	 * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
	 *
	 * @method   
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {UnorderedBulkOperation} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.initializeUnorderedBulkOp = function(options) {
	  return unordered(this.s.topology, this, options);
	}
	
	/**
	 * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.
	 *
	 * @method   
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {OrderedBulkOperation} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.initializeOrderedBulkOp = function(options) {
	  return ordered(this.s.topology, this, options);
	}
	
	// Get write concern
	var writeConcern = function(target, db, col, options) {
	  if(options.w != null || options.j != null || options.fsync != null) {
	    var opts = {};
	    if(options.w != null) opts.w = options.w;
	    if(options.wtimeout != null) opts.wtimeout = options.wtimeout;
	    if(options.j != null) opts.j = options.j;
	    if(options.fsync != null) opts.fsync = options.fsync;
	    target.writeConcern = opts;
	  } else if(col.writeConcern.w != null || col.writeConcern.j != null || col.writeConcern.fsync != null) {      
	    target.writeConcern = col.writeConcern;
	  } else if(db.writeConcern.w != null || db.writeConcern.j != null || db.writeConcern.fsync != null) {
	    target.writeConcern = db.writeConcern;
	  }
	
	  return target
	}
	
	// Figure out the read preference
	var getReadPreference = function(self, options, db, coll) {
	  var r = null
	  if(options.readPreference) {
	    r = options.readPreference
	  } else if(self.s.readPreference) {
	    r = self.s.readPreference
	  } else if(db.readPreference) {
	    r = db.readPreference;
	  }
	
	  if(r instanceof ReadPreference) {      
	    options.readPreference = new CoreReadPreference(r.mode, r.tags);
	  } else if(typeof r == 'string') {
	    options.readPreference = new CoreReadPreference(r);
	  }
	
	  return options;
	}
	
	var testForFields = {
	    limit: 1, sort: 1, fields:1, skip: 1, hint: 1, explain: 1, snapshot: 1, timeout: 1, tailable: 1, tailableRetryInterval: 1
	  , numberOfRetries: 1, awaitdata: 1, awaitData: 1, exhaust: 1, batchSize: 1, returnKey: 1, maxScan: 1, min: 1, max: 1, showDiskLoc: 1
	  , comment: 1, raw: 1, readPreference: 1, partial: 1, read: 1, dbName: 1, oplogReplay: 1, connection: 1, maxTimeMS: 1, transforms: 1
	}
	
	module.exports = Collection;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 156 */
/*!********************************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/aggregation_cursor.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var inherits = __webpack_require__(/*! util */ 57).inherits
	  , f = __webpack_require__(/*! util */ 57).format
	  , toError = __webpack_require__(/*! ./utils */ 119).toError
	  , getSingleProperty = __webpack_require__(/*! ./utils */ 119).getSingleProperty
	  , formattedOrderClause = __webpack_require__(/*! ./utils */ 119).formattedOrderClause
	  , handleCallback = __webpack_require__(/*! ./utils */ 119).handleCallback
	  , Logger = __webpack_require__(/*! mongodb-core */ 76).Logger
	  , EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter
	  , ReadPreference = __webpack_require__(/*! ./read_preference */ 120)
	  , MongoError = __webpack_require__(/*! mongodb-core */ 76).MongoError
	  , Readable = __webpack_require__(/*! stream */ 121).Readable || __webpack_require__(/*! readable-stream */ 138).Readable
	  , CoreCursor = __webpack_require__(/*! ./cursor */ 118)
	  , Query = __webpack_require__(/*! mongodb-core */ 76).Query
	  , CoreReadPreference = __webpack_require__(/*! mongodb-core */ 76).ReadPreference;
	
	/**
	 * @fileOverview The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB
	 * allowing for iteration over the results returned from the underlying query. It supports
	 * one by one document iteration, conversion to an array or can be iterated as a Node 0.10.X 
	 * or higher stream
	 * 
	 * **AGGREGATIONCURSOR Cannot directly be instantiated**
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Create a collection we want to drop later
	 *   var col = db.collection('createIndexExample1');
	 *   // Insert a bunch of documents
	 *   col.insert([{a:1, b:1}
	 *     , {a:2, b:2}, {a:3, b:3}
	 *     , {a:4, b:4}], {w:1}, function(err, result) {
	 *     test.equal(null, err);
	 * 
	 *     // Show that duplicate records got dropped
	 *     col.aggregation({}, {cursor: {}}).toArray(function(err, items) {
	 *       test.equal(null, err);
	 *       test.equal(4, items.length);
	 *       db.close();
	 *     });
	 *   });
	 * });
	 */
	
	/**
	 * Namespace provided by the browser.
	 * @external Readable
	 */
	
	/**
	 * Creates a new Aggregation Cursor instance (INTERNAL TYPE, do not instantiate directly)
	 * @class AggregationCursor
	 * @extends external:Readable
	 * @fires AggregationCursor#data
	 * @fires AggregationCursor#end
	 * @fires AggregationCursor#close
	 * @fires AggregationCursor#readable
	 * @return {AggregationCursor} an AggregationCursor instance.
	 */
	var AggregationCursor = function(bson, ns, cmd, options, topology, topologyOptions) {
	  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));
	  var self = this;
	  var state = AggregationCursor.INIT;
	  var streamOptions = {};
	
	  // MaxTimeMS
	  var maxTimeMS = null;
	
	  // Set up
	  Readable.call(this, {objectMode: true});
	
	  // Internal state
	  this.s = {
	    // MaxTimeMS
	      maxTimeMS: maxTimeMS
	    // State
	    , state: state
	    // Stream options
	    , streamOptions: streamOptions
	    // BSON
	    , bson: bson
	    // Namespae
	    , ns: ns
	    // Command
	    , cmd: cmd
	    // Options
	    , options: options
	    // Topology
	    , topology: topology
	    // Topology Options
	    , topologyOptions: topologyOptions
	  }
	}
	
	/**
	 * AggregationCursor stream data event, fired for each document in the cursor.
	 *
	 * @event AggregationCursor#data
	 * @type {object}
	 */
	
	/**
	 * AggregationCursor stream end event
	 *
	 * @event AggregationCursor#end
	 * @type {null}
	 */
	
	/**
	 * AggregationCursor stream close event
	 *
	 * @event AggregationCursor#close
	 * @type {null}
	 */
	
	/**
	 * AggregationCursor stream readable event
	 *
	 * @event AggregationCursor#readable
	 * @type {null}
	 */
	
	// Inherit from Readable
	inherits(AggregationCursor, Readable);  
	
	// Map core cursor _next method so we can apply mapping
	CoreCursor.prototype._next = CoreCursor.prototype.next;
	
	// Extend the Cursor
	for(var name in CoreCursor.prototype) {
	  AggregationCursor.prototype[name] = CoreCursor.prototype[name];
	}
	
	/**
	 * Set the batch size for the cursor.
	 * @method
	 * @param {number} value The batchSize for the cursor.
	 * @throws {MongoError}
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.batchSize = function(value) {
	  if(this.s.state == AggregationCursor.CLOSED || this.isDead()) throw new MongoError("Cursor is closed");
	  if(typeof value != 'number') throw new MongoError("batchSize requires an integer");
	  if(this.s.cmd.cursor) this.s.cmd.cursor.batchSize = value;
	  this.setCursorBatchSize(value);
	  return this;
	}
	
	/**
	 * Add a geoNear stage to the aggregation pipeline
	 * @method
	 * @param {object} document The geoNear stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.geoNear = function(document) {
	  this.s.cmd.pipeline.push({$geoNear: document});
	  return this;
	}
	
	/**
	 * Add a group stage to the aggregation pipeline
	 * @method
	 * @param {object} document The group stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.group = function(document) {
	  this.s.cmd.pipeline.push({$group: document});
	  return this;
	}
	
	/**
	 * Add a limit stage to the aggregation pipeline
	 * @method
	 * @param {number} value The state limit value.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.limit = function(value) {
	  this.s.cmd.pipeline.push({$limit: value});
	  return this;
	}
	
	/**
	 * Add a match stage to the aggregation pipeline
	 * @method
	 * @param {object} document The match stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.match = function(document) {
	  this.s.cmd.pipeline.push({$match: document});
	  return this;
	}
	
	/**
	 * Add a maxTimeMS stage to the aggregation pipeline
	 * @method
	 * @param {number} value The state maxTimeMS value.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.maxTimeMS = function(value) {
	  if(this.s.topology.lastIsMaster().minWireVersion > 2) {
	    this.s.cmd.maxTimeMS = value;
	  }
	  return this;
	}
	
	/**
	 * Add a out stage to the aggregation pipeline
	 * @method
	 * @param {number} destination The destination name.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.out = function(destination) {
	  this.s.cmd.pipeline.push({$out: destination});
	  return this;
	}
	
	/**
	 * Add a project stage to the aggregation pipeline
	 * @method
	 * @param {object} document The project stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.project = function(document) {
	  this.s.cmd.pipeline.push({$project: document});
	  return this;
	}
	
	/**
	 * Add a redact stage to the aggregation pipeline
	 * @method
	 * @param {object} document The redact stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.redact = function(document) {
	  this.s.cmd.pipeline.push({$redact: document});
	  return this;
	}
	
	/**
	 * Add a skip stage to the aggregation pipeline
	 * @method
	 * @param {number} value The state skip value.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.skip = function(value) {
	  this.s.cmd.pipeline.push({$skip: value});
	  return this;
	}
	
	/**
	 * Add a sort stage to the aggregation pipeline
	 * @method
	 * @param {object} document The sort stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.sort = function(document) {
	  this.s.cmd.pipeline.push({$sort: document});
	  return this;
	}
	
	/**
	 * Add a unwind stage to the aggregation pipeline
	 * @method
	 * @param {number} field The unwind field name.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.unwind = function(field) {
	  this.s.cmd.pipeline.push({$unwind: field});
	  return this;
	}
	
	AggregationCursor.prototype.get = AggregationCursor.prototype.toArray;
	
	/**
	 * Get the next available document from the cursor, returns null if no more documents are available.
	 * @function AggregationCursor.prototype.next
	 * @param {AggregationCursor~resultCallback} callback The result callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	
	/**
	 * Set the new batchSize of the cursor
	 * @function AggregationCursor.prototype.setBatchSize
	 * @param {number} value The new batchSize for the cursor
	 * @return {null}
	 */
	
	/**
	 * Get the batchSize of the cursor
	 * @function AggregationCursor.prototype.batchSize
	 * @param {number} value The current batchSize for the cursor
	 * @return {null}
	 */
	
	/**
	 * The callback format for results
	 * @callback AggregationCursor~toArrayResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object[]} documents All the documents the satisfy the cursor.
	 */
	
	/**
	 * Returns an array of documents. The caller is responsible for making sure that there
	 * is enough memory to store the results. Note that the array only contain partial
	 * results when this cursor had been previouly accessed. In that case,
	 * cursor.rewind() can be used to reset the cursor.
	 * @method AggregationCursor.prototype.toArray
	 * @param {AggregationCursor~toArrayResultCallback} callback The result callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	
	/**
	 * The callback format for results
	 * @callback AggregationCursor~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {(object|null)} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Iterates over all the documents for this cursor. As with **{cursor.toArray}**,
	 * not all of the elements will be iterated if this cursor had been previouly accessed.
	 * In that case, **{cursor.rewind}** can be used to reset the cursor. However, unlike
	 * **{cursor.toArray}**, the cursor will only hold a maximum of batch size elements
	 * at any given time if batch size is specified. Otherwise, the caller is responsible
	 * for making sure that the entire result can fit the memory.
	 * @method AggregationCursor.prototype.each
	 * @param {AggregationCursor~resultCallback} callback The result callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	
	/**
	 * Close the cursor, sending a AggregationCursor command and emitting close.
	 * @method AggregationCursor.prototype.close
	 * @param {AggregationCursor~resultCallback} [callback] The result callback.
	 * @return {null}
	 */   
	
	/**
	 * Is the cursor closed
	 * @method AggregationCursor.prototype.isClosed
	 * @return {boolean}
	 */   
	
	/**
	 * Execute the explain for the cursor
	 * @method AggregationCursor.prototype.explain
	 * @param {AggregationCursor~resultCallback} [callback] The result callback.
	 * @return {null}
	 */
	
	/**
	 * Clone the cursor
	 * @function AggregationCursor.prototype.clone
	 * @return {AggregationCursor}
	 */     
	
	/**
	 * Resets the cursor
	 * @function AggregationCursor.prototype.rewind
	 * @return {AggregationCursor}
	 */  
	
	/**
	 * The callback format for the forEach iterator method
	 * @callback AggregationCursor~iteratorCallback
	 * @param {Object} doc An emitted document for the iterator
	 */
	
	/**
	 * The callback error format for the forEach iterator method
	 * @callback AggregationCursor~endCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 */
	
	/*
	 * Iterates over all the documents for this cursor using the iterator, callback pattern.
	 * @method AggregationCursor.prototype.forEach
	 * @param {AggregationCursor~iteratorCallback} iterator The iteration callback.
	 * @param {AggregationCursor~endCallback} callback The end callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	
	AggregationCursor.INIT = 0;
	AggregationCursor.OPEN = 1;
	AggregationCursor.CLOSED = 2;
	
	module.exports = AggregationCursor;

/***/ },
/* 157 */
/*!****************************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/bulk/unordered.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var common = __webpack_require__(/*! ./common */ 158)
		, utils = __webpack_require__(/*! ../utils */ 119)
	  , toError = __webpack_require__(/*! ../utils */ 119).toError
	  , f = __webpack_require__(/*! util */ 57).format
	  , shallowClone = utils.shallowClone
	  , WriteError = common.WriteError
	  , BulkWriteResult = common.BulkWriteResult
	  , LegacyOp = common.LegacyOp
	  , ObjectID = __webpack_require__(/*! mongodb-core */ 76).BSON.ObjectID
	  , Batch = common.Batch
	  , mergeBatchResults = common.mergeBatchResults;
	
	/**
	 * Create a FindOperatorsUnordered instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @property {number} length Get the number of operations in the bulk.
	 * @return {FindOperatorsUnordered} a FindOperatorsUnordered instance.
	 */
	var FindOperatorsUnordered = function(self) {
	  this.s = self.s;
	}
	
	/**
	 * Add a single update document to the bulk operation
	 *
	 * @method
	 * @param {object} doc update operations
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	FindOperatorsUnordered.prototype.update = function(updateDocument) {
	  // Perform upsert
	  var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;
	
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , u: updateDocument
	    , multi: true
	    , upsert: upsert
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the update document to the list
	  return addToOperationsList(this, common.UPDATE, document);
	}
	
	/**
	 * Add a single update one document to the bulk operation
	 *
	 * @method
	 * @param {object} doc update operations
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	FindOperatorsUnordered.prototype.updateOne = function(updateDocument) {
	  // Perform upsert
	  var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;
	
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , u: updateDocument
	    , multi: false
	    , upsert: upsert
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the update document to the list
	  return addToOperationsList(this, common.UPDATE, document);
	}
	
	/**
	 * Add a replace one operation to the bulk operation
	 *
	 * @method
	 * @param {object} doc the new document to replace the existing one with
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	FindOperatorsUnordered.prototype.replaceOne = function(updateDocument) {
	  this.updateOne(updateDocument);
	}
	
	/**
	 * Upsert modifier for update bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	FindOperatorsUnordered.prototype.upsert = function() {
	  this.s.currentOp.upsert = true;
	  return this;
	}
	
	/**
	 * Add a remove one operation to the bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	FindOperatorsUnordered.prototype.removeOne = function() {
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , limit: 1
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the remove document to the list
	  return addToOperationsList(this, common.REMOVE, document);
	}
	
	/**
	 * Add a remove operation to the bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	FindOperatorsUnordered.prototype.remove = function() {
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , limit: 0
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the remove document to the list
	  return addToOperationsList(this, common.REMOVE, document);
	}
	
	//
	// Add to the operations list
	//
	var addToOperationsList = function(_self, docType, document) {
	  // Get the bsonSize
	  var bsonSize = _self.s.bson.calculateObjectSize(document, false);
	  // Throw error if the doc is bigger than the max BSON size
	  if(bsonSize >= _self.s.maxBatchSizeBytes) throw toError("document is larger than the maximum size " + _self.s.maxBatchSizeBytes);
	  // Holds the current batch
	  _self.s.currentBatch = null;
	  // Get the right type of batch
	  if(docType == common.INSERT) {
	    _self.s.currentBatch = _self.s.currentInsertBatch;
	  } else if(docType == common.UPDATE) {
	    _self.s.currentBatch = _self.s.currentUpdateBatch;
	  } else if(docType == common.REMOVE) {
	    _self.s.currentBatch = _self.s.currentRemoveBatch;
	  }
	
	  // Create a new batch object if we don't have a current one
	  if(_self.s.currentBatch == null) _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);
	
	  // Check if we need to create a new batch
	  if(((_self.s.currentBatch.size + 1) >= _self.s.maxWriteBatchSize)
	    || ((_self.s.currentBatch.sizeBytes + bsonSize) >= _self.s.maxBatchSizeBytes)
	    || (_self.s.currentBatch.batchType != docType)) {
	    // Save the batch to the execution stack
	    _self.s.batches.push(_self.s.currentBatch);
	
	    // Create a new batch
	    _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);
	  }
	
	  // We have an array of documents
	  if(Array.isArray(document)) {
	    throw toError("operation passed in cannot be an Array");
	  } else {
	    _self.s.currentBatch.operations.push(document);
	    _self.s.currentBatch.originalIndexes.push(_self.s.currentIndex);
	    _self.s.currentIndex = _self.s.currentIndex + 1;
	  }
	
	  // Save back the current Batch to the right type
	  if(docType == common.INSERT) {
	    _self.s.currentInsertBatch = _self.s.currentBatch;
	    _self.s.bulkResult.insertedIds.push({index: _self.s.currentIndex, _id: document._id});
	  } else if(docType == common.UPDATE) {
	    _self.s.currentUpdateBatch = _self.s.currentBatch;
	  } else if(docType == common.REMOVE) {
	    _self.s.currentRemoveBatch = _self.s.currentBatch;
	  }
	
	  // Update current batch size
	  _self.s.currentBatch.size = _self.s.currentBatch.size + 1;
	  _self.s.currentBatch.sizeBytes = _self.s.currentBatch.sizeBytes + bsonSize;
	
	  // Return self
	  return _self;
	}
	
	/**
	 * Create a new UnorderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @return {UnorderedBulkOperation} a UnorderedBulkOperation instance.
	 */
	var UnorderedBulkOperation = function(topology, collection, options) {
		options = options == null ? {} : options;
	
		// Contains reference to self
		var self = this;
		// Get the namesspace for the write operations
	  var namespace = collection.collectionName;
	  // Used to mark operation as executed
	  var executed = false;
	
		// Current item
	  // var currentBatch = null;
		var currentOp = null;
		var currentIndex = 0;
	  var batches = [];
	
	  // The current Batches for the different operations
	  var currentInsertBatch = null;
	  var currentUpdateBatch = null;
	  var currentRemoveBatch = null;
	
		// Handle to the bson serializer, used to calculate running sizes
		var bson = topology.bson;
	
	  // Get the capabilities
	  var capabilities = topology.capabilities();
	
	  // Set max byte size
		var maxBatchSizeBytes = topology.isMasterDoc.maxBsonObjectSize;
		var maxWriteBatchSize = topology.isMasterDoc.maxWriteBatchSize || 1000;
	
	  // Get the write concern
	  var writeConcern = common.writeConcern(shallowClone(options), collection, options);
	
	  // Final results
	  var bulkResult = {
	  	  ok: 1
	    , writeErrors: []
	    , writeConcernErrors: []
	    , insertedIds: []
	    , nInserted: 0
	    , nUpserted: 0
	    , nMatched: 0
	    , nModified: 0
	    , nRemoved: 0
	    , upserted: []
	  };
	
	  // Internal state
	  this.s = {
	    // Final result
	      bulkResult: bulkResult
	    // Current batch state
	    , currentInsertBatch: null
	    , currentUpdateBatch: null
	    , currentRemoveBatch: null
	    , currentBatch: null
	    , currentIndex: 0
	    , batches: []
	    // Write concern
	    , writeConcern: writeConcern
	    // Capabilities
	    , capabilities: capabilities
	    // Max batch size options
	    , maxBatchSizeBytes: maxBatchSizeBytes
	    , maxWriteBatchSize: maxWriteBatchSize
	    // Namespace
	    , namespace: namespace
	    // BSON
	    , bson: bson
	    // Topology
	    , topology: topology
	    // Options
	    , options: options
	    // Current operation
	    , currentOp: currentOp
	    // Executed
	    , executed: executed
	    // Collection
	    , collection: collection
	  }
	}
	
	/**
	 * Add a single insert document to the bulk operation
	 *
	 * @param {object} doc the document to insert
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	UnorderedBulkOperation.prototype.insert = function(document) {
	  if(document._id == null) document._id = new ObjectID();
	  return addToOperationsList(this, common.INSERT, document);
	}
	
	/**
	 * Initiate a find operation for an update/updateOne/remove/removeOne/replaceOne
	 *
	 * @method
	 * @param {object} selector The selector for the bulk operation.
	 * @throws {MongoError}
	 * @return {FindOperatorsUnordered}
	 */
	UnorderedBulkOperation.prototype.find = function(selector) {
	  if (!selector) {
	    throw toError("Bulk find operation must specify a selector");
	  }
	
	  // Save a current selector
	  this.s.currentOp = {
	    selector: selector
	  }
	
	  return new FindOperatorsUnordered(this);
	}
	
	Object.defineProperty(UnorderedBulkOperation.prototype, 'length', {
	  enumerable: true,
	  get: function() {
	    return this.s.currentIndex;
	  }
	});
	
	UnorderedBulkOperation.prototype.raw = function(op) {
	  var key = Object.keys(op)[0];
	
	  // Update operations
	  if((op.updateOne && op.updateOne.q)
	    || (op.updateMany && op.updateMany.q)
	    || (op.replaceOne && op.replaceOne.q)) {
	    op[key].multi = op.updateOne || op.replaceOne ? false : true;
	    return addToOperationsList(this, common.UPDATE, op[key]);
	  }
	
	  // Crud spec update format
	  if(op.updateOne || op.updateMany || op.replaceOne) {
	    var multi = op.updateOne || op.replaceOne ? false : true;
	    var operation = {q: op[key].filter, u: op[key].update || op[key].replacement, multi: multi}
	    if(op[key].upsert) operation.upsert = true;
	    return addToOperationsList(this, common.UPDATE, operation);
	  }
	
	  // Remove operations
	  if(op.removeOne || op.removeMany || (op.deleteOne && op.deleteOne.q) || op.deleteMany && op.deleteMany.q) {
	    op[key].limit = op.removeOne ? 1 : 0;
	    return addToOperationsList(this, common.REMOVE, op[key]);
	  }
	
	  // Crud spec delete operations, less efficient
	  if(op.deleteOne || op.deleteMany) {
	    var limit = op.deleteOne ? 1 : 0;
	    var operation = {q: op[key].filter, limit: limit}
	    return addToOperationsList(this, common.REMOVE, operation);
	  }
	
	  // Insert operations
	  if(op.insertOne && op.insertOne.document == null) {
	    if(op.insertOne._id == null) op.insertOne._id = new ObjectID();
	    return addToOperationsList(this, common.INSERT, op.insertOne);
	  } else if(op.insertOne && op.insertOne.document) {
	    if(op.insertOne.document._id == null) op.insertOne.document._id = new ObjectID();
	    return addToOperationsList(this, common.INSERT, op.insertOne.document);
	  }
	
	  if(op.insertMany) {
	    for(var i = 0; i < op.insertMany.length; i++) {
	      addToOperationsList(this, common.INSERT, op.insertMany[i]);
	    }
	
	    return;
	  }
	
	  // No valid type of operation
	  throw toError("bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany");
	}
	
	//
	// Execute the command
	var executeBatch = function(self, batch, callback) {
	  var finalOptions = {ordered: false}
	  if(self.s.writeConcern != null) {
	    finalOptions.writeConcern = self.s.writeConcern;
	  }
	
	  var resultHandler = function(err, result) {
	    // If we have and error
	    if(err) err.ok = 0;
	    callback(null, mergeBatchResults(false, batch, self.s.bulkResult, err, result));
	  }
	
	  try {
	    if(batch.batchType == common.INSERT) {
	      self.s.topology.insert(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    } else if(batch.batchType == common.UPDATE) {
	      self.s.topology.update(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    } else if(batch.batchType == common.REMOVE) {
	      self.s.topology.remove(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    }
	  } catch(err) {
	    // Force top level error
	    err.ok = 0;
	    // Merge top level error and return 
	    callback(null, mergeBatchResults(false, batch, self.s.bulkResult, err, null));
	  }
	}
	
	//
	// Execute all the commands
	var executeBatches = function(self, callback) {
	  var numberOfCommandsToExecute = self.s.batches.length;
	  // Execute over all the batches
	  for(var i = 0; i < self.s.batches.length; i++) {
	    executeBatch(self, self.s.batches[i], function(err, result) {
	      numberOfCommandsToExecute = numberOfCommandsToExecute - 1;
	
	      // Execute
	      if(numberOfCommandsToExecute == 0) {
	        var error = self.s.bulkResult.writeErrors.length > 0 ? self.s.bulkResult.writeErrors[0] : null;
	        callback(error, new BulkWriteResult(self.s.bulkResult));
	      }
	    });
	  }
	}
	
	/**
	 * The callback format for results
	 * @callback UnorderedBulkOperation~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {BulkWriteResult} result The bulk write result.
	 */
	
	/**
	 * Execute the ordered bulk operation
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.fsync=false] Specify a file sync write concern.
	 * @param {UnorderedBulkOperation~resultCallback} callback The result callback
	 * @throws {MongoError}
	 * @return {null}
	 */
	UnorderedBulkOperation.prototype.execute = function(_writeConcern, callback) {
	  if(this.s.executed) throw toError("batch cannot be re-executed");
	  if(typeof _writeConcern == 'function') {
	    callback = _writeConcern;
	  } else {
	    this.s.writeConcern = _writeConcern;
	  }
	
	  // If we have current batch
	  if(this.s.currentInsertBatch) this.s.batches.push(this.s.currentInsertBatch);
	  if(this.s.currentUpdateBatch) this.s.batches.push(this.s.currentUpdateBatch);
	  if(this.s.currentRemoveBatch) this.s.batches.push(this.s.currentRemoveBatch);
	
	  // If we have no operations in the bulk raise an error
	  if(this.s.batches.length == 0) {
	    throw toError("Invalid Operation, No operations in bulk");
	  }
	
	  // Execute batches
	  return executeBatches(this, function(err, result) {
	    callback(err, result);
	  });
	}
	
	/**
	 * Returns an unordered batch object
	 * @ignore
	 */
	var initializeUnorderedBulkOp = function(topology, collection, options) {
		return new UnorderedBulkOperation(topology, collection, options);
	}
	
	module.exports = initializeUnorderedBulkOp;


/***/ },
/* 158 */
/*!*************************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/bulk/common.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var utils = __webpack_require__(/*! ../utils */ 119);
	
	// Error codes
	var UNKNOWN_ERROR = 8;
	var INVALID_BSON_ERROR = 22;
	var WRITE_CONCERN_ERROR = 64;
	var MULTIPLE_ERROR = 65;
	
	// Insert types
	var INSERT = 1;
	var UPDATE = 2;
	var REMOVE = 3
	
	
	// Get write concern
	var writeConcern = function(target, col, options) {
	  if(options.w != null || options.j != null || options.fsync != null) {
	    target.writeConcern = options;
	  } else if(col.writeConcern.w != null || col.writeConcern.j != null || col.writeConcern.fsync != null) {      
	    target.writeConcern = col.writeConcern;
	  }
	
	  return target
	}
	
	/**
	 * Helper function to define properties
	 * @ignore
	 */
	var defineReadOnlyProperty = function(self, name, value) {
	  Object.defineProperty(self, name, {
	      enumerable: true
	    , get: function() {
	      return value;
	    }
	  });
	}
	
	/**
	 * Keeps the state of a unordered batch so we can rewrite the results
	 * correctly after command execution
	 * @ignore
	 */
	var Batch = function(batchType, originalZeroIndex) {  
	  this.originalZeroIndex = originalZeroIndex;
	  this.currentIndex = 0;
	  this.originalIndexes = [];
	  this.batchType = batchType;
	  this.operations = [];
	  this.size = 0;
	  this.sizeBytes = 0;
	}
	
	/**
	 * Wraps a legacy operation so we can correctly rewrite it's error
	 * @ignore
	 */
	var LegacyOp = function(batchType, operation, index) {
	  this.batchType = batchType;
	  this.index = index;
	  this.operation = operation;
	}
	
	/**
	 * Create a new BulkWriteResult instance (INTERNAL TYPE, do not instantiate directly)
	 *
	 * @class
	 * @property {boolean} ok Did bulk operation correctly execute
	 * @property {number} nInserted number of inserted documents
	 * @property {number} nUpdated number of documents updated logically
	 * @property {number} nUpserted Number of upserted documents
	 * @property {number} nModified Number of documents updated physically on disk
	 * @property {number} nRemoved Number of removed documents
	 * @return {BulkWriteResult} a BulkWriteResult instance
	 */
	var BulkWriteResult = function(bulkResult) {
	  defineReadOnlyProperty(this, "ok", bulkResult.ok);
	  defineReadOnlyProperty(this, "nInserted", bulkResult.nInserted);
	  defineReadOnlyProperty(this, "nUpserted", bulkResult.nUpserted);
	  defineReadOnlyProperty(this, "nMatched", bulkResult.nMatched);
	  defineReadOnlyProperty(this, "nModified", bulkResult.nModified);
	  defineReadOnlyProperty(this, "nRemoved", bulkResult.nRemoved);
	
	  /**
	   * Return an array of inserted ids
	   *
	   * @return {object[]}
	   */
	  this.getInsertedIds = function() {
	    return bulkResult.insertedIds;
	  }
	
	  /**
	   * Return an array of upserted ids
	   *
	   * @return {object[]}
	   */
	  this.getUpsertedIds = function() {
	    return bulkResult.upserted;
	  }
	
	  /**
	   * Return the upserted id at position x
	   *
	   * @param {number} index the number of the upserted id to return, returns undefined if no result for passed in index
	   * @return {object}
	   */
	  this.getUpsertedIdAt = function(index) {
	    return bulkResult.upserted[index]; 
	  }
	
	  /**
	   * Return raw internal result
	   *
	   * @return {object}
	   */
	  this.getRawResponse = function() {
	    return bulkResult;
	  }
	
	  /**
	   * Returns true if the bulk operation contains a write error
	   *
	   * @return {boolean}
	   */
	  this.hasWriteErrors = function() {
	    return bulkResult.writeErrors.length > 0;
	  }
	
	  /**
	   * Returns the number of write errors off the bulk operation
	   *
	   * @return {number}
	   */
	  this.getWriteErrorCount = function() {
	    return bulkResult.writeErrors.length;
	  }
	
	  /**
	   * Returns a specific write error object
	   *
	   * @return {WriteError}
	   */
	  this.getWriteErrorAt = function(index) {
	    if(index < bulkResult.writeErrors.length) {
	      return bulkResult.writeErrors[index];
	    }
	    return null;
	  }
	
	  /**
	   * Retrieve all write errors
	   *
	   * @return {object[]}
	   */
	  this.getWriteErrors = function() {
	    return bulkResult.writeErrors;
	  }
	
	  /**
	   * Retrieve lastOp if available
	   *
	   * @return {object}
	   */
	  this.getLastOp = function() {
	    return bulkResult.lastOp;
	  }
	
	  /**
	   * Retrieve the write concern error if any
	   *
	   * @return {WriteConcernError}
	   */
	  this.getWriteConcernError = function() {
	    if(bulkResult.writeConcernErrors.length == 0) {
	      return null;
	    } else if(bulkResult.writeConcernErrors.length == 1) {
	      // Return the error
	      return bulkResult.writeConcernErrors[0];
	    } else {
	
	      // Combine the errors
	      var errmsg = "";
	      for(var i = 0; i < bulkResult.writeConcernErrors.length; i++) {
	        var err = bulkResult.writeConcernErrors[i];
	        errmsg = errmsg + err.errmsg;
	        
	        // TODO: Something better
	        if(i == 0) errmsg = errmsg + " and ";
	      }
	
	      return new WriteConcernError({ errmsg : errmsg, code : WRITE_CONCERN_ERROR });
	    }
	  }
	
	  this.toJSON = function() {
	    return bulkResult;
	  }
	
	  this.toString = function() {
	    return "BulkWriteResult(" + this.toJSON(bulkResult) + ")";
	  }
	
	  this.isOk = function() {
	    return bulkResult.ok == 1;
	  }
	}
	
	/**
	 * Create a new WriteConcernError instance (INTERNAL TYPE, do not instantiate directly)
	 *
	 * @class
	 * @property {number} code Write concern error code.
	 * @property {string} errmsg Write concern error message.
	 * @return {WriteConcernError} a WriteConcernError instance
	 */
	var WriteConcernError = function(err) {
	  if(!(this instanceof WriteConcernError)) return new WriteConcernError(err);
	
	  // Define properties
	  defineReadOnlyProperty(this, "code", err.code);
	  defineReadOnlyProperty(this, "errmsg", err.errmsg);
	
	  this.toJSON = function() {
	    return {code: err.code, errmsg: err.errmsg};
	  }
	
	  this.toString = function() {
	    return "WriteConcernError(" + err.errmsg + ")";
	  }
	}
	
	/**
	 * Create a new WriteError instance (INTERNAL TYPE, do not instantiate directly)
	 *
	 * @class
	 * @property {number} code Write concern error code.
	 * @property {number} index Write concern error original bulk operation index.
	 * @property {string} errmsg Write concern error message.
	 * @return {WriteConcernError} a WriteConcernError instance
	 */
	var WriteError = function(err) {
	  if(!(this instanceof WriteError)) return new WriteError(err);
	
	  // Define properties
	  defineReadOnlyProperty(this, "code", err.code);
	  defineReadOnlyProperty(this, "index", err.index);
	  defineReadOnlyProperty(this, "errmsg", err.errmsg);
	
	  //
	  // Define access methods
	  this.getOperation = function() {
	    return err.op;
	  }
	
	  this.toJSON = function() {
	    return {code: err.code, index: err.index, errmsg: err.errmsg, op: err.op};
	  }
	
	  this.toString = function() {
	    return "WriteError(" + JSON.stringify(this.toJSON()) + ")";
	  }
	}
	
	/**
	 * Merges results into shared data structure
	 * @ignore
	 */
	var mergeBatchResults = function(ordered, batch, bulkResult, err, result) {
	  // If we have an error set the result to be the err object
	  if(err) {
	    result = err;
	  } else if(result && result.result) {
	    result = result.result;
	  } else if(result == null) {
	    return;
	  }
	
	  // Do we have a top level error stop processing and return
	  if(result.ok == 0 && bulkResult.ok == 1) {
	    bulkResult.ok = 0;
	    // bulkResult.error = utils.toError(result);
	    var writeError = {
	        index: 0
	      , code: result.code || 0
	      , errmsg: result.message
	      , op: batch.operations[0]
	    };
	
	    bulkResult.writeErrors.push(new WriteError(writeError));    
	    return;
	  } else if(result.ok == 0 && bulkResult.ok == 0) {
	    return;
	  }
	
	  // Add lastop if available
	  if(result.lastOp) {
	    bulkResult.lastOp = result.lastOp;
	  }
	
	  // If we have an insert Batch type
	  if(batch.batchType == INSERT && result.n) {
	    bulkResult.nInserted = bulkResult.nInserted + result.n;
	  }
	
	  // If we have an insert Batch type
	  if(batch.batchType == REMOVE && result.n) {
	    bulkResult.nRemoved = bulkResult.nRemoved + result.n;
	  }
	
	  var nUpserted = 0;
	
	  // We have an array of upserted values, we need to rewrite the indexes
	  if(Array.isArray(result.upserted)) {
	    nUpserted = result.upserted.length;
	
	    for(var i = 0; i < result.upserted.length; i++) {
	      bulkResult.upserted.push({
	          index: result.upserted[i].index + batch.originalZeroIndex
	        , _id: result.upserted[i]._id
	      });
	    }
	  } else if(result.upserted) {
	
	    nUpserted = 1;
	
	    bulkResult.upserted.push({
	        index: batch.originalZeroIndex
	      , _id: result.upserted
	    });
	  }
	
	  // If we have an update Batch type
	  if(batch.batchType == UPDATE && result.n) {
	    var nModified = result.nModified;
	    bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
	    bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
	    
	    if(typeof nModified == 'number') {
	      bulkResult.nModified = bulkResult.nModified + nModified;
	    } else {
	      bulkResult.nModified = null;
	    }
	  }
	
	  if(Array.isArray(result.writeErrors)) {
	    for(var i = 0; i < result.writeErrors.length; i++) {
	
	      var writeError = {
	          index: batch.originalZeroIndex + result.writeErrors[i].index
	        , code: result.writeErrors[i].code
	        , errmsg: result.writeErrors[i].errmsg
	        , op: batch.operations[result.writeErrors[i].index]
	      };
	
	      bulkResult.writeErrors.push(new WriteError(writeError));
	    }
	  }
	
	  if(result.writeConcernError) {
	    bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
	  }
	}
	
	//
	// Clone the options
	var cloneOptions = function(options) {
	  var clone = {};
	  var keys = Object.keys(options);
	  for(var i = 0; i < keys.length; i++) {
	    clone[keys[i]] = options[keys[i]];
	  }
	
	  return clone;
	}
	
	// Exports symbols
	exports.BulkWriteResult = BulkWriteResult;
	exports.WriteError = WriteError;
	exports.Batch = Batch;
	exports.LegacyOp = LegacyOp;
	exports.mergeBatchResults = mergeBatchResults;
	exports.cloneOptions = cloneOptions;
	exports.writeConcern = writeConcern;
	exports.INVALID_BSON_ERROR = INVALID_BSON_ERROR;
	exports.WRITE_CONCERN_ERROR = WRITE_CONCERN_ERROR;
	exports.MULTIPLE_ERROR = MULTIPLE_ERROR;
	exports.UNKNOWN_ERROR = UNKNOWN_ERROR;
	exports.INSERT = INSERT;
	exports.UPDATE = UPDATE;
	exports.REMOVE = REMOVE;

/***/ },
/* 159 */
/*!**************************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/bulk/ordered.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var common = __webpack_require__(/*! ./common */ 158)
		, utils = __webpack_require__(/*! ../utils */ 119)
	  , toError = __webpack_require__(/*! ../utils */ 119).toError
		, f = __webpack_require__(/*! util */ 57).format
		, shallowClone = utils.shallowClone
	  , WriteError = common.WriteError
	  , BulkWriteResult = common.BulkWriteResult
	  , LegacyOp = common.LegacyOp
	  , ObjectID = __webpack_require__(/*! mongodb-core */ 76).BSON.ObjectID
	  , Batch = common.Batch
	  , mergeBatchResults = common.mergeBatchResults;
	
	/**
	 * Create a FindOperatorsOrdered instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @return {FindOperatorsOrdered} a FindOperatorsOrdered instance.
	 */
	var FindOperatorsOrdered = function(self) {
	  this.s = self.s;
	}
	
	/**
	 * Add a single update document to the bulk operation
	 *
	 * @method
	 * @param {object} doc update operations
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	FindOperatorsOrdered.prototype.update = function(updateDocument) {
	  // Perform upsert
	  var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;
	
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , u: updateDocument
	    , multi: true
	    , upsert: upsert
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the update document to the list
	  return addToOperationsList(this, common.UPDATE, document);
	}
	
	/**
	 * Add a single update one document to the bulk operation
	 *
	 * @method
	 * @param {object} doc update operations
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	FindOperatorsOrdered.prototype.updateOne = function(updateDocument) {
	  // Perform upsert
	  var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;
	
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , u: updateDocument
	    , multi: false
	    , upsert: upsert
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the update document to the list
	  return addToOperationsList(this, common.UPDATE, document);
	}
	
	/**
	 * Add a replace one operation to the bulk operation
	 *
	 * @method
	 * @param {object} doc the new document to replace the existing one with
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	FindOperatorsOrdered.prototype.replaceOne = function(updateDocument) {
	  this.updateOne(updateDocument);
	}
	
	/**
	 * Upsert modifier for update bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {FindOperatorsOrdered}
	 */
	FindOperatorsOrdered.prototype.upsert = function() {
	  this.s.currentOp.upsert = true;
	  return this;
	}
	
	/**
	 * Add a remove one operation to the bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	FindOperatorsOrdered.prototype.deleteOne = function() {
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , limit: 1
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the remove document to the list
	  return addToOperationsList(this, common.REMOVE, document);
	}
	
	// Backward compatibility
	FindOperatorsOrdered.prototype.removeOne = FindOperatorsOrdered.prototype.deleteOne;
	
	/**
	 * Add a remove operation to the bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	FindOperatorsOrdered.prototype.delete = function() {
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , limit: 0
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the remove document to the list
	  return addToOperationsList(this, common.REMOVE, document);
	}
	
	// Backward compatibility
	FindOperatorsOrdered.prototype.remove = FindOperatorsOrdered.prototype.delete;
	
	// Add to internal list of documents
	var addToOperationsList = function(_self, docType, document) {
	  // Get the bsonSize
	  var bsonSize = _self.s.bson.calculateObjectSize(document, false);
	
	  // Throw error if the doc is bigger than the max BSON size
	  if(bsonSize >= _self.s.maxBatchSizeBytes) throw toError("document is larger than the maximum size " + _self.s.maxBatchSizeBytes);
	  // Create a new batch object if we don't have a current one
	  if(_self.s.currentBatch == null) _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);
	
	  // Check if we need to create a new batch
	  if(((_self.s.currentBatchSize + 1) >= _self.s.maxWriteBatchSize)
	    || ((_self.s.currentBatchSizeBytes +  _self.s.currentBatchSizeBytes) >= _self.s.maxBatchSizeBytes)
	    || (_self.s.currentBatch.batchType != docType)) {
	    // Save the batch to the execution stack
	    _self.s.batches.push(_self.s.currentBatch);
	
	    // Create a new batch
	    _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);
	
	    // Reset the current size trackers
	    _self.s.currentBatchSize = 0;
	    _self.s.currentBatchSizeBytes = 0;
	  } else {
	    // Update current batch size
	    _self.s.currentBatchSize = _self.s.currentBatchSize + 1;
	    _self.s.currentBatchSizeBytes = _self.s.currentBatchSizeBytes + bsonSize;
	  }
	
	  if(docType == common.INSERT) {
	    _self.s.bulkResult.insertedIds.push({index: _self.s.currentIndex, _id: document._id});
	  }
	
	  // We have an array of documents
	  if(Array.isArray(document)) {
	    throw toError("operation passed in cannot be an Array");
	  } else {
	    _self.s.currentBatch.originalIndexes.push(_self.s.currentIndex);
	    _self.s.currentBatch.operations.push(document)
	    _self.s.currentIndex = _self.s.currentIndex + 1;
	  }
	
	  // Return self
	  return _self;
	}
	
	/**
	 * Create a new OrderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @property {number} length Get the number of operations in the bulk.
	 * @return {OrderedBulkOperation} a OrderedBulkOperation instance.
	 */
	function OrderedBulkOperation(topology, collection, options) {
		options = options == null ? {} : options;
		// TODO Bring from driver information in isMaster
		var self = this;
		var executed = false;
	
		// Current item
		var currentOp = null;
	
		// Handle to the bson serializer, used to calculate running sizes
		var bson = topology.bson;
	
		// Namespace for the operation
	  var namespace = collection.collectionName;
	
	  // Set max byte size
		var maxBatchSizeBytes = topology.isMasterDoc.maxBsonObjectSize;
		var maxWriteBatchSize = topology.isMasterDoc.maxWriteBatchSize || 1000;
	
		// Get the capabilities
		var capabilities = topology.capabilities();
	
	  // Get the write concern
	  var writeConcern = common.writeConcern(shallowClone(options), collection, options);
	
	  // Current batch
	  var currentBatch = null;
	  var currentIndex = 0;
	  var currentBatchSize = 0;
	  var currentBatchSizeBytes = 0;
	  var batches = [];
	
	  // Final results
	  var bulkResult = {
	  	  ok: 1
	    , writeErrors: []
	    , writeConcernErrors: []
	    , insertedIds: []
	    , nInserted: 0
	    , nUpserted: 0
	    , nMatched: 0
	    , nModified: 0
	    , nRemoved: 0
	    , upserted: []
	  };
	
	  // Internal state
	  this.s = {
	    // Final result
	      bulkResult: bulkResult
	    // Current batch state
	    , currentBatch: null
	    , currentIndex: 0
	    , currentBatchSize: 0
	    , currentBatchSizeBytes: 0
	    , batches: []
	    // Write concern
	    , writeConcern: writeConcern
	    // Capabilities
	    , capabilities: capabilities
	    // Max batch size options
	    , maxBatchSizeBytes: maxBatchSizeBytes
	    , maxWriteBatchSize: maxWriteBatchSize
	    // Namespace
	    , namespace: namespace
	    // BSON
	    , bson: bson
	    // Topology
	    , topology: topology
	    // Options
	    , options: options
	    // Current operation
	    , currentOp: currentOp
	    // Executed
	    , executed: executed
	    // Collection
	    , collection: collection
	  }
	}
	
	OrderedBulkOperation.prototype.raw = function(op) {
	  var key = Object.keys(op)[0];
	
	  // Update operations
	  if((op.updateOne && op.updateOne.q)
	    || (op.updateMany && op.updateMany.q)
	    || (op.replaceOne && op.replaceOne.q)) {
	    op[key].multi = op.updateOne || op.replaceOne ? false : true;
	    return addToOperationsList(this, common.UPDATE, op[key]);
	  }
	
	  // Crud spec update format
	  if(op.updateOne || op.updateMany || op.replaceOne) {
	    var multi = op.updateOne || op.replaceOne ? false : true;
	    var operation = {q: op[key].filter, u: op[key].update || op[key].replacement, multi: multi}
	    if(op[key].upsert) operation.upsert = true;
	    return addToOperationsList(this, common.UPDATE, operation);
	  }
	
	  // Remove operations
	  if(op.removeOne || op.removeMany || (op.deleteOne && op.deleteOne.q) || op.deleteMany && op.deleteMany.q) {
	    op[key].limit = op.removeOne ? 1 : 0;
	    return addToOperationsList(this, common.REMOVE, op[key]);
	  }
	
	  // Crud spec delete operations, less efficient
	  if(op.deleteOne || op.deleteMany) {
	    var limit = op.deleteOne ? 1 : 0;
	    var operation = {q: op[key].filter, limit: limit}
	    return addToOperationsList(this, common.REMOVE, operation);
	  }
	
	  // Insert operations
	  if(op.insertOne && op.insertOne.document == null) {
	    if(op.insertOne._id == null) op.insertOne._id = new ObjectID();
	    return addToOperationsList(this, common.INSERT, op.insertOne);
	  } else if(op.insertOne && op.insertOne.document) {
	    if(op.insertOne.document._id == null) op.insertOne.document._id = new ObjectID();
	    return addToOperationsList(this, common.INSERT, op.insertOne.document);
	  }
	
	  if(op.insertMany) {
	    for(var i = 0; i < op.insertMany.length; i++) {
	      if(op.insertMany[i]._id == null) op.insertMany[i]._id = new ObjectID();
	      addToOperationsList(this, common.INSERT, op.insertMany[i]);
	    }
	
	    return;
	  }
	
	  // No valid type of operation
	  throw toError("bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany");
	}
	
	/**
	 * Add a single insert document to the bulk operation
	 *
	 * @param {object} doc the document to insert
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	OrderedBulkOperation.prototype.insert = function(document) {
	  if(document._id == null) document._id = new ObjectID();
	  return addToOperationsList(this, common.INSERT, document);
	}
	
	/**
	 * Initiate a find operation for an update/updateOne/remove/removeOne/replaceOne
	 *
	 * @method
	 * @param {object} selector The selector for the bulk operation.
	 * @throws {MongoError}
	 * @return {FindOperatorsOrdered}
	 */
	OrderedBulkOperation.prototype.find = function(selector) {
	  if (!selector) {
	    throw toError("Bulk find operation must specify a selector");
	  }
	
	  // Save a current selector
	  this.s.currentOp = {
	    selector: selector
	  }
	
	  return new FindOperatorsOrdered(this);
	}
	
	Object.defineProperty(OrderedBulkOperation.prototype, 'length', {
	  enumerable: true,
	  get: function() {
	    return this.s.currentIndex;
	  }
	});
	
	//
	// Execute next write command in a chain
	var executeCommands = function(self, callback) {
	  if(self.s.batches.length == 0) {
	    return callback(null, new BulkWriteResult(self.s.bulkResult));
	  }
	
	  // Ordered execution of the command
	  var batch = self.s.batches.shift();
	
	  var resultHandler = function(err, result) {
	    // If we have and error
	    if(err) err.ok = 0;
	    // Merge the results together
	    var mergeResult = mergeBatchResults(true, batch, self.s.bulkResult, err, result);
	    if(mergeResult != null) {
	      return callback(null, new BulkWriteResult(self.s.bulkResult));
	    }
	
	    // If we are ordered and have errors and they are
	    // not all replication errors terminate the operation
	    if(self.s.bulkResult.writeErrors.length > 0) {
	      return callback(self.s.bulkResult.writeErrors[0], new BulkWriteResult(self.s.bulkResult));
	    }
	
	    // Execute the next command in line
	    executeCommands(self, callback);
	  }
	
	  var finalOptions = {ordered: true}
	  if(self.s.writeConcern != null) {
	    finalOptions.writeConcern = self.s.writeConcern;
	  }
	
	  try {
	    if(batch.batchType == common.INSERT) {
	      self.s.topology.insert(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    } else if(batch.batchType == common.UPDATE) {
	      self.s.topology.update(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    } else if(batch.batchType == common.REMOVE) {
	      self.s.topology.remove(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    }
	  } catch(err) {
	    // Force top level error
	    err.ok = 0;
	    // Merge top level error and return 
	    callback(null, mergeBatchResults(false, batch, self.s.bulkResult, err, null));
	  }
	}
	
	/**
	 * The callback format for results
	 * @callback OrderedBulkOperation~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {BulkWriteResult} result The bulk write result.
	 */
	
	/**
	 * Execute the ordered bulk operation
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.fsync=false] Specify a file sync write concern.
	 * @param {OrderedBulkOperation~resultCallback} callback The result callback
	 * @throws {MongoError}
	 * @return {null}
	 */
	OrderedBulkOperation.prototype.execute = function(_writeConcern, callback) {
	  if(this.s.executed) throw new toError("batch cannot be re-executed");
	  if(typeof _writeConcern == 'function') {
	    callback = _writeConcern;
	  } else {
	    this.s.writeConcern = _writeConcern;
	  }
	
	  // If we have current batch
	  if(this.s.currentBatch) this.s.batches.push(this.s.currentBatch);
	
	  // If we have no operations in the bulk raise an error
	  if(this.s.batches.length == 0) {
	    throw toError("Invalid Operation, No operations in bulk");
	  }
	
	  // Execute the commands
	  return executeCommands(this, callback);
	}
	
	/**
	 * Returns an unordered batch object
	 * @ignore
	 */
	var initializeOrderedBulkOp = function(topology, collection, options) {
		return new OrderedBulkOperation(topology, collection, options);
	}
	
	module.exports = initializeOrderedBulkOp;


/***/ },
/* 160 */
/*!*******************************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/gridfs/grid_store.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	
	/**
	 * @fileOverview GridFS is a tool for MongoDB to store files to the database.
	 * Because of the restrictions of the object size the database can hold, a
	 * facility to split a file into several chunks is needed. The {@link GridStore}
	 * class offers a simplified api to interact with files while managing the
	 * chunks of split files behind the scenes. More information about GridFS can be
	 * found <a href="http://www.mongodb.org/display/DOCS/GridFS">here</a>.
	 *
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   GridStore = require('mongodb').GridStore,
	 *   ObjectID = require('mongodb').ObjectID,
	 *   test = require('assert');
	 *
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   var gridStore = new GridStore(db, null, "w");
	 *   gridStore.open(function(err, gridStore) {
	 *     gridStore.write("hello world!", function(err, gridStore) {
	 *       gridStore.close(function(err, result) {
	 *
	 *         // Let's read the file using object Id
	 *         GridStore.read(db, result._id, function(err, data) {
	 *           test.equal('hello world!', data);
	 *           db.close();
	 *           test.done();
	 *         });
	 *       });
	 *     });
	 *   });
	 * });
	 */
	var Chunk = __webpack_require__(/*! ./chunk */ 161),
	  ObjectID = __webpack_require__(/*! mongodb-core */ 76).BSON.ObjectID,
	  ReadPreference = __webpack_require__(/*! ../read_preference */ 120),
	  Buffer = __webpack_require__(/*! buffer */ 28).Buffer,
	  fs = __webpack_require__(/*! fs */ 84),
	  timers = __webpack_require__(/*! timers */ 81),
	  f = __webpack_require__(/*! util */ 57).format,
	  util = __webpack_require__(/*! util */ 57),
	  MongoError = __webpack_require__(/*! mongodb-core */ 76).MongoError,
	  inherits = util.inherits,
	  Duplex = __webpack_require__(/*! stream */ 121).Duplex || __webpack_require__(/*! readable-stream */ 138).Duplex;
	
	var REFERENCE_BY_FILENAME = 0,
	  REFERENCE_BY_ID = 1;
	
	/**
	 * Namespace provided by the mongodb-core and node.js
	 * @external Duplex
	 */
	
	/**
	 * Create a new GridStore instance
	 *
	 * Modes
	 *  - **"r"** - read only. This is the default mode.
	 *  - **"w"** - write in truncate mode. Existing data will be overwriten.
	 *
	 * @class
	 * @param {Db} db A database instance to interact with.
	 * @param {object} [id] optional unique id for this file
	 * @param {string} [filename] optional filename for this file, no unique constrain on the field
	 * @param {string} mode set the mode for this file.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.fsync=false] Specify a file sync write concern.
	 * @param {string} [options.root=null] Root collection to use. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.
	 * @param {string} [options.content_type=null] MIME type of the file. Defaults to **{GridStore.DEFAULT_CONTENT_TYPE}**.
	 * @param {number} [options.chunk_size=261120] Size for the chunk. Defaults to **{Chunk.DEFAULT_CHUNK_SIZE}**.
	 * @param {object} [options.metadata=null] Arbitrary data the user wants to store.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @property {number} chunkSize Get the gridstore chunk size.
	 * @property {number} md5 The md5 checksum for this file.
	 * @property {number} chunkNumber The current chunk number the gridstore has materialized into memory
	 * @return {GridStore} a GridStore instance.
	 */
	var GridStore = function GridStore(db, id, filename, mode, options) {
	  if(!(this instanceof GridStore)) return new GridStore(db, id, filename, mode, options);
	  var self = this;
	  this.db = db;
	
	  // Handle options
	  if(typeof options === 'undefined') options = {};
	  // Handle mode
	  if(typeof mode === 'undefined') {
	    mode = filename;
	    filename = undefined;
	  } else if(typeof mode == 'object') {
	    options = mode;
	    mode = filename;
	    filename = undefined;
	  }
	
	  if(id instanceof ObjectID) {
	    this.referenceBy = REFERENCE_BY_ID;
	    this.fileId = id;
	    this.filename = filename;
	  } else if(typeof filename == 'undefined') {
	    this.referenceBy = REFERENCE_BY_FILENAME;
	    this.filename = id;
	    if (mode.indexOf('w') != null) {
	      this.fileId = new ObjectID();
	    }
	  } else {
	    this.referenceBy = REFERENCE_BY_ID;
	    this.fileId = id;
	    this.filename = filename;
	  }
	
	  // Set up the rest
	  this.mode = mode == null ? "r" : mode;
	  this.options = options || {};
	
	  // Opened
	  this.isOpen = false;
	
	  // Set the root if overridden
	  this.root = this.options['root'] == null ? GridStore.DEFAULT_ROOT_COLLECTION : this.options['root'];
	  this.position = 0;
	  this.readPreference = this.options.readPreference || ReadPreference.PRIMARY;
	  this.writeConcern = _getWriteConcern(db, this.options);
	  // Set default chunk size
	  this.internalChunkSize = this.options['chunkSize'] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options['chunkSize'];
	
	  Object.defineProperty(this, "chunkSize", { enumerable: true
	   , get: function () {
	       return this.internalChunkSize;
	     }
	   , set: function(value) {
	       if(!(this.mode[0] == "w" && this.position == 0 && this.uploadDate == null)) {
	         this.internalChunkSize = this.internalChunkSize;
	       } else {
	         this.internalChunkSize = value;
	       }
	     }
	  });
	
	  Object.defineProperty(this, "md5", { enumerable: true
	   , get: function () {
	       return this.internalMd5;
	     }
	  });
	
	  Object.defineProperty(this, "chunkNumber", { enumerable: true
	   , get: function () {
	       return this.currentChunk && this.currentChunk.chunkNumber ? this.currentChunk.chunkNumber : null;
	     }
	  });
	}
	
	/**
	 * The callback format for the Gridstore.open method
	 * @callback GridStore~openCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {GridStore} gridStore The GridStore instance if the open method was successful.
	 */
	
	/**
	 * Opens the file from the database and initialize this object. Also creates a
	 * new one if file does not exist.
	 *
	 * @method
	 * @param {GridStore~openCallback} callback this will be called after executing this method
	 * @return {null}
	 */
	GridStore.prototype.open = function(callback) {
	  if( this.mode != "w" && this.mode != "w+" && this.mode != "r"){
	    callback(new MongoError("Illegal mode " + this.mode), null);
	    return;
	  }
	
	  var self = this;
	
	  // Get the write concern
	  var writeConcern = _getWriteConcern(this.db, this.options);
	
	  // If we are writing we need to ensure we have the right indexes for md5's
	  if((self.mode == "w" || self.mode == "w+")) {
	    // Get files collection
	    var collection = self.collection();
	    // Put index on filename
	    collection.ensureIndex([['filename', 1]], writeConcern, function(err, index) {
	      // Get chunk collection
	      var chunkCollection = self.chunkCollection();
	      // Ensure index on chunk collection
	      chunkCollection.ensureIndex([['files_id', 1], ['n', 1]], writeConcern, function(err, index) {
	        // Open the connection
	        _open(self, writeConcern, function(err, r) {
	          if(err) return callback(err);
	          self.isOpen = true;
	          callback(err, r);
	        });
	      });
	    });
	  } else {
	    // Open the gridstore
	    _open(self, writeConcern, function(err, r) {
	      if(err) return callback(err);
	      self.isOpen = true;
	      callback(err, r);
	    });
	  }
	};
	
	/**
	 * Verify if the file is at EOF.
	 *
	 * @method
	 * @return {boolean} true if the read/write head is at the end of this file.
	 */
	GridStore.prototype.eof = function() {
	  return this.position == this.length ? true : false;
	}
	
	/**
	 * The callback result format.
	 * @callback GridStore~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object} result The result from the callback.
	 */
	
	/**
	 * Retrieves a single character from this file.
	 *
	 * @method
	 * @param {GridStore~resultCallback} callback this gets called after this method is executed. Passes null to the first parameter and the character read to the second or null to the second if the read/write head is at the end of the file.
	 * @return {null}
	 */
	GridStore.prototype.getc = function(callback) {
	  var self = this;
	
	  if(self.eof()) {
	    callback(null, null);
	  } else if(self.currentChunk.eof()) {
	    nthChunk(self, self.currentChunk.chunkNumber + 1, function(err, chunk) {
	      self.currentChunk = chunk;
	      self.position = self.position + 1;
	      callback(err, self.currentChunk.getc());
	    });
	  } else {
	    self.position = self.position + 1;
	    callback(null, self.currentChunk.getc());
	  }
	}
	
	/**
	 * Writes a string to the file with a newline character appended at the end if
	 * the given string does not have one.
	 *
	 * @method
	 * @param {string} string the string to write.
	 * @param {GridStore~resultCallback} callback this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
	 * @return {null}
	 */
	GridStore.prototype.puts = function(string, callback) {
	  var finalString = string.match(/\n$/) == null ? string + "\n" : string;
	  this.write(finalString, callback);
	}
	
	/**
	 * Return a modified Readable stream including a possible transform method.
	 *
	 * @method
	 * @return {GridStoreStream}
	 */
	GridStore.prototype.stream = function() {
	  return new GridStoreStream(this);
	}
	
	/**
	 * Writes some data. This method will work properly only if initialized with mode "w" or "w+".
	 *
	 * @method
	 * @param {(string|Buffer)} data the data to write.
	 * @param {boolean} [close] closes this file after writing if set to true.
	 * @param {GridStore~resultCallback} callback this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
	 * @return {null}
	 */
	GridStore.prototype.write = function write(data, close, callback) {
	  return _writeNormal(this, data, close, callback);
	}
	
	/**
	 * Handles the destroy part of a stream
	 *
	 * @method
	 * @result {null}
	 */
	GridStore.prototype.destroy = function destroy() {
	  // close and do not emit any more events. queued data is not sent.
	  if(!this.writable) return;
	  this.readable = false;
	  if(this.writable) {
	    this.writable = false;
	    this._q.length = 0;
	    this.emit('close');
	  }
	}
	
	/**
	 * Stores a file from the file system to the GridFS database.
	 *
	 * @method
	 * @param {(string|Buffer|FileHandle)} file the file to store.
	 * @param {GridStore~resultCallback} callback this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
	 * @return {null}
	 */
	GridStore.prototype.writeFile = function (file, callback) {
	  var self = this;
	  if (typeof file === 'string') {
	    fs.open(file, 'r', function (err, fd) {
	      if(err) return callback(err);
	      self.writeFile(fd, callback);
	    });
	    return;
	  }
	
	  self.open(function (err, self) {
	    if(err) return callback(err, self);
	
	    fs.fstat(file, function (err, stats) {
	      if(err) return callback(err, self);
	
	      var offset = 0;
	      var index = 0;
	      var numberOfChunksLeft = Math.min(stats.size / self.chunkSize);
	
	      // Write a chunk
	      var writeChunk = function() {
	        fs.read(file, self.chunkSize, offset, 'binary', function(err, data, bytesRead) {
	          if(err) return callback(err, self);
	
	          offset = offset + bytesRead;
	
	          // Create a new chunk for the data
	          var chunk = new Chunk(self, {n:index++}, self.writeConcern);
	          chunk.write(data, function(err, chunk) {
	            if(err) return callback(err, self);
	
	            chunk.save({}, function(err, result) {
	              if(err) return callback(err, self);
	
	              self.position = self.position + data.length;
	
	              // Point to current chunk
	              self.currentChunk = chunk;
	
	              if(offset >= stats.size) {
	                fs.close(file);
	                self.close(function(err, result) {
	                  if(err) return callback(err, self);
	                  return callback(null, self);
	                });
	              } else {
	                return process.nextTick(writeChunk);
	              }
	            });
	          });
	        });
	      }
	
	      // Process the first write
	      process.nextTick(writeChunk);
	    });
	  });
	};
	
	/**
	 * Saves this file to the database. This will overwrite the old entry if it
	 * already exists. This will work properly only if mode was initialized to
	 * "w" or "w+".
	 *
	 * @method
	 * @param {GridStore~resultCallback} callback this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
	 * @return {null}
	 */
	GridStore.prototype.close = function(callback) {
	  var self = this;
	
	  if(self.mode[0] == "w") {
	    // Set up options
	    var options = self.writeConcern;
	
	    if(self.currentChunk != null && self.currentChunk.position > 0) {
	      self.currentChunk.save({}, function(err, chunk) {
	        if(err && typeof callback == 'function') return callback(err);
	
	        self.collection(function(err, files) {
	          if(err && typeof callback == 'function') return callback(err);
	
	          // Build the mongo object
	          if(self.uploadDate != null) {
	            files.remove({'_id':self.fileId}, self.writeConcern, function(err, collection) {
	              if(err && typeof callback == 'function') return callback(err);
	
	              buildMongoObject(self, function(err, mongoObject) {
	                if(err) {
	                  if(typeof callback == 'function') return callback(err); else throw err;
	                }
	
	                files.save(mongoObject, options, function(err) {
	                  if(typeof callback == 'function')
	                    callback(err, mongoObject);
	                });
	              });
	            });
	          } else {
	            self.uploadDate = new Date();
	            buildMongoObject(self, function(err, mongoObject) {
	              if(err) {
	                if(typeof callback == 'function') return callback(err); else throw err;
	              }
	
	              files.save(mongoObject, options, function(err) {
	                if(typeof callback == 'function')
	                  callback(err, mongoObject);
	              });
	            });
	          }
	        });
	      });
	    } else {
	      self.collection(function(err, files) {
	        if(err && typeof callback == 'function') return callback(err);
	
	        self.uploadDate = new Date();
	        buildMongoObject(self, function(err, mongoObject) {
	          if(err) {
	            if(typeof callback == 'function') return callback(err); else throw err;
	          }
	
	          files.save(mongoObject, options, function(err) {
	            if(typeof callback == 'function')
	              callback(err, mongoObject);
	          });
	        });
	      });
	    }
	  } else if(self.mode[0] == "r") {
	    if(typeof callback == 'function')
	      callback(null, null);
	  } else {
	    if(typeof callback == 'function')
	      callback(new MongoError(f("Illegal mode %s", self.mode), null));
	  }
	};
	
	/**
	 * The collection callback format.
	 * @callback GridStore~collectionCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection} collection The collection from the command execution.
	 */
	
	/**
	 * Retrieve this file's chunks collection.
	 *
	 * @method
	 * @param {GridStore~collectionCallback} callback the command callback.
	 * @return {Collection}
	 */
	GridStore.prototype.chunkCollection = function(callback) {
	  if(typeof callback == 'function')
	    return this.db.collection((this.root + ".chunks"), callback);
	  return this.db.collection((this.root + ".chunks"));
	};
	
	/**
	 * Deletes all the chunks of this file in the database.
	 *
	 * @method
	 * @param {GridStore~resultCallback} callback the command callback.
	 * @return {null}
	 */
	GridStore.prototype.unlink = function(callback) {
	  var self = this;
	  deleteChunks(this, function(err) {
	    if(err!==null) {
	      err.message = "at deleteChunks: " + err.message;
	      return callback(err);
	    }
	
	    self.collection(function(err, collection) {
	      if(err!==null) {
	        err.message = "at collection: " + err.message;
	        return callback(err);
	      }
	
	      collection.remove({'_id':self.fileId}, self.writeConcern, function(err) {
	        callback(err, self);
	      });
	    });
	  });
	};
	
	/**
	 * Retrieves the file collection associated with this object.
	 *
	 * @method
	 * @param {GridStore~collectionCallback} callback the command callback.
	 * @return {Collection}
	 */
	GridStore.prototype.collection = function(callback) {
	  if(typeof callback == 'function')
	    this.db.collection(this.root + ".files", callback);
	  return this.db.collection(this.root + ".files");
	};
	
	/**
	 * The readlines callback format.
	 * @callback GridStore~readlinesCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {string[]} strings The array of strings returned.
	 */
	
	/**
	 * Read the entire file as a list of strings splitting by the provided separator.
	 *
	 * @method
	 * @param {string} [separator] The character to be recognized as the newline separator.
	 * @param {GridStore~readlinesCallback} callback the command callback.
	 * @return {null}
	 */
	GridStore.prototype.readlines = function(separator, callback) {
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  separator = args.length ? args.shift() : "\n";
	
	  this.read(function(err, data) {
	    if(err) return callback(err);
	
	    var items = data.toString().split(separator);
	    items = items.length > 0 ? items.splice(0, items.length - 1) : [];
	    for(var i = 0; i < items.length; i++) {
	      items[i] = items[i] + separator;
	    }
	
	    callback(null, items);
	  });
	};
	
	/**
	 * Deletes all the chunks of this file in the database if mode was set to "w" or
	 * "w+" and resets the read/write head to the initial position.
	 *
	 * @method
	 * @param {GridStore~resultCallback} callback this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
	 * @return {null}
	 */
	GridStore.prototype.rewind = function(callback) {
	  var self = this;
	
	  if(this.currentChunk.chunkNumber != 0) {
	    if(this.mode[0] == "w") {
	      deleteChunks(self, function(err, gridStore) {
	        if(err) return callback(err);
	        self.currentChunk = new Chunk(self, {'n': 0}, self.writeConcern);
	        self.position = 0;
	        callback(null, self);
	      });
	    } else {
	      self.currentChunk(0, function(err, chunk) {
	        if(err) return callback(err);
	        self.currentChunk = chunk;
	        self.currentChunk.rewind();
	        self.position = 0;
	        callback(null, self);
	      });
	    }
	  } else {
	    self.currentChunk.rewind();
	    self.position = 0;
	    callback(null, self);
	  }
	};
	
	/**
	 * The read callback format.
	 * @callback GridStore~readCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Buffer} data The data read from the GridStore object
	 */
	
	/**
	 * Retrieves the contents of this file and advances the read/write head. Works with Buffers only.
	 *
	 * There are 3 signatures for this method:
	 *
	 * (callback)
	 * (length, callback)
	 * (length, buffer, callback)
	 *
	 * @method
	 * @param {number} [length] the number of characters to read. Reads all the characters from the read/write head to the EOF if not specified.
	 * @param {(string|Buffer)} [buffer] a string to hold temporary data. This is used for storing the string data read so far when recursively calling this method.
	 * @param {GridStore~readCallback} callback the command callback.
	 * @return {null}
	 */
	GridStore.prototype.read = function(length, buffer, callback) {
	  var self = this;
	
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  length = args.length ? args.shift() : null;
	  buffer = args.length ? args.shift() : null;
	
	  // The data is a c-terminated string and thus the length - 1
	  var finalLength = length == null ? self.length - self.position : length;
	  var finalBuffer = buffer == null ? new Buffer(finalLength) : buffer;
	  // Add a index to buffer to keep track of writing position or apply current index
	  finalBuffer._index = buffer != null && buffer._index != null ? buffer._index : 0;
	
	  if((self.currentChunk.length() - self.currentChunk.position + finalBuffer._index) >= finalLength) {
	    var slice = self.currentChunk.readSlice(finalLength - finalBuffer._index);
	    // Copy content to final buffer
	    slice.copy(finalBuffer, finalBuffer._index);
	    // Update internal position
	    self.position = self.position + finalBuffer.length;
	    // Check if we don't have a file at all
	    if(finalLength == 0 && finalBuffer.length == 0) return callback(new MongoError("File does not exist"), null);
	    // Else return data
	    return callback(null, finalBuffer);
	  }
	
	  // Read the next chunk
	  var slice = self.currentChunk.readSlice(self.currentChunk.length() - self.currentChunk.position);
	  // Copy content to final buffer
	  slice.copy(finalBuffer, finalBuffer._index);
	  // Update index position
	  finalBuffer._index += slice.length;
	
	  // Load next chunk and read more
	  nthChunk(self, self.currentChunk.chunkNumber + 1, function(err, chunk) {
	    if(err) return callback(err);
	
	    if(chunk.length() > 0) {
	      self.currentChunk = chunk;
	      self.read(length, finalBuffer, callback);
	    } else {
	      if(finalBuffer._index > 0) {
	        callback(null, finalBuffer)
	      } else {
	        callback(new MongoError("no chunks found for file, possibly corrupt"), null);
	      }
	    }
	  });
	}
	
	/**
	 * The tell callback format.
	 * @callback GridStore~tellCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {number} position The current read position in the GridStore.
	 */
	
	/**
	 * Retrieves the position of the read/write head of this file.
	 *
	 * @method
	 * @param {number} [length] the number of characters to read. Reads all the characters from the read/write head to the EOF if not specified.
	 * @param {(string|Buffer)} [buffer] a string to hold temporary data. This is used for storing the string data read so far when recursively calling this method.
	 * @param {GridStore~tellCallback} callback the command callback.
	 * @return {null}
	 */
	GridStore.prototype.tell = function(callback) {
	  callback(null, this.position);
	};
	
	/**
	 * The tell callback format.
	 * @callback GridStore~gridStoreCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {GridStore} gridStore The gridStore.
	 */
	
	/**
	 * Moves the read/write head to a new location.
	 *
	 * There are 3 signatures for this method
	 *
	 * Seek Location Modes
	 *  - **GridStore.IO_SEEK_SET**, **(default)** set the position from the start of the file.
	 *  - **GridStore.IO_SEEK_CUR**, set the position from the current position in the file.
	 *  - **GridStore.IO_SEEK_END**, set the position from the end of the file.
	 *
	 * @method
	 * @param {number} [position] the position to seek to
	 * @param {number} [seekLocation] seek mode. Use one of the Seek Location modes.
	 * @param {GridStore~gridStoreCallback} callback the command callback.
	 * @return {null}
	 */
	GridStore.prototype.seek = function(position, seekLocation, callback) {
	  var self = this;
	
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  seekLocation = args.length ? args.shift() : null;
	
	  // Seek only supports read mode
	  if(self.mode != 'r') {
	    return callback(new MongoError("seek is only supported for mode r"))
	  }
	
	  var seekLocationFinal = seekLocation == null ? GridStore.IO_SEEK_SET : seekLocation;
	  var finalPosition = position;
	  var targetPosition = 0;
	
	  // Calculate the position
	  if(seekLocationFinal == GridStore.IO_SEEK_CUR) {
	    targetPosition = self.position + finalPosition;
	  } else if(seekLocationFinal == GridStore.IO_SEEK_END) {
	    targetPosition = self.length + finalPosition;
	  } else {
	    targetPosition = finalPosition;
	  }
	
	  // Get the chunk
	  var newChunkNumber = Math.floor(targetPosition/self.chunkSize);
	  var seekChunk = function() {
	    nthChunk(self, newChunkNumber, function(err, chunk) {
	      self.currentChunk = chunk;
	      self.position = targetPosition;
	      self.currentChunk.position = (self.position % self.chunkSize);
	      callback(err, self);
	    });
	  };
	
	  seekChunk();
	}
	
	/**
	 * @ignore
	 */
	var _open = function(self, options, callback) {
	  var collection = self.collection();
	  // Create the query
	  var query = self.referenceBy == REFERENCE_BY_ID ? {_id:self.fileId} : {filename:self.filename};
	  query = null == self.fileId && self.filename == null ? null : query;
	  options.readPreference = self.readPreference;
	
	  // Fetch the chunks
	  if(query != null) {
	    collection.findOne(query, options, function(err, doc) {
	      if(err) return error(err);
	
	      // Check if the collection for the files exists otherwise prepare the new one
	      if(doc != null) {
	        self.fileId = doc._id;
	        // Prefer a new filename over the existing one if this is a write
	        self.filename = ((self.mode == 'r') || (self.filename == undefined)) ? doc.filename : self.filename;
	        self.contentType = doc.contentType;
	        self.internalChunkSize = doc.chunkSize;
	        self.uploadDate = doc.uploadDate;
	        self.aliases = doc.aliases;
	        self.length = doc.length;
	        self.metadata = doc.metadata;
	        self.internalMd5 = doc.md5;
	      } else if (self.mode != 'r') {
	        self.fileId = self.fileId == null ? new ObjectID() : self.fileId;
	        self.contentType = GridStore.DEFAULT_CONTENT_TYPE;
	        self.internalChunkSize = self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;
	        self.length = 0;
	      } else {
	         self.length = 0;
	         var txtId = self.fileId instanceof ObjectID ? self.fileId.toHexString() : self.fileId;
	         return error(new MongoError(f("file with id %s not opened for writing", (self.referenceBy == REFERENCE_BY_ID ? txtId : self.filename))), self);
	      }
	
	      // Process the mode of the object
	      if(self.mode == "r") {
	        nthChunk(self, 0, options, function(err, chunk) {
	          if(err) return error(err);
	          self.currentChunk = chunk;
	          self.position = 0;
	          callback(null, self);
	        });
	      } else if(self.mode == "w") {
	        // Delete any existing chunks
	        deleteChunks(self, options, function(err, result) {
	          if(err) return error(err);
	          self.currentChunk = new Chunk(self, {'n':0}, self.writeConcern);
	          self.contentType = self.options['content_type'] == null ? self.contentType : self.options['content_type'];
	          self.internalChunkSize = self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];
	          self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
	          self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
	          self.position = 0;
	          callback(null, self);
	        });
	      } else if(self.mode == "w+") {
	        nthChunk(self, lastChunkNumber(self), options, function(err, chunk) {
	          if(err) return error(err);
	          // Set the current chunk
	          self.currentChunk = chunk == null ? new Chunk(self, {'n':0}, self.writeConcern) : chunk;
	          self.currentChunk.position = self.currentChunk.data.length();
	          self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
	          self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
	          self.position = self.length;
	          callback(null, self);
	        });
	      }
	    });
	  } else {
	    // Write only mode
	    self.fileId = null == self.fileId ? new ObjectID() : self.fileId;
	    self.contentType = GridStore.DEFAULT_CONTENT_TYPE;
	    self.internalChunkSize = self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;
	    self.length = 0;
	
	    var collection2 = self.chunkCollection();
	    // No file exists set up write mode
	    if(self.mode == "w") {
	      // Delete any existing chunks
	      deleteChunks(self, options, function(err, result) {
	        if(err) return error(err);
	        self.currentChunk = new Chunk(self, {'n':0}, self.writeConcern);
	        self.contentType = self.options['content_type'] == null ? self.contentType : self.options['content_type'];
	        self.internalChunkSize = self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];
	        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
	        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
	        self.position = 0;
	        callback(null, self);
	      });
	    } else if(self.mode == "w+") {
	      nthChunk(self, lastChunkNumber(self), options, function(err, chunk) {
	        if(err) return error(err);
	        // Set the current chunk
	        self.currentChunk = chunk == null ? new Chunk(self, {'n':0}, self.writeConcern) : chunk;
	        self.currentChunk.position = self.currentChunk.data.length();
	        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
	        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
	        self.position = self.length;
	        callback(null, self);
	      });
	    }
	  }
	
	  // only pass error to callback once
	  function error (err) {
	    if(error.err) return;
	    callback(error.err = err);
	  }
	};
	
	/**
	 * @ignore
	 */
	var writeBuffer = function(self, buffer, close, callback) {
	  if(typeof close === "function") { callback = close; close = null; }
	  var finalClose = typeof close == 'boolean' ? close : false;
	
	  if(self.mode != "w") {
	    callback(new MongoError(f("file with id %s not opened for writing", (self.referenceBy == REFERENCE_BY_ID ? self.referenceBy : self.filename))), null);
	  } else {
	    if(self.currentChunk.position + buffer.length >= self.chunkSize) {
	      // Write out the current Chunk and then keep writing until we have less data left than a chunkSize left
	      // to a new chunk (recursively)
	      var previousChunkNumber = self.currentChunk.chunkNumber;
	      var leftOverDataSize = self.chunkSize - self.currentChunk.position;
	      var firstChunkData = buffer.slice(0, leftOverDataSize);
	      var leftOverData = buffer.slice(leftOverDataSize);
	      // A list of chunks to write out
	      var chunksToWrite = [self.currentChunk.write(firstChunkData)];
	      // If we have more data left than the chunk size let's keep writing new chunks
	      while(leftOverData.length >= self.chunkSize) {
	        // Create a new chunk and write to it
	        var newChunk = new Chunk(self, {'n': (previousChunkNumber + 1)}, self.writeConcern);
	        var firstChunkData = leftOverData.slice(0, self.chunkSize);
	        leftOverData = leftOverData.slice(self.chunkSize);
	        // Update chunk number
	        previousChunkNumber = previousChunkNumber + 1;
	        // Write data
	        newChunk.write(firstChunkData);
	        // Push chunk to save list
	        chunksToWrite.push(newChunk);
	      }
	
	      // Set current chunk with remaining data
	      self.currentChunk = new Chunk(self, {'n': (previousChunkNumber + 1)}, self.writeConcern);
	      // If we have left over data write it
	      if(leftOverData.length > 0) self.currentChunk.write(leftOverData);
	
	      // Update the position for the gridstore
	      self.position = self.position + buffer.length;
	      // Total number of chunks to write
	      var numberOfChunksToWrite = chunksToWrite.length;
	
	      for(var i = 0; i < chunksToWrite.length; i++) {
	        chunksToWrite[i].save({}, function(err, result) {
	          if(err) return callback(err);
	
	          numberOfChunksToWrite = numberOfChunksToWrite - 1;
	
	          if(numberOfChunksToWrite <= 0) {
	            // We care closing the file before returning
	            if(finalClose) {
	              return self.close(function(err, result) {
	                callback(err, self);
	              });
	            }
	
	            // Return normally
	            return callback(null, self);
	          }
	        });
	      }
	    } else {
	      // Update the position for the gridstore
	      self.position = self.position + buffer.length;
	      // We have less data than the chunk size just write it and callback
	      self.currentChunk.write(buffer);
	      // We care closing the file before returning
	      if(finalClose) {
	        return self.close(function(err, result) {
	          callback(err, self);
	        });
	      }
	      // Return normally
	      return callback(null, self);
	    }
	  }
	};
	
	/**
	 * Creates a mongoDB object representation of this object.
	 *
	 *        <pre><code>
	 *        {
	 *          '_id' : , // {number} id for this file
	 *          'filename' : , // {string} name for this file
	 *          'contentType' : , // {string} mime type for this file
	 *          'length' : , // {number} size of this file?
	 *          'chunksize' : , // {number} chunk size used by this file
	 *          'uploadDate' : , // {Date}
	 *          'aliases' : , // {array of string}
	 *          'metadata' : , // {string}
	 *        }
	 *        </code></pre>
	 *
	 * @ignore
	 */
	var buildMongoObject = function(self, callback) {
	  // Calcuate the length
	  var mongoObject = {
	    '_id': self.fileId,
	    'filename': self.filename,
	    'contentType': self.contentType,
	    'length': self.position ? self.position : 0,
	    'chunkSize': self.chunkSize,
	    'uploadDate': self.uploadDate,
	    'aliases': self.aliases,
	    'metadata': self.metadata
	  };
	
	  var md5Command = {filemd5:self.fileId, root:self.root};
	  self.db.command(md5Command, function(err, results) {
	    if(err) return callback(err);
	
	    mongoObject.md5 = results.md5;
	    callback(null, mongoObject);
	  });
	};
	
	/**
	 * Gets the nth chunk of this file.
	 * @ignore
	 */
	var nthChunk = function(self, chunkNumber, options, callback) {
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  options = options || self.writeConcern;
	  options.readPreference = self.readPreference;
	  // Get the nth chunk
	  self.chunkCollection().findOne({'files_id':self.fileId, 'n':chunkNumber}, options, function(err, chunk) {
	    if(err) return callback(err);
	
	    var finalChunk = chunk == null ? {} : chunk;
	    callback(null, new Chunk(self, finalChunk, self.writeConcern));
	  });
	};
	
	/**
	 * @ignore
	 */
	var lastChunkNumber = function(self) {
	  return Math.floor((self.length ? self.length - 1 : 0)/self.chunkSize);
	};
	
	/**
	 * Deletes all the chunks of this file in the database.
	 *
	 * @ignore
	 */
	var deleteChunks = function(self, options, callback) {
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  options = options || self.writeConcern;
	
	  if(self.fileId != null) {
	    self.chunkCollection().remove({'files_id':self.fileId}, options, function(err, result) {
	      if(err) return callback(err, false);
	      callback(null, true);
	    });
	  } else {
	    callback(null, true);
	  }
	};
	
	/**
	* The collection to be used for holding the files and chunks collection.
	*
	* @classconstant DEFAULT_ROOT_COLLECTION
	**/
	GridStore.DEFAULT_ROOT_COLLECTION = 'fs';
	
	/**
	* Default file mime type
	*
	* @classconstant DEFAULT_CONTENT_TYPE
	**/
	GridStore.DEFAULT_CONTENT_TYPE = 'binary/octet-stream';
	
	/**
	* Seek mode where the given length is absolute.
	*
	* @classconstant IO_SEEK_SET
	**/
	GridStore.IO_SEEK_SET = 0;
	
	/**
	* Seek mode where the given length is an offset to the current read/write head.
	*
	* @classconstant IO_SEEK_CUR
	**/
	GridStore.IO_SEEK_CUR = 1;
	
	/**
	* Seek mode where the given length is an offset to the end of the file.
	*
	* @classconstant IO_SEEK_END
	**/
	GridStore.IO_SEEK_END = 2;
	
	/**
	 * Checks if a file exists in the database.
	 *
	 * @method
	 * @static
	 * @param {Db} db the database to query.
	 * @param {string} name The name of the file to look for.
	 * @param {string} [rootCollection] The root collection that holds the files and chunks collection. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {GridStore~resultCallback} callback result from exists.
	 * @return {null}
	 */
	GridStore.exist = function(db, fileIdObject, rootCollection, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  rootCollection = args.length ? args.shift() : null;
	  options = args.length ? args.shift() : {};
	
	  // Establish read preference
	  var readPreference = options.readPreference || ReadPreference.PRIMARY;
	  // Fetch collection
	  var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
	  db.collection(rootCollectionFinal + ".files", function(err, collection) {
	    if(err) return callback(err);
	
	    // Build query
	    var query = (typeof fileIdObject == 'string' || Object.prototype.toString.call(fileIdObject) == '[object RegExp]' )
	      ? {'filename':fileIdObject}
	      : {'_id':fileIdObject};    // Attempt to locate file
	
	    // We have a specific query
	    if(fileIdObject != null 
	      && typeof fileIdObject == 'object' 
	      && Object.prototype.toString.call(fileIdObject) != '[object RegExp]') {
	      query = fileIdObject;
	    }
	
	    // Check if the entry exists
	    collection.findOne(query, {readPreference:readPreference}, function(err, item) {
	      if(err) return callback(err);
	      callback(null, item == null ? false : true);
	    });
	  });
	};
	
	/**
	 * Gets the list of files stored in the GridFS.
	 *
	 * @method
	 * @static
	 * @param {Db} db the database to query.
	 * @param {string} [rootCollection] The root collection that holds the files and chunks collection. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {GridStore~resultCallback} callback result from exists.
	 * @return {null}
	 */
	GridStore.list = function(db, rootCollection, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  rootCollection = args.length ? args.shift() : null;
	  options = args.length ? args.shift() : {};
	
	  // Ensure we have correct values
	  if(rootCollection != null && typeof rootCollection == 'object') {
	    options = rootCollection;
	    rootCollection = null;
	  }
	
	  // Establish read preference
	  var readPreference = options.readPreference || ReadPreference.PRIMARY;
	  // Check if we are returning by id not filename
	  var byId = options['id'] != null ? options['id'] : false;
	  // Fetch item
	  var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
	  var items = [];
	  db.collection((rootCollectionFinal + ".files"), function(err, collection) {
	    if(err) return callback(err);
	
	    collection.find({}, {readPreference:readPreference}, function(err, cursor) {
	      if(err) return callback(err);
	
	      cursor.each(function(err, item) {
	        if(item != null) {
	          items.push(byId ? item._id : item.filename);
	        } else {
	          callback(err, items);
	        }
	      });
	    });
	  });
	};
	
	/**
	 * Reads the contents of a file.
	 *
	 * This method has the following signatures
	 *
	 * (db, name, callback)
	 * (db, name, length, callback)
	 * (db, name, length, offset, callback)
	 * (db, name, length, offset, options, callback)
	 *
	 * @method
	 * @static
	 * @param {Db} db the database to query.
	 * @param {string} name The name of the file.
	 * @param {number} [length] The size of data to read.
	 * @param {number} [offset] The offset from the head of the file of which to start reading from.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {GridStore~readCallback} callback the command callback.
	 * @return {null}
	 */
	
	GridStore.read = function(db, name, length, offset, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  length = args.length ? args.shift() : null;
	  offset = args.length ? args.shift() : null;
	  options = args.length ? args.shift() : null;
	
	  new GridStore(db, name, "r", options).open(function(err, gridStore) {
	    if(err) return callback(err);
	    // Make sure we are not reading out of bounds
	    if(offset && offset >= gridStore.length) return callback("offset larger than size of file", null);
	    if(length && length > gridStore.length) return callback("length is larger than the size of the file", null);
	    if(offset && length && (offset + length) > gridStore.length) return callback("offset and length is larger than the size of the file", null);
	
	    if(offset != null) {
	      gridStore.seek(offset, function(err, gridStore) {
	        if(err) return callback(err);
	        gridStore.read(length, callback);
	      });
	    } else {
	      gridStore.read(length, callback);
	    }
	  });
	};
	
	/**
	 * Read the entire file as a list of strings splitting by the provided separator.
	 *
	 * @method
	 * @static
	 * @param {Db} db the database to query.
	 * @param {(String|object)} name the name of the file.
	 * @param {string} [separator] The character to be recognized as the newline separator.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {GridStore~readlinesCallback} callback the command callback.
	 * @return {null}
	 */
	GridStore.readlines = function(db, name, separator, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  separator = args.length ? args.shift() : null;
	  options = args.length ? args.shift() : null;
	
	  var finalSeperator = separator == null ? "\n" : separator;
	  new GridStore(db, name, "r", options).open(function(err, gridStore) {
	    if(err) return callback(err);
	    gridStore.readlines(finalSeperator, callback);
	  });
	};
	
	/**
	 * Deletes the chunks and metadata information of a file from GridFS.
	 *
	 * @method
	 * @static
	 * @param {Db} db The database to query.
	 * @param {(string|array)} names The name/names of the files to delete.
	 * @param {object} [options=null] Optional settings.
	 * @param {GridStore~resultCallback} callback the command callback.
	 * @return {null}
	 */
	GridStore.unlink = function(db, names, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  options = args.length ? args.shift() : {};
	
	  // Get the write concern
	  var writeConcern = _getWriteConcern(db, options);
	
	  // List of names
	  if(names.constructor == Array) {
	    var tc = 0;
	    for(var i = 0; i < names.length; i++) {
	      ++tc;
	      GridStore.unlink(db, names[i], options, function(result) {
	        if(--tc == 0) {
	            callback(null, self);
	        }
	      });
	    }
	  } else {
	    new GridStore(db, names, "w", options).open(function(err, gridStore) {
	      if(err) return callback(err);
	      deleteChunks(gridStore, function(err, result) {
	        if(err) return callback(err);
	        gridStore.collection(function(err, collection) {
	          if(err) return callback(err);
	          collection.remove({'_id':gridStore.fileId}, writeConcern, function(err, result) {
	            callback(err, self);
	          });
	        });
	      });
	    });
	  }
	};
	
	/**
	 *  @ignore
	 */
	var _writeNormal = function(self, data, close, callback) {
	  // If we have a buffer write it using the writeBuffer method
	  if(Buffer.isBuffer(data)) {
	    return writeBuffer(self, data, close, callback);
	  } else {
	    return writeBuffer(self, new Buffer(data, 'binary'), close, callback);
	  }
	}
	
	/**
	 * @ignore
	 */
	var _setWriteConcernHash = function(options) {
	  var finalOptions = {};
	  if(options.w != null) finalOptions.w = options.w;
	  if(options.journal == true) finalOptions.j = options.journal;
	  if(options.j == true) finalOptions.j = options.j;
	  if(options.fsync == true) finalOptions.fsync = options.fsync;
	  if(options.wtimeout != null) finalOptions.wtimeout = options.wtimeout;
	  return finalOptions;
	}
	
	/**
	 * @ignore
	 */
	var _getWriteConcern = function(self, options) {
	  // Final options
	  var finalOptions = {w:1};
	  options = options || {};
	
	  // Local options verification
	  if(options.w != null || typeof options.j == 'boolean' || typeof options.journal == 'boolean' || typeof options.fsync == 'boolean') {
	    finalOptions = _setWriteConcernHash(options);
	  } else if(options.safe != null && typeof options.safe == 'object') {
	    finalOptions = _setWriteConcernHash(options.safe);
	  } else if(typeof options.safe == "boolean") {
	    finalOptions = {w: (options.safe ? 1 : 0)};
	  } else if(self.options.w != null || typeof self.options.j == 'boolean' || typeof self.options.journal == 'boolean' || typeof self.options.fsync == 'boolean') {
	    finalOptions = _setWriteConcernHash(self.options);
	  } else if(self.safe && (self.safe.w != null || typeof self.safe.j == 'boolean' || typeof self.safe.journal == 'boolean' || typeof self.safe.fsync == 'boolean')) {
	    finalOptions = _setWriteConcernHash(self.safe);
	  } else if(typeof self.safe == "boolean") {
	    finalOptions = {w: (self.safe ? 1 : 0)};
	  }
	
	  // Ensure we don't have an invalid combination of write concerns
	  if(finalOptions.w < 1
	    && (finalOptions.journal == true || finalOptions.j == true || finalOptions.fsync == true)) throw new MongoError("No acknowledgement using w < 1 cannot be combined with journal:true or fsync:true");
	
	  // Return the options
	  return finalOptions;
	}
	
	/**
	 * Create a new GridStoreStream instance (INTERNAL TYPE, do not instantiate directly)
	 *
	 * @class
	 * @extends external:Duplex
	 * @return {GridStoreStream} a GridStoreStream instance.
	 */
	var GridStoreStream = function(gs) {
	  var self = this;
	  // Initialize the duplex stream
	  Duplex.call(this);
	
	  // Get the gridstore
	  this.gs = gs;
	
	  // End called
	  this.endCalled = false;
	
	  // If we have a seek
	  this.totalBytesToRead = this.gs.length - this.gs.position;
	  this.seekPosition = this.gs.position;
	}
	
	//
	// Inherit duplex
	inherits(GridStoreStream, Duplex);
	
	GridStoreStream.prototype._pipe = GridStoreStream.prototype.pipe;
	
	// Set up override
	GridStoreStream.prototype.pipe = function(destination) {
	  var self = this;
	
	  // Only open gridstore if not already open
	  if(!self.gs.isOpen) {
	    self.gs.open(function(err) {
	      if(err) return self.emit('error', err);
	      self.totalBytesToRead = self.gs.length - self.gs.position;
	      self._pipe.apply(self, [destination]);
	    });
	  } else {
	    self.totalBytesToRead = self.gs.length - self.gs.position;
	    self._pipe.apply(self, [destination]);    
	  }
	}
	
	// Called by stream
	GridStoreStream.prototype._read = function(n) {
	  var self = this;
	
	  var read = function() {
	    // Read data
	    self.gs.read(length, function(err, buffer) {
	      if(err && !self.endCalled) return self.emit('error', err);
	
	      // Stream is closed
	      if(self.endCalled || buffer == null) return self.push(null);
	      // Remove bytes read
	      if(buffer.length <= self.totalBytesToRead) {
	        self.totalBytesToRead = self.totalBytesToRead - buffer.length;
	        self.push(buffer);
	      } else if(buffer.length > self.totalBytesToRead) {
	        self.totalBytesToRead = self.totalBytesToRead - buffer._index;
	        self.push(buffer.slice(0, buffer._index));
	      }
	
	      // Finished reading
	      if(self.totalBytesToRead <= 0) {
	        self.endCalled = true;
	      }
	    });    
	  }
	
	  // Set read length
	  var length = self.gs.length < self.gs.chunkSize ? self.gs.length - self.seekPosition : self.gs.chunkSize;
	  if(!self.gs.isOpen) {
	    self.gs.open(function(err, gs) {
	      self.totalBytesToRead = self.gs.length - self.gs.position;
	      if(err) return self.emit('error', err);
	      read();
	    });
	  } else {
	    read();
	  }
	}
	
	GridStoreStream.prototype.destroy = function() {
	  this.pause();
	  this.endCalled = true;
	  this.gs.close();
	  this.emit('end');
	}
	
	GridStoreStream.prototype.write = function(chunk, encoding, callback) {
	  var self = this;
	  if(self.endCalled) return self.emit('error', new MongoError('attempting to write to stream after end called'))
	  // Do we have to open the gridstore
	  if(!self.gs.isOpen) {
	    self.gs.open(function() {
	      self.gs.isOpen = true;
	      self.gs.write(chunk, function() {
	        process.nextTick(function() {
	          self.emit('drain');
	        });
	      });
	    });
	    return false;
	  } else {
	    self.gs.write(chunk, function() {
	      self.emit('drain');
	    });
	    return true;
	  }
	}
	
	GridStoreStream.prototype.end = function(chunk, encoding, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  chunk = args.length ? args.shift() : null;
	  encoding = args.length ? args.shift() : null;
	  self.endCalled = true;
	
	  if(chunk) {
	    self.gs.write(chunk, function() {
	      self.gs.close(function() {
	        if(typeof callback == 'function') callback();
	        self.emit('end')
	      });
	    });
	  }
	
	  self.gs.close(function() {
	    if(typeof callback == 'function') callback();
	    self.emit('end')
	  });
	}
	
	/**
	 * The read() method pulls some data out of the internal buffer and returns it. If there is no data available, then it will return null.
	 * @function external:Duplex#read
	 * @param {number} size Optional argument to specify how much data to read.
	 * @return {(String | Buffer | null)}
	 */
	
	/**
	 * Call this function to cause the stream to return strings of the specified encoding instead of Buffer objects.
	 * @function external:Duplex#setEncoding
	 * @param {string} encoding The encoding to use.
	 * @return {null}
	 */
	
	/**
	 * This method will cause the readable stream to resume emitting data events.
	 * @function external:Duplex#resume
	 * @return {null}
	 */
	
	/**
	 * This method will cause a stream in flowing-mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.
	 * @function external:Duplex#pause
	 * @return {null}
	 */
	
	/**
	 * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.
	 * @function external:Duplex#pipe
	 * @param {Writable} destination The destination for writing data
	 * @param {object} [options] Pipe options
	 * @return {null}
	 */
	
	/**
	 * This method will remove the hooks set up for a previous pipe() call.
	 * @function external:Duplex#unpipe
	 * @param {Writable} [destination] The destination for writing data
	 * @return {null}
	 */
	
	/**
	 * This is useful in certain cases where a stream is being consumed by a parser, which needs to "un-consume" some data that it has optimistically pulled out of the source, so that the stream can be passed on to some other party.
	 * @function external:Duplex#unshift
	 * @param {(Buffer|string)} chunk Chunk of data to unshift onto the read queue.
	 * @return {null}
	 */
	
	/**
	 * Versions of Node prior to v0.10 had streams that did not implement the entire Streams API as it is today. (See "Compatibility" below for more information.)
	 * @function external:Duplex#wrap
	 * @param {Stream} stream An "old style" readable stream.
	 * @return {null}
	 */
	
	/**
	 * This method writes some data to the underlying system, and calls the supplied callback once the data has been fully handled.
	 * @function external:Duplex#write
	 * @param {(string|Buffer)} chunk The data to write
	 * @param {string} encoding The encoding, if chunk is a String
	 * @param {function} callback Callback for when this chunk of data is flushed
	 * @return {boolean}
	 */
	
	/**
	 * Call this method when no more data will be written to the stream. If supplied, the callback is attached as a listener on the finish event.
	 * @function external:Duplex#end
	 * @param {(string|Buffer)} chunk The data to write
	 * @param {string} encoding The encoding, if chunk is a String
	 * @param {function} callback Callback for when this chunk of data is flushed
	 * @return {null}
	 */
	
	/**
	 * GridStoreStream stream data event, fired for each document in the cursor.
	 *
	 * @event GridStoreStream#data
	 * @type {object}
	 */
	
	/**
	 * GridStoreStream stream end event
	 *
	 * @event GridStoreStream#end
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream close event
	 *
	 * @event GridStoreStream#close
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream readable event
	 *
	 * @event GridStoreStream#readable
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream drain event
	 *
	 * @event GridStoreStream#drain
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream finish event
	 *
	 * @event GridStoreStream#finish
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream pipe event
	 *
	 * @event GridStoreStream#pipe
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream unpipe event
	 *
	 * @event GridStoreStream#unpipe
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream error event
	 *
	 * @event GridStoreStream#error
	 * @type {null}
	 */
	
	/**
	 * @ignore
	 */
	module.exports = GridStore;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 161 */
/*!**************************************************!*\
  !*** ./~/mongoose/~/mongodb/lib/gridfs/chunk.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";
	
	var Binary = __webpack_require__(/*! mongodb-core */ 76).BSON.Binary,
	  ObjectID = __webpack_require__(/*! mongodb-core */ 76).BSON.ObjectID;
	
	/**
	 * Class for representing a single chunk in GridFS.
	 *
	 * @class
	 *
	 * @param file {GridStore} The {@link GridStore} object holding this chunk.
	 * @param mongoObject {object} The mongo object representation of this chunk.
	 *
	 * @throws Error when the type of data field for {@link mongoObject} is not
	 *     supported. Currently supported types for data field are instances of
	 *     {@link String}, {@link Array}, {@link Binary} and {@link Binary}
	 *     from the bson module
	 *
	 * @see Chunk#buildMongoObject
	 */
	var Chunk = function(file, mongoObject, writeConcern) {
	  if(!(this instanceof Chunk)) return new Chunk(file, mongoObject);
	
	  this.file = file;
	  var self = this;
	  var mongoObjectFinal = mongoObject == null ? {} : mongoObject;
	  this.writeConcern = writeConcern || {w:1};
	  this.objectId = mongoObjectFinal._id == null ? new ObjectID() : mongoObjectFinal._id;
	  this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;
	  this.data = new Binary();
	
	  if(mongoObjectFinal.data == null) {
	  } else if(typeof mongoObjectFinal.data == "string") {
	    var buffer = new Buffer(mongoObjectFinal.data.length);
	    buffer.write(mongoObjectFinal.data, 'binary', 0);
	    this.data = new Binary(buffer);
	  } else if(Array.isArray(mongoObjectFinal.data)) {
	    var buffer = new Buffer(mongoObjectFinal.data.length);
	    buffer.write(mongoObjectFinal.data.join(''), 'binary', 0);
	    this.data = new Binary(buffer);
	  } else if(mongoObjectFinal.data._bsontype === 'Binary') {
	    this.data = mongoObjectFinal.data;
	  } else if(Buffer.isBuffer(mongoObjectFinal.data)) {
	  } else {
	    throw Error("Illegal chunk format");
	  }
	  
	  // Update position
	  this.internalPosition = 0;
	};
	
	/**
	 * Writes a data to this object and advance the read/write head.
	 *
	 * @param data {string} the data to write 
	 * @param callback {function(*, GridStore)} This will be called after executing
	 *     this method. The first parameter will contain null and the second one
	 *     will contain a reference to this object.
	 */
	Chunk.prototype.write = function(data, callback) {
	  this.data.write(data, this.internalPosition);
	  this.internalPosition = this.data.length();
	  if(callback != null) return callback(null, this);
	  return this;
	};
	
	/**
	 * Reads data and advances the read/write head.
	 *
	 * @param length {number} The length of data to read.
	 *
	 * @return {string} The data read if the given length will not exceed the end of
	 *     the chunk. Returns an empty String otherwise.
	 */
	Chunk.prototype.read = function(length) {
	  // Default to full read if no index defined
	  length = length == null || length == 0 ? this.length() : length;
	
	  if(this.length() - this.internalPosition + 1 >= length) {
	    var data = this.data.read(this.internalPosition, length);
	    this.internalPosition = this.internalPosition + length;
	    return data;
	  } else {
	    return '';
	  }
	};
	
	Chunk.prototype.readSlice = function(length) {
	  if ((this.length() - this.internalPosition) >= length) {
	    var data = null;
	    if (this.data.buffer != null) { //Pure BSON
	      data = this.data.buffer.slice(this.internalPosition, this.internalPosition + length);
	    } else { //Native BSON
	      data = new Buffer(length);
	      length = this.data.readInto(data, this.internalPosition);
	    }
	    this.internalPosition = this.internalPosition + length;
	    return data;
	  } else {
	    return null;
	  }
	};
	
	/**
	 * Checks if the read/write head is at the end.
	 *
	 * @return {boolean} Whether the read/write head has reached the end of this
	 *     chunk.
	 */
	Chunk.prototype.eof = function() {
	  return this.internalPosition == this.length() ? true : false;
	};
	
	/**
	 * Reads one character from the data of this chunk and advances the read/write
	 * head.
	 *
	 * @return {string} a single character data read if the the read/write head is
	 *     not at the end of the chunk. Returns an empty String otherwise.
	 */
	Chunk.prototype.getc = function() {
	  return this.read(1);
	};
	
	/**
	 * Clears the contents of the data in this chunk and resets the read/write head
	 * to the initial position.
	 */
	Chunk.prototype.rewind = function() {
	  this.internalPosition = 0;
	  this.data = new Binary();
	};
	
	/**
	 * Saves this chunk to the database. Also overwrites existing entries having the
	 * same id as this chunk.
	 *
	 * @param callback {function(*, GridStore)} This will be called after executing
	 *     this method. The first parameter will contain null and the second one
	 *     will contain a reference to this object.
	 */
	Chunk.prototype.save = function(options, callback) {
	  var self = this;
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  self.file.chunkCollection(function(err, collection) {
	    if(err) return callback(err);
	
	    // Merge the options
	    var writeOptions = {};
	    for(var name in options) writeOptions[name] = options[name];
	    for(var name in self.writeConcern) writeOptions[name] = self.writeConcern[name];    
	
	    // collection.remove({'_id':self.objectId}, self.writeConcern, function(err, result) {
	    collection.remove({'_id':self.objectId}, writeOptions, function(err, result) {
	      if(err) return callback(err);
	
	      if(self.data.length() > 0) {
	        self.buildMongoObject(function(mongoObject) {
	          var options = {forceServerObjectId:true};
	          for(var name in self.writeConcern) {
	            options[name] = self.writeConcern[name];
	          }
	
	          collection.insert(mongoObject, writeOptions, function(err, collection) {
	            callback(err, self);
	          });
	        });
	      } else {
	        callback(null, self);
	      }
	    });
	  });
	};
	
	/**
	 * Creates a mongoDB object representation of this chunk.
	 *
	 * @param callback {function(Object)} This will be called after executing this 
	 *     method. The object will be passed to the first parameter and will have
	 *     the structure:
	 *        
	 *        <pre><code>
	 *        {
	 *          '_id' : , // {number} id for this chunk
	 *          'files_id' : , // {number} foreign key to the file collection
	 *          'n' : , // {number} chunk number
	 *          'data' : , // {bson#Binary} the chunk data itself
	 *        }
	 *        </code></pre>
	 *
	 * @see <a href="http://www.mongodb.org/display/DOCS/GridFS+Specification#GridFSSpecification-{{chunks}}">MongoDB GridFS Chunk Object Structure</a>
	 */
	Chunk.prototype.buildMongoObject = function(callback) {
	  var mongoObject = {
	    'files_id': this.file.fileId,
	    'n': this.chunkNumber,
	    'data': this.data};
	  // If we are saving using a specific ObjectId
	  if(this.objectId != null) mongoObject._id = this.objectId;
	
	  callback(mongoObject);
	};
	
	/**
	 * @return {number} the length of the data
	 */
	Chunk.prototype.length = function() {
	  return this.data.length();
	};
	
	/**
	 * The position of the read/write head
	 * @name position
	 * @lends Chunk#
	 * @field
	 */
	Object.defineProperty(Chunk.prototype, "position", { enumerable: true
	  , get: function () {
	      return this.internalPosition;
	    }
	  , set: function(value) {
	      this.internalPosition = value;
	    }
	});
	
	/**
	 * The default chunk size
	 * @constant
	 */
	Chunk.DEFAULT_CHUNK_SIZE = 1024 * 255;
	
	module.exports = Chunk;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 162 */
/*!**************************************************************!*\
  !*** ./~/mongoose/lib/drivers/node-mongodb-native/binary.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var Binary = __webpack_require__(/*! mongodb */ 72).Binary;
	
	module.exports = exports = Binary;


/***/ },
/* 163 */
/*!******************************************************************!*\
  !*** ./~/mongoose/lib/drivers/node-mongodb-native/collection.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var MongooseCollection = __webpack_require__(/*! ../../collection */ 164)
	  , Collection = __webpack_require__(/*! mongodb */ 72).Collection
	  , STATES = __webpack_require__(/*! ../../connectionstate */ 165)
	  , utils = __webpack_require__(/*! ../../utils */ 42)
	
	/**
	 * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) collection implementation.
	 *
	 * All methods methods from the [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver are copied and wrapped in queue management.
	 *
	 * @inherits Collection
	 * @api private
	 */
	
	function NativeCollection () {
	  this.collection = null;
	  MongooseCollection.apply(this, arguments);
	}
	
	/*!
	 * Inherit from abstract Collection.
	 */
	
	NativeCollection.prototype.__proto__ = MongooseCollection.prototype;
	
	/**
	 * Called when the connection opens.
	 *
	 * @api private
	 */
	
	NativeCollection.prototype.onOpen = function () {
	  var self = this;
	
	  // always get a new collection in case the user changed host:port
	  // of parent db instance when re-opening the connection.
	
	  if (!self.opts.capped.size) {
	    // non-capped
	    return self.conn.db.collection(self.name, callback);
	  }
	
	  // capped
	  return self.conn.db.collection(self.name, function (err, c) {
	    if (err) return callback(err);
	
	    // discover if this collection exists and if it is capped
	    self.conn.db.listCollections({ name: self.name }).toArray(function(err, docs) {
	      if (err) {
	        return callback(err);
	      }
	      var doc = docs[0];
	      var exists = !!doc;
	
	      if (exists) {
	        if (doc.options && doc.options.capped) {
	          callback(null, c);
	        } else {
	          var msg = 'A non-capped collection exists with the name: '+ self.name +'\n\n'
	                  + ' To use this collection as a capped collection, please '
	                  + 'first convert it.\n'
	                  + ' http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-Convertingacollectiontocapped'
	          err = new Error(msg);
	          callback(err);
	        }
	      } else {
	        // create
	        var opts = utils.clone(self.opts.capped);
	        opts.capped = true;
	        self.conn.db.createCollection(self.name, opts, callback);
	      }
	    });
	  });
	
	  function callback (err, collection) {
	    if (err) {
	      // likely a strict mode error
	      self.conn.emit('error', err);
	    } else {
	      self.collection = collection;
	      MongooseCollection.prototype.onOpen.call(self);
	    }
	  };
	};
	
	/**
	 * Called when the connection closes
	 *
	 * @api private
	 */
	
	NativeCollection.prototype.onClose = function () {
	  MongooseCollection.prototype.onClose.call(this);
	};
	
	/*!
	 * Copy the collection methods and make them subject to queues
	 */
	
	for (var i in Collection.prototype) {
	  (function(i){
	    NativeCollection.prototype[i] = function () {
	      if (this.buffer) {
	        this.addQueue(i, arguments);
	        return;
	      }
	
	      var collection = this.collection
	        , args = arguments
	        , self = this
	        , debug = self.conn.base.options.debug;
	
	      if (debug) {
	        if ('function' === typeof debug) {
	          debug.apply(debug
	            , [self.name, i].concat(utils.args(args, 0, args.length-1)));
	        } else {
	          console.error('\x1B[0;36mMongoose:\x1B[0m %s.%s(%s) %s %s %s'
	            , self.name
	            , i
	            , print(args[0])
	            , print(args[1])
	            , print(args[2])
	            , print(args[3]))
	        }
	      }
	
	      return collection[i].apply(collection, args);
	    };
	  })(i);
	}
	
	/*!
	 * Debug print helper
	 */
	
	function print (arg) {
	  var type = typeof arg;
	  if ('function' === type || 'undefined' === type) return '';
	  return format(arg);
	}
	
	/*!
	 * Debug print helper
	 */
	
	function format (obj, sub) {
	  var x = utils.clone(obj, { retainKeyOrder: 1 });
	  if (x) {
	    if ('Binary' === x.constructor.name) {
	      x = '[object Buffer]';
	    } else if ('ObjectID' === x.constructor.name) {
	      var representation = 'ObjectId("' + x.toHexString() + '")';
	      x = { inspect: function() { return representation; } };
	    } else if ('Date' === x.constructor.name) {
	      var representation = 'new Date("' + x.toUTCString() + '")';
	      x = { inspect: function() { return representation; } };
	    } else if ('Object' === x.constructor.name) {
	      var keys = Object.keys(x);
	      var numKeys = keys.length;
	      var key;
	      for (var i = 0; i < numKeys; ++i) {
	        key = keys[i];
	        if (x[key]) {
	          if ('Binary' === x[key].constructor.name) {
	            x[key] = '[object Buffer]';
	          } else if ('Object' === x[key].constructor.name) {
	            x[key] = format(x[key], true);
	          } else if ('ObjectID' === x[key].constructor.name) {
	            ;(function(x){
	              var representation = 'ObjectId("' + x[key].toHexString() + '")';
	              x[key] = { inspect: function() { return representation; } };
	            })(x)
	          } else if ('Date' === x[key].constructor.name) {
	            ;(function(x){
	              var representation = 'new Date("' + x[key].toUTCString() + '")';
	              x[key] = { inspect: function() { return representation; } };
	            })(x)
	          } else if (Array.isArray(x[key])) {
	            x[key] = x[key].map(function (o) {
	              return format(o, true)
	            });
	          }
	        }
	      }
	    }
	    if (sub) return x;
	  }
	
	  return __webpack_require__(/*! util */ 57)
	    .inspect(x, false, 10, true)
	    .replace(/\n/g, '')
	    .replace(/\s{2,}/g, ' ')
	}
	
	/**
	 * Retreives information about this collections indexes.
	 *
	 * @param {Function} callback
	 * @method getIndexes
	 * @api public
	 */
	
	NativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;
	
	/*!
	 * Module exports.
	 */
	
	module.exports = NativeCollection;


/***/ },
/* 164 */
/*!**************************************!*\
  !*** ./~/mongoose/lib/collection.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var STATES = __webpack_require__(/*! ./connectionstate */ 165)
	
	/**
	 * Abstract Collection constructor
	 *
	 * This is the base class that drivers inherit from and implement.
	 *
	 * @param {String} name name of the collection
	 * @param {Connection} conn A MongooseConnection instance
	 * @param {Object} opts optional collection options
	 * @api public
	 */
	
	function Collection (name, conn, opts) {
	  if (undefined === opts) opts = {};
	  if (undefined === opts.capped) opts.capped = {};
	
	  opts.bufferCommands = undefined === opts.bufferCommands
	    ? true
	    : opts.bufferCommands;
	
	  if ('number' == typeof opts.capped) {
	    opts.capped = { size: opts.capped };
	  }
	
	  this.opts = opts;
	  this.name = name;
	  this.conn = conn;
	  this.queue = [];
	  this.buffer = this.opts.bufferCommands;
	
	  if (STATES.connected == this.conn.readyState) {
	    this.onOpen();
	  }
	};
	
	/**
	 * The collection name
	 *
	 * @api public
	 * @property name
	 */
	
	Collection.prototype.name;
	
	/**
	 * The Connection instance
	 *
	 * @api public
	 * @property conn
	 */
	
	Collection.prototype.conn;
	
	/**
	 * Called when the database connects
	 *
	 * @api private
	 */
	
	Collection.prototype.onOpen = function () {
	  var self = this;
	  this.buffer = false;
	  self.doQueue();
	};
	
	/**
	 * Called when the database disconnects
	 *
	 * @api private
	 */
	
	Collection.prototype.onClose = function () {
	  if (this.opts.bufferCommands) {
	    this.buffer = true;
	  }
	};
	
	/**
	 * Queues a method for later execution when its
	 * database connection opens.
	 *
	 * @param {String} name name of the method to queue
	 * @param {Array} args arguments to pass to the method when executed
	 * @api private
	 */
	
	Collection.prototype.addQueue = function (name, args) {
	  this.queue.push([name, args]);
	  return this;
	};
	
	/**
	 * Executes all queued methods and clears the queue.
	 *
	 * @api private
	 */
	
	Collection.prototype.doQueue = function () {
	  for (var i = 0, l = this.queue.length; i < l; i++){
	    this[this.queue[i][0]].apply(this, this.queue[i][1]);
	  }
	  this.queue = [];
	  return this;
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.ensureIndex = function(){
	  throw new Error('Collection#ensureIndex unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.findAndModify = function(){
	  throw new Error('Collection#findAndModify unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.findOne = function(){
	  throw new Error('Collection#findOne unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.find = function(){
	  throw new Error('Collection#find unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.insert = function(){
	  throw new Error('Collection#insert unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.save = function(){
	  throw new Error('Collection#save unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.update = function(){
	  throw new Error('Collection#update unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.getIndexes = function(){
	  throw new Error('Collection#getIndexes unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.mapReduce = function(){
	  throw new Error('Collection#mapReduce unimplemented by driver');
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = Collection;


/***/ },
/* 165 */
/*!*******************************************!*\
  !*** ./~/mongoose/lib/connectionstate.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Connection states
	 */
	
	var STATES = module.exports = exports = Object.create(null);
	
	var disconnected = 'disconnected';
	var connected = 'connected';
	var connecting = 'connecting';
	var disconnecting = 'disconnecting';
	var unauthorized = 'unauthorized';
	var uninitialized = 'uninitialized';
	
	STATES[0] = disconnected;
	STATES[1] = connected;
	STATES[2] = connecting;
	STATES[3] = disconnecting;
	STATES[4] = unauthorized;
	STATES[99] = uninitialized;
	
	STATES[disconnected] = 0;
	STATES[connected] = 1;
	STATES[connecting] = 2;
	STATES[disconnecting] = 3;
	STATES[unauthorized] = 4;
	STATES[uninitialized] = 99;


/***/ },
/* 166 */
/*!******************************************************************!*\
  !*** ./~/mongoose/lib/drivers/node-mongodb-native/connection.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseConnection = __webpack_require__(/*! ../../connection */ 167)
	  , mongo = __webpack_require__(/*! mongodb */ 72)
	  , Db = mongo.Db
	  , Server = mongo.Server
	  , Mongos = mongo.Mongos
	  , STATES = __webpack_require__(/*! ../../connectionstate */ 165)
	  , ReplSetServers = mongo.ReplSet
	  , utils = __webpack_require__(/*! ../../utils */ 42);
	
	/**
	 * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.
	 *
	 * @inherits Connection
	 * @api private
	 */
	
	function NativeConnection() {
	  MongooseConnection.apply(this, arguments);
	  this._listening = false;
	};
	
	/**
	 * Expose the possible connection states.
	 * @api public
	 */
	
	NativeConnection.STATES = STATES;
	
	/*!
	 * Inherits from Connection.
	 */
	
	NativeConnection.prototype.__proto__ = MongooseConnection.prototype;
	
	/**
	 * Opens the connection to MongoDB.
	 *
	 * @param {Function} fn
	 * @return {Connection} this
	 * @api private
	 */
	
	NativeConnection.prototype.doOpen = function (fn) {
	  if (this.db) {
	    mute(this);
	  }
	
	  var server = new Server(this.host, this.port, this.options.server);
	  this.db = new Db(this.name, server, this.options.db);
	
	  var self = this;
	  this.db.open(function (err) {
	    if (err) return fn(err);
	    listen(self);
	    fn();
	  });
	
	  return this;
	};
	
	/**
	 * Switches to a different database using the same connection pool.
	 *
	 * Returns a new connection object, with the new db.
	 *
	 * @param {String} name The database name
	 * @return {Connection} New Connection Object
	 * @api public
	 */
	
	NativeConnection.prototype.useDb = function (name) {
	  // we have to manually copy all of the attributes...
	  var newConn = new this.constructor();
	  newConn.name = name;
	  newConn.base = this.base;
	  newConn.collections = {};
	  newConn.models = {};
	  newConn.replica = this.replica;
	  newConn.hosts = this.hosts;
	  newConn.host = this.host;
	  newConn.port = this.port;
	  newConn.user = this.user;
	  newConn.pass = this.pass;
	  newConn.options = this.options;
	  newConn._readyState = this._readyState;
	  newConn._closeCalled = this._closeCalled;
	  newConn._hasOpened = this._hasOpened;
	  newConn._listening = false;
	
	  // First, when we create another db object, we are not guaranteed to have a
	  // db object to work with. So, in the case where we have a db object and it
	  // is connected, we can just proceed with setting everything up. However, if
	  // we do not have a db or the state is not connected, then we need to wait on
	  // the 'open' event of the connection before doing the rest of the setup
	  // the 'connected' event is the first time we'll have access to the db object
	
	  var self = this;
	
	  if (this.db && this._readyState === STATES.connected) {
	    wireup();
	  } else {
	    this.once('connected', wireup);
	  }
	
	  function wireup () {
	    newConn.db = self.db.db(name);
	    newConn.onOpen();
	    // setup the events appropriately
	    listen(newConn);
	  }
	
	  newConn.name = name;
	
	  // push onto the otherDbs stack, this is used when state changes
	  this.otherDbs.push(newConn);
	  newConn.otherDbs.push(this);
	
	  return newConn;
	};
	
	/*!
	 * Register listeners for important events and bubble appropriately.
	 */
	
	function listen (conn) {
	  if (conn._listening) return;
	  conn._listening = true;
	
	  conn.db.on('close', function(){
	    if (conn._closeCalled) return;
	
	    // the driver never emits an `open` event. auto_reconnect still
	    // emits a `close` event but since we never get another
	    // `open` we can't emit close
	    if (conn.db.serverConfig.autoReconnect) {
	      conn.readyState = STATES.disconnected;
	      conn.emit('close');
	      return;
	    }
	    conn.onClose();
	  });
	  conn.db.on('error', function(err){
	    conn.emit('error', err);
	  });
	  conn.db.on('reconnect', function() {
	    conn.readyState = STATES.connected;
	    conn.emit('reconnected');
	  });
	  conn.db.on('timeout', function(err){
	    var error = new Error(err && err.err || 'connection timeout');
	    conn.emit('error', error);
	  });
	  conn.db.on('open', function (err, db) {
	    if (STATES.disconnected === conn.readyState && db && db.databaseName) {
	      conn.readyState = STATES.connected;
	      conn.emit('reconnected');
	    }
	  });
	  conn.db.on('parseError', function(err) {
	    conn.emit('parseError', err);
	  });
	}
	
	/*!
	 * Remove listeners registered in `listen`
	 */
	
	function mute (conn) {
	  if (!conn.db) throw new Error('missing db');
	  conn.db.removeAllListeners("close");
	  conn.db.removeAllListeners("error");
	  conn.db.removeAllListeners("timeout");
	  conn.db.removeAllListeners("open");
	  conn.db.removeAllListeners("fullsetup");
	  conn._listening = false;
	}
	
	/**
	 * Opens a connection to a MongoDB ReplicaSet.
	 *
	 * See description of [doOpen](#NativeConnection-doOpen) for server options. In this case `options.replset` is also passed to ReplSetServers.
	 *
	 * @param {Function} fn
	 * @api private
	 * @return {Connection} this
	 */
	
	NativeConnection.prototype.doOpenSet = function (fn) {
	  if (this.db) {
	    mute(this);
	  }
	
	  var servers = []
	    , self = this;
	
	  this.hosts.forEach(function (server) {
	    var host = server.host || server.ipc;
	    var port = server.port || 27017;
	    servers.push(new Server(host, port, self.options.server));
	  })
	
	  var server = this.options.mongos
	    ? new Mongos(servers, this.options.mongos)
	    : new ReplSetServers(servers, this.options.replset);
	  this.db = new Db(this.name, server, this.options.db);
	
	  this.db.on('fullsetup', function () {
	    self.emit('fullsetup')
	  });
	
	  this.db.open(function (err) {
	    if (err) return fn(err);
	    fn();
	    listen(self);
	  });
	
	  return this;
	};
	
	/**
	 * Closes the connection
	 *
	 * @param {Function} fn
	 * @return {Connection} this
	 * @api private
	 */
	
	NativeConnection.prototype.doClose = function (fn) {
	  this.db.close();
	  if (fn) fn();
	  return this;
	}
	
	/**
	 * Prepares default connection options for the node-mongodb-native driver.
	 *
	 * _NOTE: `passed` options take precedence over connection string options._
	 *
	 * @param {Object} passed options that were passed directly during connection
	 * @param {Object} [connStrOptions] options that were passed in the connection string
	 * @api private
	 */
	
	NativeConnection.prototype.parseOptions = function (passed, connStrOpts) {
	  var o = passed || {};
	  o.db || (o.db = {});
	  o.auth || (o.auth = {});
	  o.server || (o.server = {});
	  o.replset || (o.replset = {});
	  o.server.socketOptions || (o.server.socketOptions = {});
	  o.replset.socketOptions || (o.replset.socketOptions = {});
	
	  var opts = connStrOpts || {};
	  Object.keys(opts).forEach(function (name) {
	    switch (name) {
	      case 'ssl':
	      case 'poolSize':
	        if ('undefined' == typeof o.server[name]) {
	          o.server[name] = o.replset[name] = opts[name];
	        }
	        break;
	      case 'slaveOk':
	        if ('undefined' == typeof o.server.slave_ok) {
	          o.server.slave_ok = opts[name];
	        }
	        break;
	      case 'autoReconnect':
	        if ('undefined' == typeof o.server.auto_reconnect) {
	          o.server.auto_reconnect = opts[name];
	        }
	        break;
	      case 'socketTimeoutMS':
	      case 'connectTimeoutMS':
	        if ('undefined' == typeof o.server.socketOptions[name]) {
	          o.server.socketOptions[name] = o.replset.socketOptions[name] = opts[name];
	        }
	        break;
	      case 'authdb':
	        if ('undefined' == typeof o.auth.authdb) {
	          o.auth.authdb = opts[name];
	        }
	        break;
	      case 'authSource':
	        if ('undefined' == typeof o.auth.authSource) {
	          o.auth.authSource = opts[name];
	        }
	        break;
	      case 'retries':
	      case 'reconnectWait':
	      case 'rs_name':
	        if ('undefined' == typeof o.replset[name]) {
	          o.replset[name] = opts[name];
	        }
	        break;
	      case 'replicaSet':
	        if ('undefined' == typeof o.replset.rs_name) {
	          o.replset.rs_name = opts[name];
	        }
	        break;
	      case 'readSecondary':
	        if ('undefined' == typeof o.replset.read_secondary) {
	          o.replset.read_secondary = opts[name];
	        }
	        break;
	      case 'nativeParser':
	        if ('undefined' == typeof o.db.native_parser) {
	          o.db.native_parser = opts[name];
	        }
	        break;
	      case 'w':
	      case 'safe':
	      case 'fsync':
	      case 'journal':
	      case 'wtimeoutMS':
	        if ('undefined' == typeof o.db[name]) {
	          o.db[name] = opts[name];
	        }
	        break;
	      case 'readPreference':
	        if ('undefined' == typeof o.db.read_preference) {
	          o.db.read_preference = opts[name];
	        }
	        break;
	      case 'readPreferenceTags':
	        if ('undefined' == typeof o.db.read_preference_tags) {
	          o.db.read_preference_tags = opts[name];
	        }
	        break;
	    }
	  })
	
	  if (!('auto_reconnect' in o.server)) {
	    o.server.auto_reconnect = true;
	  }
	
	  if (!o.db.read_preference) {
	    // read from primaries by default
	    o.db.read_preference = 'primary';
	  }
	
	  // mongoose creates its own ObjectIds
	  o.db.forceServerObjectId = false;
	
	  // default safe using new nomenclature
	  if (!('journal' in o.db || 'j' in o.db ||
	        'fsync' in o.db || 'safe' in o.db || 'w' in o.db)) {
	    o.db.w = 1;
	  }
	
	  validate(o);
	  return o;
	}
	
	/*!
	 * Validates the driver db options.
	 *
	 * @param {Object} o
	 */
	
	function validate (o) {
	  if (-1 === o.db.w || 0 === o.db.w) {
	    if (o.db.journal || o.db.fsync || o.db.safe) {
	      throw new Error(
	          'Invalid writeConcern: '
	        + 'w set to -1 or 0 cannot be combined with safe|fsync|journal');
	    }
	  }
	}
	
	/*!
	 * Module exports.
	 */
	
	module.exports = NativeConnection;


/***/ },
/* 167 */
/*!**************************************!*\
  !*** ./~/mongoose/lib/connection.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * Module dependencies.
	 */
	
	var url = __webpack_require__(/*! url */ 168)
	  , utils = __webpack_require__(/*! ./utils */ 42)
	  , EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter
	  , driver = global.MONGOOSE_DRIVER_PATH || 'node-mongodb-native'
	  , Model = __webpack_require__(/*! ./model */ 174)
	  , Schema = __webpack_require__(/*! ./schema */ 41)
	  , Collection  = __webpack_require__(/*! ./drivers */ 219)("./" + driver + '/collection')
	  , STATES = __webpack_require__(/*! ./connectionstate */ 165)
	  , MongooseError = __webpack_require__(/*! ./error */ 32)
	  , assert =__webpack_require__(/*! assert */ 205)
	  , muri = __webpack_require__(/*! muri */ 220)
	
	/*!
	 * Protocol prefix regexp.
	 *
	 * @api private
	 */
	
	var rgxProtocol = /^(?:.)+:\/\//;
	
	/**
	 * Connection constructor
	 *
	 * For practical reasons, a Connection equals a Db.
	 *
	 * @param {Mongoose} base a mongoose instance
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `connecting`: Emitted when `connection.{open,openSet}()` is executed on this connection.
	 * @event `connected`: Emitted when this connection successfully connects to the db. May be emitted _multiple_ times in `reconnected` scenarios.
	 * @event `open`: Emitted after we `connected` and `onOpen` is executed on all of this connections models.
	 * @event `disconnecting`: Emitted when `connection.close()` was executed.
	 * @event `disconnected`: Emitted after getting disconnected from the db.
	 * @event `close`: Emitted after we `disconnected` and `onClose` executed on all of this connections models.
	 * @event `reconnected`: Emitted after we `connected` and subsequently `disconnected`, followed by successfully another successfull connection.
	 * @event `error`: Emitted when an error occurs on this connection.
	 * @event `fullsetup`: Emitted in a replica-set scenario, when all nodes specified in the connection string are connected.
	 * @api public
	 */
	
	function Connection (base) {
	  this.base = base;
	  this.collections = {};
	  this.models = {};
	  this.config = {autoIndex: true};
	  this.replica = false;
	  this.hosts = null;
	  this.host = null;
	  this.port = null;
	  this.user = null;
	  this.pass = null;
	  this.name = null;
	  this.options = null;
	  this.otherDbs = [];
	  this._readyState = STATES.disconnected;
	  this._closeCalled = false;
	  this._hasOpened = false;
	};
	
	/*!
	 * Inherit from EventEmitter
	 */
	
	Connection.prototype.__proto__ = EventEmitter.prototype;
	
	/**
	 * Connection ready state
	 *
	 * - 0 = disconnected
	 * - 1 = connected
	 * - 2 = connecting
	 * - 3 = disconnecting
	 *
	 * Each state change emits its associated event name.
	 *
	 * ####Example
	 *
	 *     conn.on('connected', callback);
	 *     conn.on('disconnected', callback);
	 *
	 * @property readyState
	 * @api public
	 */
	
	Object.defineProperty(Connection.prototype, 'readyState', {
	    get: function(){ return this._readyState; }
	  , set: function (val) {
	      if (!(val in STATES)) {
	        throw new Error('Invalid connection state: ' + val);
	      }
	
	      if (this._readyState !== val) {
	        this._readyState = val;
	        // loop over the otherDbs on this connection and change their state
	        for (var i=0; i < this.otherDbs.length; i++) {
	          this.otherDbs[i].readyState = val;
	        }
	
	        if (STATES.connected === val)
	          this._hasOpened = true;
	
	        this.emit(STATES[val]);
	      }
	    }
	});
	
	/**
	 * A hash of the collections associated with this connection
	 *
	 * @property collections
	 */
	
	Connection.prototype.collections;
	
	/**
	 * The mongodb.Db instance, set when the connection is opened
	 *
	 * @property db
	 */
	
	Connection.prototype.db;
	
	/**
	 * A hash of the global options that are associated with this connection
	 *
	 * @property global
	 */
	
	Connection.prototype.config;
	
	/**
	 * Opens the connection to MongoDB.
	 *
	 * `options` is a hash with the following possible properties:
	 *
	 *     config  - passed to the connection config instance
	 *     db      - passed to the connection db instance
	 *     server  - passed to the connection server instance(s)
	 *     replset - passed to the connection ReplSet instance
	 *     user    - username for authentication
	 *     pass    - password for authentication
	 *     auth    - options for authentication (see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate)
	 *
	 * ####Notes:
	 *
	 * Mongoose forces the db option `forceServerObjectId` false and cannot be overridden.
	 * Mongoose defaults the server `auto_reconnect` options to true which can be overridden.
	 * See the node-mongodb-native driver instance for options that it understands.
	 *
	 * _Options passed take precedence over options included in connection strings._
	 *
	 * @param {String} connection_string mongodb://uri or the host to which you are connecting
	 * @param {String} [database] database name
	 * @param {Number} [port] database port
	 * @param {Object} [options] options
	 * @param {Function} [callback]
	 * @see node-mongodb-native https://github.com/mongodb/node-mongodb-native
	 * @see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate
	 * @api public
	 */
	
	Connection.prototype.open = function (host, database, port, options, callback) {
	  var self = this
	    , parsed
	    , uri;
	
	  if ('string' === typeof database) {
	    switch (arguments.length) {
	      case 2:
	        port = 27017;
	      case 3:
	        switch (typeof port) {
	          case 'function':
	            callback = port, port = 27017;
	            break;
	          case 'object':
	            options = port, port = 27017;
	            break;
	        }
	        break;
	      case 4:
	        if ('function' === typeof options)
	          callback = options, options = {};
	    }
	  } else {
	    switch (typeof database) {
	      case 'function':
	        callback = database, database = undefined;
	        break;
	      case 'object':
	        options = database;
	        database = undefined;
	        callback = port;
	        break;
	    }
	
	    if (!rgxProtocol.test(host)) {
	      host = 'mongodb://' + host;
	    }
	
	    try {
	      parsed = muri(host);
	    } catch (err) {
	      this.error(err, callback);
	      return this;
	    }
	
	    database = parsed.db;
	    host = parsed.hosts[0].host || parsed.hosts[0].ipc;
	    port = parsed.hosts[0].port || 27017;
	  }
	
	  this.options = this.parseOptions(options, parsed && parsed.options);
	
	  // make sure we can open
	  if (STATES.disconnected !== this.readyState) {
	    var err = new Error('Trying to open unclosed connection.');
	    err.state = this.readyState;
	    this.error(err, callback);
	    return this;
	  }
	
	  if (!host) {
	    this.error(new Error('Missing hostname.'), callback);
	    return this;
	  }
	
	  if (!database) {
	    this.error(new Error('Missing database name.'), callback);
	    return this;
	  }
	
	  // authentication
	  if (options && options.user && options.pass) {
	    this.user = options.user;
	    this.pass = options.pass;
	
	  } else if (parsed && parsed.auth) {
	    this.user = parsed.auth.user;
	    this.pass = parsed.auth.pass;
	
	  // Check hostname for user/pass
	  } else if (/@/.test(host) && /:/.test(host.split('@')[0])) {
	    host = host.split('@');
	    var auth = host.shift().split(':');
	    host = host.pop();
	    this.user = auth[0];
	    this.pass = auth[1];
	
	  } else {
	    this.user = this.pass = undefined;
	  }
	
	  // global configuration options
	  if (options && options.config) {
	    if (options.config.autoIndex === false){
	      this.config.autoIndex = false;
	    }
	    else {
	      this.config.autoIndex = true;
	    }
	
	  }
	
	  this.name = database;
	  this.host = host;
	  this.port = port;
	
	  this._open(callback);
	  return this;
	};
	
	/**
	 * Opens the connection to a replica set.
	 *
	 * ####Example:
	 *
	 *     var db = mongoose.createConnection();
	 *     db.openSet("mongodb://user:pwd@localhost:27020/testing,mongodb://example.com:27020,mongodb://localhost:27019");
	 *
	 * The database name and/or auth need only be included in one URI.
	 * The `options` is a hash which is passed to the internal driver connection object.
	 *
	 * Valid `options`
	 *
	 *     db      - passed to the connection db instance
	 *     server  - passed to the connection server instance(s)
	 *     replset - passed to the connection ReplSetServer instance
	 *     user    - username for authentication
	 *     pass    - password for authentication
	 *     auth    - options for authentication (see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate)
	 *     mongos  - Boolean - if true, enables High Availability support for mongos
	 *
	 * _Options passed take precedence over options included in connection strings._
	 *
	 * ####Notes:
	 *
	 * _If connecting to multiple mongos servers, set the `mongos` option to true._
	 *
	 *     conn.open('mongodb://mongosA:27501,mongosB:27501', { mongos: true }, cb);
	 *
	 * Mongoose forces the db option `forceServerObjectId` false and cannot be overridden.
	 * Mongoose defaults the server `auto_reconnect` options to true which can be overridden.
	 * See the node-mongodb-native driver instance for options that it understands.
	 *
	 * _Options passed take precedence over options included in connection strings._
	 *
	 * @param {String} uris comma-separated mongodb:// `URI`s
	 * @param {String} [database] database name if not included in `uris`
	 * @param {Object} [options] passed to the internal driver
	 * @param {Function} [callback]
	 * @see node-mongodb-native https://github.com/mongodb/node-mongodb-native
	 * @see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate
	 * @api public
	 */
	
	Connection.prototype.openSet = function (uris, database, options, callback) {
	  if (!rgxProtocol.test(uris)) {
	    uris = 'mongodb://' + uris;
	  }
	
	  var self = this;
	
	  switch (arguments.length) {
	    case 3:
	      switch (typeof database) {
	        case 'string':
	          this.name = database;
	          break;
	        case 'object':
	          callback = options;
	          options = database;
	          database = null;
	          break;
	      }
	
	      if ('function' === typeof options) {
	        callback = options;
	        options = {};
	      }
	      break;
	    case 2:
	      switch (typeof database) {
	        case 'string':
	          this.name = database;
	          break;
	        case 'function':
	          callback = database, database = null;
	          break;
	        case 'object':
	          options = database, database = null;
	          break;
	      }
	  }
	
	  var parsed;
	  try {
	    parsed = muri(uris);
	  } catch (err) {
	    this.error(err, callback);
	    return this;
	  }
	
	  if (!this.name) {
	    this.name = parsed.db;
	  }
	
	  this.hosts = parsed.hosts;
	  this.options = this.parseOptions(options, parsed && parsed.options);
	  this.replica = true;
	
	  if (!this.name) {
	    this.error(new Error('No database name provided for replica set'), callback);
	    return this;
	  }
	
	  // authentication
	  if (options && options.user && options.pass) {
	    this.user = options.user;
	    this.pass = options.pass;
	
	  } else if (parsed && parsed.auth) {
	    this.user = parsed.auth.user;
	    this.pass = parsed.auth.pass;
	
	  } else {
	    this.user = this.pass = undefined;
	  }
	
	  // global configuration options
	  if (options && options.config) {
	    if (options.config.autoIndex === false){
	      this.config.autoIndex = false;
	    }
	    else {
	      this.config.autoIndex = true;
	    }
	
	  }
	
	  this._open(callback);
	  return this;
	};
	
	/**
	 * error
	 *
	 * Graceful error handling, passes error to callback
	 * if available, else emits error on the connection.
	 *
	 * @param {Error} err
	 * @param {Function} callback optional
	 * @api private
	 */
	
	Connection.prototype.error = function (err, callback) {
	  if (callback) return callback(err);
	  this.emit('error', err);
	}
	
	/**
	 * Handles opening the connection with the appropriate method based on connection type.
	 *
	 * @param {Function} callback
	 * @api private
	 */
	
	Connection.prototype._open = function (callback) {
	  this.readyState = STATES.connecting;
	  this._closeCalled = false;
	
	  var self = this;
	
	  var method = this.replica
	    ? 'doOpenSet'
	    : 'doOpen';
	
	  // open connection
	  this[method](function (err) {
	    if (err) {
	      self.readyState = STATES.disconnected;
	      if (self._hasOpened) {
	        if (callback) callback(err);
	      } else {
	        self.error(err, callback);
	      }
	      return;
	    }
	
	    self.onOpen(callback);
	  });
	}
	
	/**
	 * Called when the connection is opened
	 *
	 * @api private
	 */
	
	Connection.prototype.onOpen = function (callback) {
	  var self = this;
	
	  function open(err, isAuth) {
	    if (err) {
	      self.readyState = isAuth ? STATES.unauthorized : STATES.disconnected;
	      if (self._hasOpened) {
	        if (callback) callback(err);
	      } else {
	        self.error(err, callback);
	      }
	      return;
	    }
	
	    self.readyState = STATES.connected;
	
	    // avoid having the collection subscribe to our event emitter
	    // to prevent 0.3 warning
	    for (var i in self.collections)
	      self.collections[i].onOpen();
	
	    callback && callback();
	    self.emit('open');
	  };
	
	  // re-authenticate
	  if (self.user && self.pass) {
	    self.db.authenticate(self.user, self.pass, self.options.auth, function(err) {
	      open(err, true);
	    });
	  } else {
	    open();
	  }
	};
	
	/**
	 * Closes the connection
	 *
	 * @param {Function} [callback] optional
	 * @return {Connection} self
	 * @api public
	 */
	
	Connection.prototype.close = function (callback) {
	  var self = this;
	  this._closeCalled = true;
	
	  switch (this.readyState){
	    case 0: // disconnected
	      callback && callback();
	      break;
	
	    case 1: // connected
	    case 4: // unauthorized
	      this.readyState = STATES.disconnecting;
	      this.doClose(function(err){
	        if (err){
	          self.error(err, callback);
	        } else {
	          self.onClose();
	          callback && callback();
	        }
	      });
	      break;
	
	    case 2: // connecting
	      this.once('open', function(){
	        self.close(callback);
	      });
	      break;
	
	    case 3: // disconnecting
	      if (!callback) break;
	      this.once('close', function () {
	        callback();
	      });
	      break;
	  }
	
	  return this;
	};
	
	/**
	 * Called when the connection closes
	 *
	 * @api private
	 */
	
	Connection.prototype.onClose = function () {
	  this.readyState = STATES.disconnected;
	
	  // avoid having the collection subscribe to our event emitter
	  // to prevent 0.3 warning
	  for (var i in this.collections)
	    this.collections[i].onClose();
	
	  this.emit('close');
	};
	
	/**
	 * Retrieves a collection, creating it if not cached.
	 *
	 * Not typically needed by applications. Just talk to your collection through your model.
	 *
	 * @param {String} name of the collection
	 * @param {Object} [options] optional collection options
	 * @return {Collection} collection instance
	 * @api public
	 */
	
	Connection.prototype.collection = function (name, options) {
	  if (!(name in this.collections))
	    this.collections[name] = new Collection(name, this, options);
	  return this.collections[name];
	};
	
	/**
	 * Defines or retrieves a model.
	 *
	 *     var mongoose = require('mongoose');
	 *     var db = mongoose.createConnection(..);
	 *     db.model('Venue', new Schema(..));
	 *     var Ticket = db.model('Ticket', new Schema(..));
	 *     var Venue = db.model('Venue');
	 *
	 * _When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the [utils.toCollectionName](#utils_exports.toCollectionName) method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option._
	 *
	 * ####Example:
	 *
	 *     var schema = new Schema({ name: String }, { collection: 'actor' });
	 *
	 *     // or
	 *
	 *     schema.set('collection', 'actor');
	 *
	 *     // or
	 *
	 *     var collectionName = 'actor'
	 *     var M = conn.model('Actor', schema, collectionName)
	 *
	 * @param {String} name the model name
	 * @param {Schema} [schema] a schema. necessary when defining a model
	 * @param {String} [collection] name of mongodb collection (optional) if not given it will be induced from model name
	 * @see Mongoose#model #index_Mongoose-model
	 * @return {Model} The compiled model
	 * @api public
	 */
	
	Connection.prototype.model = function (name, schema, collection) {
	  // collection name discovery
	  if ('string' == typeof schema) {
	    collection = schema;
	    schema = false;
	  }
	
	  if (utils.isObject(schema) && !(schema instanceof Schema)) {
	    schema = new Schema(schema);
	  }
	
	  if (this.models[name] && !collection) {
	    // model exists but we are not subclassing with custom collection
	    if (schema instanceof Schema && schema != this.models[name].schema) {
	      throw new MongooseError.OverwriteModelError(name);
	    }
	    return this.models[name];
	  }
	
	  var opts = { cache: false, connection: this }
	  var model;
	
	  if (schema instanceof Schema) {
	    // compile a model
	    model = this.base.model(name, schema, collection, opts)
	
	    // only the first model with this name is cached to allow
	    // for one-offs with custom collection names etc.
	    if (!this.models[name]) {
	      this.models[name] = model;
	    }
	
	    model.init();
	    return model;
	  }
	
	  if (this.models[name] && collection) {
	    // subclassing current model with alternate collection
	    model = this.models[name];
	    schema = model.prototype.schema;
	    var sub = model.__subclass(this, schema, collection);
	    // do not cache the sub model
	    return sub;
	  }
	
	  // lookup model in mongoose module
	  model = this.base.models[name];
	
	  if (!model) {
	    throw new MongooseError.MissingSchemaError(name);
	  }
	
	  if (this == model.prototype.db
	      && (!collection || collection == model.collection.name)) {
	    // model already uses this connection.
	
	    // only the first model with this name is cached to allow
	    // for one-offs with custom collection names etc.
	    if (!this.models[name]) {
	      this.models[name] = model;
	    }
	
	    return model;
	  }
	
	  return this.models[name] = model.__subclass(this, schema, collection);
	};
	
	/**
	 * Returns an array of model names created on this connection.
	 * @api public
	 * @return {Array}
	 */
	
	Connection.prototype.modelNames = function () {
	  return Object.keys(this.models);
	};
	
	/*!
	 * Noop.
	 */
	
	function noop () {}
	
	/*!
	 * Module exports.
	 */
	
	Connection.STATES = STATES;
	module.exports = Connection;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 168 */
/*!******************************************!*\
  !*** ./~/node-libs-browser/~/url/url.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var punycode = __webpack_require__(/*! punycode */ 169);
	
	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;
	
	exports.Url = Url;
	
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}
	
	// Reference: RFC 3986, RFC 1808, RFC 2396
	
	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,
	
	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
	
	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
	
	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(/*! querystring */ 171);
	
	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;
	
	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}
	
	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }
	
	  var rest = url;
	
	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();
	
	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }
	
	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }
	
	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {
	
	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c
	
	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.
	
	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	
	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }
	
	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }
	
	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;
	
	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);
	
	    // pull out port.
	    this.parseHost();
	
	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';
	
	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';
	
	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }
	
	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }
	
	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }
	
	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;
	
	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }
	
	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {
	
	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }
	
	
	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }
	
	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }
	
	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};
	
	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}
	
	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }
	
	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';
	
	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }
	
	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }
	
	  var search = this.search || (query && ('?' + query)) || '';
	
	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';
	
	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }
	
	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;
	
	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');
	
	  return protocol + host + pathname + search + hash;
	};
	
	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}
	
	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};
	
	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}
	
	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }
	
	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);
	
	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;
	
	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }
	
	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });
	
	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }
	
	    result.href = result.format();
	    return result;
	  }
	
	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }
	
	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }
	
	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];
	
	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }
	
	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');
	
	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }
	
	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }
	
	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }
	
	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');
	
	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }
	
	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);
	
	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }
	
	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }
	
	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};
	
	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};
	
	function isString(arg) {
	  return typeof arg === "string";
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 169 */
/*!****************************************************!*\
  !*** ./~/node-libs-browser/~/punycode/punycode.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {
	
		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}
	
		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,
	
		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
	
		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'
	
		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
	
		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
	
		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,
	
		/** Temporary variable */
		key;
	
		/*--------------------------------------------------------------------------*/
	
		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}
	
		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
	
		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
	
		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}
	
		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}
	
		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}
	
		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}
	
		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;
	
			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.
	
			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
	
			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
	
			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.
	
			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
	
				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
	
					if (index >= inputLength) {
						error('invalid-input');
					}
	
					digit = basicToDigit(input.charCodeAt(index++));
	
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}
	
					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	
					if (digit < t) {
						break;
					}
	
					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}
	
					w *= baseMinusT;
	
				}
	
				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
	
				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}
	
				n += floor(i / out);
				i %= out;
	
				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
	
			}
	
			return ucs2encode(output);
		}
	
		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;
	
			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);
	
			// Cache the length
			inputLength = input.length;
	
			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;
	
			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}
	
			handledCPCount = basicLength = output.length;
	
			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.
	
			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}
	
			// Main encoding loop:
			while (handledCPCount < inputLength) {
	
				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}
	
				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}
	
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
	
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
	
					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}
	
					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}
	
						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
	
				++delta;
				++n;
	
			}
			return output.join('');
		}
	
		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}
	
		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}
	
		/*--------------------------------------------------------------------------*/
	
		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
	
		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/buildin/module.js */ 170)(module), (function() { return this; }())))

/***/ },
/* 170 */
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 171 */
/*!**********************************************************!*\
  !*** ./~/node-libs-browser/~/url/~/querystring/index.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.decode = exports.parse = __webpack_require__(/*! ./decode */ 172);
	exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ 173);


/***/ },
/* 172 */
/*!***********************************************************!*\
  !*** ./~/node-libs-browser/~/url/~/querystring/decode.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;
	
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	
	  return obj;
	};


/***/ },
/* 173 */
/*!***********************************************************!*\
  !*** ./~/node-libs-browser/~/url/~/querystring/encode.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 174 */
/*!*********************************!*\
  !*** ./~/mongoose/lib/model.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {/*!
	 * Module dependencies.
	 */
	
	var Document = __webpack_require__(/*! ./document */ 178)
	  , MongooseArray = __webpack_require__(/*! ./types/array */ 188)
	  , MongooseDocumentArray = __webpack_require__(/*! ./types/documentarray */ 189)
	  , MongooseBuffer = __webpack_require__(/*! ./types/buffer */ 198)
	  , MongooseError = __webpack_require__(/*! ./error */ 32)
	  , VersionError = MongooseError.VersionError
	  , DivergentArrayError = MongooseError.DivergentArrayError
	  , Query = __webpack_require__(/*! ./query */ 200)
	  , Aggregate = __webpack_require__(/*! ./aggregate */ 218)
	  , Schema = __webpack_require__(/*! ./schema */ 41)
	  , Types = __webpack_require__(/*! ./schema/index */ 175)
	  , utils = __webpack_require__(/*! ./utils */ 42)
	  , hasOwnProperty = utils.object.hasOwnProperty
	  , isMongooseObject = utils.isMongooseObject
	  , EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter
	  , merge = utils.merge
	  , Promise = __webpack_require__(/*! ./promise */ 183)
	  , assert = __webpack_require__(/*! assert */ 205)
	  , util = __webpack_require__(/*! util */ 57)
	  , tick = utils.tick;
	
	var async = __webpack_require__(/*! async */ 215);
	
	var VERSION_WHERE = 1
	  , VERSION_INC = 2
	  , VERSION_ALL = VERSION_WHERE | VERSION_INC;
	
	/**
	 * Model constructor
	 *
	 * Provides the interface to MongoDB collections as well as creates document instances.
	 *
	 * @param {Object} doc values with which to create the document
	 * @inherits Document
	 * @event `error`: If listening to this event, it is emitted when a document was saved without passing a callback and an `error` occurred. If not listening, the event bubbles to the connection used to create this Model.
	 * @event `index`: Emitted after `Model#ensureIndexes` completes. If an error occurred it is passed with the event.
	 * @api public
	 */
	
	function Model (doc, fields, skipId) {
	  Document.call(this, doc, fields, skipId);
	};
	
	/*!
	 * Inherits from Document.
	 *
	 * All Model.prototype features are available on
	 * top level (non-sub) documents.
	 */
	
	Model.prototype.__proto__ = Document.prototype;
	
	/**
	 * Connection the model uses.
	 *
	 * @api public
	 * @property db
	 */
	
	Model.prototype.db;
	
	/**
	 * Collection the model uses.
	 *
	 * @api public
	 * @property collection
	 */
	
	Model.prototype.collection;
	
	/**
	 * The name of the model
	 *
	 * @api public
	 * @property modelName
	 */
	
	Model.prototype.modelName;
	
	Model.prototype.$__handleSave = function $__handleSave(options) {
	  var self = this;
	  var innerPromise = new Promise;
	  if (!options.safe && this.schema.options.safe) {
	    options.safe = this.schema.options.safe;
	  }
	
	  if (this.isNew) {
	    // send entire doc
	    var toObjectOptions = {};
	    if (this.schema.options.toObject &&
	        this.schema.options.toObject.retainKeyOrder) {
	      toObjectOptions.retainKeyOrder = true;
	    }
	
	    toObjectOptions.depopulate = 1;
	    toObjectOptions._skipDepopulateTopLevel = true;
	    toObjectOptions.transform = false;
	
	    var obj = this.toObject(toObjectOptions);
	
	    if (!utils.object.hasOwnProperty(obj || {}, '_id')) {
	      // documents must have an _id else mongoose won't know
	      // what to update later if more changes are made. the user
	      // wouldn't know what _id was generated by mongodb either
	      // nor would the ObjectId generated my mongodb necessarily
	      // match the schema definition.
	      innerPromise.reject(new Error('document must have an _id before saving'));
	      return innerPromise;
	    }
	
	    this.$__version(true, obj);
	    this.collection.insert(obj, options.safe, function (err, ret) {
	      innerPromise.resolve(err, ret);
	    });
	    this.$__reset();
	    this.isNew = false;
	    this.emit('isNew', false);
	    // Make it possible to retry the insert
	    this.$__.inserting = true;
	
	  } else {
	    // Make sure we don't treat it as a new object on error,
	    // since it already exists
	    this.$__.inserting = false;
	
	    var delta = this.$__delta();
	
	    if (delta) {
	      if (delta instanceof Error) {
	        innerPromise.reject(delta);
	        return innerPromise;
	      }
	      var where = this.$__where(delta[0]);
	      this.collection.update(where, delta[1], options.safe, function (err, ret) {
	        innerPromise.resolve(err, ret);
	      });
	    } else {
	      this.$__reset();
	      innerPromise.fulfill(this);
	    }
	
	    this.emit('isNew', false);
	  }
	  return innerPromise;
	};
	
	/**
	 * @description Saves this document.
	 *
	 * @example:
	 *
	 *     product.sold = Date.now();
	 *     product.save(function (err, product, numberAffected) {
	 *       if (err) ..
	 *     })
	 *
	 * @description The callback will receive three parameters, `err` if an error occurred, `product` which is the saved `product`, and `numberAffected` which will be 1 when the document was found and updated in the database, otherwise 0.
	 *
	 * The `fn` callback is optional. If no `fn` is passed and validation fails, the validation error will be emitted on the connection used to create this model.
	 * @example:
	 *     var db = mongoose.createConnection(..);
	 *     var schema = new Schema(..);
	 *     var Product = db.model('Product', schema);
	 *
	 *     db.on('error', handleError);
	 *
	 * @description However, if you desire more local error handling you can add an `error` listener to the model and handle errors there instead.
	 * @example:
	 *     Product.on('error', handleError);
	 *
	 * @description As an extra measure of flow control, save will return a Promise (bound to `fn` if passed) so it could be chained, or hook to recive errors
	 * @example:
	 *     product.save().then(function (product, numberAffected) {
	 *        ...
	 *     }).onRejected(function (err) {
	 *        assert.ok(err)
	 *     })
	 *
	 * @description For legacy reasons, mongoose stores object keys in reverse order on initial save. That is, `{ a: 1, b: 2}` will be saved as `{ b: 2, a: 1 }` in MongoDB. To override this behavior, set [the `toObject.retainKeyOrder` option](http://mongoosejs.com/docs/api.html#document_Document-toObject) to true on your schema.
	 *
	 * @param {Object} [options] options set `options.safe` to override [schema's safe option](/docs/guide.html#safe)
	 * @param {function(err, product, Number)} [fn] optional callback
	 * @return {Promise} Promise
	 * @api public
	 * @see middleware http://mongoosejs.com/docs/middleware.html
	 */
	
	Model.prototype.save = function (options, fn) {
	  if ('function' == typeof options) {
	    fn = options;
	    options = undefined;
	  }
	
	  if (!options) {
	    options = {};
	  }
	
	  var self = this;
	  var finalPromise = new Promise(fn);
	
	  // Jank to be able to use mpromise.prototype.all()
	  var p0 = new Promise;
	  p0.fulfill();
	
	  // Call save hooks on subdocs
	  var p1 = p0.all(function () {
	    var subDocs = self.$__getAllSubdocs();
	    return subDocs.map(function (d) {return d.save();});
	  });
	
	  // Handle save and resaults
	  p1
	    .then(this.$__handleSave.bind(this, options))
	    .then(function (result) {
	      self.$__reset();
	      self.$__storeShard();
	
	      var numAffected = 0;
	      if (result) {
	        if (Array.isArray(result)) {
	          numAffected = result.length;
	        } else if (result.result && result.result.n !== undefined) {
	          numAffected = result.result.n;
	        } else if (result.result && result.result.nModified !== undefined) {
	          numAffected = result.result.nModified;
	        } else {
	          numAffected = result;
	        }
	      }
	
	      // was this an update that required a version bump?
	      if (self.$__.version && !self.$__.inserting) {
	        var doIncrement = VERSION_INC === (VERSION_INC & self.$__.version);
	        self.$__.version = undefined;
	
	        if (numAffected <= 0) {
	          // the update failed. pass an error back
	          return finalPromise.reject(new VersionError);
	        }
	
	        // increment version if was successful
	        if (doIncrement) {
	          var key = self.schema.options.versionKey;
	          var version = self.getValue(key) | 0;
	          self.setValue(key, version + 1);
	        }
	      }
	
	      self.emit('save', self, numAffected);
	      return finalPromise.fulfill(self, numAffected);
	    }
	    , function (err) {
	      // If the initial insert fails provide a second chance.
	      // (If we did this all the time we would break updates)
	      if (self.$__.inserting) {
	        self.isNew = true;
	        self.emit('isNew', true);
	      }
	      finalPromise.reject(err);
	    })
	    .end();
	
	  return finalPromise;
	};
	
	
	/*!
	 * Apply the operation to the delta (update) clause as
	 * well as track versioning for our where clause.
	 *
	 * @param {Document} self
	 * @param {Object} where
	 * @param {Object} delta
	 * @param {Object} data
	 * @param {Mixed} val
	 * @param {String} [operation]
	 */
	
	function operand (self, where, delta, data, val, op) {
	  // delta
	  op || (op = '$set');
	  if (!delta[op]) delta[op] = {};
	  delta[op][data.path] = val;
	
	  // disabled versioning?
	  if (false === self.schema.options.versionKey) return;
	
	  // path excluded from versioning?
	  var skipVersioning = self.schema.options.skipVersioning;
	  if (skipVersioning && skipVersioning[data.path]) return;
	
	  // already marked for versioning?
	  if (VERSION_ALL === (VERSION_ALL & self.$__.version)) return;
	
	  switch (op) {
	    case '$set':
	    case '$unset':
	    case '$pop':
	    case '$pull':
	    case '$pullAll':
	    case '$push':
	    case '$pushAll':
	    case '$addToSet':
	      break;
	    default:
	      // nothing to do
	      return;
	  }
	
	  // ensure updates sent with positional notation are
	  // editing the correct array element.
	  // only increment the version if an array position changes.
	  // modifying elements of an array is ok if position does not change.
	
	  if ('$push' == op || '$pushAll' == op || '$addToSet' == op) {
	    self.$__.version = VERSION_INC;
	  }
	  else if (/^\$p/.test(op)) {
	    // potentially changing array positions
	    self.increment();
	  }
	  else if (Array.isArray(val)) {
	    // $set an array
	    self.increment();
	  }
	  // now handling $set, $unset
	  else if (/\.\d+\.|\.\d+$/.test(data.path)) {
	    // subpath of array
	    self.$__.version = VERSION_WHERE;
	  }
	}
	
	/*!
	 * Compiles an update and where clause for a `val` with _atomics.
	 *
	 * @param {Document} self
	 * @param {Object} where
	 * @param {Object} delta
	 * @param {Object} data
	 * @param {Array} value
	 */
	
	function handleAtomics (self, where, delta, data, value) {
	  if (delta.$set && delta.$set[data.path]) {
	    // $set has precedence over other atomics
	    return;
	  }
	
	  if ('function' == typeof value.$__getAtomics) {
	    value.$__getAtomics().forEach(function (atomic) {
	      var op = atomic[0];
	      var val = atomic[1];
	      operand(self, where, delta, data, val, op);
	    })
	    return;
	  }
	
	  // legacy support for plugins
	
	  var atomics = value._atomics
	    , ops = Object.keys(atomics)
	    , i = ops.length
	    , val
	    , op;
	
	  if (0 === i) {
	    // $set
	
	    if (isMongooseObject(value)) {
	      value = value.toObject({ depopulate: 1 });
	    } else if (value.valueOf) {
	      value = value.valueOf();
	    }
	
	    return operand(self, where, delta, data, value);
	  }
	
	  while (i--) {
	    op = ops[i];
	    val = atomics[op];
	
	    if (isMongooseObject(val)) {
	      val = val.toObject({ depopulate: 1 })
	    } else if (Array.isArray(val)) {
	      val = val.map(function (mem) {
	        return isMongooseObject(mem)
	          ? mem.toObject({ depopulate: 1 })
	          : mem;
	      })
	    } else if (val.valueOf) {
	      val = val.valueOf()
	    }
	
	    if ('$addToSet' === op)
	      val = { $each: val };
	
	    operand(self, where, delta, data, val, op);
	  }
	}
	
	/**
	 * Produces a special query document of the modified properties used in updates.
	 *
	 * @api private
	 * @method $__delta
	 * @memberOf Model
	 */
	
	Model.prototype.$__delta = function () {
	  var dirty = this.$__dirty();
	  if (!dirty.length && VERSION_ALL != this.$__.version) return;
	
	  var where = {}
	    , delta = {}
	    , len = dirty.length
	    , divergent = []
	    , d = 0
	    , val
	    , obj
	
	  for (; d < len; ++d) {
	    var data = dirty[d]
	    var value = data.value
	    var schema = data.schema
	
	    var match = checkDivergentArray(this, data.path, value);
	    if (match) {
	      divergent.push(match);
	      continue;
	    }
	
	    if (divergent.length) continue;
	
	    if (undefined === value) {
	      operand(this, where, delta, data, 1, '$unset');
	
	    } else if (null === value) {
	      operand(this, where, delta, data, null);
	
	    } else if (value._path && value._atomics) {
	      // arrays and other custom types (support plugins etc)
	      handleAtomics(this, where, delta, data, value);
	
	    } else if (value._path && Buffer.isBuffer(value)) {
	      // MongooseBuffer
	      value = value.toObject();
	      operand(this, where, delta, data, value);
	
	    } else {
	      value = utils.clone(value, { depopulate: 1 });
	      operand(this, where, delta, data, value);
	    }
	  }
	
	  if (divergent.length) {
	    return new DivergentArrayError(divergent);
	  }
	
	  if (this.$__.version) {
	    this.$__version(where, delta);
	  }
	
	  return [where, delta];
	}
	
	/*!
	 * Determine if array was populated with some form of filter and is now
	 * being updated in a manner which could overwrite data unintentionally.
	 *
	 * @see https://github.com/Automattic/mongoose/issues/1334
	 * @param {Document} doc
	 * @param {String} path
	 * @return {String|undefined}
	 */
	
	function checkDivergentArray (doc, path, array) {
	  // see if we populated this path
	  var pop = doc.populated(path, true);
	
	  if (!pop && doc.$__.selected) {
	    // If any array was selected using an $elemMatch projection, we deny the update.
	    // NOTE: MongoDB only supports projected $elemMatch on top level array.
	    var top = path.split('.')[0];
	    if ((doc.$__.selected[top] && doc.$__.selected[top].$elemMatch) ||
	        doc.$__.selected[top + '.$']) {
	      return top;
	    }
	  }
	
	  if (!(pop && array && array.isMongooseArray)) return;
	
	  // If the array was populated using options that prevented all
	  // documents from being returned (match, skip, limit) or they
	  // deselected the _id field, $pop and $set of the array are
	  // not safe operations. If _id was deselected, we do not know
	  // how to remove elements. $pop will pop off the _id from the end
	  // of the array in the db which is not guaranteed to be the
	  // same as the last element we have here. $set of the entire array
	  // would be similarily destructive as we never received all
	  // elements of the array and potentially would overwrite data.
	  var check = pop.options.match ||
	              pop.options.options && hasOwnProperty(pop.options.options, 'limit') || // 0 is not permitted
	              pop.options.options && pop.options.options.skip || // 0 is permitted
	              pop.options.select && // deselected _id?
	                (0 === pop.options.select._id ||
	                /\s?-_id\s?/.test(pop.options.select))
	
	  if (check) {
	    var atomics = array._atomics;
	    if (0 === Object.keys(atomics).length || atomics.$set || atomics.$pop) {
	      return path;
	    }
	  }
	}
	
	/**
	 * Appends versioning to the where and update clauses.
	 *
	 * @api private
	 * @method $__version
	 * @memberOf Model
	 */
	
	Model.prototype.$__version = function (where, delta) {
	  var key = this.schema.options.versionKey;
	
	  if (true === where) {
	    // this is an insert
	    if (key) this.setValue(key, delta[key] = 0);
	    return;
	  }
	
	  // updates
	
	  // only apply versioning if our versionKey was selected. else
	  // there is no way to select the correct version. we could fail
	  // fast here and force them to include the versionKey but
	  // thats a bit intrusive. can we do this automatically?
	  if (!this.isSelected(key)) {
	    return;
	  }
	
	  // $push $addToSet don't need the where clause set
	  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {
	    where[key] = this.getValue(key);
	  }
	
	  if (VERSION_INC === (VERSION_INC & this.$__.version)) {
	    if (!delta.$set || typeof delta.$set[key] === 'undefined') {
	      delta.$inc || (delta.$inc = {});
	      delta.$inc[key] = 1;
	    }
	  }
	}
	
	/**
	 * Signal that we desire an increment of this documents version.
	 *
	 * ####Example:
	 *
	 *     Model.findById(id, function (err, doc) {
	 *       doc.increment();
	 *       doc.save(function (err) { .. })
	 *     })
	 *
	 * @see versionKeys http://mongoosejs.com/docs/guide.html#versionKey
	 * @api public
	 */
	
	Model.prototype.increment = function increment () {
	  this.$__.version = VERSION_ALL;
	  return this;
	}
	
	/**
	 * Returns a query object which applies shardkeys if they exist.
	 *
	 * @api private
	 * @method $__where
	 * @memberOf Model
	 */
	
	Model.prototype.$__where = function _where (where) {
	  where || (where = {});
	
	  var paths
	    , len
	
	  if (this.$__.shardval) {
	    paths = Object.keys(this.$__.shardval)
	    len = paths.length
	
	    for (var i = 0; i < len; ++i) {
	      where[paths[i]] = this.$__.shardval[paths[i]];
	    }
	  }
	
	  where._id = this._doc._id;
	  return where;
	}
	
	/**
	 * @description Removes this document from the db.
	 *
	 * @example:
	 *     product.remove(function (err, product) {
	 *       if (err) return handleError(err);
	 *       Product.findById(product._id, function (err, product) {
	 *         console.log(product) // null
	 *       })
	 *     })
	 *
	 *
	 * @description As an extra measure of flow control, remove will return a Promise (bound to `fn` if passed) so it could be chained, or hooked to recive errors
	 *
	 * @example
	 *     product.remove().then(function (product) {
	 *        ...
	 *     }).onRejected(function (err) {
	 *        assert.ok(err)
	 *     })
	 *
	 * @param {function (err, product)} [fn] optional callback
	 * @return {Promise} Promise
	 * @api public
	 */
	
	Model.prototype.remove = function remove (options, fn) {
	
	  if ('function' == typeof options) {
	    fn = options;
	    options = undefined;
	  }
	
	  if (!options) {
	    options = {};
	  }
	
	  if (this.$__.removing) {
	    this.$__.removing.onResolve(fn);
	    return this;
	  }
	
	  var promise = this.$__.removing = new Promise(fn)
	    , where = this.$__where()
	    , self = this
	    ;
	
	  if (!options.safe && this.schema.options.safe) {
	    options.safe = this.schema.options.safe;
	  }
	
	  this.collection.remove(where, options, function (err) {
	    if (!err) {
	      self.emit('remove', self);
	    }
	    promise.resolve(err, self);
	  });
	
	  return promise;
	};
	
	/**
	 * Returns another Model instance.
	 *
	 * ####Example:
	 *
	 *     var doc = new Tank;
	 *     doc.model('User').findById(id, callback);
	 *
	 * @param {String} name model name
	 * @api public
	 */
	
	Model.prototype.model = function model (name) {
	  return this.db.model(name);
	};
	
	/**
	 * Adds a discriminator type.
	 *
	 * ####Example:
	 *
	 *     function BaseSchema() {
	 *       Schema.apply(this, arguments);
	 *
	 *       this.add({
	 *         name: String,
	 *         createdAt: Date
	 *       });
	 *     }
	 *     util.inherits(BaseSchema, Schema);
	 *
	 *     var PersonSchema = new BaseSchema();
	 *     var BossSchema = new BaseSchema({ department: String });
	 *
	 *     var Person = mongoose.model('Person', PersonSchema);
	 *     var Boss = Person.discriminator('Boss', BossSchema);
	 *
	 * @param {String} name   discriminator model name
	 * @param {Schema} schema discriminator model schema
	 * @api public
	 */
	
	Model.discriminator = function discriminator (name, schema) {
	  if (!(schema instanceof Schema)) {
	    throw new Error("You must pass a valid discriminator Schema");
	  }
	
	  if (this.schema.discriminatorMapping && !this.schema.discriminatorMapping.isRoot) {
	    throw new Error("Discriminator \"" + name +
	      "\" can only be a discriminator of the root model");
	  }
	
	  var key = this.schema.options.discriminatorKey;
	  if (schema.path(key)) {
	    throw new Error("Discriminator \"" + name +
	      "\" cannot have field with name \"" + key + "\"");
	  }
	
	  // merges base schema into new discriminator schema and sets new type field.
	  (function(schema, baseSchema) {
	    utils.merge(schema, baseSchema);
	
	    var obj = {};
	    obj[key] = { type: String, default: name };
	    schema.add(obj);
	    schema.discriminatorMapping = { key: key, value: name, isRoot: false };
	
	    if (baseSchema.options.collection) {
	      schema.options.collection = baseSchema.options.collection;
	    }
	
	      // throws error if options are invalid
	    (function(a, b) {
	      a = utils.clone(a);
	      b = utils.clone(b);
	      delete a.toJSON;
	      delete a.toObject;
	      delete b.toJSON;
	      delete b.toObject;
	
	      if (!utils.deepEqual(a, b)) {
	        throw new Error("Discriminator options are not customizable " +
	          "(except toJSON & toObject)");
	      }
	    })(schema.options, baseSchema.options);
	
	    var toJSON = schema.options.toJSON
	      , toObject = schema.options.toObject;
	
	    schema.options = utils.clone(baseSchema.options);
	    if (toJSON)   schema.options.toJSON = toJSON;
	    if (toObject) schema.options.toObject = toObject;
	
	    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue.slice(schema._defaultMiddleware.length));
	    schema._requiredpaths = undefined; // reset just in case Schema#requiredPaths() was called on either schema
	  })(schema, this.schema);
	
	  if (!this.discriminators) {
	    this.discriminators = {};
	  }
	
	  if (!this.schema.discriminatorMapping) {
	    this.schema.discriminatorMapping = { key: key, value: null, isRoot: true };
	  }
	
	  if (this.discriminators[name]) {
	    throw new Error("Discriminator with name \"" + name + "\" already exists");
	  }
	
	  this.discriminators[name] = this.db.model(name, schema, this.collection.name);
	  this.discriminators[name].prototype.__proto__ = this.prototype;
	
	  // apply methods and statics
	  applyMethods(this.discriminators[name], schema);
	  applyStatics(this.discriminators[name], schema);
	
	  return this.discriminators[name];
	};
	
	// Model (class) features
	
	/*!
	 * Give the constructor the ability to emit events.
	 */
	
	for (var i in EventEmitter.prototype)
	  Model[i] = EventEmitter.prototype[i];
	
	/**
	 * Called when the model compiles.
	 *
	 * @api private
	 */
	
	Model.init = function init () {
	  if ((this.schema.options.autoIndex) ||
	      (this.schema.options.autoIndex === null && this.db.config.autoIndex)) {
	    this.ensureIndexes();
	  }
	
	  this.schema.emit('init', this);
	};
	
	/**
	 * Sends `ensureIndex` commands to mongo for each index declared in the schema.
	 *
	 * ####Example:
	 *
	 *     Event.ensureIndexes(function (err) {
	 *       if (err) return handleError(err);
	 *     });
	 *
	 * After completion, an `index` event is emitted on this `Model` passing an error if one occurred.
	 *
	 * ####Example:
	 *
	 *     var eventSchema = new Schema({ thing: { type: 'string', unique: true }})
	 *     var Event = mongoose.model('Event', eventSchema);
	 *
	 *     Event.on('index', function (err) {
	 *       if (err) console.error(err); // error occurred during index creation
	 *     })
	 *
	 * _NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution._
	 *
	 * The `ensureIndex` commands are not sent in parallel. This is to avoid the `MongoError: cannot add index with a background operation in progress` error. See [this ticket](https://github.com/Automattic/mongoose/issues/1365) for more information.
	 *
	 * @param {Function} [cb] optional callback
	 * @return {Promise}
	 * @api public
	 */
	
	Model.ensureIndexes = function ensureIndexes (cb) {
	  var promise = new Promise(cb);
	
	  var indexes = this.schema.indexes();
	  if (!indexes.length) {
	    process.nextTick(promise.fulfill.bind(promise));
	    return promise;
	  }
	
	  // Indexes are created one-by-one to support how MongoDB < 2.4 deals
	  // with background indexes.
	
	  var self = this
	    , safe = self.schema.options.safe
	
	  var done = function(err) {
	    self.emit('index', err);
	    promise.resolve(err);
	  }
	
	  var create = function() {
	    var index = indexes.shift();
	    if (!index) return done();
	
	    var options = index[1];
	    options.safe = safe;
	    self.collection.ensureIndex(index[0], options, tick(function (err) {
	      if (err) return done(err);
	      create();
	    }));
	  }
	
	  create();
	  return promise;
	}
	
	/**
	 * Schema the model uses.
	 *
	 * @property schema
	 * @receiver Model
	 * @api public
	 */
	
	Model.schema;
	
	/*!
	 * Connection instance the model uses.
	 *
	 * @property db
	 * @receiver Model
	 * @api public
	 */
	
	Model.db;
	
	/*!
	 * Collection the model uses.
	 *
	 * @property collection
	 * @receiver Model
	 * @api public
	 */
	
	Model.collection;
	
	/**
	 * Base Mongoose instance the model uses.
	 *
	 * @property base
	 * @receiver Model
	 * @api public
	 */
	
	Model.base;
	
	/**
	 * Registered discriminators for this model.
	 *
	 * @property discriminators
	 * @receiver Model
	 * @api public
	 */
	
	Model.discriminators;
	
	/**
	 * Removes documents from the collection.
	 *
	 * ####Example:
	 *
	 *     Comment.remove({ title: 'baby born from alien father' }, function (err) {
	 *
	 *     });
	 *
	 * ####Note:
	 *
	 * To remove documents without waiting for a response from MongoDB, do not pass a `callback`, then call `exec` on the returned [Query](#query-js):
	 *
	 *     var query = Comment.remove({ _id: id });
	 *     query.exec();
	 *
	 * ####Note:
	 *
	 * This method sends a remove command directly to MongoDB, no Mongoose documents are involved. Because no Mongoose documents are involved, _no middleware (hooks) are executed_.
	 *
	 * @param {Object} conditions
	 * @param {Function} [callback]
	 * @return {Promise} Promise
	 * @api public
	 */
	
	Model.remove = function remove (conditions, callback) {
	  if ('function' === typeof conditions) {
	    callback = conditions;
	    conditions = {};
	  }
	
	  // get the mongodb collection object
	  var mq = new Query(conditions, {}, this, this.collection);
	
	  return mq.remove(callback);
	};
	
	/**
	 * Finds documents
	 *
	 * The `conditions` are cast to their respective SchemaTypes before the command is sent.
	 *
	 * ####Examples:
	 *
	 *     // named john and at least 18
	 *     MyModel.find({ name: 'john', age: { $gte: 18 }});
	 *
	 *     // executes immediately, passing results to callback
	 *     MyModel.find({ name: 'john', age: { $gte: 18 }}, function (err, docs) {});
	 *
	 *     // name LIKE john and only selecting the "name" and "friends" fields, executing immediately
	 *     MyModel.find({ name: /john/i }, 'name friends', function (err, docs) { })
	 *
	 *     // passing options
	 *     MyModel.find({ name: /john/i }, null, { skip: 10 })
	 *
	 *     // passing options and executing immediately
	 *     MyModel.find({ name: /john/i }, null, { skip: 10 }, function (err, docs) {});
	 *
	 *     // executing a query explicitly
	 *     var query = MyModel.find({ name: /john/i }, null, { skip: 10 })
	 *     query.exec(function (err, docs) {});
	 *
	 *     // using the promise returned from executing a query
	 *     var query = MyModel.find({ name: /john/i }, null, { skip: 10 });
	 *     var promise = query.exec();
	 *     promise.addBack(function (err, docs) {});
	 *
	 * @param {Object} conditions
	 * @param {Object} [projection] optional fields to return (http://bit.ly/1HotzBo)
	 * @param {Object} [options] optional
	 * @param {Function} [callback]
	 * @return {Query}
	 * @see field selection #query_Query-select
	 * @see promise #promise-js
	 * @api public
	 */
	
	Model.find = function find (conditions, projection, options, callback) {
	  if ('function' == typeof conditions) {
	    callback = conditions;
	    conditions = {};
	    projection = null;
	    options = null;
	  } else if ('function' == typeof projection) {
	    callback = projection;
	    projection = null;
	    options = null;
	  } else if ('function' == typeof options) {
	    callback = options;
	    options = null;
	  }
	
	  // get the raw mongodb collection object
	  var mq = new Query({}, options, this, this.collection);
	  mq.select(projection);
	  if (this.schema.discriminatorMapping && mq.selectedInclusively()) {
	    mq.select(this.schema.options.discriminatorKey);
	  }
	
	  return mq.find(conditions, callback);
	};
	
	/**
	 * Finds a single document by id.
	 *
	 * The `id` is cast based on the Schema before sending the command.
	 *
	 * ####Example:
	 *
	 *     // find adventure by id and execute immediately
	 *     Adventure.findById(id, function (err, adventure) {});
	 *
	 *     // same as above
	 *     Adventure.findById(id).exec(callback);
	 *
	 *     // select only the adventures name and length
	 *     Adventure.findById(id, 'name length', function (err, adventure) {});
	 *
	 *     // same as above
	 *     Adventure.findById(id, 'name length').exec(callback);
	 *
	 *     // include all properties except for `length`
	 *     Adventure.findById(id, '-length').exec(function (err, adventure) {});
	 *
	 *     // passing options (in this case return the raw js objects, not mongoose documents by passing `lean`
	 *     Adventure.findById(id, 'name', { lean: true }, function (err, doc) {});
	 *
	 *     // same as above
	 *     Adventure.findById(id, 'name').lean().exec(function (err, doc) {});
	 *
	 * @param {ObjectId|HexId} id objectid, or a value that can be casted to one
	 * @param {Object} [projection] optional fields to return (http://bit.ly/1HotzBo)
	 * @param {Object} [options] optional
	 * @param {Function} [callback]
	 * @return {Query}
	 * @see field selection #query_Query-select
	 * @see lean queries #query_Query-lean
	 * @api public
	 */
	
	Model.findById = function findById (id, projection, options, callback) {
	  return this.findOne({ _id: id }, projection, options, callback);
	};
	
	/**
	 * Finds one document.
	 *
	 * The `conditions` are cast to their respective SchemaTypes before the command is sent.
	 *
	 * ####Example:
	 *
	 *     // find one iphone adventures - iphone adventures??
	 *     Adventure.findOne({ type: 'iphone' }, function (err, adventure) {});
	 *
	 *     // same as above
	 *     Adventure.findOne({ type: 'iphone' }).exec(function (err, adventure) {});
	 *
	 *     // select only the adventures name
	 *     Adventure.findOne({ type: 'iphone' }, 'name', function (err, adventure) {});
	 *
	 *     // same as above
	 *     Adventure.findOne({ type: 'iphone' }, 'name').exec(function (err, adventure) {});
	 *
	 *     // specify options, in this case lean
	 *     Adventure.findOne({ type: 'iphone' }, 'name', { lean: true }, callback);
	 *
	 *     // same as above
	 *     Adventure.findOne({ type: 'iphone' }, 'name', { lean: true }).exec(callback);
	 *
	 *     // chaining findOne queries (same as above)
	 *     Adventure.findOne({ type: 'iphone' }).select('name').lean().exec(callback);
	 *
	 * @param {Object} [conditions]
	 * @param {Object} [projection] optional fields to return (http://bit.ly/1HotzBo)
	 * @param {Object} [options] optional
	 * @param {Function} [callback]
	 * @return {Query}
	 * @see field selection #query_Query-select
	 * @see lean queries #query_Query-lean
	 * @api public
	 */
	
	Model.findOne = function findOne (conditions, projection, options, callback) {
	  if ('function' == typeof options) {
	    callback = options;
	    options = null;
	  } else if ('function' == typeof projection) {
	    callback = projection;
	    projection = null;
	    options = null;
	  } else if ('function' == typeof conditions) {
	    callback = conditions;
	    conditions = {};
	    projection = null;
	    options = null;
	  }
	
	  // get the mongodb collection object
	  var mq = new Query({}, options, this, this.collection);
	  mq.select(projection);
	  if (this.schema.discriminatorMapping && mq.selectedInclusively()) {
	    mq.select(this.schema.options.discriminatorKey);
	  }
	
	  return mq.findOne(conditions, callback);
	};
	
	/**
	 * Counts number of matching documents in a database collection.
	 *
	 * ####Example:
	 *
	 *     Adventure.count({ type: 'jungle' }, function (err, count) {
	 *       if (err) ..
	 *       console.log('there are %d jungle adventures', count);
	 *     });
	 *
	 * @param {Object} conditions
	 * @param {Function} [callback]
	 * @return {Query}
	 * @api public
	 */
	
	Model.count = function count (conditions, callback) {
	  if ('function' === typeof conditions)
	    callback = conditions, conditions = {};
	
	  // get the mongodb collection object
	  var mq = new Query({}, {}, this, this.collection);
	
	  return mq.count(conditions, callback);
	};
	
	/**
	 * Creates a Query for a `distinct` operation.
	 *
	 * Passing a `callback` immediately executes the query.
	 *
	 * ####Example
	 *
	 *     Link.distinct('url', { clicks: {$gt: 100}}, function (err, result) {
	 *       if (err) return handleError(err);
	 *
	 *       assert(Array.isArray(result));
	 *       console.log('unique urls with more than 100 clicks', result);
	 *     })
	 *
	 *     var query = Link.distinct('url');
	 *     query.exec(callback);
	 *
	 * @param {String} field
	 * @param {Object} [conditions] optional
	 * @param {Function} [callback]
	 * @return {Query}
	 * @api public
	 */
	
	Model.distinct = function distinct (field, conditions, callback) {
	  // get the mongodb collection object
	  var mq = new Query({}, {}, this, this.collection);
	
	  if ('function' == typeof conditions) {
	    callback = conditions;
	    conditions = {};
	  }
	
	  return mq.distinct(field, conditions, callback);
	};
	
	/**
	 * Creates a Query, applies the passed conditions, and returns the Query.
	 *
	 * For example, instead of writing:
	 *
	 *     User.find({age: {$gte: 21, $lte: 65}}, callback);
	 *
	 * we can instead write:
	 *
	 *     User.where('age').gte(21).lte(65).exec(callback);
	 *
	 * Since the Query class also supports `where` you can continue chaining
	 *
	 *     User
	 *     .where('age').gte(21).lte(65)
	 *     .where('name', /^b/i)
	 *     ... etc
	 *
	 * @param {String} path
	 * @param {Object} [val] optional value
	 * @return {Query}
	 * @api public
	 */
	
	Model.where = function where (path, val) {
	  // get the mongodb collection object
	  var mq = new Query({}, {}, this, this.collection).find({});
	  return mq.where.apply(mq, arguments);
	};
	
	/**
	 * Creates a `Query` and specifies a `$where` condition.
	 *
	 * Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via `find({ $where: javascript })`, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.
	 *
	 *     Blog.$where('this.comments.length > 5').exec(function (err, docs) {});
	 *
	 * @param {String|Function} argument is a javascript string or anonymous function
	 * @method $where
	 * @memberOf Model
	 * @return {Query}
	 * @see Query.$where #query_Query-%24where
	 * @api public
	 */
	
	Model.$where = function $where () {
	  var mq = new Query({}, {}, this, this.collection).find({});
	  return mq.$where.apply(mq, arguments);
	};
	
	/**
	 * Issues a mongodb findAndModify update command.
	 *
	 * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed else a Query object is returned.
	 *
	 * ####Options:
	 *
	 * - `new`: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)
	 * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 * - `select`: sets the document fields to return
	 *
	 * ####Examples:
	 *
	 *     A.findOneAndUpdate(conditions, update, options, callback) // executes
	 *     A.findOneAndUpdate(conditions, update, options)  // returns Query
	 *     A.findOneAndUpdate(conditions, update, callback) // executes
	 *     A.findOneAndUpdate(conditions, update)           // returns Query
	 *     A.findOneAndUpdate()                             // returns Query
	 *
	 * ####Note:
	 *
	 * All top level update keys which are not `atomic` operation names are treated as set operations:
	 *
	 * ####Example:
	 *
	 *     var query = { name: 'borne' };
	 *     Model.findOneAndUpdate(query, { name: 'jason borne' }, options, callback)
	 *
	 *     // is sent as
	 *     Model.findOneAndUpdate(query, { $set: { name: 'jason borne' }}, options, callback)
	 *
	 * This helps prevent accidentally overwriting your document with `{ name: 'jason borne' }`.
	 *
	 * ####Note:
	 *
	 * Although values are cast to their appropriate types when using the findAndModify helpers, the following are *not* applied:
	 *
	 * - defaults
	 * - setters
	 * - validators
	 * - middleware
	 *
	 * If you need those features, use the traditional approach of first retrieving the document.
	 *
	 *     Model.findOne({ name: 'borne' }, function (err, doc) {
	 *       if (err) ..
	 *       doc.name = 'jason borne';
	 *       doc.save(callback);
	 *     })
	 *
	 * @param {Object} [conditions]
	 * @param {Object} [update]
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query}
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 * @api public
	 */
	
	Model.findOneAndUpdate = function (conditions, update, options, callback) {
	  if ('function' == typeof options) {
	    callback = options;
	    options = null;
	  }
	  else if (1 === arguments.length) {
	    if ('function' == typeof conditions) {
	      var msg = 'Model.findOneAndUpdate(): First argument must not be a function.\n\n'
	              + '  ' + this.modelName + '.findOneAndUpdate(conditions, update, options, callback)\n'
	              + '  ' + this.modelName + '.findOneAndUpdate(conditions, update, options)\n'
	              + '  ' + this.modelName + '.findOneAndUpdate(conditions, update)\n'
	              + '  ' + this.modelName + '.findOneAndUpdate(update)\n'
	              + '  ' + this.modelName + '.findOneAndUpdate()\n';
	      throw new TypeError(msg)
	    }
	    update = conditions;
	    conditions = undefined;
	  }
	
	  var fields;
	  if (options && options.fields) {
	    fields = options.fields;
	    options.fields = undefined;
	  }
	
	  update = utils.clone(update, { depopulate: 1 });
	  if (this.schema.options.versionKey && options && options.upsert) {
	    if (!update.$setOnInsert) {
	      update.$setOnInsert = {};
	    }
	    update.$setOnInsert[this.schema.options.versionKey] = 0;
	  }
	
	  var mq = new Query({}, {}, this, this.collection);
	  mq.select(fields);
	
	  return mq.findOneAndUpdate(conditions, update, options, callback);
	}
	
	/**
	 * Issues a mongodb findAndModify update command by a documents id.
	 *
	 * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed else a Query object is returned.
	 *
	 * ####Options:
	 *
	 * - `new`: bool - true to return the modified document rather than the original. defaults to false
	 * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 * - `select`: sets the document fields to return
	 *
	 * ####Examples:
	 *
	 *     A.findByIdAndUpdate(id, update, options, callback) // executes
	 *     A.findByIdAndUpdate(id, update, options)  // returns Query
	 *     A.findByIdAndUpdate(id, update, callback) // executes
	 *     A.findByIdAndUpdate(id, update)           // returns Query
	 *     A.findByIdAndUpdate()                     // returns Query
	 *
	 * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes      immediately if `callback` is passed else a Query object is returned.
	 *
	 * ####Options:
	 *
	 * - `new`: bool - true to return the modified document rather than the original. defaults to false
	 * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 *
	 * ####Note:
	 *
	 * All top level update keys which are not `atomic` operation names are treated as set operations:
	 *
	 * ####Example:
	 *
	 *     Model.findByIdAndUpdate(id, { name: 'jason borne' }, options, callback)
	 *
	 *     // is sent as
	 *     Model.findByIdAndUpdate(id, { $set: { name: 'jason borne' }}, options, callback)
	 *
	 * This helps prevent accidentally overwriting your document with `{ name: 'jason borne' }`.
	 *
	 * ####Note:
	 *
	 * Although values are cast to their appropriate types when using the findAndModify helpers, the following are *not* applied:
	 *
	 * - defaults
	 * - setters
	 * - validators
	 * - middleware
	 *
	 * If you need those features, use the traditional approach of first retrieving the document.
	 *
	 *     Model.findById(id, function (err, doc) {
	 *       if (err) ..
	 *       doc.name = 'jason borne';
	 *       doc.save(callback);
	 *     })
	 *
	 * @param {ObjectId|HexId} id an ObjectId or string that can be cast to one.
	 * @param {Object} [update]
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query}
	 * @see Model.findOneAndUpdate #model_Model.findOneAndUpdate
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 * @api public
	 */
	
	Model.findByIdAndUpdate = function (id, update, options, callback) {
	  var args;
	  if (1 === arguments.length) {
	    if ('function' == typeof id) {
	      var msg = 'Model.findByIdAndUpdate(): First argument must not be a function.\n\n'
	                + '  ' + this.modelName + '.findByIdAndUpdate(id, callback)\n'
	                + '  ' + this.modelName + '.findByIdAndUpdate(id)\n'
	                + '  ' + this.modelName + '.findByIdAndUpdate()\n';
	      throw new TypeError(msg)
	    }
	    return this.findOneAndUpdate({_id: id }, undefined);
	  }
	
	  args = utils.args(arguments, 1);
	
	  // if a model is passed in instead of an id
	  if (id && id._id) {
	    id = id._id;
	  }
	  if (id) {
	    args.unshift({ _id: id });
	  }
	  return this.findOneAndUpdate.apply(this, args);
	}
	
	/**
	 * Issue a mongodb findAndModify remove command.
	 *
	 * Finds a matching document, removes it, passing the found document (if any) to the callback.
	 *
	 * Executes immediately if `callback` is passed else a Query object is returned.
	 *
	 * ####Options:
	 *
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 * - `select`: sets the document fields to return
	 *
	 * ####Examples:
	 *
	 *     A.findOneAndRemove(conditions, options, callback) // executes
	 *     A.findOneAndRemove(conditions, options)  // return Query
	 *     A.findOneAndRemove(conditions, callback) // executes
	 *     A.findOneAndRemove(conditions) // returns Query
	 *     A.findOneAndRemove()           // returns Query
	 *
	 * Although values are cast to their appropriate types when using the findAndModify helpers, the following are *not* applied:
	 *
	 * - defaults
	 * - setters
	 * - validators
	 * - middleware
	 *
	 * If you need those features, use the traditional approach of first retrieving the document.
	 *
	 *     Model.findById(id, function (err, doc) {
	 *       if (err) ..
	 *       doc.remove(callback);
	 *     })
	 *
	 * @param {Object} conditions
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query}
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 * @api public
	 */
	
	Model.findOneAndRemove = function (conditions, options, callback) {
	  if (1 === arguments.length && 'function' == typeof conditions) {
	    var msg = 'Model.findOneAndRemove(): First argument must not be a function.\n\n'
	              + '  ' + this.modelName + '.findOneAndRemove(conditions, callback)\n'
	              + '  ' + this.modelName + '.findOneAndRemove(conditions)\n'
	              + '  ' + this.modelName + '.findOneAndRemove()\n';
	    throw new TypeError(msg)
	  }
	
	  if ('function' == typeof options) {
	    callback = options;
	    options = undefined;
	  }
	
	  var fields;
	  if (options) {
	    fields = options.select;
	    options.select = undefined;
	  }
	
	  var mq = new Query({}, {}, this, this.collection);
	  mq.select(fields);
	
	  return mq.findOneAndRemove(conditions, options, callback);
	}
	
	/**
	 * Issue a mongodb findAndModify remove command by a documents id.
	 *
	 * Finds a matching document, removes it, passing the found document (if any) to the callback.
	 *
	 * Executes immediately if `callback` is passed, else a `Query` object is returned.
	 *
	 * ####Options:
	 *
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 * - `select`: sets the document fields to return
	 *
	 * ####Examples:
	 *
	 *     A.findByIdAndRemove(id, options, callback) // executes
	 *     A.findByIdAndRemove(id, options)  // return Query
	 *     A.findByIdAndRemove(id, callback) // executes
	 *     A.findByIdAndRemove(id) // returns Query
	 *     A.findByIdAndRemove()           // returns Query
	 *
	 * @param {ObjectId|HexString} id ObjectId or string that can be cast to one
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query}
	 * @see Model.findOneAndRemove #model_Model.findOneAndRemove
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 */
	
	Model.findByIdAndRemove = function (id, options, callback) {
	  if (1 === arguments.length && 'function' == typeof id) {
	    var msg = 'Model.findByIdAndRemove(): First argument must not be a function.\n\n'
	              + '  ' + this.modelName + '.findByIdAndRemove(id, callback)\n'
	              + '  ' + this.modelName + '.findByIdAndRemove(id)\n'
	              + '  ' + this.modelName + '.findByIdAndRemove()\n';
	    throw new TypeError(msg)
	  }
	
	  return this.findOneAndRemove({ _id: id }, options, callback);
	}
	
	/**
	 * Shortcut for creating a new Document that is automatically saved to the db if valid.
	 *
	 * ####Example:
	 *
	 *     // pass individual docs
	 *     Candy.create({ type: 'jelly bean' }, { type: 'snickers' }, function (err, jellybean, snickers) {
	 *       if (err) // ...
	 *     });
	 *
	 *     // pass an array
	 *     var array = [{ type: 'jelly bean' }, { type: 'snickers' }];
	 *     Candy.create(array, function (err, candies) {
	 *       if (err) // ...
	 *
	 *       var jellybean = candies[0];
	 *       var snickers = candies[1];
	 *       // ...
	 *     });
	 *
	 *     // callback is optional; use the returned promise if you like:
	 *     var promise = Candy.create({ type: 'jawbreaker' });
	 *     promise.then(function (jawbreaker) {
	 *       // ...
	 *     })
	 *
	 * @param {Array|Object...} doc(s)
	 * @param {Function} [fn] callback
	 * @return {Promise}
	 * @api public
	 */
	
	Model.create = function create (doc, fn) {
	  var args
	    , cb
	
	  if (Array.isArray(doc)) {
	    args = doc;
	    cb = fn;
	  } else {
	    var last = arguments[arguments.length - 1];
	    if ('function' == typeof last) {
	      cb = last;
	      args = utils.args(arguments, 0, arguments.length - 1);
	    } else {
	      args = utils.args(arguments);
	    }
	  }
	
	  var promise = new Promise(cb);
	  var ModelConstructor = this;
	  if (args.length === 0) {
	    process.nextTick(function() {
	      promise.fulfill.apply(promise, null);
	    });
	    return promise;
	  }
	
	  var toExecute = [];
	  args.forEach(function(doc) {
	    toExecute.push(function(callback) {
	      (new ModelConstructor(doc)).save(function(error, doc) {
	        callback(error, doc);
	      });
	    });
	  });
	
	  async.parallel(toExecute, function(error, savedDocs) {
	    if (error) {
	      return promise.reject(error);
	    }
	
	    if (doc instanceof Array) {
	      promise.fulfill.call(promise, savedDocs);
	    } else {
	      promise.fulfill.apply(promise, savedDocs);
	    }
	  });
	
	  return promise;
	};
	
	/**
	 * Shortcut for creating a new Document from existing raw data, pre-saved in the DB.
	 * The document returned has no paths marked as modified initially.
	 *
	 * ####Example:
	 *
	 *     // hydrate previous data into a Mongoose document
	 *     var mongooseCandy = Candy.hydrate({ _id: '54108337212ffb6d459f854c', type: 'jelly bean' });
	 *
	 * @param {Object} obj
	 * @return {Document}
	 * @api public
	 */
	
	Model.hydrate = function (obj) {
	  var model = __webpack_require__(/*! ./queryhelpers */ 216).createModel(this, obj);
	  model.init(obj);
	  return model;
	};
	
	/**
	 * Updates documents in the database without returning them.
	 *
	 * ####Examples:
	 *
	 *     MyModel.update({ age: { $gt: 18 } }, { oldEnough: true }, fn);
	 *     MyModel.update({ name: 'Tobi' }, { ferret: true }, { multi: true }, function (err, raw) {
	 *       if (err) return handleError(err);
	 *       console.log('The raw response from Mongo was ', raw);
	 *     });
	 *
	 * ####Valid options:
	 *
	 *  - `safe` (boolean) safe mode (defaults to value set in schema (true))
	 *  - `upsert` (boolean) whether to create the doc if it doesn't match (false)
	 *  - `multi` (boolean) whether multiple documents should be updated (false)
	 *  - `strict` (boolean) overrides the `strict` option for this update
	 *  - `overwrite` (boolean) disables update-only mode, allowing you to overwrite the doc (false)
	 *
	 * All `update` values are cast to their appropriate SchemaTypes before being sent.
	 *
	 * The `callback` function receives `(err, rawResponse)`.
	 *
	 * - `err` is the error if any occurred
	 * - `rawResponse` is the full response from Mongo
	 *
	 * ####Note:
	 *
	 * All top level keys which are not `atomic` operation names are treated as set operations:
	 *
	 * ####Example:
	 *
	 *     var query = { name: 'borne' };
	 *     Model.update(query, { name: 'jason borne' }, options, callback)
	 *
	 *     // is sent as
	 *     Model.update(query, { $set: { name: 'jason borne' }}, options, callback)
	 *     // if overwrite option is false. If overwrite is true, sent without the $set wrapper.
	 *
	 * This helps prevent accidentally overwriting all documents in your collection with `{ name: 'jason borne' }`.
	 *
	 * ####Note:
	 *
	 * Be careful to not use an existing model instance for the update clause (this won't work and can cause weird behavior like infinite loops). Also, ensure that the update clause does not have an _id property, which causes Mongo to return a "Mod on _id not allowed" error.
	 *
	 * ####Note:
	 *
	 * To update documents without waiting for a response from MongoDB, do not pass a `callback`, then call `exec` on the returned [Query](#query-js):
	 *
	 *     Comment.update({ _id: id }, { $set: { text: 'changed' }}).exec();
	 *
	 * ####Note:
	 *
	 * Although values are casted to their appropriate types when using update, the following are *not* applied:
	 *
	 * - defaults
	 * - setters
	 * - validators
	 * - middleware
	 *
	 * If you need those features, use the traditional approach of first retrieving the document.
	 *
	 *     Model.findOne({ name: 'borne' }, function (err, doc) {
	 *       if (err) ..
	 *       doc.name = 'jason borne';
	 *       doc.save(callback);
	 *     })
	 *
	 * @see strict http://mongoosejs.com/docs/guide.html#strict
	 * @see response http://docs.mongodb.org/v2.6/reference/command/update/#output
	 * @param {Object} conditions
	 * @param {Object} doc
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query}
	 * @api public
	 */
	
	Model.update = function update (conditions, doc, options, callback) {
	  var mq = new Query({}, {}, this, this.collection);
	  // gh-2406
	  // make local deep copy of conditions
	  conditions = utils.clone(conditions);
	  options = typeof options === 'function' ? options : utils.clone(options);
	
	  return mq.update(conditions, doc, options, callback);
	};
	
	/**
	 * Executes a mapReduce command.
	 *
	 * `o` is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver implementation. See [node-mongodb-native mapReduce() documentation](http://mongodb.github.io/node-mongodb-native/api-generated/collection.html#mapreduce) for more detail about options.
	 *
	 * ####Example:
	 *
	 *     var o = {};
	 *     o.map = function () { emit(this.name, 1) }
	 *     o.reduce = function (k, vals) { return vals.length }
	 *     User.mapReduce(o, function (err, results) {
	 *       console.log(results)
	 *     })
	 *
	 * ####Other options:
	 *
	 * - `query` {Object} query filter object.
	 * - `sort` {Object} sort input objects using this key
	 * - `limit` {Number} max number of documents
	 * - `keeptemp` {Boolean, default:false} keep temporary data
	 * - `finalize` {Function} finalize function
	 * - `scope` {Object} scope variables exposed to map/reduce/finalize during execution
	 * - `jsMode` {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X
	 * - `verbose` {Boolean, default:false} provide statistics on job execution time.
	 * - `readPreference` {String}
	 * - `out*` {Object, default: {inline:1}} sets the output target for the map reduce job.
	 *
	 * ####* out options:
	 *
	 * - `{inline:1}` the results are returned in an array
	 * - `{replace: 'collectionName'}` add the results to collectionName: the results replace the collection
	 * - `{reduce: 'collectionName'}` add the results to collectionName: if dups are detected, uses the reducer / finalize functions
	 * - `{merge: 'collectionName'}` add the results to collectionName: if dups exist the new docs overwrite the old
	 *
	 * If `options.out` is set to `replace`, `merge`, or `reduce`, a Model instance is returned that can be used for further querying. Queries run against this model are all executed with the `lean` option; meaning only the js object is returned and no Mongoose magic is applied (getters, setters, etc).
	 *
	 * ####Example:
	 *
	 *     var o = {};
	 *     o.map = function () { emit(this.name, 1) }
	 *     o.reduce = function (k, vals) { return vals.length }
	 *     o.out = { replace: 'createdCollectionNameForResults' }
	 *     o.verbose = true;
	 *
	 *     User.mapReduce(o, function (err, model, stats) {
	 *       console.log('map reduce took %d ms', stats.processtime)
	 *       model.find().where('value').gt(10).exec(function (err, docs) {
	 *         console.log(docs);
	 *       });
	 *     })
	 *
	 *     // a promise is returned so you may instead write
	 *     var promise = User.mapReduce(o);
	 *     promise.then(function (model, stats) {
	 *       console.log('map reduce took %d ms', stats.processtime)
	 *       return model.find().where('value').gt(10).exec();
	 *     }).then(function (docs) {
	 *        console.log(docs);
	 *     }).then(null, handleError).end()
	 *
	 * @param {Object} o an object specifying map-reduce options
	 * @param {Function} [callback] optional callback
	 * @see http://www.mongodb.org/display/DOCS/MapReduce
	 * @return {Promise}
	 * @api public
	 */
	
	Model.mapReduce = function mapReduce (o, callback) {
	  var promise = new Promise(callback);
	  var self = this;
	
	  if (!Model.mapReduce.schema) {
	    var opts = { noId: true, noVirtualId: true, strict: false }
	    Model.mapReduce.schema = new Schema({}, opts);
	  }
	
	  if (!o.out) o.out = { inline: 1 };
	  if (false !== o.verbose) o.verbose = true;
	
	  o.map = String(o.map);
	  o.reduce = String(o.reduce);
	
	  if (o.query) {
	    var q = new Query(o.query);
	    q.cast(this);
	    o.query = q._conditions;
	    q = undefined;
	  }
	
	  this.collection.mapReduce(null, null, o, function (err, ret, stats) {
	    if (err) return promise.error(err);
	
	    if (ret.findOne && ret.mapReduce) {
	      // returned a collection, convert to Model
	      var model = Model.compile(
	          '_mapreduce_' + ret.collectionName
	        , Model.mapReduce.schema
	        , ret.collectionName
	        , self.db
	        , self.base);
	
	      model._mapreduce = true;
	
	      return promise.fulfill(model, stats);
	    }
	
	    promise.fulfill(ret, stats);
	  });
	
	  return promise;
	}
	
	/**
	 * geoNear support for Mongoose
	 *
	 * ####Options:
	 * - `lean` {Boolean} return the raw object
	 * - All options supported by the driver are also supported
	 *
	 * ####Example:
	 *
	 *     // Legacy point
	 *     Model.geoNear([1,3], { maxDistance : 5, spherical : true }, function(err, results, stats) {
	 *        console.log(results);
	 *     });
	 *
	 *     // geoJson
	 *     var point = { type : "Point", coordinates : [9,9] };
	 *     Model.geoNear(point, { maxDistance : 5, spherical : true }, function(err, results, stats) {
	 *        console.log(results);
	 *     });
	 *
	 * @param {Object/Array} GeoJSON point or legacy coordinate pair [x,y] to search near
	 * @param {Object} options for the qurery
	 * @param {Function} [callback] optional callback for the query
	 * @return {Promise}
	 * @see http://docs.mongodb.org/manual/core/2dsphere/
	 * @see http://mongodb.github.io/node-mongodb-native/api-generated/collection.html?highlight=geonear#geoNear
	 * @api public
	 */
	
	Model.geoNear = function (near, options, callback) {
	  if ('function' == typeof options) {
	    callback = options;
	    options = {};
	  }
	
	  var self = this;
	  var promise = new Promise(callback);
	  if (!near) {
	    promise.error(new Error("Must pass a near option to geoNear"));
	    return promise;
	  }
	
	  var x,y;
	
	  var handler = function (err, res) {
	    if (err) return promise.error(err);
	    if (options.lean) return promise.fulfill(res.results, res.stats);
	
	    var count = res.results.length;
	    // if there are no results, fulfill the promise now
	    if (count == 0) {
	      return promise.fulfill(res.results, res.stats);
	    }
	
	    var errSeen = false;
	    for (var i=0; i < res.results.length; i++) {
	      var temp = res.results[i].obj;
	      res.results[i].obj = new self();
	      res.results[i].obj.init(temp, function (err) {
	        if (err && !errSeen) {
	          errSeen = true;
	          return promise.error(err);
	        }
	        --count || promise.fulfill(res.results, res.stats);
	      });
	    }
	  };
	
	  if (Array.isArray(near)) {
	    if (near.length != 2) {
	      promise.error(new Error("If using legacy coordinates, must be an array of size 2 for geoNear"));
	      return promise;
	    }
	    x = near[0];
	    y = near[1];
	    this.collection.geoNear(x, y, options, handler);
	  } else {
	    if (near.type != "Point" || !Array.isArray(near.coordinates)) {
	      promise.error(new Error("Must pass either a legacy coordinate array or GeoJSON Point to geoNear"));
	      return promise;
	    }
	
	    this.collection.geoNear(near, options, handler);
	  }
	
	  return promise;
	};
	
	/**
	 * Performs [aggregations](http://docs.mongodb.org/manual/applications/aggregation/) on the models collection.
	 *
	 * If a `callback` is passed, the `aggregate` is executed and a `Promise` is returned. If a callback is not passed, the `aggregate` itself is returned.
	 *
	 * ####Example:
	 *
	 *     // Find the max balance of all accounts
	 *     Users.aggregate(
	 *         { $group: { _id: null, maxBalance: { $max: '$balance' }}}
	 *       , { $project: { _id: 0, maxBalance: 1 }}
	 *       , function (err, res) {
	 *       if (err) return handleError(err);
	 *       console.log(res); // [ { maxBalance: 98000 } ]
	 *     });
	 *
	 *     // Or use the aggregation pipeline builder.
	 *     Users.aggregate()
	 *       .group({ _id: null, maxBalance: { $max: '$balance' } })
	 *       .select('-id maxBalance')
	 *       .exec(function (err, res) {
	 *         if (err) return handleError(err);
	 *         console.log(res); // [ { maxBalance: 98 } ]
	 *     });
	 *
	 * ####NOTE:
	 *
	 * - Arguments are not cast to the model's schema because `$project` operators allow redefining the "shape" of the documents at any stage of the pipeline, which may leave documents in an incompatible format.
	 * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).
	 * - Requires MongoDB >= 2.1
	 *
	 * @see Aggregate #aggregate_Aggregate
	 * @see MongoDB http://docs.mongodb.org/manual/applications/aggregation/
	 * @param {Object|Array} [...] aggregation pipeline operator(s) or operator array
	 * @param {Function} [callback]
	 * @return {Aggregate|Promise}
	 * @api public
	 */
	
	Model.aggregate = function aggregate () {
	  var args = [].slice.call(arguments)
	    , aggregate
	    , callback;
	
	  if ('function' === typeof args[args.length - 1]) {
	    callback = args.pop();
	  }
	
	  if (1 === args.length && util.isArray(args[0])) {
	    aggregate = new Aggregate(args[0]);
	  } else {
	    aggregate = new Aggregate(args);
	  }
	
	  aggregate.bind(this);
	
	  if ('undefined' === typeof callback) {
	    return aggregate;
	  }
	
	  return aggregate.exec(callback);
	}
	
	/**
	 * Implements `$geoSearch` functionality for Mongoose
	 *
	 * ####Example:
	 *
	 *     var options = { near: [10, 10], maxDistance: 5 };
	 *     Locations.geoSearch({ type : "house" }, options, function(err, res) {
	 *       console.log(res);
	 *     });
	 *
	 * ####Options:
	 * - `near` {Array} x,y point to search for
	 * - `maxDistance` {Number} the maximum distance from the point near that a result can be
	 * - `limit` {Number} The maximum number of results to return
	 * - `lean` {Boolean} return the raw object instead of the Mongoose Model
	 *
	 * @param {Object} condition an object that specifies the match condition (required)
	 * @param {Object} options for the geoSearch, some (near, maxDistance) are required
	 * @param {Function} [callback] optional callback
	 * @return {Promise}
	 * @see http://docs.mongodb.org/manual/reference/command/geoSearch/
	 * @see http://docs.mongodb.org/manual/core/geohaystack/
	 * @api public
	 */
	
	Model.geoSearch = function (conditions, options, callback) {
	  if ('function' == typeof options) {
	    callback = options;
	    options = {};
	  }
	
	  var promise = new Promise(callback);
	
	  if (conditions == undefined || !utils.isObject(conditions)) {
	    return promise.error(new Error("Must pass conditions to geoSearch"));
	  }
	
	  if (!options.near) {
	    return promise.error(new Error("Must specify the near option in geoSearch"));
	  }
	
	  if (!Array.isArray(options.near)) {
	    return promise.error(new Error("near option must be an array [x, y]"));
	  }
	
	
	  // send the conditions in the options object
	  options.search = conditions;
	  var self = this;
	
	  this.collection.geoHaystackSearch(options.near[0], options.near[1], options, function (err, res) {
	    // have to deal with driver problem. Should be fixed in a soon-ish release
	    // (7/8/2013)
	    if (err || res.errmsg) {
	      if (!err) err = new Error(res.errmsg);
	      if (res && res.code !== undefined) err.code = res.code;
	      return promise.error(err);
	    }
	
	    var count = res.results.length;
	    if (options.lean || (count == 0)) return promise.fulfill(res.results, res.stats);
	
	    var errSeen = false;
	    for (var i=0; i < res.results.length; i++) {
	      var temp = res.results[i];
	      res.results[i] = new self();
	      res.results[i].init(temp, {}, function (err) {
	        if (err && !errSeen) {
	          errSeen = true;
	          return promise.error(err);
	        }
	
	        --count || (!errSeen && promise.fulfill(res.results, res.stats));
	      });
	    }
	  });
	
	  return promise;
	};
	
	/**
	 * Populates document references.
	 *
	 * ####Available options:
	 *
	 * - path: space delimited path(s) to populate
	 * - select: optional fields to select
	 * - match: optional query conditions to match
	 * - model: optional name of the model to use for population
	 * - options: optional query options like sort, limit, etc
	 *
	 * ####Examples:
	 *
	 *     // populates a single object
	 *     User.findById(id, function (err, user) {
	 *       var opts = [
	 *           { path: 'company', match: { x: 1 }, select: 'name' }
	 *         , { path: 'notes', options: { limit: 10 }, model: 'override' }
	 *       ]
	 *
	 *       User.populate(user, opts, function (err, user) {
	 *         console.log(user);
	 *       })
	 *     })
	 *
	 *     // populates an array of objects
	 *     User.find(match, function (err, users) {
	 *       var opts = [{ path: 'company', match: { x: 1 }, select: 'name' }]
	 *
	 *       var promise = User.populate(users, opts);
	 *       promise.then(console.log).end();
	 *     })
	 *
	 *     // imagine a Weapon model exists with two saved documents:
	 *     //   { _id: 389, name: 'whip' }
	 *     //   { _id: 8921, name: 'boomerang' }
	 *
	 *     var user = { name: 'Indiana Jones', weapon: 389 }
	 *     Weapon.populate(user, { path: 'weapon', model: 'Weapon' }, function (err, user) {
	 *       console.log(user.weapon.name) // whip
	 *     })
	 *
	 *     // populate many plain objects
	 *     var users = [{ name: 'Indiana Jones', weapon: 389 }]
	 *     users.push({ name: 'Batman', weapon: 8921 })
	 *     Weapon.populate(users, { path: 'weapon' }, function (err, users) {
	 *       users.forEach(function (user) {
	 *         console.log('%s uses a %s', users.name, user.weapon.name)
	 *         // Indiana Jones uses a whip
	 *         // Batman uses a boomerang
	 *       })
	 *     })
	 *     // Note that we didn't need to specify the Weapon model because
	 *     // we were already using it's populate() method.
	 *
	 * @param {Document|Array} docs Either a single document or array of documents to populate.
	 * @param {Object} options A hash of key/val (path, options) used for population.
	 * @param {Function} [cb(err,doc)] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.
	 * @return {Promise}
	 * @api public
	 */
	
	Model.populate = function (docs, paths, cb) {
	  var promise = new Promise(cb);
	
	  // always resolve on nextTick for consistent async behavior
	  function resolve () {
	    var args = utils.args(arguments);
	    process.nextTick(function () {
	      promise.resolve.apply(promise, args);
	    });
	  }
	
	  // normalized paths
	  var paths = utils.populate(paths);
	  var pending = paths.length;
	
	  if (0 === pending) {
	    resolve(null, docs);
	    return promise;
	  }
	
	  // each path has its own query options and must be executed separately
	  var i = pending;
	  var path;
	  var model = this;
	  while (i--) {
	    path = paths[i];
	    if ('function' === typeof path.model) model = path.model;
	    populate(model, docs, path, next);
	  }
	
	  return promise;
	
	  function next (err) {
	    if (err) return resolve(err);
	    if (--pending) return;
	    resolve(null, docs);
	  }
	}
	
	/*!
	 * Populates `docs`
	 */
	var excludeIdReg = /\s?-_id\s?/,
	  excludeIdRegGlobal = /\s?-_id\s?/g;
	
	function populate(model, docs, options, cb) {
	  var modelsMap, rawIds;
	
	  // normalize single / multiple docs passed
	  if (!Array.isArray(docs)) {
	    docs = [docs];
	  }
	
	  if (0 === docs.length || docs.every(utils.isNullOrUndefined)) {
	    return cb();
	  }
	
	  modelsMap = getModelsMapForPopulate(model, docs, options);
	  rawIds = getIdsForAndAddIdsInMapPopulate(modelsMap);
	
	  var i, len = modelsMap.length,
	    mod, match, select, promise, vals = [];
	
	  promise = new Promise(function(err, vals, options, assignmentOpts) {
	    if (err) return cb(err);
	
	    var lean = options.options && options.options.lean,
	      len = vals.length,
	      rawOrder = {}, rawDocs = {}, key, val;
	
	    // optimization:
	    // record the document positions as returned by
	    // the query result.
	    for (var i = 0; i < len; i++) {
	      val = vals[i];
	      key = String(utils.getValue('_id', val));
	      rawDocs[key] = val;
	      rawOrder[key] = i;
	
	      // flag each as result of population
	      if (!lean) val.$__.wasPopulated = true;
	    }
	
	    assignVals({
	      rawIds: rawIds,
	      rawDocs: rawDocs,
	      rawOrder: rawOrder,
	      docs: docs,
	      path: options.path,
	      options: assignmentOpts
	    });
	    cb();
	  });
	
	  for (i = 0; i < len; i++) {
	    mod = modelsMap[i];
	    select = mod.options.select;
	
	    if (mod.options.match) {
	      match = utils.object.shallowCopy(mod.options.match);
	    } else {
	      match = {};
	    }
	
	    var ids = utils.array.flatten(mod.ids, function(item) {
	      // no need to include undefined values in our query
	      return undefined !== item;
	    });
	
	    ids = utils.array.unique(ids);
	
	    if (0 === ids.length || ids.every(utils.isNullOrUndefined)) {
	      return cb();
	    }
	
	    match._id || (match._id = {
	      $in: ids
	    });
	
	    var assignmentOpts = {};
	    assignmentOpts.sort = mod.options.options && mod.options.options.sort || undefined;
	    assignmentOpts.excludeId = excludeIdReg.test(select) || (select && 0 === select._id);
	
	    if (assignmentOpts.excludeId) {
	      // override the exclusion from the query so we can use the _id
	      // for document matching during assignment. we'll delete the
	      // _id back off before returning the result.
	      if ('string' == typeof select) {
	        select = select.replace(excludeIdRegGlobal, ' ');
	      } else {
	        // preserve original select conditions by copying
	        select = utils.object.shallowCopy(select);
	        delete select._id;
	      }
	    }
	
	    if (mod.options.options && mod.options.options.limit) {
	      assignmentOpts.originalLimit = mod.options.options.limit;
	      mod.options.options.limit = mod.options.options.limit * ids.length;
	    }
	
	    mod.Model.find(match, select, mod.options.options, next.bind(this, i + 1 < len, mod.options, assignmentOpts));
	  }
	
	  function next(end, options, assignmentOpts, err, valsFromDb) {
	    if (err) return promise.resolve(err);
	    vals = vals.concat(valsFromDb);
	    if (!end) {
	      promise.resolve(err, vals, options, assignmentOpts);
	    }
	  }
	}
	
	function getModelsMapForPopulate(model, docs, options) {
	  var i, doc, len = docs.length,
	    available = {},
	    map = [],
	    modelNameFromQuery = options.model && options.model.modelName || options.model,
	    schema, refPath, Model, currentOptions, modelNames, modelName, discriminatorKey, modelForFindSchema;
	
	  schema = model._getSchema(options.path);
	
	  if(schema && schema.caster){
	    schema = schema.caster;
	  }
	
	  if (!schema && model.discriminators){
	    discriminatorKey = model.schema.discriminatorMapping.key
	  }
	
	  refPath = schema && schema.options && schema.options.refPath;
	
	  for (i = 0; i < len; i++) {
	    doc = docs[i];
	
	    if(refPath){
	      modelNames = utils.getValue(refPath, doc);
	    }else{
	      if(!modelNameFromQuery){
	        var schemaForCurrentDoc;
	
	        if(!schema && discriminatorKey){
	          modelForFindSchema = utils.getValue(discriminatorKey, doc);
	
	          if(modelForFindSchema){
	            schemaForCurrentDoc = model.db.model(modelForFindSchema)._getSchema(options.path);
	
	            if(schemaForCurrentDoc && schemaForCurrentDoc.caster){
	              schemaForCurrentDoc = schemaForCurrentDoc.caster;
	            }
	          }
	        } else {
	          schemaForCurrentDoc = schema;
	        }
	
	        modelNames = [
	          schemaForCurrentDoc && schemaForCurrentDoc.options && schemaForCurrentDoc.options.ref            // declared in schema
	          || model.modelName                                           // an ad-hoc structure
	        ]
	      }else{
	        modelNames = [modelNameFromQuery];  // query options
	      }
	    }
	
	    if (!modelNames)
	      continue;
	
	    if (!Array.isArray(modelNames)) {
	      modelNames = [modelNames];
	    }
	
	    var k = modelNames.length;
	    while (k--) {
	      modelName = modelNames[k];
	      if (!available[modelName]) {
	        Model = model.db.model(modelName);
	        currentOptions = {
	          model: Model
	        };
	
	        if(schema && !discriminatorKey){
	          options.model = Model;
	        }
	
	        utils.merge(currentOptions, options);
	
	        available[modelName] = {
	          Model: Model,
	          options: currentOptions,
	          docs: [doc],
	          ids: []
	        };
	        map.push(available[modelName]);
	      } else {
	        available[modelName].docs.push(doc);
	      }
	
	    }
	  }
	
	  return map;
	}
	
	function getIdsForAndAddIdsInMapPopulate(modelsMap) {
	  var rawIds = [] // for the correct position
	    ,
	    i, j, doc, docs, id, len, len2, ret, isDocument, populated, options, path;
	
	  len2 = modelsMap.length;
	  for (j = 0; j < len2; j++) {
	    docs = modelsMap[j].docs;
	    len = docs.length;
	    options = modelsMap[j].options;
	    path = options.path;
	
	    for (i = 0; i < len; i++) {
	      ret = undefined;
	      doc = docs[i];
	      id = String(utils.getValue("_id", doc));
	      isDocument = !! doc.$__;
	
	      if (!ret || Array.isArray(ret) && 0 === ret.length) {
	        ret = utils.getValue(path, doc);
	      }
	
	      if (ret) {
	        ret = convertTo_id(ret);
	
	        options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;
	      }
	
	      rawIds.push(ret);
	      modelsMap[j].ids.push(ret);
	
	      if (isDocument) {
	        // cache original populated _ids and model used
	        doc.populated(path, options._docs[id], options);
	      }
	    }
	  }
	
	  return rawIds;
	}
	
	/*!
	 * Retrieve the _id of `val` if a Document or Array of Documents.
	 *
	 * @param {Array|Document|Any} val
	 * @return {Array|Document|Any}
	 */
	
	function convertTo_id (val) {
	  if (val instanceof Model) return val._id;
	
	  if (Array.isArray(val)) {
	    for (var i = 0; i < val.length; ++i) {
	      if (val[i] instanceof Model) {
	        val[i] = val[i]._id;
	      }
	    }
	    return val;
	  }
	
	  return val;
	}
	
	/*!
	 * Assigns documents returned from a population query back
	 * to the original document path.
	 */
	
	function assignVals (o) {
	  // replace the original ids in our intermediate _ids structure
	  // with the documents found by query
	
	  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, o.options);
	
	  // now update the original documents being populated using the
	  // result structure that contains real documents.
	
	  var docs = o.docs;
	  var path = o.path;
	  var rawIds = o.rawIds;
	  var options = o.options;
	
	  for (var i = 0; i < docs.length; ++i) {
	    utils.setValue(path, rawIds[i], docs[i], function (val) {
	      return valueFilter(val, options);
	    });
	  }
	}
	
	/*!
	 * 1) Apply backwards compatible find/findOne behavior to sub documents
	 *
	 *    find logic:
	 *      a) filter out non-documents
	 *      b) remove _id from sub docs when user specified
	 *
	 *    findOne
	 *      a) if no doc found, set to null
	 *      b) remove _id from sub docs when user specified
	 *
	 * 2) Remove _ids when specified by users query.
	 *
	 * background:
	 * _ids are left in the query even when user excludes them so
	 * that population mapping can occur.
	 */
	
	function valueFilter (val, assignmentOpts) {
	  if (Array.isArray(val)) {
	    // find logic
	    var ret = [];
	    var numValues = val.length;
	    for (var i = 0; i < numValues; ++i) {
	      var subdoc = val[i];
	      if (!isDoc(subdoc)) continue;
	      maybeRemoveId(subdoc, assignmentOpts);
	      ret.push(subdoc);
	      if (assignmentOpts.originalLimit &&
	          ret.length >= assignmentOpts.originalLimit) {
	        break;
	      }
	    }
	
	    // Since we don't want to have to create a new mongoosearray, make sure to
	    // modify the array in place
	    while (val.length > ret.length) {
	      Array.prototype.pop.apply(val, []);
	    }
	    for (var i = 0; i < ret.length; ++i) {
	      val[i] = ret[i];
	    }
	    return val;
	  }
	
	  // findOne
	  if (isDoc(val)) {
	    maybeRemoveId(val, assignmentOpts);
	    return val;
	  }
	
	  return null;
	}
	
	/*!
	 * Remove _id from `subdoc` if user specified "lean" query option
	 */
	
	function maybeRemoveId (subdoc, assignmentOpts) {
	  if (assignmentOpts.excludeId) {
	    if ('function' == typeof subdoc.setValue) {
	      delete subdoc._doc._id;
	    } else {
	      delete subdoc._id;
	    }
	  }
	}
	
	/*!
	 * Determine if `doc` is a document returned
	 * by a populate query.
	 */
	
	function isDoc (doc) {
	  if (null == doc)
	    return false;
	
	  var type = typeof doc;
	  if ('string' == type)
	    return false;
	
	  if ('number' == type)
	    return false;
	
	  if (Buffer.isBuffer(doc))
	    return false;
	
	  if ('ObjectID' == doc.constructor.name)
	    return false;
	
	  // only docs
	  return true;
	}
	
	/*!
	 * Assign `vals` returned by mongo query to the `rawIds`
	 * structure returned from utils.getVals() honoring
	 * query sort order if specified by user.
	 *
	 * This can be optimized.
	 *
	 * Rules:
	 *
	 *   if the value of the path is not an array, use findOne rules, else find.
	 *   for findOne the results are assigned directly to doc path (including null results).
	 *   for find, if user specified sort order, results are assigned directly
	 *   else documents are put back in original order of array if found in results
	 *
	 * @param {Array} rawIds
	 * @param {Array} vals
	 * @param {Boolean} sort
	 * @api private
	 */
	
	function assignRawDocsToIdStructure (rawIds, resultDocs, resultOrder, options, recursed) {
	  // honor user specified sort order
	  var newOrder = [];
	  var sorting = options.sort && rawIds.length > 1;
	  var found;
	  var doc;
	  var sid;
	  var id;
	
	  for (var i = 0; i < rawIds.length; ++i) {
	    id = rawIds[i];
	
	    if (Array.isArray(id)) {
	      // handle [ [id0, id2], [id3] ]
	      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);
	      newOrder.push(id);
	      continue;
	    }
	
	    if (null === id && !sorting) {
	      // keep nulls for findOne unless sorting, which always
	      // removes them (backward compat)
	      newOrder.push(id);
	      continue;
	    }
	
	    sid = String(id);
	    found = false;
	
	    if (recursed) {
	      // apply find behavior
	
	      // assign matching documents in original order unless sorting
	      doc = resultDocs[sid];
	      if (doc) {
	        if (sorting) {
	          newOrder[resultOrder[sid]] = doc;
	        } else {
	          newOrder.push(doc);
	        }
	      } else {
	        newOrder.push(id);
	      }
	    } else {
	      // apply findOne behavior - if document in results, assign, else assign null
	      newOrder[i] = doc = resultDocs[sid] || null;
	    }
	  }
	
	  rawIds.length = 0;
	  if (newOrder.length) {
	    // reassign the documents based on corrected order
	
	    // forEach skips over sparse entries in arrays so we
	    // can safely use this to our advantage dealing with sorted
	    // result sets too.
	    newOrder.forEach(function (doc, i) {
	      rawIds[i] = doc;
	    });
	  }
	}
	
	/**
	 * Finds the schema for `path`. This is different than
	 * calling `schema.path` as it also resolves paths with
	 * positional selectors (something.$.another.$.path).
	 *
	 * @param {String} path
	 * @return {Schema}
	 * @api private
	 */
	
	Model._getSchema = function _getSchema (path) {
	  var schema = this.schema
	    , pathschema = schema.path(path);
	
	  if (pathschema)
	    return pathschema;
	
	  // look for arrays
	  return (function search (parts, schema) {
	    var p = parts.length + 1
	      , foundschema
	      , trypath
	
	    while (p--) {
	      trypath = parts.slice(0, p).join('.');
	      foundschema = schema.path(trypath);
	      if (foundschema) {
	        if (foundschema.caster) {
	
	          // array of Mixed?
	          if (foundschema.caster instanceof Types.Mixed) {
	            return foundschema.caster;
	          }
	
	          // Now that we found the array, we need to check if there
	          // are remaining document paths to look up for casting.
	          // Also we need to handle array.$.path since schema.path
	          // doesn't work for that.
	          // If there is no foundschema.schema we are dealing with
	          // a path like array.$
	          if (p !== parts.length && foundschema.schema) {
	            if ('$' === parts[p]) {
	              // comments.$.comments.$.title
	              return search(parts.slice(p+1), foundschema.schema);
	            } else {
	              // this is the last path of the selector
	              return search(parts.slice(p), foundschema.schema);
	            }
	          }
	        }
	        return foundschema;
	      }
	    }
	  })(path.split('.'), schema)
	}
	
	/*!
	 * Compiler utility.
	 *
	 * @param {String} name model name
	 * @param {Schema} schema
	 * @param {String} collectionName
	 * @param {Connection} connection
	 * @param {Mongoose} base mongoose instance
	 */
	
	Model.compile = function compile (name, schema, collectionName, connection, base) {
	  var versioningEnabled = false !== schema.options.versionKey;
	
	  if (versioningEnabled && !schema.paths[schema.options.versionKey]) {
	    // add versioning to top level documents only
	    var o = {};
	    o[schema.options.versionKey] = Number;
	    schema.add(o);
	  }
	
	  // generate new class
	  function model (doc, fields, skipId) {
	    if (!(this instanceof model))
	      return new model(doc, fields, skipId);
	    Model.call(this, doc, fields, skipId);
	  };
	
	  model.hooks = schema.s.hooks.clone();
	  model.base = base;
	  model.modelName = name;
	  model.__proto__ = Model;
	  model.prototype.__proto__ = Model.prototype;
	  model.model = Model.prototype.model;
	  model.db = model.prototype.db = connection;
	  model.discriminators = model.prototype.discriminators = undefined;
	
	  model.prototype.$__setSchema(schema);
	
	  var collectionOptions = {
	      bufferCommands: schema.options.bufferCommands
	    , capped: schema.options.capped
	  };
	
	  model.prototype.collection = connection.collection(
	      collectionName
	    , collectionOptions
	  );
	
	  // apply methods and statics
	  applyMethods(model, schema);
	  applyStatics(model, schema);
	
	  model.schema = model.prototype.schema;
	  model.collection = model.prototype.collection;
	
	  return model;
	};
	
	/*!
	 * Register methods for this model
	 *
	 * @param {Model} model
	 * @param {Schema} schema
	 */
	var applyMethods = function(model, schema) {
	  for (var i in schema.methods) {
	    if (typeof schema.methods[i] === 'function') {
	      model.prototype[i] = schema.methods[i];
	    } else {
	      (function(_i) {
	        Object.defineProperty(model.prototype, _i, {
	          get: function() {
	            var h = {};
	            for (var k in schema.methods[_i]) {
	              h[k] = schema.methods[_i][k].bind(this);
	            }
	            return h;
	          },
	          configurable: true
	        });
	      })(i);
	    }
	  }
	};
	
	/*!
	 * Register statics for this model
	 * @param {Model} model
	 * @param {Schema} schema
	 */
	var applyStatics = function(model, schema) {
	  for (var i in schema.statics) {
	    model[i] = schema.statics[i];
	  }
	};
	
	/*!
	 * Subclass this model with `conn`, `schema`, and `collection` settings.
	 *
	 * @param {Connection} conn
	 * @param {Schema} [schema]
	 * @param {String} [collection]
	 * @return {Model}
	 */
	
	Model.__subclass = function subclass (conn, schema, collection) {
	  // subclass model using this connection and collection name
	  var model = this;
	
	  var Model = function Model (doc, fields, skipId) {
	    if (!(this instanceof Model)) {
	      return new Model(doc, fields, skipId);
	    }
	    model.call(this, doc, fields, skipId);
	  }
	
	  Model.__proto__ = model;
	  Model.prototype.__proto__ = model.prototype;
	  Model.db = Model.prototype.db = conn;
	
	  var s = schema && 'string' != typeof schema
	    ? schema
	    : model.prototype.schema;
	
	  var options = s.options || {};
	
	  if (!collection) {
	    collection = model.prototype.schema.get('collection')
	              || utils.toCollectionName(model.modelName, options);
	  }
	
	  var collectionOptions = {
	      bufferCommands: s ? options.bufferCommands : true
	    , capped: s && options.capped
	  };
	
	  Model.prototype.collection = conn.collection(collection, collectionOptions);
	  Model.collection = Model.prototype.collection;
	  Model.init();
	  return Model;
	}
	
	/*!
	 * Module exports.
	 */
	
	module.exports = exports = Model;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 175 */
/*!****************************************!*\
  !*** ./~/mongoose/lib/schema/index.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module exports.
	 */
	
	exports.String = __webpack_require__(/*! ./string */ 176);
	
	exports.Number = __webpack_require__(/*! ./number */ 191);
	
	exports.Boolean = __webpack_require__(/*! ./boolean */ 192);
	
	exports.DocumentArray = __webpack_require__(/*! ./documentarray */ 193);
	
	exports.Array = __webpack_require__(/*! ./array */ 194);
	
	exports.Buffer = __webpack_require__(/*! ./buffer */ 196);
	
	exports.Date = __webpack_require__(/*! ./date */ 195);
	
	exports.ObjectId = __webpack_require__(/*! ./objectid */ 190);
	
	exports.Mixed = __webpack_require__(/*! ./mixed */ 180);
	
	// alias
	
	exports.Oid = exports.ObjectId;
	exports.Object = exports.Mixed;
	exports.Bool = exports.Boolean;


/***/ },
/* 176 */
/*!*****************************************!*\
  !*** ./~/mongoose/lib/schema/string.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	/*!
	 * Module dependencies.
	 */
	
	var SchemaType = __webpack_require__(/*! ../schematype */ 177)
	  , CastError = SchemaType.CastError
	  , errorMessages = __webpack_require__(/*! ../error */ 32).messages
	  , utils = __webpack_require__(/*! ../utils */ 42)
	  , Document
	
	/**
	 * String SchemaType constructor.
	 *
	 * @param {String} key
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api private
	 */
	
	function SchemaString (key, options) {
	  this.enumValues = [];
	  this.regExp = null;
	  SchemaType.call(this, key, options, 'String');
	};
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api private
	 */
	SchemaString.schemaName = 'String';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaString.prototype = Object.create( SchemaType.prototype );
	SchemaString.prototype.constructor = SchemaString;
	
	/**
	 * Adds an enum validator
	 *
	 * ####Example:
	 *
	 *     var states = 'opening open closing closed'.split(' ')
	 *     var s = new Schema({ state: { type: String, enum: states }})
	 *     var M = db.model('M', s)
	 *     var m = new M({ state: 'invalid' })
	 *     m.save(function (err) {
	 *       console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.
	 *       m.state = 'open'
	 *       m.save(callback) // success
	 *     })
	 *
	 *     // or with custom error messages
	 *     var enu = {
	 *       values: 'opening open closing closed'.split(' '),
	 *       message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'
	 *     }
	 *     var s = new Schema({ state: { type: String, enum: enu })
	 *     var M = db.model('M', s)
	 *     var m = new M({ state: 'invalid' })
	 *     m.save(function (err) {
	 *       console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`
	 *       m.state = 'open'
	 *       m.save(callback) // success
	 *     })
	 *
	 * @param {String|Object} [args...] enumeration values
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaString.prototype.enum = function () {
	  if (this.enumValidator) {
	    this.validators = this.validators.filter(function(v) {
	      return v.validator != this.enumValidator;
	    }, this);
	    this.enumValidator = false;
	  }
	
	  if (undefined === arguments[0] || false === arguments[0]) {
	    return this;
	  }
	
	  var values;
	  var errorMessage;
	
	  if (utils.isObject(arguments[0])) {
	    values = arguments[0].values;
	    errorMessage = arguments[0].message;
	  } else {
	    values = arguments;
	    errorMessage = errorMessages.String.enum;
	  }
	
	  for (var i = 0; i < values.length; i++) {
	    if (undefined !== values[i]) {
	      this.enumValues.push(this.cast(values[i]));
	    }
	  }
	
	  var vals = this.enumValues;
	  this.enumValidator = function (v) {
	    return undefined === v || ~vals.indexOf(v);
	  };
	  this.validators.push({
	    validator: this.enumValidator,
	    message: errorMessage,
	    kind: 'enum'
	  });
	
	  return this;
	};
	
	/**
	 * Adds a lowercase setter.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ email: { type: String, lowercase: true }})
	 *     var M = db.model('M', s);
	 *     var m = new M({ email: 'SomeEmail@example.COM' });
	 *     console.log(m.email) // someemail@example.com
	 *
	 * @api public
	 * @return {SchemaType} this
	 */
	
	SchemaString.prototype.lowercase = function () {
	  return this.set(function (v, self) {
	    if ('string' != typeof v) v = self.cast(v)
	    if (v) return v.toLowerCase();
	    return v;
	  });
	};
	
	/**
	 * Adds an uppercase setter.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ caps: { type: String, uppercase: true }})
	 *     var M = db.model('M', s);
	 *     var m = new M({ caps: 'an example' });
	 *     console.log(m.caps) // AN EXAMPLE
	 *
	 * @api public
	 * @return {SchemaType} this
	 */
	
	SchemaString.prototype.uppercase = function () {
	  return this.set(function (v, self) {
	    if ('string' != typeof v) v = self.cast(v)
	    if (v) return v.toUpperCase();
	    return v;
	  });
	};
	
	/**
	 * Adds a trim setter.
	 *
	 * The string value will be trimmed when set.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ name: { type: String, trim: true }})
	 *     var M = db.model('M', s)
	 *     var string = ' some name '
	 *     console.log(string.length) // 11
	 *     var m = new M({ name: string })
	 *     console.log(m.name.length) // 9
	 *
	 * @api public
	 * @return {SchemaType} this
	 */
	
	SchemaString.prototype.trim = function () {
	  return this.set(function (v, self) {
	    if ('string' != typeof v) v = self.cast(v)
	    if (v) return v.trim();
	    return v;
	  });
	};
	
	/**
	 * Sets a minimum length validator.
	 *
	 * ####Example:
	 *
	 *     var schema = new Schema({ postalCode: { type: String, minlength: 5 })
	 *     var Address = db.model('Address', schema)
	 *     var address = new Address({ postalCode: '9512' })
	 *     address.save(function (err) {
	 *       console.error(err) // validator error
	 *       address.postalCode = '95125';
	 *       address.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MINLENGTH} token which will be replaced with the invalid value
	 *     var minlength = [10, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum length ({MINLENGTH}).'];
	 *     var schema = new Schema({ postalCode: { type: String, minlength: minlength })
	 *     var Address = mongoose.model('Address', schema);
	 *     var address = new Address({ postalCode: '9512' });
	 *     s.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).
	 *     })
	 *
	 * @param {Number} value minimum string length
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaString.prototype.minlength = function (value, message) {
	  if (this.minlengthValidator) {
	    this.validators = this.validators.filter(function (v) {
	      return v.validator != this.minlengthValidator;
	    }, this);
	  }
	
	  if (null != value) {
	    var msg = message || errorMessages.String.minlength;
	    msg = msg.replace(/{MINLENGTH}/, value);
	    this.validators.push({
	      validator: this.minlengthValidator = function (v) {
	        return v === null || v.length >= value;
	      },
	      message: msg,
	      type: 'minlength'
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Sets a maximum length validator.
	 *
	 * ####Example:
	 *
	 *     var schema = new Schema({ postalCode: { type: String, maxlength: 9 })
	 *     var Address = db.model('Address', schema)
	 *     var address = new Address({ postalCode: '9512512345' })
	 *     address.save(function (err) {
	 *       console.error(err) // validator error
	 *       address.postalCode = '95125';
	 *       address.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MAXLENGTH} token which will be replaced with the invalid value
	 *     var maxlength = [10, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];
	 *     var schema = new Schema({ postalCode: { type: String, maxlength: maxlength })
	 *     var Address = mongoose.model('Address', schema);
	 *     var address = new Address({ postalCode: '9512512345' });
	 *     address.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512512345`) exceeds the maximum allowed length (10).
	 *     })
	 *
	 * @param {Number} value maximum string length
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaString.prototype.maxlength = function (value, message) {
	  if (this.maxlengthValidator) {
	    this.validators = this.validators.filter(function(v){
	      return v.validator != this.maxlengthValidator;
	    }, this);
	  }
	
	  if (null != value) {
	    var msg = message || errorMessages.String.maxlength;
	    msg = msg.replace(/{MAXLENGTH}/, value);
	    this.validators.push({
	      validator: this.maxlengthValidator = function(v) {
	        return v === null || v.length <= value;
	      },
	      message: msg,
	      type: 'maxlength'
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Sets a regexp validator.
	 *
	 * Any value that does not pass `regExp`.test(val) will fail validation.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ name: { type: String, match: /^a/ }})
	 *     var M = db.model('M', s)
	 *     var m = new M({ name: 'I am invalid' })
	 *     m.validate(function (err) {
	 *       console.error(String(err)) // "ValidationError: Path `name` is invalid (I am invalid)."
	 *       m.name = 'apples'
	 *       m.validate(function (err) {
	 *         assert.ok(err) // success
	 *       })
	 *     })
	 *
	 *     // using a custom error message
	 *     var match = [ /\.html$/, "That file doesn't end in .html ({VALUE})" ];
	 *     var s = new Schema({ file: { type: String, match: match }})
	 *     var M = db.model('M', s);
	 *     var m = new M({ file: 'invalid' });
	 *     m.validate(function (err) {
	 *       console.log(String(err)) // "ValidationError: That file doesn't end in .html (invalid)"
	 *     })
	 *
	 * Empty strings, `undefined`, and `null` values always pass the match validator. If you require these values, enable the `required` validator also.
	 *
	 *     var s = new Schema({ name: { type: String, match: /^a/, required: true }})
	 *
	 * @param {RegExp} regExp regular expression to test against
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaString.prototype.match = function match (regExp, message) {
	  // yes, we allow multiple match validators
	
	  var msg = message || errorMessages.String.match;
	
	  var matchValidator = function(v) {
	    var ret = ((null != v && '' !== v)
	      ? regExp.test(v)
	      : true);
	    return ret;
	  };
	
	  this.validators.push({ validator: matchValidator, message: msg, type: 'regexp' });
	  return this;
	};
	
	/**
	 * Check required
	 *
	 * @param {String|null|undefined} value
	 * @api private
	 */
	
	SchemaString.prototype.checkRequired = function checkRequired (value, doc) {
	  if (SchemaType._isRef(this, value, doc, true)) {
	    return null != value;
	  } else {
	    return (value instanceof String || typeof value == 'string') && value.length;
	  }
	};
	
	/**
	 * Casts to String
	 *
	 * @api private
	 */
	
	SchemaString.prototype.cast = function (value, doc, init) {
	  if (SchemaType._isRef(this, value, doc, init)) {
	    // wait! we may need to cast this to a document
	
	    if (null == value) {
	      return value;
	    }
	
	    // lazy load
	    Document || (Document = __webpack_require__(/*! ./../document */ 178));
	
	    if (value instanceof Document) {
	      value.$__.wasPopulated = true;
	      return value;
	    }
	
	    // setting a populated path
	    if ('string' == typeof value) {
	      return value;
	    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {
	      throw new CastError('string', value, this.path);
	    }
	
	    // Handle the case where user directly sets a populated
	    // path to a plain object; cast to the Model used in
	    // the population query.
	    var path = doc.$__fullPath(this.path);
	    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;
	    var pop = owner.populated(path, true);
	    var ret = new pop.options.model(value);
	    ret.$__.wasPopulated = true;
	    return ret;
	  }
	
	  // If null or undefined
	  if (value == null) {
	    return value;
	  }
	
	  if ('undefined' !== typeof value) {
	    // handle documents being passed
	    if (value._id && 'string' == typeof value._id) {
	      return value._id;
	    }
	
	    // Re: gh-647 and gh-3030, we're ok with casting using `toString()`
	    // **unless** its the default Object.toString, because "[object Object]"
	    // doesn't really qualify as useful data
	    if (value.toString && value.toString !== Object.prototype.toString) {
	      return value.toString();
	    }
	  }
	
	  throw new CastError('string', value, this.path);
	};
	
	/*!
	 * ignore
	 */
	
	function handleSingle (val) {
	  return this.castForQuery(val);
	}
	
	function handleArray (val) {
	  var self = this;
	  return val.map(function (m) {
	    return self.castForQuery(m);
	  });
	}
	
	SchemaString.prototype.$conditionalHandlers =
	  utils.options(SchemaType.prototype.$conditionalHandlers, {
	    '$all': handleArray,
	    '$gt' : handleSingle,
	    '$gte': handleSingle,
	    '$in' : handleArray,
	    '$lt' : handleSingle,
	    '$lte': handleSingle,
	    '$ne' : handleSingle,
	    '$nin': handleArray,
	    '$options': handleSingle,
	    '$regex': handleSingle
	  });
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [val]
	 * @api private
	 */
	
	SchemaString.prototype.castForQuery = function ($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	    if (!handler)
	      throw new Error("Can't use " + $conditional + " with String.");
	    return handler.call(this, val);
	  } else {
	    val = $conditional;
	    if (val instanceof RegExp) return val;
	    return this.cast(val);
	  }
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaString;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 177 */
/*!**************************************!*\
  !*** ./~/mongoose/lib/schematype.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * Module dependencies.
	 */
	
	var utils = __webpack_require__(/*! ./utils */ 42);
	var error = __webpack_require__(/*! ./error */ 32);
	var errorMessages = error.messages;
	var CastError = error.CastError;
	var ValidatorError = error.ValidatorError;
	
	/**
	 * SchemaType constructor
	 *
	 * @param {String} path
	 * @param {Object} [options]
	 * @param {String} [instance]
	 * @api public
	 */
	
	function SchemaType (path, options, instance) {
	  this.path = path;
	  this.instance = instance;
	  this.validators = [];
	  this.setters = [];
	  this.getters = [];
	  this.options = options;
	  this._index = null;
	  this.selected;
	
	  for (var i in options) if (this[i] && 'function' == typeof this[i]) {
	    // { unique: true, index: true }
	    if ('index' == i && this._index) continue;
	
	    var opts = Array.isArray(options[i])
	      ? options[i]
	      : [options[i]];
	
	    this[i].apply(this, opts);
	  }
	};
	
	/**
	 * Sets a default value for this SchemaType.
	 *
	 * ####Example:
	 *
	 *     var schema = new Schema({ n: { type: Number, default: 10 })
	 *     var M = db.model('M', schema)
	 *     var m = new M;
	 *     console.log(m.n) // 10
	 *
	 * Defaults can be either `functions` which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.
	 *
	 * ####Example:
	 *
	 *     // values are cast:
	 *     var schema = new Schema({ aNumber: { type: Number, default: 4.815162342 }})
	 *     var M = db.model('M', schema)
	 *     var m = new M;
	 *     console.log(m.aNumber) // 4.815162342
	 *
	 *     // default unique objects for Mixed types:
	 *     var schema = new Schema({ mixed: Schema.Types.Mixed });
	 *     schema.path('mixed').default(function () {
	 *       return {};
	 *     });
	 *
	 *     // if we don't use a function to return object literals for Mixed defaults,
	 *     // each document will receive a reference to the same object literal creating
	 *     // a "shared" object instance:
	 *     var schema = new Schema({ mixed: Schema.Types.Mixed });
	 *     schema.path('mixed').default({});
	 *     var M = db.model('M', schema);
	 *     var m1 = new M;
	 *     m1.mixed.added = 1;
	 *     console.log(m1.mixed); // { added: 1 }
	 *     var m2 = new M;
	 *     console.log(m2.mixed); // { added: 1 }
	 *
	 * @param {Function|any} val the default value
	 * @return {defaultValue}
	 * @api public
	 */
	
	SchemaType.prototype.default = function (val) {
	  if (1 === arguments.length) {
	    this.defaultValue = typeof val === 'function'
	      ? val
	      : this.cast(val);
	    return this;
	  } else if (arguments.length > 1) {
	    this.defaultValue = utils.args(arguments);
	  }
	  return this.defaultValue;
	};
	
	/**
	 * Declares the index options for this schematype.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ name: { type: String, index: true })
	 *     var s = new Schema({ loc: { type: [Number], index: 'hashed' })
	 *     var s = new Schema({ loc: { type: [Number], index: '2d', sparse: true })
	 *     var s = new Schema({ loc: { type: [Number], index: { type: '2dsphere', sparse: true }})
	 *     var s = new Schema({ date: { type: Date, index: { unique: true, expires: '1d' }})
	 *     Schema.path('my.path').index(true);
	 *     Schema.path('my.date').index({ expires: 60 });
	 *     Schema.path('my.path').index({ unique: true, sparse: true });
	 *
	 * ####NOTE:
	 *
	 * _Indexes are created in the background by default. Specify `background: false` to override._
	 *
	 * [Direction doesn't matter for single key indexes](http://www.mongodb.org/display/DOCS/Indexes#Indexes-CompoundKeysIndexes)
	 *
	 * @param {Object|Boolean|String} options
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.index = function (options) {
	  this._index = options;
	  utils.expires(this._index);
	  return this;
	};
	
	/**
	 * Declares an unique index.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ name: { type: String, unique: true })
	 *     Schema.path('name').index({ unique: true });
	 *
	 * _NOTE: violating the constraint returns an `E11000` error from MongoDB when saving, not a Mongoose validation error._
	 *
	 * @param {Boolean} bool
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.unique = function (bool) {
	  if (null == this._index || 'boolean' == typeof this._index) {
	    this._index = {};
	  } else if ('string' == typeof this._index) {
	    this._index = { type: this._index };
	  }
	
	  this._index.unique = bool;
	  return this;
	};
	
	/**
	 * Declares a full text index.
	 *
	 * ###Example:
	 *
	 *      var s = new Schema({name : {type: String, text : true })
	 *      Schema.path('name').index({text : true});
	 * @param bool
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.text = function(bool) {
	  if (null == this._index || 'boolean' == typeof this._index) {
	    this._index = {};
	  } else if ('string' == typeof this._index) {
	    this._index = { type: this._index };
	  }
	
	  this._index.text = bool;
	  return this;
	};
	
	/**
	 * Declares a sparse index.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ name: { type: String, sparse: true })
	 *     Schema.path('name').index({ sparse: true });
	 *
	 * @param {Boolean} bool
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.sparse = function (bool) {
	  if (null == this._index || 'boolean' == typeof this._index) {
	    this._index = {};
	  } else if ('string' == typeof this._index) {
	    this._index = { type: this._index };
	  }
	
	  this._index.sparse = bool;
	  return this;
	};
	
	/**
	 * Adds a setter to this schematype.
	 *
	 * ####Example:
	 *
	 *     function capitalize (val) {
	 *       if ('string' != typeof val) val = '';
	 *       return val.charAt(0).toUpperCase() + val.substring(1);
	 *     }
	 *
	 *     // defining within the schema
	 *     var s = new Schema({ name: { type: String, set: capitalize }})
	 *
	 *     // or by retreiving its SchemaType
	 *     var s = new Schema({ name: String })
	 *     s.path('name').set(capitalize)
	 *
	 * Setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.
	 *
	 * Suppose you are implementing user registration for a website. Users provide an email and password, which gets saved to mongodb. The email is a string that you will want to normalize to lower case, in order to avoid one email having more than one account -- e.g., otherwise, avenue@q.com can be registered for 2 accounts via avenue@q.com and AvEnUe@Q.CoM.
	 *
	 * You can set up email lower case normalization easily via a Mongoose setter.
	 *
	 *     function toLower (v) {
	 *       return v.toLowerCase();
	 *     }
	 *
	 *     var UserSchema = new Schema({
	 *       email: { type: String, set: toLower }
	 *     })
	 *
	 *     var User = db.model('User', UserSchema)
	 *
	 *     var user = new User({email: 'AVENUE@Q.COM'})
	 *     console.log(user.email); // 'avenue@q.com'
	 *
	 *     // or
	 *     var user = new User
	 *     user.email = 'Avenue@Q.com'
	 *     console.log(user.email) // 'avenue@q.com'
	 *
	 * As you can see above, setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.
	 *
	 * _NOTE: we could have also just used the built-in `lowercase: true` SchemaType option instead of defining our own function._
	 *
	 *     new Schema({ email: { type: String, lowercase: true }})
	 *
	 * Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.
	 *
	 *     function inspector (val, schematype) {
	 *       if (schematype.options.required) {
	 *         return schematype.path + ' is required';
	 *       } else {
	 *         return val;
	 *       }
	 *     }
	 *
	 *     var VirusSchema = new Schema({
	 *       name: { type: String, required: true, set: inspector },
	 *       taxonomy: { type: String, set: inspector }
	 *     })
	 *
	 *     var Virus = db.model('Virus', VirusSchema);
	 *     var v = new Virus({ name: 'Parvoviridae', taxonomy: 'Parvovirinae' });
	 *
	 *     console.log(v.name);     // name is required
	 *     console.log(v.taxonomy); // Parvovirinae
	 *
	 * @param {Function} fn
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.set = function (fn) {
	  if ('function' != typeof fn)
	    throw new TypeError('A setter must be a function.');
	  this.setters.push(fn);
	  return this;
	};
	
	/**
	 * Adds a getter to this schematype.
	 *
	 * ####Example:
	 *
	 *     function dob (val) {
	 *       if (!val) return val;
	 *       return (val.getMonth() + 1) + "/" + val.getDate() + "/" + val.getFullYear();
	 *     }
	 *
	 *     // defining within the schema
	 *     var s = new Schema({ born: { type: Date, get: dob })
	 *
	 *     // or by retreiving its SchemaType
	 *     var s = new Schema({ born: Date })
	 *     s.path('born').get(dob)
	 *
	 * Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.
	 *
	 * Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:
	 *
	 *     function obfuscate (cc) {
	 *       return '****-****-****-' + cc.slice(cc.length-4, cc.length);
	 *     }
	 *
	 *     var AccountSchema = new Schema({
	 *       creditCardNumber: { type: String, get: obfuscate }
	 *     });
	 *
	 *     var Account = db.model('Account', AccountSchema);
	 *
	 *     Account.findById(id, function (err, found) {
	 *       console.log(found.creditCardNumber); // '****-****-****-1234'
	 *     });
	 *
	 * Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.
	 *
	 *     function inspector (val, schematype) {
	 *       if (schematype.options.required) {
	 *         return schematype.path + ' is required';
	 *       } else {
	 *         return schematype.path + ' is not';
	 *       }
	 *     }
	 *
	 *     var VirusSchema = new Schema({
	 *       name: { type: String, required: true, get: inspector },
	 *       taxonomy: { type: String, get: inspector }
	 *     })
	 *
	 *     var Virus = db.model('Virus', VirusSchema);
	 *
	 *     Virus.findById(id, function (err, virus) {
	 *       console.log(virus.name);     // name is required
	 *       console.log(virus.taxonomy); // taxonomy is not
	 *     })
	 *
	 * @param {Function} fn
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.get = function (fn) {
	  if ('function' != typeof fn)
	    throw new TypeError('A getter must be a function.');
	  this.getters.push(fn);
	  return this;
	};
	
	/**
	 * Adds validator(s) for this document path.
	 *
	 * Validators always receive the value to validate as their first argument and must return `Boolean`. Returning `false` means validation failed.
	 *
	 * The error message argument is optional. If not passed, the [default generic error message template](#error_messages_MongooseError-messages) will be used.
	 *
	 * ####Examples:
	 *
	 *     // make sure every value is equal to "something"
	 *     function validator (val) {
	 *       return val == 'something';
	 *     }
	 *     new Schema({ name: { type: String, validate: validator }});
	 *
	 *     // with a custom error message
	 *
	 *     var custom = [validator, 'Uh oh, {PATH} does not equal "something".']
	 *     new Schema({ name: { type: String, validate: custom }});
	 *
	 *     // adding many validators at a time
	 *
	 *     var many = [
	 *         { validator: validator, msg: 'uh oh' }
	 *       , { validator: anotherValidator, msg: 'failed' }
	 *     ]
	 *     new Schema({ name: { type: String, validate: many }});
	 *
	 *     // or utilizing SchemaType methods directly:
	 *
	 *     var schema = new Schema({ name: 'string' });
	 *     schema.path('name').validate(validator, 'validation of `{PATH}` failed with value `{VALUE}`');
	 *
	 * ####Error message templates:
	 *
	 * From the examples above, you may have noticed that error messages support baseic templating. There are a few other template keywords besides `{PATH}` and `{VALUE}` too. To find out more, details are available [here](#error_messages_MongooseError-messages)
	 *
	 * ####Asynchronous validation:
	 *
	 * Passing a validator function that receives two arguments tells mongoose that the validator is an asynchronous validator. The first argument passed to the validator function is the value being validated. The second argument is a callback function that must called when you finish validating the value and passed either `true` or `false` to communicate either success or failure respectively.
	 *
	 *     schema.path('name').validate(function (value, respond) {
	 *       doStuff(value, function () {
	 *         ...
	 *         respond(false); // validation failed
	 *       })
	*      }, '{PATH} failed validation.');
	*
	 * You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.
	 *
	 * Validation occurs `pre('save')` or whenever you manually execute [document#validate](#document_Document-validate).
	 *
	 * If validation fails during `pre('save')` and no callback was passed to receive the error, an `error` event will be emitted on your Models associated db [connection](#connection_Connection), passing the validation error object along.
	 *
	 *     var conn = mongoose.createConnection(..);
	 *     conn.on('error', handleError);
	 *
	 *     var Product = conn.model('Product', yourSchema);
	 *     var dvd = new Product(..);
	 *     dvd.save(); // emits error on the `conn` above
	 *
	 * If you desire handling these errors at the Model level, attach an `error` listener to your Model and the event will instead be emitted there.
	 *
	 *     // registering an error listener on the Model lets us handle errors more locally
	 *     Product.on('error', handleError);
	 *
	 * @param {RegExp|Function|Object} obj validator
	 * @param {String} [errorMsg] optional error message
	 * @param {String} [type] optional validator type
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.validate = function (obj, message, type) {
	  if ('function' == typeof obj || obj && 'RegExp' === utils.getFunctionName(obj.constructor)) {
	    var properties;
	    if (message instanceof Object && !type) {
	      properties = utils.clone(message);
	      if (!properties.message) {
	        properties.message = properties.msg;
	      }
	      properties.validator = obj;
	      properties.type = properties.type || 'user defined';
	    } else {
	      if (!message) message = errorMessages.general.default;
	      if (!type) type = 'user defined';
	      properties = { message: message, type: type, validator: obj };
	    }
	    this.validators.push(properties);
	    return this;
	  }
	
	  var i
	    , length
	    , arg;
	
	  for (i=0, length=arguments.length; i<length; i++) {
	    arg = arguments[i];
	    if (!(arg && 'Object' === utils.getFunctionName(arg.constructor))) {
	      var msg = 'Invalid validator. Received (' + typeof arg + ') '
	        + arg
	        + '. See http://mongoosejs.com/docs/api.html#schematype_SchemaType-validate';
	
	      throw new Error(msg);
	    }
	    this.validate(arg.validator, arg);
	  }
	
	  return this;
	};
	
	/**
	 * Adds a required validator to this schematype. The required validator is added
	 * to the front of the validators array using `unshift()`.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ born: { type: Date, required: true })
	 *
	 *     // or with custom error message
	 *
	 *     var s = new Schema({ born: { type: Date, required: '{PATH} is required!' })
	 *
	 *     // or through the path API
	 *
	 *     Schema.path('name').required(true);
	 *
	 *     // with custom error messaging
	 *
	 *     Schema.path('name').required(true, 'grrr :( ');
	 *
	 *
	 * @param {Boolean} required enable/disable the validator
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaType.prototype.required = function (required, message) {
	  if (false === required) {
	    this.validators = this.validators.filter(function (v) {
	      return v.validator != this.requiredValidator;
	    }, this);
	
	    this.isRequired = false;
	    return this;
	  }
	
	  var self = this;
	  this.isRequired = true;
	
	  this.requiredValidator = function (v) {
	    // in here, `this` refers to the validating document.
	    // no validation when this path wasn't selected in the query.
	    if ('isSelected' in this &&
	        !this.isSelected(self.path) &&
	        !this.isModified(self.path)) return true;
	
	    return (('function' === typeof required) && !required.apply(this)) ||
	        self.checkRequired(v, this);
	  }
	
	  if ('string' == typeof required) {
	    message = required;
	    required = undefined;
	  }
	
	  var msg = message || errorMessages.general.required;
	  this.validators.unshift({
	    validator: this.requiredValidator,
	    message: msg,
	    type: 'required'
	  });
	
	  return this;
	};
	
	/**
	 * Gets the default value
	 *
	 * @param {Object} scope the scope which callback are executed
	 * @param {Boolean} init
	 * @api private
	 */
	
	SchemaType.prototype.getDefault = function (scope, init) {
	  var ret = 'function' === typeof this.defaultValue
	    ? this.defaultValue.call(scope)
	    : this.defaultValue;
	
	  if (null !== ret && undefined !== ret) {
	    return this.cast(ret, scope, init);
	  } else {
	    return ret;
	  }
	};
	
	/**
	 * Applies setters
	 *
	 * @param {Object} value
	 * @param {Object} scope
	 * @param {Boolean} init
	 * @api private
	 */
	
	SchemaType.prototype.applySetters = function (value, scope, init, priorVal) {
	  var v = value
	    , setters = this.setters
	    , len = setters.length
	    , caster = this.caster;
	
	  while (len--) {
	    v = setters[len].call(scope, v, this);
	  }
	
	  if (Array.isArray(v) && caster && caster.setters) {
	    var newVal = [];
	    for (var i = 0; i < v.length; i++) {
	      newVal.push(caster.applySetters(v[i], scope, init, priorVal));
	    }
	    v = newVal;
	  }
	
	  if (null === v || undefined === v) return v;
	
	  // do not cast until all setters are applied #665
	  v = this.cast(v, scope, init, priorVal);
	
	  return v;
	};
	
	/**
	 * Applies getters to a value
	 *
	 * @param {Object} value
	 * @param {Object} scope
	 * @api private
	 */
	
	SchemaType.prototype.applyGetters = function (value, scope) {
	  var v = value
	    , getters = this.getters
	    , len = getters.length;
	
	  if (!len) {
	    return v;
	  }
	
	  while (len--) {
	    v = getters[len].call(scope, v, this);
	  }
	
	  return v;
	};
	
	/**
	 * Sets default `select()` behavior for this path.
	 *
	 * Set to `true` if this path should always be included in the results, `false` if it should be excluded by default. This setting can be overridden at the query level.
	 *
	 * ####Example:
	 *
	 *     T = db.model('T', new Schema({ x: { type: String, select: true }}));
	 *     T.find(..); // field x will always be selected ..
	 *     // .. unless overridden;
	 *     T.find().select('-x').exec(callback);
	 *
	 * @param {Boolean} val
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.select = function select (val) {
	  this.selected = !! val;
	  return this;
	};
	
	/**
	 * Performs a validation of `value` using the validators declared for this SchemaType.
	 *
	 * @param {any} value
	 * @param {Function} callback
	 * @param {Object} scope
	 * @api private
	 */
	
	SchemaType.prototype.doValidate = function (value, fn, scope) {
	  var err = false
	    , path = this.path
	    , count = this.validators.length;
	
	  if (!count) return fn(null);
	
	  var validate = function(ok, validatorProperties) {
	    if (err) return;
	    if (ok === undefined || ok) {
	      --count || fn(null);
	    } else {
	      err = new ValidatorError(validatorProperties);
	      fn(err);
	    }
	  };
	
	  var self = this;
	  this.validators.forEach(function (v) {
	    if (err) {
	      return;
	    }
	
	    var validator = v.validator;
	
	    var validatorProperties = utils.clone(v);
	    validatorProperties.path = path;
	    validatorProperties.value = value;
	
	    if (validator instanceof RegExp) {
	      validate(validator.test(value), validatorProperties);
	    } else if ('function' === typeof validator) {
	      if (value === undefined && !self.isRequired) {
	        validate(true, validatorProperties);
	        return;
	      }
	      if (2 === validator.length) {
	        validator.call(scope, value, function (ok) {
	          validate(ok, validatorProperties);
	        });
	      } else {
	        validate(validator.call(scope, value), validatorProperties);
	      }
	    }
	  });
	};
	
	/**
	 * Performs a validation of `value` using the validators declared for this SchemaType.
	 *
	 * ####Note:
	 *
	 * This method ignores the asynchronous validators.
	 *
	 * @param {any} value
	 * @param {Object} scope
	 * @return {MongooseError|undefined}
	 * @api private
	 */
	
	SchemaType.prototype.doValidateSync = function (value, scope) {
	  var err = null
	    , path = this.path
	    , count = this.validators.length;
	
	  if (!count) return null;
	
	  var validate = function(ok, validatorProperties) {
	    if (err) return;
	    if (ok === undefined || ok) {
	
	    } else {
	      err = new ValidatorError(validatorProperties);
	    }
	  };
	
	  var self = this;
	  if (value === undefined && !self.isRequired) {
	    return null;
	  }
	
	  this.validators.forEach(function (v) {
	    var validator = v.validator;
	    var validatorProperties = utils.clone(v);
	    validatorProperties.path = path;
	    validatorProperties.value = value;
	
	    if (validator instanceof RegExp) {
	      validate(validator.test(value), validatorProperties);
	    } else if ('function' === typeof validator) {
	      // if not async validators
	      if (2 !== validator.length) {
	        validate(validator.call(scope, value), validatorProperties);
	      }
	    }
	  });
	
	  return err;
	};
	
	/**
	 * Determines if value is a valid Reference.
	 *
	 * @param {SchemaType} self
	 * @param {Object} value
	 * @param {Document} doc
	 * @param {Boolean} init
	 * @return {Boolean}
	 * @api private
	 */
	
	SchemaType._isRef = function (self, value, doc, init) {
	  // fast path
	  var ref = init && self.options && self.options.ref;
	
	  if (!ref && doc && doc.$__fullPath) {
	    // checks for
	    // - this populated with adhoc model and no ref was set in schema OR
	    // - setting / pushing values after population
	    var path = doc.$__fullPath(self.path);
	    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;
	    ref = owner.populated(path);
	  }
	
	  if (ref) {
	    if (null == value) return true;
	    if (!Buffer.isBuffer(value) &&  // buffers are objects too
	        'Binary' != value._bsontype // raw binary value from the db
	        && utils.isObject(value)    // might have deselected _id in population query
	       ) {
	      return true;
	    }
	  }
	
	  return false;
	};
	
	/*!
	 * ignore
	 */
	
	function handleSingle(val) {
	  return this.cast(val);
	}
	
	// Default conditional handlers for all schema types
	SchemaType.prototype.$conditionalHandlers = {
	  '$eq': handleSingle
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = exports = SchemaType;
	
	exports.CastError = CastError;
	
	exports.ValidatorError = ValidatorError;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 178 */
/*!************************************!*\
  !*** ./~/mongoose/lib/document.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {/*!
	 * Module dependencies.
	 */
	
	var EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter
	  , setMaxListeners = EventEmitter.prototype.setMaxListeners
	  , MongooseError = __webpack_require__(/*! ./error */ 32)
	  , MixedSchema = __webpack_require__(/*! ./schema/mixed */ 180)
	  , Schema = __webpack_require__(/*! ./schema */ 41)
	  , ObjectId = __webpack_require__(/*! ./types/objectid */ 45)
	  , ValidatorError = __webpack_require__(/*! ./schematype */ 177).ValidatorError
	  , utils = __webpack_require__(/*! ./utils */ 42)
	  , clone = utils.clone
	  , isMongooseObject = utils.isMongooseObject
	  , inspect = __webpack_require__(/*! util */ 57).inspect
	  , ValidationError = MongooseError.ValidationError
	  , InternalCache = __webpack_require__(/*! ./internal */ 181)
	  , deepEqual = utils.deepEqual
	  , hooks = __webpack_require__(/*! hooks-fixed */ 179)
	  , Promise = __webpack_require__(/*! ./promise */ 183)
	  , DocumentArray
	  , MongooseArray
	  , Embedded
	
	/**
	 * Document constructor.
	 *
	 * @param {Object} obj the values to set
	 * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data
	 * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `init`: Emitted on a document after it has was retreived from the db and fully hydrated by Mongoose.
	 * @event `save`: Emitted when the document is successfully saved
	 * @api private
	 */
	
	function Document (obj, fields, skipId) {
	  this.$__ = new InternalCache;
	  this.$__.emitter = new EventEmitter();
	  this.isNew = true;
	  this.errors = undefined;
	
	  var schema = this.schema;
	
	  if ('boolean' === typeof fields) {
	    this.$__.strictMode = fields;
	    fields = undefined;
	  } else {
	    this.$__.strictMode = schema.options && schema.options.strict;
	    this.$__.selected = fields;
	  }
	
	  var required = schema.requiredPaths();
	  for (var i = 0; i < required.length; ++i) {
	    this.$__.activePaths.require(required[i]);
	  }
	
	  this.$__.emitter.setMaxListeners(0);
	  this._doc = this.$__buildDoc(obj, fields, skipId);
	
	  if (obj) {
	    this.set(obj, undefined, true);
	  }
	
	  if (!schema.options.strict && obj) {
	    var self = this
	      , keys = Object.keys(this._doc);
	
	    keys.forEach(function(key) {
	      if (!(key in schema.tree)) {
	        defineKey(key, null, self);
	      }
	    });
	  }
	
	  this.$__registerHooksFromSchema();
	}
	
	/*!
	 * Document exposes the NodeJS event emitter API, so you can use
	 * `on`, `once`, etc.
	 */
	utils.each(
	  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',
	    'removeAllListeners', 'addListener'],
	  function(emitterFn) {
	    Document.prototype[emitterFn] = function() {
	      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
	    };
	  });
	
	Document.prototype.constructor = Document;
	
	/**
	 * The documents schema.
	 *
	 * @api public
	 * @property schema
	 */
	
	Document.prototype.schema;
	
	/**
	 * Boolean flag specifying if the document is new.
	 *
	 * @api public
	 * @property isNew
	 */
	
	Document.prototype.isNew;
	
	/**
	 * The string version of this documents _id.
	 *
	 * ####Note:
	 *
	 * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.
	 *
	 *     new Schema({ name: String }, { id: false });
	 *
	 * @api public
	 * @see Schema options /docs/guide.html#options
	 * @property id
	 */
	
	Document.prototype.id;
	
	/**
	 * Hash containing current validation errors.
	 *
	 * @api public
	 * @property errors
	 */
	
	Document.prototype.errors;
	
	/**
	 * Builds the default doc structure
	 *
	 * @param {Object} obj
	 * @param {Object} [fields]
	 * @param {Boolean} [skipId]
	 * @return {Object}
	 * @api private
	 * @method $__buildDoc
	 * @memberOf Document
	 */
	
	Document.prototype.$__buildDoc = function (obj, fields, skipId) {
	  var doc = {}
	    , self = this
	    , exclude
	    , keys
	    , key
	    , ki
	
	  // determine if this doc is a result of a query with
	  // excluded fields
	  if (fields && 'Object' === utils.getFunctionName(fields.constructor)) {
	    keys = Object.keys(fields);
	    ki = keys.length;
	
	    while (ki--) {
	      if ('_id' !== keys[ki]) {
	        exclude = 0 === fields[keys[ki]];
	        break;
	      }
	    }
	  }
	
	  var paths = Object.keys(this.schema.paths)
	    , plen = paths.length
	    , ii = 0
	
	  for (; ii < plen; ++ii) {
	    var p = paths[ii];
	
	    if ('_id' == p) {
	      if (skipId) continue;
	      if (obj && '_id' in obj) continue;
	    }
	
	    var type = this.schema.paths[p];
	    var path = p.split('.');
	    var len = path.length;
	    var last = len - 1;
	    var curPath = '';
	    var doc_ = doc;
	    var i = 0;
	    var included = false;
	
	    for (; i < len; ++i) {
	      var piece = path[i]
	        , def
	
	      curPath += piece;
	
	      // support excluding intermediary levels
	      if (exclude) {
	        if (curPath in fields) break;
	      } else if (fields && curPath in fields) {
	        included = true;
	      }
	
	      if (i === last) {
	        if (fields) {
	          if (exclude) {
	            // apply defaults to all non-excluded fields
	            if (p in fields) continue;
	
	            def = type.getDefault(self, true);
	            if ('undefined' !== typeof def) {
	              doc_[piece] = def;
	              self.$__.activePaths.default(p);
	            }
	
	          } else if (included) {
	            // selected field
	            def = type.getDefault(self, true);
	            if ('undefined' !== typeof def) {
	              doc_[piece] = def;
	              self.$__.activePaths.default(p);
	            }
	          }
	        } else {
	          def = type.getDefault(self, true);
	          if ('undefined' !== typeof def) {
	            doc_[piece] = def;
	            self.$__.activePaths.default(p);
	          }
	        }
	      } else {
	        doc_ = doc_[piece] || (doc_[piece] = {});
	        curPath += '.';
	      }
	    }
	  }
	
	  return doc;
	};
	
	/**
	 * Initializes the document without setters or marking anything modified.
	 *
	 * Called internally after a document is returned from mongodb.
	 *
	 * @param {Object} doc document returned by mongo
	 * @param {Function} fn callback
	 * @api private
	 */
	
	Document.prototype.init = function (doc, opts, fn) {
	  // do not prefix this method with $__ since its
	  // used by public hooks
	
	  if ('function' == typeof opts) {
	    fn = opts;
	    opts = null;
	  }
	
	  this.isNew = false;
	
	  // handle docs with populated paths
	  // If doc._id is not null or undefined
	  if (doc._id != null && opts && opts.populated && opts.populated.length) {
	    var id = String(doc._id);
	    for (var i = 0; i < opts.populated.length; ++i) {
	      var item = opts.populated[i];
	      this.populated(item.path, item._docs[id], item);
	    }
	  }
	
	  init(this, doc, this._doc);
	  this.$__storeShard();
	
	  this.emit('init', this);
	  if (fn) fn(null);
	  return this;
	};
	
	/*!
	 * Init helper.
	 *
	 * @param {Object} self document instance
	 * @param {Object} obj raw mongodb doc
	 * @param {Object} doc object we are initializing
	 * @api private
	 */
	
	function init (self, obj, doc, prefix) {
	  prefix = prefix || '';
	
	  var keys = Object.keys(obj)
	    , len = keys.length
	    , schema
	    , path
	    , i;
	
	  while (len--) {
	    i = keys[len];
	    path = prefix + i;
	    schema = self.schema.path(path);
	
	    if (!schema && utils.isObject(obj[i]) &&
	        (!obj[i].constructor || 'Object' == utils.getFunctionName(obj[i].constructor))) {
	      // assume nested object
	      if (!doc[i]) doc[i] = {};
	      init(self, obj[i], doc[i], path + '.');
	    } else {
	      if (obj[i] === null) {
	        doc[i] = null;
	      } else if (obj[i] !== undefined) {
	        if (schema) {
	          try {
	            doc[i] = schema.cast(obj[i], self, true);
	          } catch (e) {
	            self.invalidate(e.path, new ValidatorError({
	              path: e.path,
	              message: e.message,
	              type: 'cast',
	              value: e.value
	            }));
	          }
	        } else {
	          doc[i] = obj[i];
	        }
	      }
	      // mark as hydrated
	      if (!self.isModified(path)) {
	        self.$__.activePaths.init(path);
	      }
	    }
	  }
	}
	
	/**
	 * Stores the current values of the shard keys.
	 *
	 * ####Note:
	 *
	 * _Shard key values do not / are not allowed to change._
	 *
	 * @api private
	 * @method $__storeShard
	 * @memberOf Document
	 */
	
	Document.prototype.$__storeShard = function () {
	  // backwards compat
	  var key = this.schema.options.shardKey || this.schema.options.shardkey;
	  if (!(key && 'Object' == utils.getFunctionName(key.constructor))) return;
	
	  var orig = this.$__.shardval = {}
	    , paths = Object.keys(key)
	    , len = paths.length
	    , val
	
	  for (var i = 0; i < len; ++i) {
	    val = this.getValue(paths[i]);
	    if (isMongooseObject(val)) {
	      orig[paths[i]] = val.toObject({ depopulate: true })
	    } else if (null != val &&
	        val.valueOf &&
	        // Explicitly don't take value of dates
	        (!val.constructor || utils.getFunctionName(val.constructor) !== 'Date')) {
	      orig[paths[i]] = val.valueOf();
	    } else {
	      orig[paths[i]] = val;
	    }
	  }
	}
	
	/*!
	 * Set up middleware support
	 */
	
	for (var k in hooks) {
	  Document.prototype[k] = Document[k] = hooks[k];
	}
	
	/**
	 * Sends an update command with this document `_id` as the query selector.
	 *
	 * ####Example:
	 *
	 *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);
	 *
	 * ####Valid options:
	 *
	 *  - same as in [Model.update](#model_Model.update)
	 *
	 * @see Model.update #model_Model.update
	 * @param {Object} doc
	 * @param {Object} options
	 * @param {Function} callback
	 * @return {Query}
	 * @api public
	 */
	
	Document.prototype.update = function update () {
	  var args = utils.args(arguments);
	  args.unshift({_id: this._id});
	  return this.constructor.update.apply(this.constructor, args);
	}
	
	/**
	 * Sets the value of a path, or many paths.
	 *
	 * ####Example:
	 *
	 *     // path, value
	 *     doc.set(path, value)
	 *
	 *     // object
	 *     doc.set({
	 *         path  : value
	 *       , path2 : {
	 *            path  : value
	 *         }
	 *     })
	 *
	 *     // on-the-fly cast to number
	 *     doc.set(path, value, Number)
	 *
	 *     // on-the-fly cast to string
	 *     doc.set(path, value, String)
	 *
	 *     // changing strict mode behavior
	 *     doc.set(path, value, { strict: false });
	 *
	 * @param {String|Object} path path or object of key/vals to set
	 * @param {Any} val the value to set
	 * @param {Schema|String|Number|Buffer|etc..} [type] optionally specify a type for "on-the-fly" attributes
	 * @param {Object} [options] optionally specify options that modify the behavior of the set
	 * @api public
	 */
	
	Document.prototype.set = function (path, val, type, options) {
	  if (type && 'Object' == utils.getFunctionName(type.constructor)) {
	    options = type;
	    type = undefined;
	  }
	
	  var merge = options && options.merge
	    , adhoc = type && true !== type
	    , constructing = true === type
	    , adhocs
	
	  var strict = options && 'strict' in options
	    ? options.strict
	    : this.$__.strictMode;
	
	  if (adhoc) {
	    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
	    adhocs[path] = Schema.interpretAsType(path, type);
	  }
	
	  if ('string' !== typeof path) {
	    // new Document({ key: val })
	
	    if (null === path || undefined === path) {
	      var _ = path;
	      path = val;
	      val = _;
	
	    } else {
	      var prefix = val
	        ? val + '.'
	        : '';
	
	      if (path instanceof Document) {
	        if (path.$__isNested) {
	          path = path.toObject();
	        } else {
	          path = path._doc;
	        }
	      }
	
	      var keys = Object.keys(path)
	        , i = keys.length
	        , pathtype
	        , key;
	
	      while (i--) {
	        key = keys[i];
	        var pathName = prefix + key;
	        pathtype = this.schema.pathType(pathName);
	
	        if (null != path[key]
	            // need to know if plain object - no Buffer, ObjectId, ref, etc
	            && utils.isObject(path[key])
	            && (!path[key].constructor || 'Object' == utils.getFunctionName(path[key].constructor))
	            && 'virtual' !== pathtype
	            && 'real' !== pathtype
	            && !(this.$__path(pathName) instanceof MixedSchema)
	            && !(this.schema.paths[pathName] && this.schema.paths[pathName].options.ref)) {
	          this.set(path[key], prefix + key, constructing);
	        } else if (strict) {
	          if ('real' === pathtype || 'virtual' === pathtype) {
	            this.set(prefix + key, path[key], constructing);
	          } else if ('throw' == strict) {
	            throw new Error('Field `' + key + '` is not in schema.');
	          }
	        } else if (undefined !== path[key]) {
	          this.set(prefix + key, path[key], constructing);
	        }
	      }
	
	      return this;
	    }
	  }
	
	  // ensure _strict is honored for obj props
	  // docschema = new Schema({ path: { nest: 'string' }})
	  // doc.set('path', obj);
	  var pathType = this.schema.pathType(path);
	  if ('nested' == pathType && val) {
	    if (utils.isObject(val) &&
	        (!val.constructor || 'Object' == utils.getFunctionName(val.constructor))) {
	      if (!merge) this.setValue(path, null);
	      this.set(val, path, constructing);
	      return this;
	    }
	    this.invalidate(path, new MongooseError.CastError('Object', val, path));
	    return this;
	  }
	
	  var schema;
	  var parts = path.split('.');
	
	  if ('adhocOrUndefined' == pathType && strict) {
	
	    // check for roots that are Mixed types
	    var mixed;
	
	    for (var i = 0; i < parts.length; ++i) {
	      var subpath = parts.slice(0, i+1).join('.');
	      schema = this.schema.path(subpath);
	      if (schema instanceof MixedSchema) {
	        // allow changes to sub paths of mixed types
	        mixed = true;
	        break;
	      }
	    }
	
	    if (!mixed) {
	      if ('throw' == strict) {
	        throw new Error("Field `" + path + "` is not in schema.");
	      }
	      return this;
	    }
	
	  } else if ('virtual' == pathType) {
	    schema = this.schema.virtualpath(path);
	    schema.applySetters(val, this);
	    return this;
	  } else {
	    schema = this.$__path(path);
	  }
	
	  var pathToMark;
	
	  // When using the $set operator the path to the field must already exist.
	  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"
	
	  if (parts.length <= 1) {
	    pathToMark = path;
	  } else {
	    for (var i = 0; i < parts.length; ++i) {
	      var subpath = parts.slice(0, i+1).join('.');
	      if (this.isDirectModified(subpath) // earlier prefixes that are already
	                                         // marked as dirty have precedence
	          || this.get(subpath) === null) {
	        pathToMark = subpath;
	        break;
	      }
	    }
	
	    if (!pathToMark) pathToMark = path;
	  }
	
	  // if this doc is being constructed we should not trigger getters
	  var priorVal = constructing
	    ? undefined
	    : this.getValue(path);
	
	  if (!schema) {
	    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
	    return this;
	  }
	
	  var shouldSet = true;
	  try {
	    // If the user is trying to set a ref path to a document with
	    // the correct model name, treat it as populated
	    if (schema.options &&
	        schema.options.ref &&
	        val instanceof Document &&
	        schema.options.ref === val.constructor.modelName) {
	      this.populated(path, val._id);
	    }
	    val = schema.applySetters(val, this, false, priorVal);
	    this.$markValid(path);
	  } catch (e) {
	    this.invalidate(path,
	      new MongooseError.CastError(schema.instance, val, path));
	    shouldSet = false;
	  }
	
	  if (shouldSet) {
	    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
	  }
	
	  return this;
	}
	
	/**
	 * Determine if we should mark this change as modified.
	 *
	 * @return {Boolean}
	 * @api private
	 * @method $__shouldModify
	 * @memberOf Document
	 */
	
	Document.prototype.$__shouldModify = function (
	    pathToMark, path, constructing, parts, schema, val, priorVal) {
	
	  if (this.isNew) return true;
	
	  if (undefined === val && !this.isSelected(path)) {
	    // when a path is not selected in a query, its initial
	    // value will be undefined.
	    return true;
	  }
	
	  if (undefined === val && path in this.$__.activePaths.states.default) {
	    // we're just unsetting the default value which was never saved
	    return false;
	  }
	
	  if (!deepEqual(val, priorVal || this.get(path))) {
	    return true;
	  }
	
	  if (!constructing &&
	      null != val &&
	      path in this.$__.activePaths.states.default &&
	      deepEqual(val, schema.getDefault(this, constructing))) {
	    // a path with a default was $unset on the server
	    // and the user is setting it to the same value again
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Handles the actual setting of the value and marking the path modified if appropriate.
	 *
	 * @api private
	 * @method $__set
	 * @memberOf Document
	 */
	
	Document.prototype.$__set = function (
	    pathToMark, path, constructing, parts, schema, val, priorVal) {
	  Embedded = Embedded || __webpack_require__(/*! ./types/embedded */ 185);
	
	  var shouldModify = this.$__shouldModify.apply(this, arguments);
	  var _this = this;
	
	  if (shouldModify) {
	    this.markModified(pathToMark, val);
	
	    // handle directly setting arrays (gh-1126)
	    MongooseArray || (MongooseArray = __webpack_require__(/*! ./types/array */ 188));
	    if (val && val.isMongooseArray) {
	      val._registerAtomic('$set', val);
	
	      // Small hack for gh-1638: if we're overwriting the entire array, ignore
	      // paths that were modified before the array overwrite
	      this.$__.activePaths.forEach(function(modifiedPath) {
	        if (modifiedPath.indexOf(path + '.') === 0) {
	          _this.$__.activePaths.ignore(modifiedPath);
	        }
	      });
	    }
	  }
	
	  var obj = this._doc
	    , i = 0
	    , l = parts.length
	
	  for (; i < l; i++) {
	    var next = i + 1
	      , last = next === l;
	
	    if (last) {
	      obj[parts[i]] = val;
	    } else {
	      if (obj[parts[i]] && 'Object' === utils.getFunctionName(obj[parts[i]].constructor)) {
	        obj = obj[parts[i]];
	      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {
	        obj = obj[parts[i]];
	      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {
	        obj = obj[parts[i]];
	      } else {
	        obj = obj[parts[i]] = {};
	      }
	    }
	  }
	}
	
	/**
	 * Gets a raw value from a path (no getters)
	 *
	 * @param {String} path
	 * @api private
	 */
	
	Document.prototype.getValue = function (path) {
	  return utils.getValue(path, this._doc);
	}
	
	/**
	 * Sets a raw value for a path (no casting, setters, transformations)
	 *
	 * @param {String} path
	 * @param {Object} value
	 * @api private
	 */
	
	Document.prototype.setValue = function (path, val) {
	  utils.setValue(path, val, this._doc);
	  return this;
	}
	
	/**
	 * Returns the value of a path.
	 *
	 * ####Example
	 *
	 *     // path
	 *     doc.get('age') // 47
	 *
	 *     // dynamic casting to a string
	 *     doc.get('age', String) // "47"
	 *
	 * @param {String} path
	 * @param {Schema|String|Number|Buffer|etc..} [type] optionally specify a type for on-the-fly attributes
	 * @api public
	 */
	
	Document.prototype.get = function (path, type) {
	  var adhoc;
	  if (type) {
	    adhoc = Schema.interpretAsType(path, type);
	  }
	
	  var schema = this.$__path(path) || this.schema.virtualpath(path)
	    , pieces = path.split('.')
	    , obj = this._doc;
	
	  for (var i = 0, l = pieces.length; i < l; i++) {
	    obj = undefined === obj || null === obj
	      ? undefined
	      : obj[pieces[i]];
	  }
	
	  if (adhoc) {
	    obj = adhoc.cast(obj);
	  }
	
	  if (schema) {
	    obj = schema.applyGetters(obj, this);
	  }
	
	  return obj;
	};
	
	/**
	 * Returns the schematype for the given `path`.
	 *
	 * @param {String} path
	 * @api private
	 * @method $__path
	 * @memberOf Document
	 */
	
	Document.prototype.$__path = function (path) {
	  var adhocs = this.$__.adhocPaths
	    , adhocType = adhocs && adhocs[path];
	
	  if (adhocType) {
	    return adhocType;
	  } else {
	    return this.schema.path(path);
	  }
	};
	
	/**
	 * Marks the path as having pending changes to write to the db.
	 *
	 * _Very helpful when using [Mixed](./schematypes.html#mixed) types._
	 *
	 * ####Example:
	 *
	 *     doc.mixed.type = 'changed';
	 *     doc.markModified('mixed.type');
	 *     doc.save() // changes to mixed.type are now persisted
	 *
	 * @param {String} path the path to mark modified
	 * @api public
	 */
	
	Document.prototype.markModified = function (path) {
	  this.$__.activePaths.modify(path);
	}
	
	/**
	 * Returns the list of paths that have been modified.
	 *
	 * @return {Array}
	 * @api public
	 */
	
	Document.prototype.modifiedPaths = function () {
	  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
	
	  return directModifiedPaths.reduce(function (list, path) {
	    var parts = path.split('.');
	    return list.concat(parts.reduce(function (chains, part, i) {
	      return chains.concat(parts.slice(0, i).concat(part).join('.'));
	    }, []));
	  }, []);
	};
	
	/**
	 * Returns true if this document was modified, else false.
	 *
	 * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.
	 *
	 * ####Example
	 *
	 *     doc.set('documents.0.title', 'changed');
	 *     doc.isModified()                    // true
	 *     doc.isModified('documents')         // true
	 *     doc.isModified('documents.0.title') // true
	 *     doc.isDirectModified('documents')   // false
	 *
	 * @param {String} [path] optional
	 * @return {Boolean}
	 * @api public
	 */
	
	Document.prototype.isModified = function (path) {
	  return path
	    ? !!~this.modifiedPaths().indexOf(path)
	    : this.$__.activePaths.some('modify');
	};
	
	/**
	 * Returns true if `path` was directly set and modified, else false.
	 *
	 * ####Example
	 *
	 *     doc.set('documents.0.title', 'changed');
	 *     doc.isDirectModified('documents.0.title') // true
	 *     doc.isDirectModified('documents') // false
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api public
	 */
	
	Document.prototype.isDirectModified = function (path) {
	  return (path in this.$__.activePaths.states.modify);
	};
	
	/**
	 * Checks if `path` was initialized.
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api public
	 */
	
	Document.prototype.isInit = function (path) {
	  return (path in this.$__.activePaths.states.init);
	};
	
	/**
	 * Checks if `path` was selected in the source query which initialized this document.
	 *
	 * ####Example
	 *
	 *     Thing.findOne().select('name').exec(function (err, doc) {
	 *        doc.isSelected('name') // true
	 *        doc.isSelected('age')  // false
	 *     })
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api public
	 */
	
	Document.prototype.isSelected = function isSelected (path) {
	  if (this.$__.selected) {
	
	    if ('_id' === path) {
	      return 0 !== this.$__.selected._id;
	    }
	
	    var paths = Object.keys(this.$__.selected)
	      , i = paths.length
	      , inclusive = false
	      , cur
	
	    if (1 === i && '_id' === paths[0]) {
	      // only _id was selected.
	      return 0 === this.$__.selected._id;
	    }
	
	    while (i--) {
	      cur = paths[i];
	      if ('_id' == cur) continue;
	      inclusive = !! this.$__.selected[cur];
	      break;
	    }
	
	    if (path in this.$__.selected) {
	      return inclusive;
	    }
	
	    i = paths.length;
	    var pathDot = path + '.';
	
	    while (i--) {
	      cur = paths[i];
	      if ('_id' == cur) continue;
	
	      if (0 === cur.indexOf(pathDot)) {
	        return inclusive;
	      }
	
	      if (0 === pathDot.indexOf(cur + '.')) {
	        return inclusive;
	      }
	    }
	
	    return ! inclusive;
	  }
	
	  return true;
	};
	
	/**
	 * Executes registered validation rules for this document.
	 *
	 * ####Note:
	 *
	 * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.
	 *
	 * ####Example:
	 *
	 *     doc.validate(function (err) {
	 *       if (err) handleError(err);
	 *       else // validation passed
	 *     });
	 *
	 * @param {Function} optional cb called after validation completes, passing an error if one occurred
	 * @return {Promise} Promise
	 * @api public
	 */
	
	Document.prototype.validate = function (cb) {
	  var self = this;
	  var promise = new Promise(cb);
	
	  // only validate required fields when necessary
	  var paths = Object.keys(this.$__.activePaths.states.require).filter(function (path) {
	    if (!self.isSelected(path) && !self.isModified(path)) return false;
	    return true;
	  });
	
	  paths = paths.concat(Object.keys(this.$__.activePaths.states.init));
	  paths = paths.concat(Object.keys(this.$__.activePaths.states.modify));
	  paths = paths.concat(Object.keys(this.$__.activePaths.states.default));
	
	  if (0 === paths.length) {
	    process.nextTick(function() {
	      complete();
	    });
	    return promise;
	  }
	
	  var validating = {}
	    , total = 0;
	
	  // gh-661: if a whole array is modified, make sure to run validation on all
	  // the children as well
	  for (var i = 0; i < paths.length; ++i) {
	    var path = paths[i];
	    var val = self.getValue(path);
	    if (val instanceof Array && !Buffer.isBuffer(val) &&
	        !val.isMongooseDocumentArray) {
	      var numElements = val.length;
	      for (var j = 0; j < numElements; ++j) {
	        paths.push(path + '.' + j);
	      }
	    }
	  }
	  paths.forEach(validatePath);
	  return promise;
	
	  function validatePath (path) {
	    if (validating[path]) return;
	
	    validating[path] = true;
	    total++;
	
	    process.nextTick(function(){
	      var p = self.schema.path(path);
	      if (!p) {
	        return --total || complete();
	      }
	
	      // If user marked as invalid or there was a cast error, don't validate
	      if (!self.$isValid(path)) {
	        --total || complete();
	        return;
	      }
	
	      var val = self.getValue(path);
	      p.doValidate(val, function (err) {
	        if (err) {
	          self.invalidate(path, err, undefined, true);
	        }
	        --total || complete();
	      }, self);
	    });
	  }
	
	  function complete () {
	    var err = self.$__.validationError;
	    self.$__.validationError = undefined;
	    self.emit('validate', self);
	    if (err) {
	      for (var key in err.errors) {
	        // Make sure cast errors persist
	        if (!self.__parent && err.errors[key] instanceof MongooseError.CastError) {
	          self.invalidate(key, err.errors[key]);
	        }
	      }
	      promise.reject(err);
	    } else {
	      promise.fulfill();
	    }
	  }
	};
	
	/**
	 * Executes registered validation rules (skipping asynchronous validators) for this document.
	 *
	 * ####Note:
	 *
	 * This method is useful if you need synchronous validation.
	 *
	 * ####Example:
	 *
	 *     var err = doc.validateSync();
	 *     if ( err ){
	 *       handleError( err );
	 *     } else {
	 *       // validation passed
	 *     }
	 *
	 * @return {MongooseError|undefined} MongooseError if there are errors during validation, or undefined if there is no error.
	 * @api public
	 */
	
	Document.prototype.validateSync = function () {
	  var self = this;
	
	  // only validate required fields when necessary
	  var paths = Object.keys(this.$__.activePaths.states.require).filter(function (path) {
	    if (!self.isSelected(path) && !self.isModified(path)) return false;
	    return true;
	  });
	
	  paths = paths.concat(Object.keys(this.$__.activePaths.states.init));
	  paths = paths.concat(Object.keys(this.$__.activePaths.states.modify));
	  paths = paths.concat(Object.keys(this.$__.activePaths.states.default));
	
	  var validating = {};
	
	  paths.forEach(function (path) {
	    if (validating[path]) return;
	
	    validating[path] = true;
	
	    var p = self.schema.path(path);
	    if (!p) return;
	    if (!self.$isValid(path)) {
	      return;
	    }
	
	    var val = self.getValue(path);
	    var err = p.doValidateSync(val, self);
	    if (err) {
	      self.invalidate(path, err, undefined, true);
	    }
	  });
	
	  var err = self.$__.validationError;
	  self.$__.validationError = undefined;
	  self.emit('validate', self);
	
	  if (err) {
	    for (var key in err.errors) {
	      // Make sure cast errors persist
	      if (err.errors[key] instanceof MongooseError.CastError) {
	        self.invalidate(key, err.errors[key]);
	      }
	    }
	  }
	
	  return err;
	};
	
	/**
	 * Marks a path as invalid, causing validation to fail.
	 *
	 * The `errorMsg` argument will become the message of the `ValidationError`.
	 *
	 * The `value` argument (if passed) will be available through the `ValidationError.value` property.
	 *
	 *     doc.invalidate('size', 'must be less than 20', 14);
	
	 *     doc.validate(function (err) {
	 *       console.log(err)
	 *       // prints
	 *       { message: 'Validation failed',
	 *         name: 'ValidationError',
	 *         errors:
	 *          { size:
	 *             { message: 'must be less than 20',
	 *               name: 'ValidatorError',
	 *               path: 'size',
	 *               type: 'user defined',
	 *               value: 14 } } }
	 *     })
	 *
	 * @param {String} path the field to invalidate
	 * @param {String|Error} errorMsg the error which states the reason `path` was invalid
	 * @param {Object|String|Number|any} value optional invalid value
	 * @api public
	 */
	
	Document.prototype.invalidate = function (path, err, val) {
	  if (!this.$__.validationError) {
	    this.$__.validationError = new ValidationError(this);
	  }
	
	  if (this.$__.validationError.errors[path]) return;
	
	  if (!err || 'string' === typeof err) {
	    err = new ValidatorError({
	      path: path,
	      message: err,
	      type: 'user defined',
	      value: val
	    });
	  }
	
	  if (this.$__.validationError == err) return;
	
	  this.$__.validationError.errors[path] = err;
	};
	
	/**
	 * Marks a path as valid, removing existing validation errors.
	 *
	 * @param {String} path the field to mark as valid
	 * @api private
	 * @method $markValid
	 * @receiver Document
	 */
	
	Document.prototype.$markValid = function(path) {
	  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {
	    return;
	  }
	
	  delete this.$__.validationError.errors[path];
	  if (Object.keys(this.$__.validationError.errors).length === 0) {
	    this.$__.validationError = null;
	  }
	};
	
	/**
	 * Checks if a path is invalid
	 *
	 * @param {String} path the field to check
	 * @method $isValid
	 * @api private
	 * @receiver Document
	 */
	
	Document.prototype.$isValid = function(path) {
	  return !this.$__.validationError || !this.$__.validationError.errors[path];
	};
	
	/**
	 * Resets the internal modified state of this document.
	 *
	 * @api private
	 * @return {Document}
	 * @method $__reset
	 * @memberOf Document
	 */
	
	Document.prototype.$__reset = function reset () {
	  var self = this;
	  DocumentArray || (DocumentArray = __webpack_require__(/*! ./types/documentarray */ 189));
	
	  this.$__.activePaths
	  .map('init', 'modify', function (i) {
	    return self.getValue(i);
	  })
	  .filter(function (val) {
	    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
	  })
	  .forEach(function (array) {
	    var i = array.length;
	    while (i--) {
	      var doc = array[i];
	      if (!doc) continue;
	      doc.$__reset();
	    }
	  });
	
	  // clear atomics
	  this.$__dirty().forEach(function (dirt) {
	    var type = dirt.value;
	    if (type && type._atomics) {
	      type._atomics = {};
	    }
	  });
	
	  // Clear 'modify'('dirty') cache
	  this.$__.activePaths.clear('modify');
	  this.$__.validationError = undefined;
	  this.errors = undefined;
	  var self = this;
	  this.schema.requiredPaths().forEach(function (path) {
	    self.$__.activePaths.require(path);
	  });
	
	  return this;
	}
	
	/**
	 * Returns this documents dirty paths / vals.
	 *
	 * @api private
	 * @method $__dirty
	 * @memberOf Document
	 */
	
	Document.prototype.$__dirty = function () {
	  var self = this;
	
	  var all = this.$__.activePaths.map('modify', function (path) {
	    return {
	      path: path,
	      value: self.getValue(path),
	      schema: self.$__path(path)
	    };
	  });
	
	  // gh-2558: if we had to set a default and the value is not undefined,
	  // we have to save as well
	  all = all.concat(this.$__.activePaths.map('default', function (path) {
	    if (path === '_id' || !self.getValue(path)) {
	      return;
	    }
	    return {
	      path: path,
	      value: self.getValue(path),
	      schema: self.$__path(path)
	    };
	  }));
	
	  // Sort dirty paths in a flat hierarchy.
	  all.sort(function (a, b) {
	    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));
	  });
	
	  // Ignore "foo.a" if "foo" is dirty already.
	  var minimal = []
	    , lastPath
	    , top;
	
	  all.forEach(function (item, i) {
	    if (!item) {
	      return;
	    }
	    if (item.path.indexOf(lastPath) !== 0) {
	      lastPath = item.path + '.';
	      minimal.push(item);
	      top = item;
	    } else {
	      // special case for top level MongooseArrays
	      if (top.value && top.value._atomics && top.value.hasAtomics()) {
	        // the `top` array itself and a sub path of `top` are being modified.
	        // the only way to honor all of both modifications is through a $set
	        // of entire array.
	        top.value._atomics = {};
	        top.value._atomics.$set = top.value;
	      }
	    }
	  });
	
	  top = lastPath = null;
	  return minimal;
	}
	
	/*!
	 * Compiles schemas.
	 */
	
	function compile (tree, proto, prefix) {
	  var keys = Object.keys(tree)
	    , i = keys.length
	    , limb
	    , key;
	
	  while (i--) {
	    key = keys[i];
	    limb = tree[key];
	
	    defineKey(key
	        , (('Object' === utils.getFunctionName(limb.constructor)
	               && Object.keys(limb).length)
	               && (!limb.type || limb.type.type)
	               ? limb
	               : null)
	        , proto
	        , prefix
	        , keys);
	  }
	};
	
	// gets descriptors for all properties of `object`
	// makes all properties non-enumerable to match previous behavior to #2211
	function getOwnPropertyDescriptors(object) {
	  var result = {};
	
	  Object.getOwnPropertyNames(object).forEach(function(key) {
	    result[key] = Object.getOwnPropertyDescriptor(object, key);
	    result[key].enumerable = true;
	  });
	
	  return result;
	}
	
	/*!
	 * Defines the accessor named prop on the incoming prototype.
	 */
	
	function defineKey (prop, subprops, prototype, prefix, keys) {
	  var prefix = prefix || ''
	    , path = (prefix ? prefix + '.' : '') + prop;
	
	  if (subprops) {
	
	    Object.defineProperty(prototype, prop, {
	        enumerable: true
	      , configurable: true
	      , get: function () {
	          if (!this.$__.getters)
	            this.$__.getters = {};
	
	          if (!this.$__.getters[path]) {
	            var nested = Object.create(Object.getPrototypeOf(this), getOwnPropertyDescriptors(this));
	
	            // save scope for nested getters/setters
	            if (!prefix) nested.$__.scope = this;
	
	            // shadow inherited getters from sub-objects so
	            // thing.nested.nested.nested... doesn't occur (gh-366)
	            var i = 0
	              , len = keys.length;
	
	            for (; i < len; ++i) {
	              // over-write the parents getter without triggering it
	              Object.defineProperty(nested, keys[i], {
	                  enumerable: false   // It doesn't show up.
	                , writable: true      // We can set it later.
	                , configurable: true  // We can Object.defineProperty again.
	                , value: undefined    // It shadows its parent.
	              });
	            }
	
	            nested.toObject = function() {
	              return this.get(path);
	            };
	
	            nested.toJSON = nested.toObject;
	
	            nested.$__isNested = true;
	
	            compile(subprops, nested, path);
	            this.$__.getters[path] = nested;
	          }
	
	          return this.$__.getters[path];
	        }
	      , set: function (v) {
	          if (v instanceof Document) v = v.toObject();
	          return (this.$__.scope || this).set(path, v);
	        }
	    });
	
	  } else {
	    Object.defineProperty(prototype, prop, {
	        enumerable: true
	      , configurable: true
	      , get: function ( ) { return this.get.call(this.$__.scope || this, path); }
	      , set: function (v) { return this.set.call(this.$__.scope || this, path, v); }
	    });
	  }
	}
	
	/**
	 * Assigns/compiles `schema` into this documents prototype.
	 *
	 * @param {Schema} schema
	 * @api private
	 * @method $__setSchema
	 * @memberOf Document
	 */
	
	Document.prototype.$__setSchema = function (schema) {
	  compile(schema.tree, this);
	  this.schema = schema;
	};
	
	
	/**
	 * Get active path that were changed and are arrays
	 *
	 * @api private
	 * @method $__getArrayPathsToValidate
	 * @memberOf Document
	 */
	
	Document.prototype.$__getArrayPathsToValidate = function () {
	  DocumentArray || (DocumentArray = __webpack_require__(/*! ./types/documentarray */ 189));
	
	  // validate all document arrays.
	  return this.$__.activePaths
	    .map('init', 'modify', function (i) {
	      return this.getValue(i);
	    }.bind(this))
	    .filter(function (val) {
	      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
	    }).reduce(function(seed, array) {
	      return seed.concat(array);
	    }, [])
	    .filter(function (doc) {return doc});
	};
	
	
	/**
	 * Get all subdocs (by bfs)
	 *
	 * @api private
	 * @method $__getAllSubdocs
	 * @memberOf Document
	 */
	
	Document.prototype.$__getAllSubdocs = function () {
	  DocumentArray || (DocumentArray = __webpack_require__(/*! ./types/documentarray */ 189));
	  Embedded = Embedded || __webpack_require__(/*! ./types/embedded */ 185);
	
	  function docReducer(seed, path) {
	    var val = this[path];
	    if (val instanceof Embedded) seed.push(val);
	    if (val && val.isMongooseDocumentArray) {
	      val.forEach(function _docReduce(doc) {
	        if (!doc || !doc._doc) return;
	        if (doc instanceof Embedded) seed.push(doc);
	        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);
	      });
	    }
	    return seed;
	  }
	
	  var subDocs = Object.keys(this._doc).reduce(docReducer.bind(this), []);
	
	  return subDocs;
	};
	
	/**
	 * Executes methods queued from the Schema definition
	 *
	 * @api private
	 * @method $__registerHooksFromSchema
	 * @memberOf Document
	 */
	
	Document.prototype.$__registerHooksFromSchema = function () {
	  Embedded = Embedded || __webpack_require__(/*! ./types/embedded */ 185);
	
	  var self = this;
	  var q = self.schema && self.schema.callQueue;
	  if (!q.length) return self;
	
	  // we are only interested in 'pre' hooks, and group by point-cut
	  var toWrap = q.reduce(function (seed, pair) {
	    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {
	      self[pair[0]].apply(self, pair[1]);
	      return seed;
	    }
	    var args = [].slice.call(pair[1]);
	    var pointCut = pair[0] === 'on' ? 'post' : args[0];
	    if (!(pointCut in seed)) seed[pointCut] = [];
	    seed[pointCut].push(args);
	    return seed;
	  }, {post: []});
	
	  // 'post' hooks are simpler
	  toWrap.post.forEach(function (args) {
	    self.on.apply(self, args);
	  });
	  delete toWrap.post;
	
	  Object.keys(toWrap).forEach(function (pointCut) {
	
	    // skip weird handlers
	    if (~"set ".indexOf(pointCut)) {
	      toWrap[pointCut].forEach(function (args) {
	        self.pre.apply(self, args);
	      });
	      return;
	    }
	
	    // this is so we can wrap everything into a promise;
	    var newName = ('$__original_' + pointCut);
	    if (!self[pointCut]) {
	      return;
	    }
	    self[newName] = self[pointCut];
	    self[pointCut] = function wrappedPointCut () {
	      var args = [].slice.call(arguments);
	      var lastArg = args.pop();
	
	      var wrapingPromise = new Promise;
	      wrapingPromise.end();
	      if (typeof lastArg == 'function') {
	        wrapingPromise.onResolve(lastArg);
	      }
	      if (!(this instanceof Embedded) && !wrapingPromise.hasRejectListeners()) {
	        wrapingPromise.onReject(self.$__handleReject.bind(self));
	      }
	      args.push(function () {
	        return wrapingPromise.resolve.apply(wrapingPromise, arguments);
	      });
	
	      // fire original
	      self[newName].apply(self, args);
	      return wrapingPromise;
	    };
	
	    toWrap[pointCut].forEach(function (args) {
	      args[0] = newName;
	      self.pre.apply(self, args);
	    });
	  })
	  return self;
	};
	
	
	Document.prototype.$__handleReject = function handleReject(err) {
	  // emit on the Model if listening
	  if (this.listeners('error').length) {
	    this.emit('error', err);
	  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {
	    this.constructor.emit('error', err);
	  } else if (this.listeners && this.listeners('error').length) {
	    this.emit('error', err);
	  }
	};
	
	
	
	/**
	 * Internal helper for toObject() and toJSON() that doesn't manipulate options
	 *
	 * @api private
	 * @method $toObject
	 * @memberOf Document
	 */
	
	Document.prototype.$toObject = function(options, json) {
	  var defaultOptions = { transform: true, json: json };
	
	  if (options && options.depopulate && !options._skipDepopulateTopLevel && this.$__.wasPopulated) {
	    // populated paths that we set to a document
	    return clone(this._id, options);
	  }
	
	  // If we're calling toObject on a populated doc, we may want to skip
	  // depopulated on the top level
	  if (options && options._skipDepopulateTopLevel) {
	    options._skipDepopulateTopLevel = false;
	  }
	
	  // When internally saving this document we always pass options,
	  // bypassing the custom schema options.
	  var optionsParameter = options;
	  if (!(options && 'Object' == utils.getFunctionName(options.constructor)) ||
	      (options && options._useSchemaOptions)) {
	    if (json) {
	      options = this.schema.options.toJSON ?
	        clone(this.schema.options.toJSON) :
	        {};
	      options.json = true;
	      options._useSchemaOptions = true;
	    } else {
	      options = this.schema.options.toObject ?
	        clone(this.schema.options.toObject) :
	        {};
	      options.json = false;
	      options._useSchemaOptions = true;
	    }
	  }
	
	  for (var key in defaultOptions) {
	    if (options[key] === undefined) {
	      options[key] = defaultOptions[key];
	    }
	  }
	
	  ;('minimize' in options) || (options.minimize = this.schema.options.minimize);
	
	  // remember the root transform function
	  // to save it from being overwritten by sub-transform functions
	  var originalTransform = options.transform;
	
	  var ret = clone(this._doc, options);
	
	  if (options.virtuals || options.getters && false !== options.virtuals) {
	    applyGetters(this, ret, 'virtuals', options);
	  }
	
	  if (options.getters) {
	    applyGetters(this, ret, 'paths', options);
	    // applyGetters for paths will add nested empty objects;
	    // if minimize is set, we need to remove them.
	    if (options.minimize) {
	      ret = minimize(ret) || {};
	    }
	  }
	
	  if (options.versionKey === false && this.schema.options.versionKey) {
	    delete ret[this.schema.options.versionKey];
	  }
	
	  var transform = options.transform;
	
	  // In the case where a subdocument has its own transform function, we need to
	  // check and see if the parent has a transform (options.transform) and if the
	  // child schema has a transform (this.schema.options.toObject) In this case,
	  // we need to adjust options.transform to be the child schema's transform and
	  // not the parent schema's
	  if (true === transform ||
	      (this.schema.options.toObject && transform)) {
	
	    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;
	
	    if (opts) {
	      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);
	    }
	  } else {
	    options.transform = originalTransform;
	  }
	
	  if ('function' == typeof transform) {
	    var xformed = transform(this, ret, options);
	    if ('undefined' != typeof xformed) ret = xformed;
	  }
	
	  return ret;
	};
	
	/**
	 * Converts this document into a plain javascript object, ready for storage in MongoDB.
	 *
	 * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.
	 *
	 * ####Options:
	 *
	 * - `getters` apply all getters (path and virtual getters)
	 * - `virtuals` apply virtual getters (can override `getters` option)
	 * - `minimize` remove empty objects (defaults to true)
	 * - `transform` a transform function to apply to the resulting document before returning
	 * - `depopulate` depopulate any populated paths, replacing them with their original refs (defaults to false)
	 * - `versionKey` whether to include the version key (defaults to true)
	 * - `retainKeyOrder` keep the order of object keys. If this is set to true, `Object.keys(new Doc({ a: 1, b: 2}).toObject())` will always produce `['a', 'b']` (defaults to false)
	 *
	 * ####Getters/Virtuals
	 *
	 * Example of only applying path getters
	 *
	 *     doc.toObject({ getters: true, virtuals: false })
	 *
	 * Example of only applying virtual getters
	 *
	 *     doc.toObject({ virtuals: true })
	 *
	 * Example of applying both path and virtual getters
	 *
	 *     doc.toObject({ getters: true })
	 *
	 * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.
	 *
	 *     schema.set('toObject', { virtuals: true })
	 *
	 * ####Transform
	 *
	 * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.
	 *
	 * Transform functions receive three arguments
	 *
	 *     function (doc, ret, options) {}
	 *
	 * - `doc` The mongoose document which is being converted
	 * - `ret` The plain object representation which has been converted
	 * - `options` The options in use (either schema options or the options passed inline)
	 *
	 * ####Example
	 *
	 *     // specify the transform schema option
	 *     if (!schema.options.toObject) schema.options.toObject = {};
	 *     schema.options.toObject.transform = function (doc, ret, options) {
	 *       // remove the _id of every document before returning the result
	 *       delete ret._id;
	 *     }
	 *
	 *     // without the transformation in the schema
	 *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }
	 *
	 *     // with the transformation
	 *     doc.toObject(); // { name: 'Wreck-it Ralph' }
	 *
	 * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:
	 *
	 *     if (!schema.options.toObject) schema.options.toObject = {};
	 *     schema.options.toObject.transform = function (doc, ret, options) {
	 *       return { movie: ret.name }
	 *     }
	 *
	 *     // without the transformation in the schema
	 *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }
	 *
	 *     // with the transformation
	 *     doc.toObject(); // { movie: 'Wreck-it Ralph' }
	 *
	 * _Note: if a transform function returns `undefined`, the return value will be ignored._
	 *
	 * Transformations may also be applied inline, overridding any transform set in the options:
	 *
	 *     function xform (doc, ret, options) {
	 *       return { inline: ret.name, custom: true }
	 *     }
	 *
	 *     // pass the transform as an inline option
	 *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }
	 *
	 * _Note: if you call `toObject` and pass any options, the transform declared in your schema options will __not__ be applied. To force its application pass `transform: true`_
	 *
	 *     if (!schema.options.toObject) schema.options.toObject = {};
	 *     schema.options.toObject.hide = '_id';
	 *     schema.options.toObject.transform = function (doc, ret, options) {
	 *       if (options.hide) {
	 *         options.hide.split(' ').forEach(function (prop) {
	 *           delete ret[prop];
	 *         });
	 *       }
	 *     }
	 *
	 *     var doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });
	 *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }
	 *     doc.toObject({ hide: 'secret _id' });                  // { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }
	 *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }
	 *
	 * Transforms are applied _only to the document and are not applied to sub-documents_.
	 *
	 * Transforms, like all of these options, are also available for `toJSON`.
	 *
	 * See [schema options](/docs/guide.html#toObject) for some more details.
	 *
	 * _During save, no custom options are applied to the document before being sent to the database._
	 *
	 * @param {Object} [options]
	 * @return {Object} js object
	 * @see mongodb.Binary http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html
	 * @api public
	 */
	
	Document.prototype.toObject = function (options) {
	  return this.$toObject(options);
	};
	
	/*!
	 * Minimizes an object, removing undefined values and empty objects
	 *
	 * @param {Object} object to minimize
	 * @return {Object}
	 */
	
	function minimize (obj) {
	  var keys = Object.keys(obj)
	    , i = keys.length
	    , hasKeys
	    , key
	    , val
	
	  while (i--) {
	    key = keys[i];
	    val = obj[key];
	
	    if (utils.isObject(val)) {
	      obj[key] = minimize(val);
	    }
	
	    if (undefined === obj[key]) {
	      delete obj[key];
	      continue;
	    }
	
	    hasKeys = true;
	  }
	
	  return hasKeys
	    ? obj
	    : undefined;
	}
	
	/*!
	 * Applies virtuals properties to `json`.
	 *
	 * @param {Document} self
	 * @param {Object} json
	 * @param {String} type either `virtuals` or `paths`
	 * @return {Object} `json`
	 */
	
	function applyGetters (self, json, type, options) {
	  var schema = self.schema
	    , paths = Object.keys(schema[type])
	    , i = paths.length
	    , path
	
	  while (i--) {
	    path = paths[i];
	
	    var parts = path.split('.')
	      , plen = parts.length
	      , last = plen - 1
	      , branch = json
	      , part
	
	    for (var ii = 0; ii < plen; ++ii) {
	      part = parts[ii];
	      if (ii === last) {
	        branch[part] = clone(self.get(path), options);
	      } else {
	        branch = branch[part] || (branch[part] = {});
	      }
	    }
	  }
	
	  return json;
	}
	
	/**
	 * The return value of this method is used in calls to JSON.stringify(doc).
	 *
	 * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.
	 *
	 *     schema.set('toJSON', { virtuals: true })
	 *
	 * See [schema options](/docs/guide.html#toJSON) for details.
	 *
	 * @param {Object} options
	 * @return {Object}
	 * @see Document#toObject #document_Document-toObject
	 * @api public
	 */
	
	Document.prototype.toJSON = function (options) {
	  return this.$toObject(options, true);
	};
	
	/**
	 * Helper for console.log
	 *
	 * @api public
	 */
	
	Document.prototype.inspect = function (options) {
	  var opts = options && 'Object' == utils.getFunctionName(options.constructor) ? options : {};
	  opts.minimize = false;
	  return inspect(this.toObject(opts));
	};
	
	/**
	 * Helper for console.log
	 *
	 * @api public
	 * @method toString
	 */
	
	Document.prototype.toString = Document.prototype.inspect;
	
	/**
	 * Returns true if the Document stores the same data as doc.
	 *
	 * Documents are considered equal when they have matching `_id`s, unless neither
	 * document has an `_id`, in which case this function falls back to using
	 * `deepEqual()`.
	 *
	 * @param {Document} doc a document to compare
	 * @return {Boolean}
	 * @api public
	 */
	
	Document.prototype.equals = function (doc) {
	  var tid = this.get('_id');
	  var docid = doc.get('_id');
	  if (!tid && !docid) {
	    return deepEqual(this, doc);
	  }
	  return tid && tid.equals
	    ? tid.equals(docid)
	    : tid === docid;
	};
	
	/**
	 * Populates document references, executing the `callback` when complete.
	 *
	 * ####Example:
	 *
	 *     doc
	 *     .populate('company')
	 *     .populate({
	 *       path: 'notes',
	 *       match: /airline/,
	 *       select: 'text',
	 *       model: 'modelName'
	 *       options: opts
	 *     }, function (err, user) {
	 *       assert(doc._id == user._id) // the document itself is passed
	 *     })
	 *
	 *     // summary
	 *     doc.populate(path)               // not executed
	 *     doc.populate(options);           // not executed
	 *     doc.populate(path, callback)     // executed
	 *     doc.populate(options, callback); // executed
	 *     doc.populate(callback);          // executed
	 *
	 *
	 * ####NOTE:
	 *
	 * Population does not occur unless a `callback` is passed *or* you explicitly
	 * call `execPopulate()`.
	 * Passing the same path a second time will overwrite the previous path options.
	 * See [Model.populate()](#model_Model.populate) for explaination of options.
	 *
	 * @see Model.populate #model_Model.populate
	 * @param {String|Object} [path] The path to populate or an options object
	 * @param {Function} [callback] When passed, population is invoked
	 * @api public
	 * @return {Document} this
	 */
	
	Document.prototype.populate = function populate () {
	  if (0 === arguments.length) return this;
	
	  var pop = this.$__.populate || (this.$__.populate = {});
	  var args = utils.args(arguments);
	  var fn;
	
	  if ('function' == typeof args[args.length-1]) {
	    fn = args.pop();
	  }
	
	  // allow `doc.populate(callback)`
	  if (args.length) {
	    // use hash to remove duplicate paths
	    var res = utils.populate.apply(null, args);
	    for (var i = 0; i < res.length; ++i) {
	      pop[res[i].path] = res[i];
	    }
	  }
	
	  if (fn) {
	    var paths = utils.object.vals(pop);
	    this.$__.populate = undefined;
	    this.constructor.populate(this, paths, fn);
	  }
	
	  return this;
	};
	
	/**
	 * Explicitly executes population and returns a promise. Useful for ES6
	 * integration.
	 *
	 * ####Example:
	 *
	 *     var promise = doc.
	 *       populate('company').
	 *       populate({
	 *         path: 'notes',
	 *         match: /airline/,
	 *         select: 'text',
	 *         model: 'modelName'
	 *         options: opts
	 *       }).
	 *       execPopulate();
	 *
	 *     // summary
	 *     doc.execPopulate()
	 *
	 *
	 * ####NOTE:
	 *
	 * Population does not occur unless a `callback` is passed.
	 * Passing the same path a second time will overwrite the previous path options.
	 * See [Model.populate()](#model_Model.populate) for explaination of options.
	 *
	 * @see Document.populate #Document_model.populate
	 * @api public
	 * @return {Promise} promise that resolves to the document when population is done
	 */
	
	Document.prototype.execPopulate = function() {
	  var promise = new Promise;
	  var _this = this;
	
	  this.populate(function(error) {
	    if (error) {
	      return promise.reject(error);
	    }
	    promise.fulfill(_this);
	  });
	  return promise;
	};
	
	/**
	 * Gets _id(s) used during population of the given `path`.
	 *
	 * ####Example:
	 *
	 *     Model.findOne().populate('author').exec(function (err, doc) {
	 *       console.log(doc.author.name)         // Dr.Seuss
	 *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'
	 *     })
	 *
	 * If the path was not populated, undefined is returned.
	 *
	 * @param {String} path
	 * @return {Array|ObjectId|Number|Buffer|String|undefined}
	 * @api public
	 */
	
	Document.prototype.populated = function (path, val, options) {
	  // val and options are internal
	
	  if (val == null) {
	    if (!this.$__.populated) return undefined;
	    var v = this.$__.populated[path];
	    if (v) return v.value;
	    return undefined;
	  }
	
	  // internal
	
	  if (true === val) {
	    if (!this.$__.populated) return undefined;
	    return this.$__.populated[path];
	  }
	
	  this.$__.populated || (this.$__.populated = {});
	  this.$__.populated[path] = { value: val, options: options };
	  return val;
	}
	
	/**
	 * Returns the full path to this document.
	 *
	 * @param {String} [path]
	 * @return {String}
	 * @api private
	 * @method $__fullPath
	 * @memberOf Document
	 */
	
	Document.prototype.$__fullPath = function (path) {
	  // overridden in SubDocuments
	  return path || '';
	}
	
	/*!
	 * Module exports.
	 */
	
	Document.ValidationError = ValidationError;
	module.exports = exports = Document;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43), __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 179 */
/*!*******************************************!*\
  !*** ./~/mongoose/~/hooks-fixed/hooks.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	// TODO Add in pre and post skipping options
	module.exports = {
	  /**
	   *  Declares a new hook to which you can add pres and posts
	   *  @param {String} name of the function
	   *  @param {Function} the method
	   *  @param {Function} the error handler callback
	   */
	  hook: function (name, fn, errorCb) {
	    if (arguments.length === 1 && typeof name === 'object') {
	      for (var k in name) { // `name` is a hash of hookName->hookFn
	        this.hook(k, name[k]);
	      }
	      return;
	    }
	
	    var proto = this.prototype || this
	      , pres = proto._pres = proto._pres || {}
	      , posts = proto._posts = proto._posts || {};
	    pres[name] = pres[name] || [];
	    posts[name] = posts[name] || [];
	
	    proto[name] = function () {
	      var self = this
	        , hookArgs // arguments eventually passed to the hook - are mutable
	        , lastArg = arguments[arguments.length-1]
	        , pres = this._pres[name]
	        , posts = this._posts[name]
	        , _total = pres.length
	        , _current = -1
	        , _asyncsLeft = proto[name].numAsyncPres
	        , _asyncsDone = function(err) {
	            if (err) {
	              return handleError(err);
	            }
	            --_asyncsLeft || _done.apply(self, hookArgs);
	          }
	        , handleError = function(err) {
	            if ('function' == typeof lastArg)
	              return lastArg(err);
	            if (errorCb) return errorCb.call(self, err);
	            throw err;
	          }
	        , _next = function () {
	            if (arguments[0] instanceof Error) {
	              return handleError(arguments[0]);
	            }
	            var _args = Array.prototype.slice.call(arguments)
	              , currPre
	              , preArgs;
	            if (_args.length && !(arguments[0] == null && typeof lastArg === 'function'))
	              hookArgs = _args;
	            if (++_current < _total) {
	              currPre = pres[_current]
	              if (currPre.isAsync && currPre.length < 2)
	                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");
	              if (currPre.length < 1)
	                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");
	              preArgs = (currPre.isAsync
	                          ? [once(_next), once(_asyncsDone)]
	                          : [once(_next)]).concat(hookArgs);
	              return currPre.apply(self, preArgs);
	            } else if (!_asyncsLeft) {
	              return _done.apply(self, hookArgs);
	            }
	          }
	        , _done = function () {
	            var args_ = Array.prototype.slice.call(arguments)
	              , ret, total_, current_, next_, done_, postArgs;
	
	            if (_current === _total) {
	              
	              next_ = function () {
	                if (arguments[0] instanceof Error) {
	                  return handleError(arguments[0]);
	                }
	                var args_ = Array.prototype.slice.call(arguments, 1)
	                  , currPost
	                  , postArgs;
	                if (args_.length) hookArgs = args_;
	                if (++current_ < total_) {
	                  currPost = posts[current_]
	                  if (currPost.length < 1)
	                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");
	                  postArgs = [once(next_)].concat(hookArgs);
	                  return currPost.apply(self, postArgs);
	                } else if (typeof lastArg === 'function'){
	                  // All post handlers are done, call original callback function
	                  return lastArg.apply(self, arguments);
	                }
	              };
	
	              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
	              // a callback.  We trap that callback and wait to call it until all post handlers have finished.
	              if(typeof lastArg === 'function'){
	                args_[args_.length - 1] = once(next_);
	              }
	
	              total_ = posts.length;
	              current_ = -1;
	              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward
	
	              if (total_ && typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually
	              return ret;
	            }
	          };
	
	      return _next.apply(this, arguments);
	    };
	    
	    proto[name].numAsyncPres = 0;
	
	    return this;
	  },
	
	  pre: function (name, isAsync, fn, errorCb) {
	    if ('boolean' !== typeof arguments[1]) {
	      errorCb = fn;
	      fn = isAsync;
	      isAsync = false;
	    }
	    var proto = this.prototype || this
	      , pres = proto._pres = proto._pres || {};
	
	    this._lazySetupHooks(proto, name, errorCb);
	
	    if (fn.isAsync = isAsync) {
	      proto[name].numAsyncPres++;
	    }
	
	    (pres[name] = pres[name] || []).push(fn);
	    return this;
	  },
	  post: function (name, isAsync, fn) {
	    if (arguments.length === 2) {
	      fn = isAsync;
	      isAsync = false;
	    }
	    var proto = this.prototype || this
	      , posts = proto._posts = proto._posts || {};
	    
	    this._lazySetupHooks(proto, name);
	    (posts[name] = posts[name] || []).push(fn);
	    return this;
	  },
	  removePre: function (name, fnToRemove) {
	    var proto = this.prototype || this
	      , pres = proto._pres || (proto._pres || {});
	    if (!pres[name]) return this;
	    if (arguments.length === 1) {
	      // Remove all pre callbacks for hook `name`
	      pres[name].length = 0;
	    } else {
	      pres[name] = pres[name].filter( function (currFn) {
	        return currFn !== fnToRemove;
	      });
	    }
	    return this;
	  },
	  _lazySetupHooks: function (proto, methodName, errorCb) {
	    if ('undefined' === typeof proto[methodName].numAsyncPres) {
	      this.hook(methodName, proto[methodName], errorCb);
	    }
	  }
	};
	
	function once (fn, scope) {
	  return function fnWrapper () {
	    if (fnWrapper.hookCalled) return;
	    fnWrapper.hookCalled = true;
	    return fn.apply(scope, arguments);
	  };
	}


/***/ },
/* 180 */
/*!****************************************!*\
  !*** ./~/mongoose/lib/schema/mixed.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var SchemaType = __webpack_require__(/*! ../schematype */ 177);
	var utils = __webpack_require__(/*! ../utils */ 42);
	
	/**
	 * Mixed SchemaType constructor.
	 *
	 * @param {String} path
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api private
	 */
	
	function Mixed (path, options) {
	  if (options && options.default) {
	    var def = options.default;
	    if (Array.isArray(def) && 0 === def.length) {
	      // make sure empty array defaults are handled
	      options.default = Array;
	    } else if (!options.shared &&
	               utils.isObject(def) &&
	               0 === Object.keys(def).length) {
	      // prevent odd "shared" objects between documents
	      options.default = function () {
	        return {}
	      }
	    }
	  }
	
	  SchemaType.call(this, path, options, 'Mixed');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api private
	 */
	Mixed.schemaName = 'Mixed';
	
	/*!
	 * Inherits from SchemaType.
	 */
	Mixed.prototype = Object.create( SchemaType.prototype );
	Mixed.prototype.constructor = Mixed;
	
	/**
	 * Required validator
	 *
	 * @api private
	 */
	
	Mixed.prototype.checkRequired = function (val) {
	  return (val !== undefined) && (val !== null);
	};
	
	/**
	 * Casts `val` for Mixed.
	 *
	 * _this is a no-op_
	 *
	 * @param {Object} value to cast
	 * @api private
	 */
	
	Mixed.prototype.cast = function (val) {
	  return val;
	};
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $cond
	 * @param {any} [val]
	 * @api private
	 */
	
	Mixed.prototype.castForQuery = function ($cond, val) {
	  if (arguments.length === 2) return val;
	  return $cond;
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = Mixed;


/***/ },
/* 181 */
/*!************************************!*\
  !*** ./~/mongoose/lib/internal.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Dependencies
	 */
	
	var StateMachine = __webpack_require__(/*! ./statemachine */ 182)
	var ActiveRoster = StateMachine.ctor('require', 'modify', 'init', 'default', 'ignore');
	
	module.exports = exports = InternalCache;
	
	function InternalCache () {
	  this.strictMode = undefined;
	  this.selected = undefined;
	  this.shardval = undefined;
	  this.saveError = undefined;
	  this.validationError = undefined;
	  this.adhocPaths = undefined;
	  this.removing = undefined;
	  this.inserting = undefined;
	  this.version = undefined;
	  this.getters = {};
	  this._id = undefined;
	  this.populate = undefined; // what we want to populate in this doc
	  this.populated = undefined;// the _ids that have been populated
	  this.wasPopulated = false; // if this doc was the result of a population
	  this.scope = undefined;
	  this.activePaths = new ActiveRoster;
	
	  // embedded docs
	  this.ownerDocument = undefined;
	  this.fullPath = undefined;
	}


/***/ },
/* 182 */
/*!****************************************!*\
  !*** ./~/mongoose/lib/statemachine.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var utils = __webpack_require__(/*! ./utils */ 42);
	
	/*!
	 * StateMachine represents a minimal `interface` for the
	 * constructors it builds via StateMachine.ctor(...).
	 *
	 * @api private
	 */
	
	var StateMachine = module.exports = exports = function StateMachine () {
	}
	
	/*!
	 * StateMachine.ctor('state1', 'state2', ...)
	 * A factory method for subclassing StateMachine.
	 * The arguments are a list of states. For each state,
	 * the constructor's prototype gets state transition
	 * methods named after each state. These transition methods
	 * place their path argument into the given state.
	 *
	 * @param {String} state
	 * @param {String} [state]
	 * @return {Function} subclass constructor
	 * @private
	 */
	
	StateMachine.ctor = function () {
	  var states = utils.args(arguments);
	
	  var ctor = function () {
	    StateMachine.apply(this, arguments);
	    this.paths = {};
	    this.states = {};
	    this.stateNames = states;
	
	    var i = states.length
	      , state;
	
	    while (i--) {
	      state = states[i];
	      this.states[state] = {};
	    }
	  };
	
	  ctor.prototype = new StateMachine();
	
	  states.forEach(function (state) {
	    // Changes the `path`'s state to `state`.
	    ctor.prototype[state] = function (path) {
	      this._changeState(path, state);
	    }
	  });
	
	  return ctor;
	};
	
	/*!
	 * This function is wrapped by the state change functions:
	 *
	 * - `require(path)`
	 * - `modify(path)`
	 * - `init(path)`
	 *
	 * @api private
	 */
	
	StateMachine.prototype._changeState = function _changeState (path, nextState) {
	  var prevBucket = this.states[this.paths[path]];
	  if (prevBucket) delete prevBucket[path];
	
	  this.paths[path] = nextState;
	  this.states[nextState][path] = true;
	}
	
	/*!
	 * ignore
	 */
	
	StateMachine.prototype.clear = function clear (state) {
	  var keys = Object.keys(this.states[state])
	    , i = keys.length
	    , path
	
	  while (i--) {
	    path = keys[i];
	    delete this.states[state][path];
	    delete this.paths[path];
	  }
	}
	
	/*!
	 * Checks to see if at least one path is in the states passed in via `arguments`
	 * e.g., this.some('required', 'inited')
	 *
	 * @param {String} state that we want to check for.
	 * @private
	 */
	
	StateMachine.prototype.some = function some () {
	  var self = this;
	  var what = arguments.length ? arguments : this.stateNames;
	  return Array.prototype.some.call(what, function (state) {
	    return Object.keys(self.states[state]).length;
	  });
	}
	
	/*!
	 * This function builds the functions that get assigned to `forEach` and `map`,
	 * since both of those methods share a lot of the same logic.
	 *
	 * @param {String} iterMethod is either 'forEach' or 'map'
	 * @return {Function}
	 * @api private
	 */
	
	StateMachine.prototype._iter = function _iter (iterMethod) {
	  return function () {
	    var numArgs = arguments.length
	      , states = utils.args(arguments, 0, numArgs-1)
	      , callback = arguments[numArgs-1];
	
	    if (!states.length) states = this.stateNames;
	
	    var self = this;
	
	    var paths = states.reduce(function (paths, state) {
	      return paths.concat(Object.keys(self.states[state]));
	    }, []);
	
	    return paths[iterMethod](function (path, i, paths) {
	      return callback(path, i, paths);
	    });
	  };
	}
	
	/*!
	 * Iterates over the paths that belong to one of the parameter states.
	 *
	 * The function profile can look like:
	 * this.forEach(state1, fn);         // iterates over all paths in state1
	 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
	 * this.forEach(fn);                 // iterates over all paths in all states
	 *
	 * @param {String} [state]
	 * @param {String} [state]
	 * @param {Function} callback
	 * @private
	 */
	
	StateMachine.prototype.forEach = function forEach () {
	  this.forEach = this._iter('forEach');
	  return this.forEach.apply(this, arguments);
	}
	
	/*!
	 * Maps over the paths that belong to one of the parameter states.
	 *
	 * The function profile can look like:
	 * this.forEach(state1, fn);         // iterates over all paths in state1
	 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
	 * this.forEach(fn);                 // iterates over all paths in all states
	 *
	 * @param {String} [state]
	 * @param {String} [state]
	 * @param {Function} callback
	 * @return {Array}
	 * @private
	 */
	
	StateMachine.prototype.map = function map () {
	  this.map = this._iter('map');
	  return this.map.apply(this, arguments);
	}
	


/***/ },
/* 183 */
/*!***********************************!*\
  !*** ./~/mongoose/lib/promise.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies
	 */
	
	var MPromise = __webpack_require__(/*! mpromise */ 184);
	var util = __webpack_require__(/*! util */ 57);
	
	/**
	 * Promise constructor.
	 *
	 * Promises are returned from executed queries. Example:
	 *
	 *     var query = Candy.find({ bar: true });
	 *     var promise = query.exec();
	 *
	 * @param {Function} fn a function which will be called when the promise is resolved that accepts `fn(err, ...){}` as signature
	 * @inherits mpromise https://github.com/aheckmann/mpromise
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `err`: Emits when the promise is rejected
	 * @event `complete`: Emits when the promise is fulfilled
	 * @api public
	 */
	
	function Promise (fn) {
	  MPromise.call(this, fn);
	}
	
	/*!
	 * Inherit from mpromise
	 */
	
	Promise.prototype = Object.create(MPromise.prototype, {
	    constructor: {
	        value: Promise
	      , enumerable: false
	      , writable: true
	      , configurable: true
	    }
	});
	
	/*!
	 * Override event names for backward compatibility.
	 */
	
	Promise.SUCCESS = 'complete';
	Promise.FAILURE = 'err';
	
	/**
	 * Adds `listener` to the `event`.
	 *
	 * If `event` is either the success or failure event and the event has already been emitted, the`listener` is called immediately and passed the results of the original emitted event.
	 *
	 * @see mpromise#on https://github.com/aheckmann/mpromise#on
	 * @method on
	 * @memberOf Promise
	 * @param {String} event
	 * @param {Function} listener
	 * @return {Promise} this
	 * @api public
	 */
	
	/**
	 * Rejects this promise with `reason`.
	 *
	 * If the promise has already been fulfilled or rejected, not action is taken.
	 *
	 * @see mpromise#reject https://github.com/aheckmann/mpromise#reject
	 * @method reject
	 * @memberOf Promise
	 * @param {Object|String|Error} reason
	 * @return {Promise} this
	 * @api public
	 */
	
	/**
	 * Rejects this promise with `err`.
	 *
	 * If the promise has already been fulfilled or rejected, not action is taken.
	 *
	 * Differs from [#reject](#promise_Promise-reject) by first casting `err` to an `Error` if it is not `instanceof Error`.
	 *
	 * @api public
	 * @param {Error|String} err
	 * @return {Promise} this
	 */
	
	Promise.prototype.error = function (err) {
	  if (!(err instanceof Error)) {
	    if (err instanceof Object) {
	      err = util.inspect(err);
	    }
	    err = new Error(err);
	  }
	  return this.reject(err);
	}
	
	/**
	 * Resolves this promise to a rejected state if `err` is passed or a fulfilled state if no `err` is passed.
	 *
	 * If the promise has already been fulfilled or rejected, not action is taken.
	 *
	 * `err` will be cast to an Error if not already instanceof Error.
	 *
	 * _NOTE: overrides [mpromise#resolve](https://github.com/aheckmann/mpromise#resolve) to provide error casting._
	 *
	 * @param {Error} [err] error or null
	 * @param {Object} [val] value to fulfill the promise with
	 * @api public
	 */
	
	Promise.prototype.resolve = function (err) {
	  if (err) return this.error(err);
	  return this.fulfill.apply(this, Array.prototype.slice.call(arguments, 1));
	};
	
	/**
	 * Adds a single function as a listener to both err and complete.
	 *
	 * It will be executed with traditional node.js argument position when the promise is resolved.
	 *
	 *     promise.addBack(function (err, args...) {
	 *       if (err) return handleError(err);
	 *       console.log('success');
	 *     })
	 *
	 * Alias of [mpromise#onResolve](https://github.com/aheckmann/mpromise#onresolve).
	 *
	 * _Deprecated. Use `onResolve` instead._
	 *
	 * @method addBack
	 * @param {Function} listener
	 * @return {Promise} this
	 * @deprecated
	 */
	
	Promise.prototype.addBack = Promise.prototype.onResolve;
	
	/**
	 * Fulfills this promise with passed arguments.
	 *
	 * @method fulfill
	 * @receiver Promise
	 * @see https://github.com/aheckmann/mpromise#fulfill
	 * @param {any} args
	 * @api public
	 */
	
	/**
	 * Fulfills this promise with passed arguments.
	 *
	 * Alias of [mpromise#fulfill](https://github.com/aheckmann/mpromise#fulfill).
	 *
	 * _Deprecated. Use `fulfill` instead._
	 *
	 * @method complete
	 * @receiver Promise
	 * @param {any} args
	 * @api public
	 * @deprecated
	 */
	
	Promise.prototype.complete = MPromise.prototype.fulfill;
	
	/**
	 * Adds a listener to the `complete` (success) event.
	 *
	 * Alias of [mpromise#onFulfill](https://github.com/aheckmann/mpromise#onfulfill).
	 *
	 * _Deprecated. Use `onFulfill` instead._
	 *
	 * @method addCallback
	 * @param {Function} listener
	 * @return {Promise} this
	 * @api public
	 * @deprecated
	 */
	
	Promise.prototype.addCallback = Promise.prototype.onFulfill;
	
	/**
	 * Adds a listener to the `err` (rejected) event.
	 *
	 * Alias of [mpromise#onReject](https://github.com/aheckmann/mpromise#onreject).
	 *
	 * _Deprecated. Use `onReject` instead._
	 *
	 * @method addErrback
	 * @param {Function} listener
	 * @return {Promise} this
	 * @api public
	 * @deprecated
	 */
	
	Promise.prototype.addErrback = Promise.prototype.onReject;
	
	/**
	 * Creates a new promise and returns it. If `onFulfill` or `onReject` are passed, they are added as SUCCESS/ERROR callbacks to this promise after the nextTick.
	 *
	 * Conforms to [promises/A+](https://github.com/promises-aplus/promises-spec) specification.
	 *
	 * ####Example:
	 *
	 *     var promise = Meetups.find({ tags: 'javascript' }).select('_id').exec();
	 *     promise.then(function (meetups) {
	 *       var ids = meetups.map(function (m) {
	 *         return m._id;
	 *       });
	 *       return People.find({ meetups: { $in: ids }).exec();
	 *     }).then(function (people) {
	 *       if (people.length < 10000) {
	 *         throw new Error('Too few people!!!');
	 *       } else {
	 *         throw new Error('Still need more people!!!');
	 *       }
	 *     }).then(null, function (err) {
	 *       assert.ok(err instanceof Error);
	 *     });
	 *
	 * @see promises-A+ https://github.com/promises-aplus/promises-spec
	 * @see mpromise#then https://github.com/aheckmann/mpromise#then
	 * @method then
	 * @memberOf Promise
	 * @param {Function} onFulFill
	 * @param {Function} onReject
	 * @return {Promise} newPromise
	 */
	
	/**
	 * Signifies that this promise was the last in a chain of `then()s`: if a handler passed to the call to `then` which produced this promise throws, the exception will go uncaught.
	 *
	 * ####Example:
	 *
	 *     var p = new Promise;
	 *     p.then(function(){ throw new Error('shucks') });
	 *     setTimeout(function () {
	 *       p.fulfill();
	 *       // error was caught and swallowed by the promise returned from
	 *       // p.then(). we either have to always register handlers on
	 *       // the returned promises or we can do the following...
	 *     }, 10);
	 *
	 *     // this time we use .end() which prevents catching thrown errors
	 *     var p = new Promise;
	 *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--
	 *     setTimeout(function () {
	 *       p.fulfill(); // throws "shucks"
	 *     }, 10);
	 *
	 * @api public
	 * @see mpromise#end https://github.com/aheckmann/mpromise#end
	 * @method end
	 * @memberOf Promise
	 */
	
	/*!
	 * expose
	 */
	
	module.exports = Promise;


/***/ },
/* 184 */
/*!**********************************************!*\
  !*** ./~/mongoose/~/mpromise/lib/promise.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	var util = __webpack_require__(/*! util */ 57);
	var EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter;
	function toArray(arr, start, end) {
	  return Array.prototype.slice.call(arr, start, end)
	}
	function strongUnshift(x, arrLike) {
	  var arr = toArray(arrLike);
	  arr.unshift(x);
	  return arr;
	}
	
	
	/**
	 * Promise constructor.
	 *
	 * _NOTE: The success and failure event names can be overridden by setting `Promise.SUCCESS` and `Promise.FAILURE` respectively._
	 *
	 * @param {Function} back a function that accepts `fn(err, ...){}` as signature
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `reject`: Emits when the promise is rejected (event name may be overridden)
	 * @event `fulfill`: Emits when the promise is fulfilled (event name may be overridden)
	 * @api public
	 */
	function Promise(back) {
	  this.emitter = new EventEmitter();
	  this.emitted = {};
	  this.ended = false;
	  if ('function' == typeof back)
	    this.onResolve(back);
	}
	
	
	/*
	 * Module exports.
	 */
	module.exports = Promise;
	
	
	/*!
	 * event names
	 */
	Promise.SUCCESS = 'fulfill';
	Promise.FAILURE = 'reject';
	
	
	/**
	 * Adds `listener` to the `event`.
	 *
	 * If `event` is either the success or failure event and the event has already been emitted, the`listener` is called immediately and passed the results of the original emitted event.
	 *
	 * @param {String} event
	 * @param {Function} callback
	 * @return {Promise} this
	 * @api private
	 */
	Promise.prototype.on = function (event, callback) {
	  if (this.emitted[event])
	    callback.apply(undefined, this.emitted[event]);
	  else
	    this.emitter.on(event, callback);
	
	  return this;
	};
	
	
	/**
	 * Keeps track of emitted events to run them on `on`.
	 *
	 * @api private
	 */
	Promise.prototype.safeEmit = function (event) {
	  // ensures a promise can't be fulfill() or reject() more than once
	  if (event == Promise.SUCCESS || event == Promise.FAILURE) {
	    if (this.emitted[Promise.SUCCESS] || this.emitted[Promise.FAILURE]) {
	      return this;
	    }
	    this.emitted[event] = toArray(arguments, 1);
	  }
	
	  this.emitter.emit.apply(this.emitter, arguments);
	  return this;
	};
	
	
	/**
	 * Fulfills this promise with passed arguments.
	 *
	 * If this promise has already been fulfilled or rejected, no action is taken.
	 *
	 * @api public
	 */
	Promise.prototype.fulfill = function () {
	  return this.safeEmit.apply(this, strongUnshift(Promise.SUCCESS, arguments));
	};
	
	
	/**
	 * Rejects this promise with `reason`.
	 *
	 * If this promise has already been fulfilled or rejected, no action is taken.
	 *
	 * @api public
	 * @param {Object|String} reason
	 * @return {Promise} this
	 */
	Promise.prototype.reject = function (reason) {
	  if (this.ended && !this.hasRejectListeners()) throw reason;
	  return this.safeEmit(Promise.FAILURE, reason);
	};
	
	
	/**
	 * Resolves this promise to a rejected state if `err` is passed or
	 * fulfilled state if no `err` is passed.
	 *
	 * @param {Error} [err] error or null
	 * @param {Object} [val] value to fulfill the promise with
	 * @api public
	 */
	Promise.prototype.resolve = function (err, val) {
	  if (err) return this.reject(err);
	  return this.fulfill(val);
	};
	
	
	/**
	 * Adds a listener to the SUCCESS event.
	 *
	 * @return {Promise} this
	 * @api public
	 */
	Promise.prototype.onFulfill = function (fn) {
	  if (!fn) return this;
	  if ('function' != typeof fn) throw new TypeError("fn should be a function");
	  return this.on(Promise.SUCCESS, fn);
	};
	
	
	Promise.prototype.hasRejectListeners = function () {
	  return this.emitter.listeners(Promise.FAILURE).length > 0;
	};
	
	
	/**
	 * Adds a listener to the FAILURE event.
	 *
	 * @return {Promise} this
	 * @api public
	 */
	Promise.prototype.onReject = function (fn) {
	  if (!fn) return this;
	  if ('function' != typeof fn) throw new TypeError("fn should be a function");
	  return this.on(Promise.FAILURE, fn);
	};
	
	
	/**
	 * Adds a single function as a listener to both SUCCESS and FAILURE.
	 *
	 * It will be executed with traditional node.js argument position:
	 * function (err, args...) {}
	 *
	 * Also marks the promise as `end`ed, since it's the common use-case, and yet has no
	 * side effects unless `fn` is undefined or null.
	 *
	 * @param {Function} fn
	 * @return {Promise} this
	 */
	Promise.prototype.onResolve = function (fn) {
	  this.end();
	  if (!fn) return this;
	  if ('function' != typeof fn) throw new TypeError("fn should be a function");
	  this.on(Promise.FAILURE, function (err) { fn.call(this, err); });
	  this.on(Promise.SUCCESS, function () { fn.apply(this, strongUnshift(null, arguments)); });
	  return this;
	};
	
	
	/**
	 * Creates a new promise and returns it. If `onFulfill` or
	 * `onReject` are passed, they are added as SUCCESS/ERROR callbacks
	 * to this promise after the next tick.
	 *
	 * Conforms to [promises/A+](https://github.com/promises-aplus/promises-spec) specification. Read for more detail how to use this method.
	 *
	 * ####Example:
	 *
	 *     var p = new Promise;
	 *     p.then(function (arg) {
	 *       return arg + 1;
	 *     }).then(function (arg) {
	 *       throw new Error(arg + ' is an error!');
	 *     }).then(null, function (err) {
	 *       assert.ok(err instanceof Error);
	 *       assert.equal('2 is an error', err.message);
	 *     });
	 *     p.complete(1);
	 *
	 * @see promises-A+ https://github.com/promises-aplus/promises-spec
	 * @param {Function} onFulfill
	 * @param {Function} [onReject]
	 * @return {Promise} newPromise
	 */
	Promise.prototype.then = function (onFulfill, onReject) {
	  var newPromise = new Promise;
	
	  if ('function' == typeof onFulfill) {
	    this.onFulfill(handler(newPromise, onFulfill));
	  } else {
	    this.onFulfill(newPromise.fulfill.bind(newPromise));
	  }
	
	  if ('function' == typeof onReject) {
	    this.onReject(handler(newPromise, onReject));
	  } else {
	    this.onReject(newPromise.reject.bind(newPromise));
	  }
	
	  return newPromise;
	};
	
	
	function handler(promise, fn) {
	  function newTickHandler() {
	    var pDomain = promise.emitter.domain;
	    if (pDomain && pDomain !== process.domain) pDomain.enter();
	    try {
	      var x = fn.apply(undefined, boundHandler.args);
	    } catch (err) {
	      promise.reject(err);
	      return;
	    }
	    resolve(promise, x);
	  }
	  function boundHandler() {
	    boundHandler.args = arguments;
	    process.nextTick(newTickHandler);
	  }
	  return boundHandler;
	}
	
	
	function resolve(promise, x) {
	  function fulfillOnce() {
	    if (done++) return;
	    resolve.apply(undefined, strongUnshift(promise, arguments));
	  }
	  function rejectOnce(reason) {
	    if (done++) return;
	    promise.reject(reason);
	  }
	
	  if (promise === x) {
	    promise.reject(new TypeError("promise and x are the same"));
	    return;
	  }
	  var rest = toArray(arguments, 1);
	  var type = typeof x;
	  if ('undefined' == type || null == x || !('object' == type || 'function' == type)) {
	    promise.fulfill.apply(promise, rest);
	    return;
	  }
	
	  try {
	    var theThen = x.then;
	  } catch (err) {
	    promise.reject(err);
	    return;
	  }
	
	  if ('function' != typeof theThen) {
	    promise.fulfill.apply(promise, rest);
	    return;
	  }
	
	  var done = 0;
	  try {
	    var ret = theThen.call(x, fulfillOnce, rejectOnce);
	    return ret;
	  } catch (err) {
	    if (done++) return;
	    promise.reject(err);
	  }
	}
	
	
	/**
	 * Signifies that this promise was the last in a chain of `then()s`: if a handler passed to the call to `then` which produced this promise throws, the exception will go uncaught.
	 *
	 * ####Example:
	 *
	 *     var p = new Promise;
	 *     p.then(function(){ throw new Error('shucks') });
	 *     setTimeout(function () {
	 *       p.fulfill();
	 *       // error was caught and swallowed by the promise returned from
	 *       // p.then(). we either have to always register handlers on
	 *       // the returned promises or we can do the following...
	 *     }, 10);
	 *
	 *     // this time we use .end() which prevents catching thrown errors
	 *     var p = new Promise;
	 *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--
	 *     setTimeout(function () {
	 *       p.fulfill(); // throws "shucks"
	 *     }, 10);
	 *
	 * @api public
	 * @param {Function} [onReject]
	 * @return {Promise} this
	 */
	Promise.prototype.end = function (onReject) {
	  this.onReject(onReject);
	  this.ended = true;
	  return this;
	};
	
	
	/**
	 * A debug utility function that adds handlers to a promise that will log some output to the `console`
	 *
	 * ####Example:
	 *
	 *     var p = new Promise;
	 *     p.then(function(){ throw new Error('shucks') });
	 *     setTimeout(function () {
	 *       p.fulfill();
	 *       // error was caught and swallowed by the promise returned from
	 *       // p.then(). we either have to always register handlers on
	 *       // the returned promises or we can do the following...
	 *     }, 10);
	 *
	 *     // this time we use .end() which prevents catching thrown errors
	 *     var p = new Promise;
	 *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--
	 *     setTimeout(function () {
	 *       p.fulfill(); // throws "shucks"
	 *     }, 10);
	 *
	 * @api public
	 * @param {Promise} p
	 * @param {String} name
	 * @return {Promise} this
	 */
	Promise.trace = function (p, name) {
	  p.then(
	    function () {
	      console.log("%s fulfill %j", name, toArray(arguments));
	    },
	    function () {
	      console.log("%s reject %j", name, toArray(arguments));
	    }
	  )
	};
	
	
	Promise.prototype.chain = function (p2) {
	  var p1 = this;
	  p1.onFulfill(p2.fulfill.bind(p2));
	  p1.onReject(p2.reject.bind(p2));
	  return p2;
	};
	
	
	Promise.prototype.all = function (promiseOfArr) {
	  var pRet = new Promise;
	  this.then(promiseOfArr).then(
	    function (promiseArr) {
	      var count = 0;
	      var ret = [];
	      var errSentinel;
	      if (!promiseArr.length) pRet.resolve();
	      promiseArr.forEach(function (promise, index) {
	        if (errSentinel) return;
	        count++;
	        promise.then(
	          function (val) {
	            if (errSentinel) return;
	            ret[index] = val;
	            --count;
	            if (count == 0) pRet.fulfill(ret);
	          },
	          function (err) {
	            if (errSentinel) return;
	            errSentinel = err;
	            pRet.reject(err);
	          }
	        );
	      });
	      return pRet;
	    }
	    , pRet.reject.bind(pRet)
	  );
	  return pRet;
	};
	
	
	Promise.hook = function (arr) {
	  var p1 = new Promise;
	  var pFinal = new Promise;
	  var signalP = function () {
	    --count;
	    if (count == 0)
	      pFinal.fulfill();
	    return pFinal;
	  };
	  var count = 1;
	  var ps = p1;
	  arr.forEach(function (hook) {
	    ps = ps.then(
	      function () {
	        var p = new Promise;
	        count++;
	        hook(p.resolve.bind(p), signalP);
	        return p;
	      }
	    )
	  });
	  ps = ps.then(signalP);
	  p1.resolve();
	  return ps;
	};
	
	
	/* This is for the A+ tests, but it's very useful as well */
	Promise.fulfilled = function fulfilled() { var p = new Promise; p.fulfill.apply(p, arguments); return p; };
	Promise.rejected = function rejected(reason) { return new Promise().reject(reason); };
	Promise.deferred = function deferred() {
	  var p = new Promise;
	  return {
	    promise: p,
	    reject: p.reject.bind(p),
	    resolve: p.fulfill.bind(p),
	    callback: p.resolve.bind(p)
	  }
	};
	/* End A+ tests adapter bit */
	
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 185 */
/*!******************************************!*\
  !*** ./~/mongoose/lib/types/embedded.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var Document = __webpack_require__(/*! ../document_provider */ 186)();
	var inspect = __webpack_require__(/*! util */ 57).inspect;
	var Promise = __webpack_require__(/*! ../promise */ 183);
	
	/**
	 * EmbeddedDocument constructor.
	 *
	 * @param {Object} obj js object returned from the db
	 * @param {MongooseDocumentArray} parentArr the parent array of this document
	 * @param {Boolean} skipId
	 * @inherits Document
	 * @api private
	 */
	
	function EmbeddedDocument (obj, parentArr, skipId, fields, index) {
	  if (parentArr) {
	    this.__parentArray = parentArr;
	    this.__parent = parentArr._parent;
	  } else {
	    this.__parentArray = undefined;
	    this.__parent = undefined;
	  }
	  this.__index = index;
	
	  Document.call(this, obj, fields, skipId);
	
	  var self = this;
	  this.on('isNew', function (val) {
	    self.isNew = val;
	  });
	}
	
	/*!
	 * Inherit from Document
	 */
	EmbeddedDocument.prototype = Object.create( Document.prototype );
	EmbeddedDocument.prototype.constructor = EmbeddedDocument;
	
	/**
	 * Marks the embedded doc modified.
	 *
	 * ####Example:
	 *
	 *     var doc = blogpost.comments.id(hexstring);
	 *     doc.mixed.type = 'changed';
	 *     doc.markModified('mixed.type');
	 *
	 * @param {String} path the path which changed
	 * @api public
	 * @receiver EmbeddedDocument
	 */
	
	EmbeddedDocument.prototype.markModified = function (path) {
	  if (!this.__parentArray) return;
	
	  this.$__.activePaths.modify(path);
	  if (this.isNew) {
	    // Mark the WHOLE parent array as modified
	    // if this is a new document (i.e., we are initializing
	    // a document),
	    this.__parentArray._markModified();
	  } else {
	    this.__parentArray._markModified(this, path);
	  }
	};
	
	/**
	 * Used as a stub for [hooks.js](https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3)
	 *
	 * ####NOTE:
	 *
	 * _This is a no-op. Does not actually save the doc to the db._
	 *
	 * @param {Function} [fn]
	 * @return {Promise} resolved Promise
	 * @api private
	 */
	
	EmbeddedDocument.prototype.save = function (fn) {
	  var promise = new Promise(fn);
	  promise.fulfill();
	  return promise;
	}
	
	/**
	 * Removes the subdocument from its parent array.
	 *
	 * @param {Function} [fn]
	 * @api public
	 */
	
	EmbeddedDocument.prototype.remove = function (fn) {
	  if (!this.__parentArray) return this;
	
	  var _id;
	  if (!this.willRemove) {
	    _id = this._doc._id;
	    if (!_id) {
	      throw new Error('For your own good, Mongoose does not know ' +
	                      'how to remove an EmbeddedDocument that has no _id');
	    }
	    this.__parentArray.pull({ _id: _id });
	    this.willRemove = true;
	    registerRemoveListener(this);
	  }
	
	  if (fn)
	    fn(null);
	
	  return this;
	};
	
	/*!
	 * Registers remove event listeners for triggering
	 * on subdocuments.
	 *
	 * @param {EmbeddedDocument} sub
	 * @api private
	 */
	
	function registerRemoveListener (sub) {
	  var owner = sub.ownerDocument();
	
	  owner.on('save', emitRemove);
	  owner.on('remove', emitRemove);
	
	  function emitRemove () {
	    owner.removeListener('save', emitRemove);
	    owner.removeListener('remove', emitRemove);
	    sub.emit('remove', sub);
	    owner = sub = emitRemove = null;
	  };
	};
	
	/**
	 * Override #update method of parent documents.
	 * @api private
	 */
	
	EmbeddedDocument.prototype.update = function () {
	  throw new Error('The #update method is not available on EmbeddedDocuments');
	}
	
	/**
	 * Helper for console.log
	 *
	 * @api public
	 */
	
	EmbeddedDocument.prototype.inspect = function () {
	  return inspect(this.toObject());
	};
	
	/**
	 * Marks a path as invalid, causing validation to fail.
	 *
	 * @param {String} path the field to invalidate
	 * @param {String|Error} err error which states the reason `path` was invalid
	 * @return {Boolean}
	 * @api public
	 */
	
	EmbeddedDocument.prototype.invalidate = function (path, err, val, first) {
	  if (!this.__parent) {
	    var msg = 'Unable to invalidate a subdocument that has not been added to an array.'
	    throw new Error(msg);
	  }
	
	  var index = this.__index;
	  if (typeof index !== 'undefined') {
	    var parentPath = this.__parentArray._path;
	    var fullPath = [parentPath, index, path].join('.');
	    this.__parent.invalidate(fullPath, err, val);
	  }
	
	  if (first) {
	    this.$__.validationError = this.ownerDocument().$__.validationError;
	  }
	
	  return true;
	};
	
	/**
	 * Marks a path as valid, removing existing validation errors.
	 *
	 * @param {String} path the field to mark as valid
	 * @api private
	 * @method $markValid
	 * @receiver EmbeddedDocument
	 */
	
	EmbeddedDocument.prototype.$markValid = function(path) {
	  if (!this.__parent) {
	    return;
	  }
	
	  var index = this.__index;
	  if (typeof index !== 'undefined') {
	    var parentPath = this.__parentArray._path;
	    var fullPath = [parentPath, index, path].join('.');
	    this.__parent.$markValid(fullPath);
	  }
	};
	
	/**
	 * Checks if a path is invalid
	 *
	 * @param {String} path the field to check
	 * @api private
	 * @method $isValid
	 * @receiver EmbeddedDocument
	 */
	
	EmbeddedDocument.prototype.$isValid = function(path) {
	  var index = this.__index;
	  if (typeof index !== 'undefined') {
	    var parentPath = this.__parentArray._path;
	    var fullPath = [parentPath, index, path].join('.');
	
	    return !this.__parent.$__.validationError ||
	      !this.__parent.$__.validationError.errors[path];
	  }
	
	  return true;
	};
	
	/**
	 * Returns the top level document of this sub-document.
	 *
	 * @return {Document}
	 */
	
	EmbeddedDocument.prototype.ownerDocument = function () {
	  if (this.$__.ownerDocument) {
	    return this.$__.ownerDocument;
	  }
	
	  var parent = this.__parent;
	  if (!parent) return this;
	
	  while (parent.__parent) {
	    parent = parent.__parent;
	  }
	
	  return this.$__.ownerDocument = parent;
	}
	
	/**
	 * Returns the full path to this document. If optional `path` is passed, it is appended to the full path.
	 *
	 * @param {String} [path]
	 * @return {String}
	 * @api private
	 * @method $__fullPath
	 * @memberOf EmbeddedDocument
	 */
	
	EmbeddedDocument.prototype.$__fullPath = function (path) {
	  if (!this.$__.fullPath) {
	    var parent = this;
	    if (!parent.__parent) return path;
	
	    var paths = [];
	    while (parent.__parent) {
	      paths.unshift(parent.__parentArray._path);
	      parent = parent.__parent;
	    }
	
	    this.$__.fullPath = paths.join('.');
	
	    if (!this.$__.ownerDocument) {
	      // optimization
	      this.$__.ownerDocument = parent;
	    }
	  }
	
	  return path
	    ? this.$__.fullPath + '.' + path
	    : this.$__.fullPath;
	}
	
	/**
	 * Returns this sub-documents parent document.
	 *
	 * @api public
	 */
	
	EmbeddedDocument.prototype.parent = function () {
	  return this.__parent;
	}
	
	/**
	 * Returns this sub-documents parent array.
	 *
	 * @api public
	 */
	
	EmbeddedDocument.prototype.parentArray = function () {
	  return this.__parentArray;
	}
	
	/*!
	 * Module exports.
	 */
	
	module.exports = EmbeddedDocument;


/***/ },
/* 186 */
/*!*********************************************!*\
  !*** ./~/mongoose/lib/document_provider.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/*!
	 * Module dependencies.
	 */
	var Document = __webpack_require__(/*! ./document.js */ 178);
	var BrowserDocument = __webpack_require__(/*! ./browserDocument.js */ 187);
	
	/**
	 * Returns the Document constructor for the current context
	 *
	 * @api private
	 */
	module.exports = function() {
	  if (typeof window !== 'undefined' && typeof document !== 'undefined' && document === window.document) {
	    return BrowserDocument;
	  } else {
	    return Document;
	  }
	};

/***/ },
/* 187 */
/*!*******************************************!*\
  !*** ./~/mongoose/lib/browserDocument.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var NodeJSDocument = __webpack_require__(/*! ./document */ 178)
	  , EventEmitter = __webpack_require__(/*! events */ 74).EventEmitter
	  , setMaxListeners = EventEmitter.prototype.setMaxListeners
	  , MongooseError = __webpack_require__(/*! ./error */ 32)
	  , MixedSchema = __webpack_require__(/*! ./schema/mixed */ 180)
	  , Schema = __webpack_require__(/*! ./schema */ 41)
	  , ObjectId = __webpack_require__(/*! ./types/objectid */ 45)
	  , ValidatorError = __webpack_require__(/*! ./schematype */ 177).ValidatorError
	  , utils = __webpack_require__(/*! ./utils */ 42)
	  , clone = utils.clone
	  , isMongooseObject = utils.isMongooseObject
	  , inspect = __webpack_require__(/*! util */ 57).inspect
	  , ValidationError = MongooseError.ValidationError
	  , InternalCache = __webpack_require__(/*! ./internal */ 181)
	  , deepEqual = utils.deepEqual
	  , hooks = __webpack_require__(/*! hooks-fixed */ 179)
	  , Promise = __webpack_require__(/*! ./promise */ 183)
	  , DocumentArray
	  , MongooseArray
	  , Embedded
	
	/**
	 * Document constructor.
	 *
	 * @param {Object} obj the values to set
	 * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data
	 * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `init`: Emitted on a document after it has was retreived from the db and fully hydrated by Mongoose.
	 * @event `save`: Emitted when the document is successfully saved
	 * @api private
	 */
	
	function Document (obj, schema, fields, skipId, skipInit) {
	  if ( !(this instanceof Document) )
	    return new Document( obj, schema, fields, skipId, skipInit );
	
	
	  if (utils.isObject(schema) && !(schema instanceof Schema)) {
	    schema = new Schema(schema);
	  }
	
	  // When creating EmbeddedDocument, it already has the schema and he doesn't need the _id
	  schema = this.schema || schema;
	
	  // Generate ObjectId if it is missing, but it requires a scheme
	  if ( !this.schema && schema.options._id ){
	    obj = obj || {};
	
	    if ( obj._id === undefined ){
	      obj._id = new ObjectId();
	    }
	  }
	
	  if ( !schema ){
	    throw new MongooseError.MissingSchemaError();
	  }
	
	  this.$__setSchema(schema);
	
	  this.$__ = new InternalCache;
	  this.$__.emitter = new EventEmitter();
	  this.isNew = true;
	  this.errors = undefined;
	
	  //var schema = this.schema;
	
	  if ('boolean' === typeof fields) {
	    this.$__.strictMode = fields;
	    fields = undefined;
	  } else {
	    this.$__.strictMode = this.schema.options && this.schema.options.strict;
	    this.$__.selected = fields;
	  }
	
	  var required = this.schema.requiredPaths();
	  for (var i = 0; i < required.length; ++i) {
	    this.$__.activePaths.require(required[i]);
	  }
	
	  setMaxListeners.call(this, 0);
	  this._doc = this.$__buildDoc(obj, fields, skipId);
	
	  if ( !skipInit && obj ){
	    this.init( obj );
	  }
	
	  this.$__registerHooksFromSchema();
	
	  // apply methods
	  for ( var m in schema.methods ){
	    this[ m ] = schema.methods[ m ];
	  }
	  // apply statics
	  for ( var s in schema.statics ){
	    this[ s ] = schema.statics[ s ];
	  }
	}
	
	/*!
	 * Inherit from the NodeJS document
	 */
	Document.prototype = Object.create(NodeJSDocument.prototype);
	Document.prototype.constructor = Document;
	
	
	
	/*!
	 * Module exports.
	 */
	
	Document.ValidationError = ValidationError;
	module.exports = exports = Document;


/***/ },
/* 188 */
/*!***************************************!*\
  !*** ./~/mongoose/lib/types/array.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {/*!
	 * Module dependencies.
	 */
	
	var EmbeddedDocument = __webpack_require__(/*! ./embedded */ 185);
	var Document = __webpack_require__(/*! ../document */ 178);
	var ObjectId = __webpack_require__(/*! ./objectid */ 45);
	var utils = __webpack_require__(/*! ../utils */ 42);
	var isMongooseObject = utils.isMongooseObject;
	
	/**
	 * Mongoose Array constructor.
	 *
	 * ####NOTE:
	 *
	 * _Values always have to be passed to the constructor to initialize, otherwise `MongooseArray#push` will mark the array as modified._
	 *
	 * @param {Array} values
	 * @param {String} path
	 * @param {Document} doc parent document
	 * @api private
	 * @inherits Array
	 * @see http://bit.ly/f6CnZU
	 */
	
	function MongooseArray (values, path, doc) {
	  var arr = [].concat(values);
	
	  utils.decorate( arr, MongooseArray.mixin );
	  arr.isMongooseArray = true;
	
	  arr._atomics = {};
	  arr.validators = [];
	  arr._path = path;
	
	  // Because doc comes from the context of another function, doc === global
	  // can happen if there was a null somewhere up the chain (see #3020)
	  if (doc && doc !== global) {
	    arr._parent = doc;
	    arr._schema = doc.schema.path(path);
	  }
	
	  return arr;
	}
	
	MongooseArray.mixin = {
	
	  /**
	   * Stores a queue of atomic operations to perform
	   *
	   * @property _atomics
	   * @api private
	   */
	
	  _atomics: undefined,
	
	  /**
	   * Parent owner document
	   *
	   * @property _parent
	   * @api private
	   * @receiver MongooseArray
	   */
	
	  _parent: undefined,
	
	  /**
	   * Casts a member based on this arrays schema.
	   *
	   * @param {any} value
	   * @return value the casted value
	   * @method _cast
	   * @api private
	   * @receiver MongooseArray
	   */
	
	  _cast: function (value) {
	    var owner = this._owner;
	    var populated = false;
	    var Model;
	
	    if (this._parent) {
	      // if a populated array, we must cast to the same model
	      // instance as specified in the original query.
	      if (!owner) {
	        owner = this._owner = this._parent.ownerDocument
	          ? this._parent.ownerDocument()
	          : this._parent;
	      }
	
	      populated = owner.populated(this._path, true);
	    }
	
	    if (populated && null != value) {
	      // cast to the populated Models schema
	      Model = populated.options.model;
	
	      // only objects are permitted so we can safely assume that
	      // non-objects are to be interpreted as _id
	      if (Buffer.isBuffer(value) ||
	          value instanceof ObjectId || !utils.isObject(value)) {
	        value = { _id: value };
	      }
	
	      // gh-2399
	      // we should cast model only when it's not a discriminator
	      var isDisc = value.schema && value.schema.discriminatorMapping &&
	        value.schema.discriminatorMapping.key !== undefined;
	      if (!isDisc) {
	        value = new Model(value);
	      }
	      return this._schema.caster.cast(value, this._parent, true)
	    }
	
	    return this._schema.caster.cast(value, this._parent, false)
	  },
	
	  /**
	   * Marks this array as modified.
	   *
	   * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)
	   *
	   * @param {EmbeddedDocument} embeddedDoc the embedded doc that invoked this method on the Array
	   * @param {String} embeddedPath the path which changed in the embeddedDoc
	   * @method _markModified
	   * @api private
	   * @receiver MongooseArray
	   */
	
	  _markModified: function (elem, embeddedPath) {
	    var parent = this._parent
	      , dirtyPath;
	
	    if (parent) {
	      dirtyPath = this._path;
	
	      if (arguments.length) {
	        if (null != embeddedPath) {
	          // an embedded doc bubbled up the change
	          dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;
	        } else {
	          // directly set an index
	          dirtyPath = dirtyPath + '.' + elem;
	        }
	      }
	      parent.markModified(dirtyPath);
	    }
	
	    return this;
	  },
	
	  /**
	   * Register an atomic operation with the parent.
	   *
	   * @param {Array} op operation
	   * @param {any} val
	   * @method _registerAtomic
	   * @api private
	   * @receiver MongooseArray
	   */
	
	  _registerAtomic: function (op, val) {
	    if ('$set' == op) {
	      // $set takes precedence over all other ops.
	      // mark entire array modified.
	      this._atomics = { $set: val };
	      return this;
	    }
	
	    var atomics = this._atomics;
	
	    // reset pop/shift after save
	    if ('$pop' == op && !('$pop' in atomics)) {
	      var self = this;
	      this._parent.once('save', function () {
	        self._popped = self._shifted = null;
	      });
	    }
	
	    // check for impossible $atomic combos (Mongo denies more than one
	    // $atomic op on a single path
	    if (this._atomics.$set ||
	        Object.keys(atomics).length && !(op in atomics)) {
	      // a different op was previously registered.
	      // save the entire thing.
	      this._atomics = { $set: this };
	      return this;
	    }
	
	    if (op === '$pullAll' || op === '$pushAll' || op === '$addToSet') {
	      atomics[op] || (atomics[op] = []);
	      atomics[op] = atomics[op].concat(val);
	    } else if (op === '$pullDocs') {
	      var pullOp = atomics['$pull'] || (atomics['$pull'] = {})
	        , selector = pullOp['_id'] || (pullOp['_id'] = {'$in' : [] });
	      selector['$in'] = selector['$in'].concat(val);
	    } else {
	      atomics[op] = val;
	    }
	
	    return this;
	  },
	
	  /**
	   * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.
	   *
	   * If no atomics exist, we return all array values after conversion.
	   *
	   * @return {Array}
	   * @method $__getAtomics
	   * @memberOf MongooseArray
	   * @api private
	   */
	
	  $__getAtomics: function () {
	    var ret = [];
	    var keys = Object.keys(this._atomics);
	    var i = keys.length;
	
	    if (0 === i) {
	      ret[0] = ['$set', this.toObject({ depopulate: 1, transform: false })];
	      return ret;
	    }
	
	    while (i--) {
	      var op = keys[i];
	      var val = this._atomics[op];
	
	      // the atomic values which are arrays are not MongooseArrays. we
	      // need to convert their elements as if they were MongooseArrays
	      // to handle populated arrays versus DocumentArrays properly.
	      if (isMongooseObject(val)) {
	        val = val.toObject({ depopulate: 1, transform: false });
	      } else if (Array.isArray(val)) {
	        val = this.toObject.call(val, { depopulate: 1, transform: false });
	      } else if (val.valueOf) {
	        val = val.valueOf();
	      }
	
	      if ('$addToSet' == op) {
	        val = { $each: val }
	      }
	
	      ret.push([op, val]);
	    }
	
	    return ret;
	  },
	
	  /**
	   * Returns the number of pending atomic operations to send to the db for this array.
	   *
	   * @api private
	   * @return {Number}
	   * @method hasAtomics
	   * @receiver MongooseArray
	   */
	
	  hasAtomics: function hasAtomics () {
	    if (!(this._atomics && 'Object' === this._atomics.constructor.name)) {
	      return 0;
	    }
	
	    return Object.keys(this._atomics).length;
	  },
	
	  /**
	   * Internal helper for .map()
	   *
	   * @api private
	   * @return {Number}
	   * @method _mapCast
	   * @receiver MongooseArray
	   */
	  _mapCast: function(val, index) {
	    return this._cast(val, this.length + index);
	  },
	
	  /**
	   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.
	   *
	   * @param {Object} [args...]
	   * @api public
	   * @method push
	   * @receiver MongooseArray
	   */
	
	  push: function () {
	    var values = [].map.call(arguments, this._mapCast, this);
	    var ret = [].push.apply(this, values);
	
	    // $pushAll might be fibbed (could be $push). But it makes it easier to
	    // handle what could have been $push, $pushAll combos
	    this._registerAtomic('$pushAll', values);
	    this._markModified();
	    return ret;
	  },
	
	  /**
	   * Pushes items to the array non-atomically.
	   *
	   * ####NOTE:
	   *
	   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @param {any} [args...]
	   * @api public
	   * @method nonAtomicPush
	   * @receiver MongooseArray
	   */
	
	  nonAtomicPush: function () {
	    var values = [].map.call(arguments, this._mapCast, this);
	    var ret = [].push.apply(this, values);
	    this._registerAtomic('$set', this);
	    this._markModified();
	    return ret;
	  },
	
	  /**
	   * Pops the array atomically at most one time per document `save()`.
	   *
	   * #### NOTE:
	   *
	   * _Calling this mulitple times on an array before saving sends the same command as calling it once._
	   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._
	   *
	   *      doc.array = [1,2,3];
	   *
	   *      var popped = doc.array.$pop();
	   *      console.log(popped); // 3
	   *      console.log(doc.array); // [1,2]
	   *
	   *      // no affect
	   *      popped = doc.array.$pop();
	   *      console.log(doc.array); // [1,2]
	   *
	   *      doc.save(function (err) {
	   *        if (err) return handleError(err);
	   *
	   *        // we saved, now $pop works again
	   *        popped = doc.array.$pop();
	   *        console.log(popped); // 2
	   *        console.log(doc.array); // [1]
	   *      })
	   *
	   * @api public
	   * @method $pop
	   * @memberOf MongooseArray
	   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop
	   * @method $pop
	   * @receiver MongooseArray
	   */
	
	  $pop: function () {
	    this._registerAtomic('$pop', 1);
	    this._markModified();
	
	    // only allow popping once
	    if (this._popped) return;
	    this._popped = true;
	
	    return [].pop.call(this);
	  },
	
	  /**
	   * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.
	   *
	   * ####Note:
	   *
	   * _marks the entire array as modified which will pass the entire thing to $set potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @see MongooseArray#$pop #types_array_MongooseArray-%24pop
	   * @api public
	   * @method pop
	   * @receiver MongooseArray
	   */
	
	  pop: function () {
	    var ret = [].pop.call(this);
	    this._registerAtomic('$set', this);
	    this._markModified();
	    return ret;
	  },
	
	  /**
	   * Atomically shifts the array at most one time per document `save()`.
	   *
	   * ####NOTE:
	   *
	   * _Calling this mulitple times on an array before saving sends the same command as calling it once._
	   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._
	   *
	   *      doc.array = [1,2,3];
	   *
	   *      var shifted = doc.array.$shift();
	   *      console.log(shifted); // 1
	   *      console.log(doc.array); // [2,3]
	   *
	   *      // no affect
	   *      shifted = doc.array.$shift();
	   *      console.log(doc.array); // [2,3]
	   *
	   *      doc.save(function (err) {
	   *        if (err) return handleError(err);
	   *
	   *        // we saved, now $shift works again
	   *        shifted = doc.array.$shift();
	   *        console.log(shifted ); // 2
	   *        console.log(doc.array); // [3]
	   *      })
	   *
	   * @api public
	   * @memberOf MongooseArray
	   * @method $shift
	   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop
	   */
	
	  $shift: function $shift () {
	    this._registerAtomic('$pop', -1);
	    this._markModified();
	
	    // only allow shifting once
	    if (this._shifted) return;
	    this._shifted = true;
	
	    return [].shift.call(this);
	  },
	
	  /**
	   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
	   *
	   * ####Example:
	   *
	   *     doc.array = [2,3];
	   *     var res = doc.array.shift();
	   *     console.log(res) // 2
	   *     console.log(doc.array) // [3]
	   *
	   * ####Note:
	   *
	   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @api public
	   * @method shift
	   * @receiver MongooseArray
	   */
	
	  shift: function () {
	    var ret = [].shift.call(this);
	    this._registerAtomic('$set', this);
	    this._markModified();
	    return ret;
	  },
	
	  /**
	   * Pulls items from the array atomically.
	   *
	   * ####Examples:
	   *
	   *     doc.array.pull(ObjectId)
	   *     doc.array.pull({ _id: 'someId' })
	   *     doc.array.pull(36)
	   *     doc.array.pull('tag 1', 'tag 2')
	   *
	   * To remove a document from a subdocument array we may pass an object with a matching `_id`.
	   *
	   *     doc.subdocs.push({ _id: 4815162342 })
	   *     doc.subdocs.pull({ _id: 4815162342 }) // removed
	   *
	   * Or we may passing the _id directly and let mongoose take care of it.
	   *
	   *     doc.subdocs.push({ _id: 4815162342 })
	   *     doc.subdocs.pull(4815162342); // works
	   *
	   * @param {any} [args...]
	   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull
	   * @api public
	   * @method pull
	   * @receiver MongooseArray
	   */
	
	  pull: function () {
	    var values = [].map.call(arguments, this._cast, this)
	      , cur = this._parent.get(this._path)
	      , i = cur.length
	      , mem;
	
	    while (i--) {
	      mem = cur[i];
	      if (mem instanceof EmbeddedDocument) {
	        if (values.some(function (v) { return v.equals(mem); } )) {
	          [].splice.call(cur, i, 1);
	        }
	      } else if (~cur.indexOf.call(values, mem)) {
	        [].splice.call(cur, i, 1);
	      }
	    }
	
	    if (values[0] instanceof EmbeddedDocument) {
	      this._registerAtomic('$pullDocs', values.map( function (v) { return v._id; } ));
	    } else {
	      this._registerAtomic('$pullAll', values);
	    }
	
	    this._markModified();
	    return this;
	  },
	
	  /**
	   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.
	   *
	   * ####Note:
	   *
	   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @api public
	   * @method splice
	   * @receiver MongooseArray
	   */
	
	  splice: function splice () {
	    var ret, vals, i;
	
	    if (arguments.length) {
	      vals = [];
	      for (i = 0; i < arguments.length; ++i) {
	        vals[i] = i < 2
	          ? arguments[i]
	          : this._cast(arguments[i], arguments[0] + (i - 2));
	      }
	      ret = [].splice.apply(this, vals);
	      this._registerAtomic('$set', this);
	      this._markModified();
	    }
	
	    return ret;
	  },
	
	  /**
	   * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
	   *
	   * ####Note:
	   *
	   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @api public
	   * @method unshift
	   * @receiver MongooseArray
	   */
	
	  unshift: function () {
	    var values = [].map.call(arguments, this._cast, this);
	    [].unshift.apply(this, values);
	    this._registerAtomic('$set', this);
	    this._markModified();
	    return this.length;
	  },
	
	  /**
	   * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.
	   *
	   * ####NOTE:
	   *
	   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @api public
	   * @method sort
	   * @receiver MongooseArray
	   */
	
	  sort: function () {
	    var ret = [].sort.apply(this, arguments);
	    this._registerAtomic('$set', this);
	    this._markModified();
	    return ret;
	  },
	
	  /**
	   * Adds values to the array if not already present.
	   *
	   * ####Example:
	   *
	   *     console.log(doc.array) // [2,3,4]
	   *     var added = doc.array.addToSet(4,5);
	   *     console.log(doc.array) // [2,3,4,5]
	   *     console.log(added)     // [5]
	   *
	   * @param {any} [args...]
	   * @return {Array} the values that were added
	   * @receiver MongooseArray
	   * @api public
	   * @method addToSet
	   */
	
	  addToSet: function addToSet () {
	    var values = [].map.call(arguments, this._mapCast, this);
	    var added = [];
	    var type = values[0] instanceof EmbeddedDocument ? 'doc' :
	               values[0] instanceof Date ? 'date' :
	               '';
	
	    values.forEach(function (v) {
	      var found;
	      switch (type) {
	        case 'doc':
	          found = this.some(function(doc){ return doc.equals(v) });
	          break;
	        case 'date':
	          var val = +v;
	          found = this.some(function(d){ return +d === val });
	          break;
	        default:
	          found = ~this.indexOf(v);
	      }
	
	      if (!found) {
	        [].push.call(this, v);
	        this._registerAtomic('$addToSet', v);
	        this._markModified();
	        [].push.call(added, v);
	      }
	    }, this);
	
	    return added;
	  },
	
	  /**
	   * Sets the casted `val` at index `i` and marks the array modified.
	   *
	   * ####Example:
	   *
	   *     // given documents based on the following
	   *     var Doc = mongoose.model('Doc', new Schema({ array: [Number] }));
	   *
	   *     var doc = new Doc({ array: [2,3,4] })
	   *
	   *     console.log(doc.array) // [2,3,4]
	   *
	   *     doc.array.set(1,"5");
	   *     console.log(doc.array); // [2,5,4] // properly cast to number
	   *     doc.save() // the change is saved
	   *
	   *     // VS not using array#set
	   *     doc.array[1] = "5";
	   *     console.log(doc.array); // [2,"5",4] // no casting
	   *     doc.save() // change is not saved
	   *
	   * @return {Array} this
	   * @api public
	   * @method set
	   * @receiver MongooseArray
	   */
	
	  set: function set (i, val) {
	    this[i] = this._cast(val, i);
	    this._markModified(i);
	    return this;
	  },
	
	  /**
	   * Returns a native js Array.
	   *
	   * @param {Object} options
	   * @return {Array}
	   * @api public
	   * @method toObject
	   * @receiver MongooseArray
	   */
	
	  toObject: function (options) {
	    if (options && options.depopulate) {
	      return this.map(function (doc) {
	        return doc instanceof Document
	          ? doc.toObject(options)
	          : doc
	      });
	    }
	
	    return this.slice();
	  },
	
	  /**
	   * Helper for console.log
	   *
	   * @api public
	   * @method inspect
	   * @receiver MongooseArray
	   */
	
	  inspect: function () {
	    return JSON.stringify(this);
	  },
	
	  /**
	   * Return the index of `obj` or `-1` if not found.
	   *
	   * @param {Object} obj the item to look for
	   * @return {Number}
	   * @api public
	   * @method indexOf
	   * @receiver MongooseArray
	   */
	
	  indexOf: function indexOf (obj) {
	    if (obj instanceof ObjectId) obj = obj.toString();
	    for (var i = 0, len = this.length; i < len; ++i) {
	      if (obj == this[i])
	        return i;
	    }
	    return -1;
	  }
	};
	
	/**
	 * Alias of [pull](#types_array_MongooseArray-pull)
	 *
	 * @see MongooseArray#pull #types_array_MongooseArray-pull
	 * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull
	 * @api public
	 * @memberOf MongooseArray
	 * @method remove
	 */
	
	MongooseArray.mixin.remove = MongooseArray.mixin.pull;
	
	/*!
	 * Module exports.
	 */
	
	module.exports = exports = MongooseArray;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 189 */
/*!***********************************************!*\
  !*** ./~/mongoose/lib/types/documentarray.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * Module dependencies.
	 */
	
	var MongooseArray = __webpack_require__(/*! ./array */ 188)
	  , ObjectId = __webpack_require__(/*! ./objectid */ 45)
	  , ObjectIdSchema = __webpack_require__(/*! ../schema/objectid */ 190)
	  , utils = __webpack_require__(/*! ../utils */ 42)
	  , util = __webpack_require__(/*! util */ 57)
	  , Document = __webpack_require__(/*! ../document */ 178)
	
	/**
	 * DocumentArray constructor
	 *
	 * @param {Array} values
	 * @param {String} path the path to this array
	 * @param {Document} doc parent document
	 * @api private
	 * @return {MongooseDocumentArray}
	 * @inherits MongooseArray
	 * @see http://bit.ly/f6CnZU
	 */
	
	function MongooseDocumentArray (values, path, doc) {
	  var arr = [].concat(values);
	
	  // Values always have to be passed to the constructor to initialize, since
	  // otherwise MongooseArray#push will mark the array as modified to the parent.
	  utils.decorate( arr, MongooseDocumentArray.mixin );
	  arr.isMongooseArray = true;
	  arr.isMongooseDocumentArray = true;
	
	  arr._atomics = {};
	  arr.validators = [];
	  arr._path = path;
	
	  if (doc) {
	    arr._parent = doc;
	    arr._schema = doc.schema.path(path);
	    arr._handlers = {
	      isNew: arr.notify('isNew'),
	      save: arr.notify('save')
	    };
	
	    doc.on('save', arr._handlers.save);
	    doc.on('isNew', arr._handlers.isNew);
	  }
	
	  return arr;
	}
	
	/*!
	 * Inherits from MongooseArray
	 */
	MongooseDocumentArray.mixin = Object.create( MongooseArray.mixin );
	
	/**
	 * Overrides MongooseArray#cast
	 *
	 * @method _cast
	 * @api private
	 * @receiver MongooseDocumentArray
	 */
	
	MongooseDocumentArray.mixin._cast = function (value, index) {
	  if (value instanceof this._schema.casterConstructor) {
	    if (!(value.__parent && value.__parentArray)) {
	      // value may have been created using array.create()
	      value.__parent = this._parent;
	      value.__parentArray = this;
	    }
	    value.__index = index;
	    return value;
	  }
	
	  // handle cast('string') or cast(ObjectId) etc.
	  // only objects are permitted so we can safely assume that
	  // non-objects are to be interpreted as _id
	  if (Buffer.isBuffer(value) ||
	      value instanceof ObjectId || !utils.isObject(value)) {
	    value = { _id: value };
	  }
	  return new this._schema.casterConstructor(value, this, undefined, undefined, index);
	};
	
	/**
	 * Searches array items for the first document with a matching _id.
	 *
	 * ####Example:
	 *
	 *     var embeddedDoc = m.array.id(some_id);
	 *
	 * @return {EmbeddedDocument|null} the subdocument or null if not found.
	 * @param {ObjectId|String|Number|Buffer} id
	 * @TODO cast to the _id based on schema for proper comparison
	 * @method id
	 * @api public
	 * @receiver MongooseDocumentArray
	 */
	
	MongooseDocumentArray.mixin.id = function (id) {
	  var casted
	    , sid
	    , _id
	
	  try {
	    var casted_ = ObjectIdSchema.prototype.cast.call({}, id);
	    if (casted_) casted = String(casted_);
	  } catch (e) {
	    casted = null;
	  }
	
	  for (var i = 0, l = this.length; i < l; i++) {
	    _id = this[i].get('_id');
	
	    if (_id instanceof Document) {
	      sid || (sid = String(id));
	      if (sid == _id._id) return this[i];
	    } else if (!(_id instanceof ObjectId)) {
	      sid || (sid = String(id));
	      if (sid == _id) return this[i];
	    } else if (casted == _id) {
	      return this[i];
	    }
	  }
	
	  return null;
	};
	
	/**
	 * Returns a native js Array of plain js objects
	 *
	 * ####NOTE:
	 *
	 * _Each sub-document is converted to a plain object by calling its `#toObject` method._
	 *
	 * @param {Object} [options] optional options to pass to each documents `toObject` method call during conversion
	 * @return {Array}
	 * @method toObject
	 * @api public
	 * @receiver MongooseDocumentArray
	 */
	
	MongooseDocumentArray.mixin.toObject = function (options) {
	  return this.map(function (doc) {
	    return doc && doc.toObject(options) || null;
	  });
	};
	
	/**
	 * Helper for console.log
	 *
	 * @method inspect
	 * @api public
	 * @receiver MongooseDocumentArray
	 */
	
	MongooseDocumentArray.mixin.inspect = function () {
	  return '[' + Array.prototype.map.call(this, function (doc) {
	    if (doc) {
	      return doc.inspect
	        ? doc.inspect()
	        : util.inspect(doc)
	    }
	    return 'null'
	  }).join('\n') + ']';
	};
	
	/**
	 * Creates a subdocument casted to this schema.
	 *
	 * This is the same subdocument constructor used for casting.
	 *
	 * @param {Object} obj the value to cast to this arrays SubDocument schema
	 * @method create
	 * @api public
	 * @receiver MongooseDocumentArray
	 */
	
	MongooseDocumentArray.mixin.create = function (obj) {
	  return new this._schema.casterConstructor(obj);
	}
	
	/**
	 * Creates a fn that notifies all child docs of `event`.
	 *
	 * @param {String} event
	 * @return {Function}
	 * @method notify
	 * @api private
	 * @receiver MongooseDocumentArray
	 */
	
	MongooseDocumentArray.mixin.notify = function notify (event) {
	  var self = this;
	  return function notify (val) {
	    var i = self.length;
	    while (i--) {
	      if (!self[i]) continue;
	      switch(event) {
	        // only swap for save event for now, we may change this to all event types later
	        case 'save':
	          val = self[i];
	          break;
	        default:
	          // NO-OP
	          break;
	      }
	      self[i].emit(event, val);
	    }
	  }
	}
	
	/*!
	 * Module exports.
	 */
	
	module.exports = MongooseDocumentArray;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 190 */
/*!*******************************************!*\
  !*** ./~/mongoose/lib/schema/objectid.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * Module dependencies.
	 */
	
	var SchemaType = __webpack_require__(/*! ../schematype */ 177)
	  , CastError = SchemaType.CastError
	  , oid = __webpack_require__(/*! ../types/objectid */ 45)
	  , utils = __webpack_require__(/*! ../utils */ 42)
	  , Document
	
	/**
	 * ObjectId SchemaType constructor.
	 *
	 * @param {String} key
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api private
	 */
	
	function ObjectId (key, options) {
	  SchemaType.call(this, key, options, 'ObjectID');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api private
	 */
	ObjectId.schemaName = 'ObjectId';
	
	/*!
	 * Inherits from SchemaType.
	 */
	ObjectId.prototype = Object.create( SchemaType.prototype );
	ObjectId.prototype.constructor = ObjectId;
	
	/**
	 * Adds an auto-generated ObjectId default if turnOn is true.
	 * @param {Boolean} turnOn auto generated ObjectId defaults
	 * @api public
	 * @return {SchemaType} this
	 */
	
	ObjectId.prototype.auto = function (turnOn) {
	  if (turnOn) {
	    this.default(defaultId);
	    this.set(resetId)
	  }
	
	  return this;
	};
	
	/**
	 * Check required
	 *
	 * @api private
	 */
	
	ObjectId.prototype.checkRequired = function checkRequired (value, doc) {
	  if (SchemaType._isRef(this, value, doc, true)) {
	    return null != value;
	  } else {
	    return value instanceof oid;
	  }
	};
	
	/**
	 * Casts to ObjectId
	 *
	 * @param {Object} value
	 * @param {Object} doc
	 * @param {Boolean} init whether this is an initialization cast
	 * @api private
	 */
	
	ObjectId.prototype.cast = function (value, doc, init) {
	  if (SchemaType._isRef(this, value, doc, init)) {
	    // wait! we may need to cast this to a document
	
	    if (null == value) {
	      return value;
	    }
	
	    // lazy load
	    Document || (Document = __webpack_require__(/*! ./../document */ 178));
	
	    if (value instanceof Document) {
	      value.$__.wasPopulated = true;
	      return value;
	    }
	
	    // setting a populated path
	    if (value instanceof oid) {
	      return value;
	    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {
	      throw new CastError('ObjectId', value, this.path);
	    }
	
	    // Handle the case where user directly sets a populated
	    // path to a plain object; cast to the Model used in
	    // the population query.
	    var path = doc.$__fullPath(this.path);
	    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;
	    var pop = owner.populated(path, true);
	    var ret = new pop.options.model(value);
	    ret.$__.wasPopulated = true;
	    return ret;
	  }
	
	  // If null or undefined
	  if (value == null) return value;
	
	  if (value instanceof oid)
	    return value;
	
	  if (value._id) {
	    if (value._id instanceof oid) {
	      return value._id;
	    }
	    if (value._id.toString instanceof Function) {
	      try {
	        return oid.createFromHexString(value._id.toString());
	      } catch(e) {}
	    }
	  }
	
	  if (value.toString instanceof Function) {
	    try {
	      return oid.createFromHexString(value.toString());
	    } catch (err) {
	      throw new CastError('ObjectId', value, this.path);
	    }
	  }
	
	  throw new CastError('ObjectId', value, this.path);
	};
	
	/*!
	 * ignore
	 */
	
	function handleSingle (val) {
	  return this.cast(val);
	}
	
	function handleArray (val) {
	  var self = this;
	  return val.map(function (m) {
	    return self.cast(m);
	  });
	}
	
	ObjectId.prototype.$conditionalHandlers =
	  utils.options(SchemaType.prototype.$conditionalHandlers, {
	    '$all': handleArray,
	    '$gt': handleSingle,
	    '$gte': handleSingle,
	    '$in': handleArray,
	    '$lt': handleSingle,
	    '$lte': handleSingle,
	    '$ne': handleSingle,
	    '$nin': handleArray
	  });
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [val]
	 * @api private
	 */
	
	ObjectId.prototype.castForQuery = function ($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	    if (!handler)
	      throw new Error("Can't use " + $conditional + " with ObjectId.");
	    return handler.call(this, val);
	  } else {
	    return this.cast($conditional);
	  }
	};
	
	/*!
	 * ignore
	 */
	
	function defaultId () {
	  return new oid();
	};
	
	function resetId (v) {
	  this.$__._id = null;
	  return v;
	}
	
	/*!
	 * Module exports.
	 */
	
	module.exports = ObjectId;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 191 */
/*!*****************************************!*\
  !*** ./~/mongoose/lib/schema/number.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * Module requirements.
	 */
	
	var SchemaType = __webpack_require__(/*! ../schematype */ 177)
	  , CastError = SchemaType.CastError
	  , errorMessages = __webpack_require__(/*! ../error */ 32).messages
	  , utils = __webpack_require__(/*! ../utils */ 42)
	  , Document
	
	/**
	 * Number SchemaType constructor.
	 *
	 * @param {String} key
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api private
	 */
	
	function SchemaNumber (key, options) {
	  SchemaType.call(this, key, options, 'Number');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api private
	 */
	SchemaNumber.schemaName = 'Number';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaNumber.prototype = Object.create( SchemaType.prototype );
	SchemaNumber.prototype.constructor = SchemaNumber;
	
	/**
	 * Required validator for number
	 *
	 * @api private
	 */
	
	SchemaNumber.prototype.checkRequired = function checkRequired (value, doc) {
	  if (SchemaType._isRef(this, value, doc, true)) {
	    return null != value;
	  } else {
	    return typeof value == 'number' || value instanceof Number;
	  }
	};
	
	/**
	 * Sets a minimum number validator.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ n: { type: Number, min: 10 })
	 *     var M = db.model('M', s)
	 *     var m = new M({ n: 9 })
	 *     m.save(function (err) {
	 *       console.error(err) // validator error
	 *       m.n = 10;
	 *       m.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MIN} token which will be replaced with the invalid value
	 *     var min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];
	 *     var schema = new Schema({ n: { type: Number, min: min })
	 *     var M = mongoose.model('Measurement', schema);
	 *     var s= new M({ n: 4 });
	 *     s.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).
	 *     })
	 *
	 * @param {Number} value minimum number
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaNumber.prototype.min = function (value, message) {
	  if (this.minValidator) {
	    this.validators = this.validators.filter(function (v) {
	      return v.validator != this.minValidator;
	    }, this);
	  }
	
	  if (null != value) {
	    var msg = message || errorMessages.Number.min;
	    msg = msg.replace(/{MIN}/, value);
	    this.validators.push({
	      validator: this.minValidator = function (v) {
	        return v === null || v >= value;
	      },
	      message: msg,
	      type: 'min'
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Sets a maximum number validator.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ n: { type: Number, max: 10 })
	 *     var M = db.model('M', s)
	 *     var m = new M({ n: 11 })
	 *     m.save(function (err) {
	 *       console.error(err) // validator error
	 *       m.n = 10;
	 *       m.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MAX} token which will be replaced with the invalid value
	 *     var max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];
	 *     var schema = new Schema({ n: { type: Number, max: max })
	 *     var M = mongoose.model('Measurement', schema);
	 *     var s= new M({ n: 4 });
	 *     s.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).
	 *     })
	 *
	 * @param {Number} maximum number
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaNumber.prototype.max = function (value, message) {
	  if (this.maxValidator) {
	    this.validators = this.validators.filter(function(v){
	      return v.validator != this.maxValidator;
	    }, this);
	  }
	
	  if (null != value) {
	    var msg = message || errorMessages.Number.max;
	    msg = msg.replace(/{MAX}/, value);
	    this.validators.push({
	      validator: this.maxValidator = function(v) {
	        return v === null || v <= value;
	      },
	      message: msg,
	      type: 'max'
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Casts to number
	 *
	 * @param {Object} value value to cast
	 * @param {Document} doc document that triggers the casting
	 * @param {Boolean} init
	 * @api private
	 */
	
	SchemaNumber.prototype.cast = function (value, doc, init) {
	  if (SchemaType._isRef(this, value, doc, init)) {
	    // wait! we may need to cast this to a document
	
	    if (null == value) {
	      return value;
	    }
	
	    // lazy load
	    Document || (Document = __webpack_require__(/*! ./../document */ 178));
	
	    if (value instanceof Document) {
	      value.$__.wasPopulated = true;
	      return value;
	    }
	
	    // setting a populated path
	    if ('number' == typeof value) {
	      return value;
	    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {
	      throw new CastError('number', value, this.path);
	    }
	
	    // Handle the case where user directly sets a populated
	    // path to a plain object; cast to the Model used in
	    // the population query.
	    var path = doc.$__fullPath(this.path);
	    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;
	    var pop = owner.populated(path, true);
	    var ret = new pop.options.model(value);
	    ret.$__.wasPopulated = true;
	    return ret;
	  }
	
	  var val = value && value._id
	    ? value._id // documents
	    : value;
	
	  if (!isNaN(val)){
	    if (null === val) return val;
	    if ('' === val) return null;
	    if ('string' == typeof val) val = Number(val);
	    if (val instanceof Number) return val
	    if ('number' == typeof val) return val;
	    if (val.toString && !Array.isArray(val) &&
	        val.toString() == Number(val)) {
	      return new Number(val)
	    }
	  }
	
	  throw new CastError('number', value, this.path);
	};
	
	/*!
	 * ignore
	 */
	
	function handleSingle (val) {
	  return this.cast(val)
	}
	
	function handleArray (val) {
	  var self = this;
	  return val.map(function (m) {
	    return self.cast(m)
	  });
	}
	
	SchemaNumber.prototype.$conditionalHandlers =
	  utils.options(SchemaType.prototype.$conditionalHandlers, {
	    '$all': handleArray,
	    '$gt' : handleSingle,
	    '$gte': handleSingle,
	    '$in' : handleArray,
	    '$lt' : handleSingle,
	    '$lte': handleSingle,
	    '$ne' : handleSingle,
	    '$mod': handleArray,
	    '$nin': handleArray
	  });
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [value]
	 * @api private
	 */
	
	SchemaNumber.prototype.castForQuery = function ($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	    if (!handler)
	      throw new Error("Can't use " + $conditional + " with Number.");
	    return handler.call(this, val);
	  } else {
	    val = this.cast($conditional);
	    return val == null ? val : val
	  }
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaNumber;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 192 */
/*!******************************************!*\
  !*** ./~/mongoose/lib/schema/boolean.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var utils = __webpack_require__(/*! ../utils */ 42);
	
	var SchemaType = __webpack_require__(/*! ../schematype */ 177);
	var utils = __webpack_require__(/*! ../utils */ 42);
	
	/**
	 * Boolean SchemaType constructor.
	 *
	 * @param {String} path
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api private
	 */
	
	function SchemaBoolean (path, options) {
	  SchemaType.call(this, path, options, 'Boolean');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api private
	 */
	SchemaBoolean.schemaName = 'Boolean';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaBoolean.prototype = Object.create( SchemaType.prototype );
	SchemaBoolean.prototype.constructor = SchemaBoolean;
	
	/**
	 * Required validator
	 *
	 * @api private
	 */
	
	SchemaBoolean.prototype.checkRequired = function (value) {
	  return value === true || value === false;
	};
	
	/**
	 * Casts to boolean
	 *
	 * @param {Object} value
	 * @api private
	 */
	
	SchemaBoolean.prototype.cast = function (value) {
	  if (null === value) return value;
	  if ('0' === value) return false;
	  if ('true' === value) return true;
	  if ('false' === value) return false;
	  return !! value;
	}
	
	/*!
	 * ignore
	 */
	
	function handleArray (val) {
	  var self = this;
	  return val.map(function (m) {
	    return self.cast(m);
	  });
	}
	
	SchemaBoolean.$conditionalHandlers =
	  utils.options(SchemaType.prototype.$conditionalHandlers, {
	    '$in': handleArray
	  });
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} val
	 * @api private
	 */
	
	SchemaBoolean.prototype.castForQuery = function ($conditional, val) {
	  var handler;
	  if (2 === arguments.length) {
	    handler = SchemaBoolean.$conditionalHandlers[$conditional];
	
	    if (handler) {
	      return handler.call(this, val);
	    }
	
	    return this.cast(val);
	  }
	
	  return this.cast($conditional);
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaBoolean;


/***/ },
/* 193 */
/*!************************************************!*\
  !*** ./~/mongoose/lib/schema/documentarray.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var ArrayType = __webpack_require__(/*! ./array */ 194);
	var Document = __webpack_require__(/*! ../document */ 178);
	var MongooseDocumentArray = __webpack_require__(/*! ../types/documentarray */ 189);
	var SchemaType = __webpack_require__(/*! ../schematype */ 177);
	var Subdocument = __webpack_require__(/*! ../types/embedded */ 185);
	
	/**
	 * SubdocsArray SchemaType constructor
	 *
	 * @param {String} key
	 * @param {Schema} schema
	 * @param {Object} options
	 * @inherits SchemaArray
	 * @api private
	 */
	
	function DocumentArray (key, schema, options) {
	
	  // compile an embedded document for this schema
	  function EmbeddedDocument () {
	    Subdocument.apply(this, arguments);
	  }
	
	  EmbeddedDocument.prototype = Object.create(Subdocument.prototype);
	  EmbeddedDocument.prototype.$__setSchema(schema);
	  EmbeddedDocument.schema = schema;
	
	  // apply methods
	  for (var i in schema.methods)
	    EmbeddedDocument.prototype[i] = schema.methods[i];
	
	  // apply statics
	  for (var i in schema.statics)
	    EmbeddedDocument[i] = schema.statics[i];
	
	  EmbeddedDocument.options = options;
	  this.schema = schema;
	
	  ArrayType.call(this, key, EmbeddedDocument, options);
	
	  this.schema = schema;
	  var path = this.path;
	  var fn = this.defaultValue;
	
	  this.default(function(){
	    var arr = fn.call(this);
	    if (!Array.isArray(arr)) arr = [arr];
	    return new MongooseDocumentArray(arr, path, this);
	  });
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api private
	 */
	DocumentArray.schemaName = 'DocumentArray';
	
	/*!
	 * Inherits from ArrayType.
	 */
	DocumentArray.prototype = Object.create( ArrayType.prototype );
	DocumentArray.prototype.constructor = DocumentArray;
	
	/**
	 * Performs local validations first, then validations on each embedded doc
	 *
	 * @api private
	 */
	
	DocumentArray.prototype.doValidate = function (array, fn, scope) {
	  SchemaType.prototype.doValidate.call(this, array, function (err) {
	    if (err) {
	      return fn(err);
	    }
	
	    var count = array && array.length;
	    var error;
	
	    if (!count) return fn();
	
	    // handle sparse arrays, do not use array.forEach which does not
	    // iterate over sparse elements yet reports array.length including
	    // them :(
	
	    for (var i = 0, len = count; i < len; ++i) {
	      // sidestep sparse entries
	      var doc = array[i];
	      if (!doc) {
	        --count || fn(error);
	        continue;
	      }
	
	      doc.validate(function (err) {
	        if (err) {
	          error = err;
	        }
	        --count || fn(error);
	      });
	    }
	  }, scope);
	};
	
	/**
	 * Performs local validations first, then validations on each embedded doc.
	 *
	 * ####Note:
	 *
	 * This method ignores the asynchronous validators.
	 *
	 * @return {MongooseError|undefined}
	 * @api private
	 */
	
	DocumentArray.prototype.doValidateSync = function (array, scope) {
	  var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);
	  if (schemaTypeError) return schemaTypeError;
	
	  var count = array && array.length
	    , resultError = null;
	
	  if (!count) return;
	
	  // handle sparse arrays, do not use array.forEach which does not
	  // iterate over sparse elements yet reports array.length including
	  // them :(
	
	  for (var i = 0, len = count; i < len; ++i) {
	    // only first error
	    if ( resultError ) break;
	    // sidestep sparse entries
	    var doc = array[i];
	    if (!doc) continue;
	
	    var subdocValidateError = doc.validateSync();
	
	    if (subdocValidateError) {
	      resultError = subdocValidateError;
	    }
	  }
	
	  return resultError;
	};
	
	/**
	 * Casts contents
	 *
	 * @param {Object} value
	 * @param {Document} document that triggers the casting
	 * @api private
	 */
	
	DocumentArray.prototype.cast = function (value, doc, init, prev) {
	  var selected
	    , subdoc
	    , i
	
	  if (!Array.isArray(value)) {
	    // gh-2442 mark whole array as modified if we're initializing a doc from
	    // the db and the path isn't an array in the document
	    if (!!doc && init) {
	      doc.markModified(this.path);
	    }
	    return this.cast([value], doc, init, prev);
	  }
	
	  if (!(value && value.isMongooseDocumentArray)) {
	    value = new MongooseDocumentArray(value, this.path, doc);
	    if (prev && prev._handlers) {
	      for (var key in prev._handlers) {
	        doc.removeListener(key, prev._handlers[key]);
	      }
	    }
	  }
	
	  i = value.length;
	
	  while (i--) {
	    if (!(value[i] instanceof Subdocument) && value[i]) {
	      if (init) {
	        selected || (selected = scopePaths(this, doc.$__.selected, init));
	        subdoc = new this.casterConstructor(null, value, true, selected, i);
	        value[i] = subdoc.init(value[i]);
	      } else {
	        try {
	          subdoc = prev.id(value[i]._id);
	        } catch(e) {}
	
	        if (prev && subdoc) {
	          // handle resetting doc with existing id but differing data
	          // doc.array = [{ doc: 'val' }]
	          subdoc.set(value[i]);
	          // if set() is hooked it will have no return value
	          // see gh-746
	          value[i] = subdoc;
	        } else {
	          subdoc = new this.casterConstructor(value[i], value, undefined, undefined, i);
	          // if set() is hooked it will have no return value
	          // see gh-746
	          value[i] = subdoc;
	        }
	      }
	    }
	  }
	
	  return value;
	}
	
	/*!
	 * Scopes paths selected in a query to this array.
	 * Necessary for proper default application of subdocument values.
	 *
	 * @param {DocumentArray} array - the array to scope `fields` paths
	 * @param {Object|undefined} fields - the root fields selected in the query
	 * @param {Boolean|undefined} init - if we are being created part of a query result
	 */
	
	function scopePaths (array, fields, init) {
	  if (!(init && fields)) return undefined;
	
	  var path = array.path + '.'
	    , keys = Object.keys(fields)
	    , i = keys.length
	    , selected = {}
	    , hasKeys
	    , key
	
	  while (i--) {
	    key = keys[i];
	    if (0 === key.indexOf(path)) {
	      hasKeys || (hasKeys = true);
	      selected[key.substring(path.length)] = fields[key];
	    }
	  }
	
	  return hasKeys && selected || undefined;
	}
	
	/*!
	 * Module exports.
	 */
	
	module.exports = DocumentArray;


/***/ },
/* 194 */
/*!****************************************!*\
  !*** ./~/mongoose/lib/schema/array.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var SchemaType = __webpack_require__(/*! ../schematype */ 177)
	  , CastError = SchemaType.CastError
	  , NumberSchema = __webpack_require__(/*! ./number */ 191)
	  , Types = {
	        Boolean: __webpack_require__(/*! ./boolean */ 192)
	      , Date: __webpack_require__(/*! ./date */ 195)
	      , Number: __webpack_require__(/*! ./number */ 191)
	      , String: __webpack_require__(/*! ./string */ 176)
	      , ObjectId: __webpack_require__(/*! ./objectid */ 190)
	      , Buffer: __webpack_require__(/*! ./buffer */ 196)
	    }
	  , MongooseArray = __webpack_require__(/*! ../types */ 197).Array
	  , EmbeddedDoc = __webpack_require__(/*! ../types */ 197).Embedded
	  , Mixed = __webpack_require__(/*! ./mixed */ 180)
	  , cast = __webpack_require__(/*! ../cast */ 199)
	  , utils = __webpack_require__(/*! ../utils */ 42)
	  , isMongooseObject = utils.isMongooseObject
	
	/**
	 * Array SchemaType constructor
	 *
	 * @param {String} key
	 * @param {SchemaType} cast
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api private
	 */
	
	function SchemaArray (key, cast, options) {
	  if (cast) {
	    var castOptions = {};
	
	    if ('Object' === utils.getFunctionName(cast.constructor)) {
	      if (cast.type) {
	        // support { type: Woot }
	        castOptions = utils.clone(cast); // do not alter user arguments
	        delete castOptions.type;
	        cast = cast.type;
	      } else {
	        cast = Mixed;
	      }
	    }
	
	    // support { type: 'String' }
	    var name = 'string' == typeof cast
	      ? cast
	      : utils.getFunctionName(cast);
	
	    var caster = name in Types
	      ? Types[name]
	      : cast;
	
	    this.casterConstructor = caster;
	    this.caster = new caster(null, castOptions);
	    if (!(this.caster instanceof EmbeddedDoc)) {
	      this.caster.path = key;
	    }
	  }
	
	  SchemaType.call(this, key, options, 'Array');
	
	  var self = this
	    , defaultArr
	    , fn;
	
	  if (this.defaultValue) {
	    defaultArr = this.defaultValue;
	    fn = 'function' == typeof defaultArr;
	  }
	
	  this.default(function(){
	    var arr = fn ? defaultArr() : defaultArr || [];
	    return new MongooseArray(arr, self.path, this);
	  });
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api private
	 */
	SchemaArray.schemaName = 'Array';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaArray.prototype = Object.create( SchemaType.prototype );
	SchemaArray.prototype.constructor = SchemaArray;
	
	/**
	 * Check required
	 *
	 * @param {Array} value
	 * @api private
	 */
	
	SchemaArray.prototype.checkRequired = function (value) {
	  return !!(value && value.length);
	};
	
	/**
	 * Overrides the getters application for the population special-case
	 *
	 * @param {Object} value
	 * @param {Object} scope
	 * @api private
	 */
	
	SchemaArray.prototype.applyGetters = function (value, scope) {
	  if (this.caster.options && this.caster.options.ref) {
	    // means the object id was populated
	    return value;
	  }
	
	  return SchemaType.prototype.applyGetters.call(this, value, scope);
	};
	
	/**
	 * Casts values for set().
	 *
	 * @param {Object} value
	 * @param {Document} doc document that triggers the casting
	 * @param {Boolean} init whether this is an initialization cast
	 * @api private
	 */
	
	SchemaArray.prototype.cast = function (value, doc, init) {
	  if (Array.isArray(value)) {
	
	    if (!value.length && doc) {
	      var indexes = doc.schema.indexedPaths();
	
	      for (var i = 0, l = indexes.length; i < l; ++i) {
	        var pathIndex = indexes[i][0][this.path];
	        if ('2dsphere' === pathIndex || '2d' === pathIndex) {
	          return;
	        }
	      }
	    }
	
	    if (!(value && value.isMongooseArray)) {
	      value = new MongooseArray(value, this.path, doc);
	    }
	
	    if (this.caster) {
	      try {
	        for (var i = 0, l = value.length; i < l; i++) {
	          value[i] = this.caster.cast(value[i], doc, init);
	        }
	      } catch (e) {
	        // rethrow
	        throw new CastError(e.type, value, this.path);
	      }
	    }
	
	    return value;
	  } else {
	    // gh-2442: if we're loading this from the db and its not an array, mark
	    // the whole array as modified.
	    if (!!doc && !!init) {
	      doc.markModified(this.path);
	    }
	    return this.cast([value], doc, init);
	  }
	};
	
	/**
	 * Casts values for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [value]
	 * @api private
	 */
	
	SchemaArray.prototype.castForQuery = function ($conditional, value) {
	  var handler
	    , val;
	
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	
	    if (!handler) {
	      throw new Error("Can't use " + $conditional + " with Array.");
	    }
	
	    val = handler.call(this, value);
	
	  } else {
	
	    val = $conditional;
	    var proto = this.casterConstructor.prototype;
	    var method = proto.castForQuery || proto.cast;
	    var caster = this.caster;
	
	    if (Array.isArray(val)) {
	      val = val.map(function (v) {
	        if (method) v = method.call(caster, v);
	        return isMongooseObject(v) ?
	          v.toObject({ virtuals: false }) :
	          v;
	      });
	
	    } else if (method) {
	      val = method.call(caster, val);
	    }
	  }
	
	  return val && isMongooseObject(val) ?
	    val.toObject({ virtuals: false }) :
	    val;
	};
	
	/*!
	 * @ignore
	 *
	 * $atomic cast helpers
	 */
	
	function castToNumber (val) {
	  return Types.Number.prototype.cast.call(this, val);
	}
	
	function castArraysOfNumbers (arr, self) {
	  self || (self = this);
	
	  arr.forEach(function (v, i) {
	    if (Array.isArray(v)) {
	      castArraysOfNumbers(v, self);
	    } else {
	      arr[i] = castToNumber.call(self, v);
	    }
	  });
	}
	
	function cast$near (val) {
	  if (Array.isArray(val)) {
	    castArraysOfNumbers(val, this);
	    return val;
	  }
	
	  if (val && val.$geometry) {
	    return cast$geometry(val, this);
	  }
	
	  return SchemaArray.prototype.castForQuery.call(this, val);
	}
	
	function cast$geometry (val, self) {
	  switch (val.$geometry.type) {
	    case 'Polygon':
	    case 'LineString':
	    case 'Point':
	      castArraysOfNumbers(val.$geometry.coordinates, self);
	      break;
	    default:
	      // ignore unknowns
	      break;
	  }
	
	  if (val.$maxDistance) {
	    val.$maxDistance = castToNumber.call(self, val.$maxDistance);
	  }
	
	  return val;
	}
	
	function cast$within (val) {
	  var self = this;
	
	  if (val.$maxDistance) {
	    val.$maxDistance = castToNumber.call(self, val.$maxDistance);
	  }
	
	  if (val.$box || val.$polygon) {
	    var type = val.$box ? '$box' : '$polygon';
	    val[type].forEach(function (arr) {
	      if (!Array.isArray(arr)) {
	        var msg = 'Invalid $within $box argument. '
	                + 'Expected an array, received ' + arr;
	        throw new TypeError(msg);
	      }
	      arr.forEach(function (v, i) {
	        arr[i] = castToNumber.call(this, v);
	      });
	    })
	  } else if (val.$center || val.$centerSphere) {
	    var type = val.$center ? '$center' : '$centerSphere';
	    val[type].forEach(function (item, i) {
	      if (Array.isArray(item)) {
	        item.forEach(function (v, j) {
	          item[j] = castToNumber.call(this, v);
	        });
	      } else {
	        val[type][i] = castToNumber.call(this, item);
	      }
	    })
	  } else if (val.$geometry) {
	    cast$geometry(val, this);
	  }
	
	  return val;
	}
	
	function cast$all (val) {
	  if (!Array.isArray(val)) {
	    val = [val];
	  }
	
	  val = val.map(function (v) {
	    if (utils.isObject(v)) {
	      var o = {};
	      o[this.path] = v;
	      return cast(this.casterConstructor.schema, o)[this.path];
	    }
	    return v;
	  }, this);
	
	  return this.castForQuery(val);
	}
	
	function cast$elemMatch (val) {
	  var hasDollarKey = false;
	  var keys = Object.keys(val);
	  var numKeys = keys.length;
	  var key;
	  var value;
	  for (var i = 0; i < numKeys; ++i) {
	    var key = keys[i];
	    var value = val[key];
	    if (key.indexOf('$') === 0 && value) {
	      val[key] = this.castForQuery(key, value);
	      hasDollarKey = true;
	    }
	  }
	  if (hasDollarKey) {
	    return val;
	  }
	
	  return cast(this.casterConstructor.schema, val);
	}
	
	function cast$geoIntersects (val) {
	  var geo = val.$geometry;
	  if (!geo) return;
	
	  cast$geometry(val, this);
	  return val;
	}
	
	var handle = SchemaArray.prototype.$conditionalHandlers = {};
	
	handle.$all = cast$all;
	handle.$options = String;
	handle.$elemMatch = cast$elemMatch;
	handle.$geoIntersects = cast$geoIntersects;
	handle.$or = handle.$and = function(val) {
	  if (!Array.isArray(val)) {
	    throw new TypeError('conditional $or/$and require array');
	  }
	
	  var ret = [];
	  for (var i = 0; i < val.length; ++i) {
	    ret.push(cast(this.casterConstructor.schema, val[i]));
	  }
	
	  return ret;
	};
	
	handle.$near =
	handle.$nearSphere = cast$near;
	
	handle.$within =
	handle.$geoWithin = cast$within;
	
	handle.$size =
	handle.$maxDistance = castToNumber;
	
	handle.$eq =
	handle.$gt =
	handle.$gte =
	handle.$in =
	handle.$lt =
	handle.$lte =
	handle.$ne =
	handle.$nin =
	handle.$regex = SchemaArray.prototype.castForQuery;
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaArray;


/***/ },
/* 195 */
/*!***************************************!*\
  !*** ./~/mongoose/lib/schema/date.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module requirements.
	 */
	
	var errorMessages = __webpack_require__(/*! ../error */ 32).messages
	var utils = __webpack_require__(/*! ../utils */ 42);
	
	var SchemaType = __webpack_require__(/*! ../schematype */ 177);
	
	var CastError = SchemaType.CastError;
	
	/**
	 * Date SchemaType constructor.
	 *
	 * @param {String} key
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api private
	 */
	
	function SchemaDate (key, options) {
	  SchemaType.call(this, key, options, 'Date');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api private
	 */
	SchemaDate.schemaName = 'Date';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaDate.prototype = Object.create( SchemaType.prototype );
	SchemaDate.prototype.constructor = SchemaDate;
	
	/**
	 * Declares a TTL index (rounded to the nearest second) for _Date_ types only.
	 *
	 * This sets the `expiresAfterSeconds` index option available in MongoDB >= 2.1.2.
	 * This index type is only compatible with Date types.
	 *
	 * ####Example:
	 *
	 *     // expire in 24 hours
	 *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});
	 *
	 * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:
	 *
	 * ####Example:
	 *
	 *     // expire in 24 hours
	 *     new Schema({ createdAt: { type: Date, expires: '24h' }});
	 *
	 *     // expire in 1.5 hours
	 *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});
	 *
	 *     // expire in 7 days
	 *     var schema = new Schema({ createdAt: Date });
	 *     schema.path('createdAt').expires('7d');
	 *
	 * @param {Number|String} when
	 * @added 3.0.0
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaDate.prototype.expires = function (when) {
	  if (!this._index || 'Object' !== this._index.constructor.name) {
	    this._index = {};
	  }
	
	  this._index.expires = when;
	  utils.expires(this._index);
	  return this;
	};
	
	/**
	 * Required validator for date
	 *
	 * @api private
	 */
	
	SchemaDate.prototype.checkRequired = function (value) {
	  return value instanceof Date;
	};
	
	/**
	 * Sets a minimum date validator.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ d: { type: Date, min: Date('1970-01-01') })
	 *     var M = db.model('M', s)
	 *     var m = new M({ d: Date('1969-12-31') })
	 *     m.save(function (err) {
	 *       console.error(err) // validator error
	 *       m.d = Date('2014-12-08');
	 *       m.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MIN} token which will be replaced with the invalid value
	 *     var min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];
	 *     var schema = new Schema({ d: { type: Date, min: min })
	 *     var M = mongoose.model('M', schema);
	 *     var s= new M({ d: Date('1969-12-31') });
	 *     s.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).
	 *     })
	 *
	 * @param {Date} value minimum date
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaDate.prototype.min = function (value, message) {
	  if (this.minValidator) {
	    this.validators = this.validators.filter(function (v) {
	      return v.validator != this.minValidator;
	    }, this);
	  }
	
	  if (value) {
	    var msg = message || errorMessages.Date.min;
	    msg = msg.replace(/{MIN}/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));
	    var self = this;
	    this.validators.push({
	      validator: this.minValidator = function (val) {
	        var min = (value === Date.now ? value() : self.cast(value));
	        return val === null || val.valueOf() >= min.valueOf();
	      },
	      message: msg,
	      type: 'min'
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Sets a maximum date validator.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ d: { type: Date, max: Date('2014-01-01') })
	 *     var M = db.model('M', s)
	 *     var m = new M({ d: Date('2014-12-08') })
	 *     m.save(function (err) {
	 *       console.error(err) // validator error
	 *       m.d = Date('2013-12-31');
	 *       m.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MAX} token which will be replaced with the invalid value
	 *     var max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];
	 *     var schema = new Schema({ d: { type: Date, max: max })
	 *     var M = mongoose.model('M', schema);
	 *     var s= new M({ d: Date('2014-12-08') });
	 *     s.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).
	 *     })
	 *
	 * @param {Date} maximum date
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaDate.prototype.max = function (value, message) {
	  if (this.maxValidator) {
	    this.validators = this.validators.filter(function(v){
	      return v.validator != this.maxValidator;
	    }, this);
	  }
	
	  if (value) {
	    var msg = message || errorMessages.Date.max;
	    msg = msg.replace(/{MAX}/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));
	    var self = this;
	    this.validators.push({
	      validator: this.maxValidator = function(val) {
	        var max = (value === Date.now ? value() : self.cast(value));
	        return val === null || val.valueOf() <= max.valueOf();
	      },
	      message: msg,
	      type: 'max'
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Casts to date
	 *
	 * @param {Object} value to cast
	 * @api private
	 */
	
	SchemaDate.prototype.cast = function (value) {
	  // If null or undefined
	  if (value == null || value === '')
	    return value;
	
	  if (value instanceof Date)
	    return value;
	
	  var date;
	
	  // support for timestamps
	  if (typeof value !== 'undefined') {
	    if (value instanceof Number || 'number' == typeof value
	        || String(value) == Number(value)) {
	      date = new Date(Number(value));
	    } else if (value.toString) {
	      // support for date strings
	      date = new Date(value.toString());
	    }
	
	    if (date.toString() != 'Invalid Date') {
	      return date;
	    }
	  }
	
	  throw new CastError('date', value, this.path);
	};
	
	/*!
	 * Date Query casting.
	 *
	 * @api private
	 */
	
	function handleSingle (val) {
	  return this.cast(val);
	}
	
	function handleArray (val) {
	  var self = this;
	  return val.map( function (m) {
	    return self.cast(m);
	  });
	}
	
	SchemaDate.prototype.$conditionalHandlers =
	  utils.options(SchemaType.prototype.$conditionalHandlers, {
	    '$all': handleArray,
	    '$gt': handleSingle,
	    '$gte': handleSingle,
	    '$in': handleArray,
	    '$lt': handleSingle,
	    '$lte': handleSingle,
	    '$ne': handleSingle,
	    '$nin': handleArray
	  });
	
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [value]
	 * @api private
	 */
	
	SchemaDate.prototype.castForQuery = function ($conditional, val) {
	  var handler;
	
	  if (2 !== arguments.length) {
	    return this.cast($conditional);
	  }
	
	  handler = this.$conditionalHandlers[$conditional];
	
	  if (!handler) {
	    throw new Error("Can't use " + $conditional + " with Date.");
	  }
	
	  return handler.call(this, val);
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaDate;


/***/ },
/* 196 */
/*!*****************************************!*\
  !*** ./~/mongoose/lib/schema/buffer.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * Module dependencies.
	 */
	
	var utils = __webpack_require__(/*! ../utils */ 42);
	
	var MongooseBuffer = __webpack_require__(/*! ../types */ 197).Buffer;
	var SchemaType = __webpack_require__(/*! ../schematype */ 177);
	
	var Binary = MongooseBuffer.Binary;
	var CastError = SchemaType.CastError;
	var Document;
	
	/**
	 * Buffer SchemaType constructor
	 *
	 * @param {String} key
	 * @param {SchemaType} cast
	 * @inherits SchemaType
	 * @api private
	 */
	
	function SchemaBuffer (key, options) {
	  SchemaType.call(this, key, options, 'Buffer');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api private
	 */
	SchemaBuffer.schemaName = 'Buffer';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaBuffer.prototype = Object.create( SchemaType.prototype );
	SchemaBuffer.prototype.constructor = SchemaBuffer;
	
	/**
	 * Check required
	 *
	 * @api private
	 */
	
	SchemaBuffer.prototype.checkRequired = function (value, doc) {
	  if (SchemaType._isRef(this, value, doc, true)) {
	    return null != value;
	  } else {
	    return !!(value && value.length);
	  }
	};
	
	/**
	 * Casts contents
	 *
	 * @param {Object} value
	 * @param {Document} doc document that triggers the casting
	 * @param {Boolean} init
	 * @api private
	 */
	
	SchemaBuffer.prototype.cast = function (value, doc, init) {
	  if (SchemaType._isRef(this, value, doc, init)) {
	    // wait! we may need to cast this to a document
	
	    if (null == value) {
	      return value;
	    }
	
	    // lazy load
	    Document || (Document = __webpack_require__(/*! ./../document */ 178));
	
	    if (value instanceof Document) {
	      value.$__.wasPopulated = true;
	      return value;
	    }
	
	    // setting a populated path
	    if (Buffer.isBuffer(value)) {
	      return value;
	    } else if (!utils.isObject(value)) {
	      throw new CastError('buffer', value, this.path);
	    }
	
	    // Handle the case where user directly sets a populated
	    // path to a plain object; cast to the Model used in
	    // the population query.
	    var path = doc.$__fullPath(this.path);
	    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;
	    var pop = owner.populated(path, true);
	    var ret = new pop.options.model(value);
	    ret.$__.wasPopulated = true;
	    return ret;
	  }
	
	  // documents
	  if (value && value._id) {
	    value = value._id;
	  }
	
	  if (value && value.isMongooseBuffer) {
	    return value;
	  }
	
	  if (Buffer.isBuffer(value)) {
	    if (!value || !value.isMongooseBuffer) {
	      value = new MongooseBuffer(value, [this.path, doc]);
	    }
	
	    return value;
	  } else if (value instanceof Binary) {
	    var ret = new MongooseBuffer(value.value(true), [this.path, doc]);
	    if (typeof value.sub_type !== 'number') {
	      throw new CastError('buffer', value, this.path);
	    }
	    ret._subtype = value.sub_type;
	    return ret;
	  }
	
	  if (null === value) return value;
	
	  var type = typeof value;
	  if ('string' == type || 'number' == type || Array.isArray(value)) {
	    var ret = new MongooseBuffer(value, [this.path, doc]);
	    return ret;
	  }
	
	  throw new CastError('buffer', value, this.path);
	};
	
	/*!
	 * ignore
	 */
	function handleSingle (val) {
	  return this.castForQuery(val);
	}
	
	function handleArray (val) {
	  var self = this;
	  return val.map( function (m) {
	    return self.castForQuery(m);
	  });
	}
	
	SchemaBuffer.prototype.$conditionalHandlers =
	  utils.options(SchemaType.prototype.$conditionalHandlers, {
	    '$gt' : handleSingle,
	    '$gte': handleSingle,
	    '$in' : handleArray,
	    '$lt' : handleSingle,
	    '$lte': handleSingle,
	    '$ne' : handleSingle,
	    '$nin': handleArray
	  });
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [value]
	 * @api private
	 */
	
	SchemaBuffer.prototype.castForQuery = function ($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	    if (!handler)
	      throw new Error("Can't use " + $conditional + " with Buffer.");
	    return handler.call(this, val);
	  } else {
	    val = $conditional;
	    return this.cast(val).toObject();
	  }
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaBuffer;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 197 */
/*!***************************************!*\
  !*** ./~/mongoose/lib/types/index.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module exports.
	 */
	
	exports.Array = __webpack_require__(/*! ./array */ 188);
	exports.Buffer = __webpack_require__(/*! ./buffer */ 198);
	
	exports.Document = // @deprecate
	exports.Embedded = __webpack_require__(/*! ./embedded */ 185);
	
	exports.DocumentArray = __webpack_require__(/*! ./documentarray */ 189);
	exports.ObjectId = __webpack_require__(/*! ./objectid */ 45);


/***/ },
/* 198 */
/*!****************************************!*\
  !*** ./~/mongoose/lib/types/buffer.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * Module dependencies.
	 */
	
	var Binary = __webpack_require__(/*! ../drivers */ 46).Binary
	  , utils = __webpack_require__(/*! ../utils */ 42);
	
	/**
	 * Mongoose Buffer constructor.
	 *
	 * Values always have to be passed to the constructor to initialize.
	 *
	 * @param {Buffer} value
	 * @param {String} encode
	 * @param {Number} offset
	 * @api private
	 * @inherits Buffer
	 * @see http://bit.ly/f6CnZU
	 */
	
	function MongooseBuffer (value, encode, offset) {
	  var length = arguments.length;
	  var val;
	
	  if (0 === length || null === arguments[0] || undefined === arguments[0]) {
	    val = 0;
	  } else {
	    val = value;
	  }
	
	  var encoding;
	  var path;
	  var doc;
	
	  if (Array.isArray(encode)) {
	    // internal casting
	    path = encode[0];
	    doc = encode[1];
	  } else {
	    encoding = encode;
	  }
	
	  var buf = new Buffer(val, encoding, offset);
	  utils.decorate( buf, MongooseBuffer.mixin );
	  buf.isMongooseBuffer = true;
	
	  // make sure these internal props don't show up in Object.keys()
	  Object.defineProperties(buf, {
	      validators: { value: [] }
	    , _path: { value: path }
	    , _parent: { value: doc }
	  });
	
	  if (doc && "string" === typeof path) {
	    Object.defineProperty(buf, '_schema', {
	        value: doc.schema.path(path)
	    });
	  }
	
	  buf._subtype = 0;
	  return buf;
	}
	
	/*!
	 * Inherit from Buffer.
	 */
	
	//MongooseBuffer.prototype = new Buffer(0);
	
	MongooseBuffer.mixin = {
	
	  /**
	   * Parent owner document
	   *
	   * @api private
	   * @property _parent
	   * @receiver MongooseBuffer
	   */
	
	  _parent: undefined,
	
	  /**
	   * Default subtype for the Binary representing this Buffer
	   *
	   * @api private
	   * @property _subtype
	   * @receiver MongooseBuffer
	   */
	
	  _subtype: undefined,
	
	  /**
	   * Marks this buffer as modified.
	   *
	   * @api private
	   * @method _markModified
	   * @receiver MongooseBuffer
	   */
	
	  _markModified: function () {
	    var parent = this._parent;
	
	    if (parent) {
	      parent.markModified(this._path);
	    }
	    return this;
	  },
	
	  /**
	   * Writes the buffer.
	   *
	   * @api public
	   * @method write
	   * @receiver MongooseBuffer
	   */
	
	  write: function () {
	    var written = Buffer.prototype.write.apply(this, arguments);
	
	    if (written > 0) {
	      this._markModified();
	    }
	
	    return written;
	  },
	
	  /**
	   * Copies the buffer.
	   *
	   * ####Note:
	   *
	   * `Buffer#copy` does not mark `target` as modified so you must copy from a `MongooseBuffer` for it to work as expected. This is a work around since `copy` modifies the target, not this.
	   *
	   * @return {MongooseBuffer}
	   * @param {Buffer} target
	   * @method copy
	   * @receiver MongooseBuffer
	   */
	
	  copy: function (target) {
	    var ret = Buffer.prototype.copy.apply(this, arguments);
	
	    if (target && target.isMongooseBuffer) {
	      target._markModified();
	    }
	
	    return ret;
	  }
	};
	
	/*!
	 * Compile other Buffer methods marking this buffer as modified.
	 */
	
	;(
	// node < 0.5
	'writeUInt8 writeUInt16 writeUInt32 writeInt8 writeInt16 writeInt32 ' +
	'writeFloat writeDouble fill ' +
	'utf8Write binaryWrite asciiWrite set ' +
	
	// node >= 0.5
	'writeUInt16LE writeUInt16BE writeUInt32LE writeUInt32BE ' +
	'writeInt16LE writeInt16BE writeInt32LE writeInt32BE ' +
	'writeFloatLE writeFloatBE writeDoubleLE writeDoubleBE'
	).split(' ').forEach(function (method) {
	  if (!Buffer.prototype[method]) return;
	  MongooseBuffer.mixin[method] = new Function(
	    'var ret = Buffer.prototype.'+method+'.apply(this, arguments);' +
	    'this._markModified();' +
	    'return ret;'
	  )
	});
	
	/**
	 * Converts this buffer to its Binary type representation.
	 *
	 * ####SubTypes:
	 *
	 *   var bson = require('bson')
	 *   bson.BSON_BINARY_SUBTYPE_DEFAULT
	 *   bson.BSON_BINARY_SUBTYPE_FUNCTION
	 *   bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY
	 *   bson.BSON_BINARY_SUBTYPE_UUID
	 *   bson.BSON_BINARY_SUBTYPE_MD5
	 *   bson.BSON_BINARY_SUBTYPE_USER_DEFINED
	 *
	 *   doc.buffer.toObject(bson.BSON_BINARY_SUBTYPE_USER_DEFINED);
	 *
	 * @see http://bsonspec.org/#/specification
	 * @param {Hex} [subtype]
	 * @return {Binary}
	 * @api public
	 * @method toObject
	 * @receiver MongooseBuffer
	 */
	
	MongooseBuffer.mixin.toObject = function (options) {
	  var subtype = 'number' == typeof options
	    ? options
	    : (this._subtype || 0);
	  return new Binary(this, subtype);
	};
	
	/**
	 * Determines if this buffer is equals to `other` buffer
	 *
	 * @param {Buffer} other
	 * @return {Boolean}
	 * @method equals
	 * @receiver MongooseBuffer
	 */
	
	MongooseBuffer.mixin.equals = function (other) {
	  if (!Buffer.isBuffer(other)) {
	    return false;
	  }
	
	  if (this.length !== other.length) {
	    return false;
	  }
	
	  for (var i = 0; i < this.length; ++i) {
	    if (this[i] !== other[i]) return false;
	  }
	
	  return true;
	};
	
	/**
	 * Sets the subtype option and marks the buffer modified.
	 *
	 * ####SubTypes:
	 *
	 *   var bson = require('bson')
	 *   bson.BSON_BINARY_SUBTYPE_DEFAULT
	 *   bson.BSON_BINARY_SUBTYPE_FUNCTION
	 *   bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY
	 *   bson.BSON_BINARY_SUBTYPE_UUID
	 *   bson.BSON_BINARY_SUBTYPE_MD5
	 *   bson.BSON_BINARY_SUBTYPE_USER_DEFINED
	 *
	 *   doc.buffer.subtype(bson.BSON_BINARY_SUBTYPE_UUID);
	 *
	 * @see http://bsonspec.org/#/specification
	 * @param {Hex} subtype
	 * @api public
	 * @method subtype
	 * @receiver MongooseBuffer
	 */
	
	MongooseBuffer.mixin.subtype = function (subtype) {
	  if ('number' != typeof subtype) {
	    throw new TypeError('Invalid subtype. Expected a number');
	  }
	
	  if (this._subtype != subtype) {
	    this._markModified();
	  }
	
	  this._subtype = subtype;
	};
	
	/*!
	 * Module exports.
	 */
	
	MongooseBuffer.Binary = Binary;
	
	module.exports = MongooseBuffer;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 199 */
/*!********************************!*\
  !*** ./~/mongoose/lib/cast.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var utils = __webpack_require__(/*! ./utils */ 42);
	var Types = __webpack_require__(/*! ./schema/index */ 175);
	
	/**
	 * Handles internal casting for queries
	 *
	 * @param {Schema} schema
	 * @param {Object obj Object to cast
	 * @api private
	 */
	
	var cast = module.exports = function(schema, obj) {
	  var paths = Object.keys(obj)
	    , i = paths.length
	    , any$conditionals
	    , schematype
	    , nested
	    , path
	    , type
	    , val;
	
	  while (i--) {
	    path = paths[i];
	    val = obj[path];
	
	    if ('$or' === path || '$nor' === path || '$and' === path) {
	      var k = val.length;
	      var orComponentQuery;
	
	      while (k--) {
	        val[k] = cast(schema, val[k]);
	      }
	
	    } else if (path === '$where') {
	      type = typeof val;
	
	      if ('string' !== type && 'function' !== type) {
	        throw new Error("Must have a string or function for $where");
	      }
	
	      if ('function' === type) {
	        obj[path] = val.toString();
	      }
	
	      continue;
	
	    } else {
	
	      if (!schema) {
	        // no casting for Mixed types
	        continue;
	      }
	
	      schematype = schema.path(path);
	
	      if (!schematype) {
	        // Handle potential embedded array queries
	        var split = path.split('.')
	          , j = split.length
	          , pathFirstHalf
	          , pathLastHalf
	          , remainingConds
	          , castingQuery;
	
	        // Find the part of the var path that is a path of the Schema
	        while (j--) {
	          pathFirstHalf = split.slice(0, j).join('.');
	          schematype = schema.path(pathFirstHalf);
	          if (schematype) break;
	        }
	
	        // If a substring of the input path resolves to an actual real path...
	        if (schematype) {
	          // Apply the casting; similar code for $elemMatch in schema/array.js
	          if (schematype.caster && schematype.caster.schema) {
	            remainingConds = {};
	            pathLastHalf = split.slice(j).join('.');
	            remainingConds[pathLastHalf] = val;
	            obj[path] = cast(schematype.caster.schema, remainingConds)[pathLastHalf];
	          } else {
	            obj[path] = val;
	          }
	          continue;
	        }
	
	        if (utils.isObject(val)) {
	          // handle geo schemas that use object notation
	          // { loc: { long: Number, lat: Number }
	
	          var geo = val.$near ? '$near' :
	                    val.$nearSphere ? '$nearSphere' :
	                    val.$within ? '$within' :
	                    val.$geoIntersects ? '$geoIntersects' : '';
	
	          if (!geo) {
	            continue;
	          }
	
	          var numbertype = new Types.Number('__QueryCasting__')
	          var value = val[geo];
	
	          if (val.$maxDistance) {
	            val.$maxDistance = numbertype.castForQuery(val.$maxDistance);
	          }
	
	          if ('$within' == geo) {
	            var withinType = value.$center
	                          || value.$centerSphere
	                          || value.$box
	                          || value.$polygon;
	
	            if (!withinType) {
	              throw new Error('Bad $within paramater: ' + JSON.stringify(val));
	            }
	
	            value = withinType;
	
	          } else if ('$near' == geo &&
	              'string' == typeof value.type && Array.isArray(value.coordinates)) {
	            // geojson; cast the coordinates
	            value = value.coordinates;
	
	          } else if (('$near' == geo || '$nearSphere' == geo || '$geoIntersects' == geo) &&
	              value.$geometry && 'string' == typeof value.$geometry.type &&
	              Array.isArray(value.$geometry.coordinates)) {
	            // geojson; cast the coordinates
	            value = value.$geometry.coordinates;
	          }
	
	          ;(function _cast (val) {
	            if (Array.isArray(val)) {
	              val.forEach(function (item, i) {
	                if (Array.isArray(item) || utils.isObject(item)) {
	                  return _cast(item);
	                }
	                val[i] = numbertype.castForQuery(item);
	              });
	            } else {
	              var nearKeys= Object.keys(val);
	              var nearLen = nearKeys.length;
	              while (nearLen--) {
	                var nkey = nearKeys[nearLen];
	                var item = val[nkey];
	                if (Array.isArray(item) || utils.isObject(item)) {
	                  _cast(item);
	                  val[nkey] = item;
	                } else {
	                  val[nkey] = numbertype.castForQuery(item);
	                }
	              }
	            }
	          })(value);
	        }
	
	      } else if (val === null || val === undefined) {
	        continue;
	      } else if ('Object' === val.constructor.name) {
	
	        any$conditionals = Object.keys(val).some(function (k) {
	          return k.charAt(0) === '$' && k !== '$id' && k !== '$ref';
	        });
	
	        if (!any$conditionals) {
	          obj[path] = schematype.castForQuery(val);
	        } else {
	
	          var ks = Object.keys(val)
	            , k = ks.length
	            , $cond;
	
	          while (k--) {
	            $cond = ks[k];
	            nested = val[$cond];
	
	            if ('$exists' === $cond) {
	              if ('boolean' !== typeof nested) {
	                throw new Error("$exists parameter must be Boolean");
	              }
	              continue;
	            }
	
	            if ('$type' === $cond) {
	              if ('number' !== typeof nested) {
	                throw new Error("$type parameter must be Number");
	              }
	              continue;
	            }
	
	            if ('$not' === $cond) {
	              cast(schema, nested);
	            } else {
	              val[$cond] = schematype.castForQuery($cond, nested);
	            }
	          }
	        }
	      } else {
	        obj[path] = schematype.castForQuery(val);
	      }
	    }
	  }
	
	  return obj;
	}


/***/ },
/* 200 */
/*!*********************************!*\
  !*** ./~/mongoose/lib/query.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*!
	 * Module dependencies.
	 */
	
	var mquery = __webpack_require__(/*! mquery */ 201);
	var util = __webpack_require__(/*! util */ 57);
	var events = __webpack_require__(/*! events */ 74);
	var mongo = __webpack_require__(/*! mongodb */ 72);
	var readPref = __webpack_require__(/*! ./drivers */ 46).ReadPreference;
	
	var updateValidators = __webpack_require__(/*! ./services/updateValidators */ 214);
	var utils = __webpack_require__(/*! ./utils */ 42);
	var Promise = __webpack_require__(/*! ./promise */ 183);
	var helpers = __webpack_require__(/*! ./queryhelpers */ 216);
	var Types = __webpack_require__(/*! ./schema/index */ 175);
	var Document = __webpack_require__(/*! ./document */ 178);
	var QueryStream = __webpack_require__(/*! ./querystream */ 217);
	var cast = __webpack_require__(/*! ./cast */ 199);
	var ValidationError = __webpack_require__(/*! ./error/validation.js */ 36);
	
	/**
	 * Query constructor used for building queries.
	 *
	 * ####Example:
	 *
	 *     var query = new Query();
	 *     query.setOptions({ lean : true });
	 *     query.collection(model.collection);
	 *     query.where('age').gte(21).exec(callback);
	 *
	 * @param {Object} [options]
	 * @param {Object} [model]
	 * @param {Object} [conditions]
	 * @param {Object} [collection] Mongoose collection
	 * @api private
	 */
	
	function Query(conditions, options, model, collection) {
	  // this stuff is for dealing with custom queries created by #toConstructor
	  if (!this._mongooseOptions) {
	    this._mongooseOptions = {};
	  }
	
	  // this is the case where we have a CustomQuery, we need to check if we got
	  // options passed in, and if we did, merge them in
	  if (options) {
	    var keys = Object.keys(options);
	    for (var i=0; i < keys.length; i++) {
	      var k = keys[i];
	      this._mongooseOptions[k] = options[k];
	    }
	  }
	
	  if (collection) {
	    this.mongooseCollection = collection;
	  }
	
	  if (model) {
	    this.model = model;
	    this.schema = model.schema;
	  }
	
	  // this is needed because map reduce returns a model that can be queried, but
	  // all of the queries on said model should be lean
	  if (this.model && this.model._mapreduce) {
	    this.lean();
	  }
	
	  // inherit mquery
	  mquery.call(this, this.mongooseCollection, options);
	
	  if (conditions) {
	    this.find(conditions);
	  }
	
	  if (this.schema) {
	    this._execUpdate = this.model.hooks.createWrapper('update',
	      Query.prototype._execUpdate, this);
	  }
	}
	
	/*!
	 * inherit mquery
	 */
	
	Query.prototype = new mquery;
	Query.prototype.constructor = Query;
	Query.base = mquery.prototype;
	
	/**
	 * Flag to opt out of using `$geoWithin`.
	 *
	 *     mongoose.Query.use$geoWithin = false;
	 *
	 * MongoDB 2.4 deprecated the use of `$within`, replacing it with `$geoWithin`. Mongoose uses `$geoWithin` by default (which is 100% backward compatible with $within). If you are running an older version of MongoDB, set this flag to `false` so your `within()` queries continue to work.
	 *
	 * @see http://docs.mongodb.org/manual/reference/operator/geoWithin/
	 * @default true
	 * @property use$geoWithin
	 * @memberOf Query
	 * @receiver Query
	 * @api public
	 */
	
	Query.use$geoWithin = mquery.use$geoWithin;
	
	/**
	 * Converts this query to a customized, reusable query constructor with all arguments and options retained.
	 *
	 * ####Example
	 *
	 *     // Create a query for adventure movies and read from the primary
	 *     // node in the replica-set unless it is down, in which case we'll
	 *     // read from a secondary node.
	 *     var query = Movie.find({ tags: 'adventure' }).read('primaryPreferred');
	 *
	 *     // create a custom Query constructor based off these settings
	 *     var Adventure = query.toConstructor();
	 *
	 *     // Adventure is now a subclass of mongoose.Query and works the same way but with the
	 *     // default query parameters and options set.
	 *     Adventure().exec(callback)
	 *
	 *     // further narrow down our query results while still using the previous settings
	 *     Adventure().where({ name: /^Life/ }).exec(callback);
	 *
	 *     // since Adventure is a stand-alone constructor we can also add our own
	 *     // helper methods and getters without impacting global queries
	 *     Adventure.prototype.startsWith = function (prefix) {
	 *       this.where({ name: new RegExp('^' + prefix) })
	 *       return this;
	 *     }
	 *     Object.defineProperty(Adventure.prototype, 'highlyRated', {
	 *       get: function () {
	 *         this.where({ rating: { $gt: 4.5 }});
	 *         return this;
	 *       }
	 *     })
	 *     Adventure().highlyRated.startsWith('Life').exec(callback)
	 *
	 * New in 3.7.3
	 *
	 * @return {Query} subclass-of-Query
	 * @api public
	 */
	
	Query.prototype.toConstructor = function toConstructor () {
	  var CustomQuery = function(criteria, options) {
	    if (!(this instanceof CustomQuery))
	      return new CustomQuery(criteria, options);
	    Query.call(this, criteria, options || null);
	  };
	
	  util.inherits(CustomQuery, Query);
	
	  // set inherited defaults
	  var p = CustomQuery.prototype;
	
	  p.options = {};
	
	  p.setOptions(this.options);
	
	  p.op = this.op;
	  p._conditions = utils.clone(this._conditions);
	  p._fields = utils.clone(this._fields);
	  p._update = utils.clone(this._update);
	  p._path = this._path;
	  p._distinct = this._distinct;
	  p._collection = this._collection;
	  p.model = this.model;
	  p.mongooseCollection = this.mongooseCollection;
	  p._mongooseOptions = this._mongooseOptions;
	
	  return CustomQuery;
	}
	
	/**
	 * Specifies a javascript function or expression to pass to MongoDBs query system.
	 *
	 * ####Example
	 *
	 *     query.$where('this.comments.length === 10 || this.name.length === 5')
	 *
	 *     // or
	 *
	 *     query.$where(function () {
	 *       return this.comments.length === 10 || this.name.length === 5;
	 *     })
	 *
	 * ####NOTE:
	 *
	 * Only use `$where` when you have a condition that cannot be met using other MongoDB operators like `$lt`.
	 * **Be sure to read about all of [its caveats](http://docs.mongodb.org/manual/reference/operator/where/) before using.**
	 *
	 * @see $where http://docs.mongodb.org/manual/reference/operator/where/
	 * @method $where
	 * @param {String|Function} js javascript string or function
	 * @return {Query} this
	 * @memberOf Query
	 * @method $where
	 * @api public
	 */
	
	/**
	 * Specifies a `path` for use with chaining.
	 *
	 * ####Example
	 *
	 *     // instead of writing:
	 *     User.find({age: {$gte: 21, $lte: 65}}, callback);
	 *
	 *     // we can instead write:
	 *     User.where('age').gte(21).lte(65);
	 *
	 *     // passing query conditions is permitted
	 *     User.find().where({ name: 'vonderful' })
	 *
	 *     // chaining
	 *     User
	 *     .where('age').gte(21).lte(65)
	 *     .where('name', /^vonderful/i)
	 *     .where('friends').slice(10)
	 *     .exec(callback)
	 *
	 * @method where
	 * @memberOf Query
	 * @param {String|Object} [path]
	 * @param {any} [val]
	 * @return {Query} this
	 * @api public
	 */
	
	/**
	 * Specifies the complementary comparison value for paths specified with `where()`
	 *
	 * ####Example
	 *
	 *     User.where('age').equals(49);
	 *
	 *     // is the same as
	 *
	 *     User.where('age', 49);
	 *
	 * @method equals
	 * @memberOf Query
	 * @param {Object} val
	 * @return {Query} this
	 * @api public
	 */
	
	/**
	 * Specifies arguments for an `$or` condition.
	 *
	 * ####Example
	 *
	 *     query.or([{ color: 'red' }, { status: 'emergency' }])
	 *
	 * @see $or http://docs.mongodb.org/manual/reference/operator/or/
	 * @method or
	 * @memberOf Query
	 * @param {Array} array array of conditions
	 * @return {Query} this
	 * @api public
	 */
	
	/**
	 * Specifies arguments for a `$nor` condition.
	 *
	 * ####Example
	 *
	 *     query.nor([{ color: 'green' }, { status: 'ok' }])
	 *
	 * @see $nor http://docs.mongodb.org/manual/reference/operator/nor/
	 * @method nor
	 * @memberOf Query
	 * @param {Array} array array of conditions
	 * @return {Query} this
	 * @api public
	 */
	
	/**
	 * Specifies arguments for a `$and` condition.
	 *
	 * ####Example
	 *
	 *     query.and([{ color: 'green' }, { status: 'ok' }])
	 *
	 * @method and
	 * @memberOf Query
	 * @see $and http://docs.mongodb.org/manual/reference/operator/and/
	 * @param {Array} array array of conditions
	 * @return {Query} this
	 * @api public
	 */
	
	/**
	 * Specifies a $gt query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * ####Example
	 *
	 *     Thing.find().where('age').gt(21)
	 *
	 *     // or
	 *     Thing.find().gt('age', 21)
	 *
	 * @method gt
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @see $gt http://docs.mongodb.org/manual/reference/operator/gt/
	 * @api public
	 */
	
	/**
	 * Specifies a $gte query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method gte
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @see $gte http://docs.mongodb.org/manual/reference/operator/gte/
	 * @api public
	 */
	
	/**
	 * Specifies a $lt query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method lt
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @see $lt http://docs.mongodb.org/manual/reference/operator/lt/
	 * @api public
	 */
	
	/**
	 * Specifies a $lte query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method lte
	 * @see $lte http://docs.mongodb.org/manual/reference/operator/lte/
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $ne query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @see $ne http://docs.mongodb.org/manual/reference/operator/ne/
	 * @method ne
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies an $in query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @see $in http://docs.mongodb.org/manual/reference/operator/in/
	 * @method in
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies an $nin query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @see $nin http://docs.mongodb.org/manual/reference/operator/nin/
	 * @method nin
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies an $all query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @see $all http://docs.mongodb.org/manual/reference/operator/all/
	 * @method all
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $size query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * ####Example
	 *
	 *     MyModel.where('tags').size(0).exec(function (err, docs) {
	 *       if (err) return handleError(err);
	 *
	 *       assert(Array.isArray(docs));
	 *       console.log('documents with 0 tags', docs);
	 *     })
	 *
	 * @see $size http://docs.mongodb.org/manual/reference/operator/size/
	 * @method size
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $regex query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @see $regex http://docs.mongodb.org/manual/reference/operator/regex/
	 * @method regex
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $maxDistance query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @see $maxDistance http://docs.mongodb.org/manual/reference/operator/maxDistance/
	 * @method maxDistance
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a `$mod` condition
	 *
	 * @method mod
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @return {Query} this
	 * @see $mod http://docs.mongodb.org/manual/reference/operator/mod/
	 * @api public
	 */
	
	/**
	 * Specifies an `$exists` condition
	 *
	 * ####Example
	 *
	 *     // { name: { $exists: true }}
	 *     Thing.where('name').exists()
	 *     Thing.where('name').exists(true)
	 *     Thing.find().exists('name')
	 *
	 *     // { name: { $exists: false }}
	 *     Thing.where('name').exists(false);
	 *     Thing.find().exists('name', false);
	 *
	 * @method exists
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @return {Query} this
	 * @see $exists http://docs.mongodb.org/manual/reference/operator/exists/
	 * @api public
	 */
	
	/**
	 * Specifies an `$elemMatch` condition
	 *
	 * ####Example
	 *
	 *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})
	 *
	 *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})
	 *
	 *     query.elemMatch('comment', function (elem) {
	 *       elem.where('author').equals('autobot');
	 *       elem.where('votes').gte(5);
	 *     })
	 *
	 *     query.where('comment').elemMatch(function (elem) {
	 *       elem.where({ author: 'autobot' });
	 *       elem.where('votes').gte(5);
	 *     })
	 *
	 * @method elemMatch
	 * @memberOf Query
	 * @param {String|Object|Function} path
	 * @param {Object|Function} criteria
	 * @return {Query} this
	 * @see $elemMatch http://docs.mongodb.org/manual/reference/operator/elemMatch/
	 * @api public
	 */
	
	/**
	 * Defines a `$within` or `$geoWithin` argument for geo-spatial queries.
	 *
	 * ####Example
	 *
	 *     query.where(path).within().box()
	 *     query.where(path).within().circle()
	 *     query.where(path).within().geometry()
	 *
	 *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });
	 *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });
	 *     query.where('loc').within({ polygon: [[],[],[],[]] });
	 *
	 *     query.where('loc').within([], [], []) // polygon
	 *     query.where('loc').within([], []) // box
	 *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry
	 *
	 * **MUST** be used after `where()`.
	 *
	 * ####NOTE:
	 *
	 * As of Mongoose 3.7, `$geoWithin` is always used for queries. To change this behavior, see [Query.use$geoWithin](#query_Query-use%2524geoWithin).
	 *
	 * ####NOTE:
	 *
	 * In Mongoose 3.7, `within` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).
	 *
	 * @method within
	 * @see $polygon http://docs.mongodb.org/manual/reference/operator/polygon/
	 * @see $box http://docs.mongodb.org/manual/reference/operator/box/
	 * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/
	 * @see $center http://docs.mongodb.org/manual/reference/operator/center/
	 * @see $centerSphere http://docs.mongodb.org/manual/reference/operator/centerSphere/
	 * @memberOf Query
	 * @return {Query} this
	 * @api public
	 */
	
	/**
	 * Specifies a $slice projection for an array.
	 *
	 * ####Example
	 *
	 *     query.slice('comments', 5)
	 *     query.slice('comments', -5)
	 *     query.slice('comments', [10, 5])
	 *     query.where('comments').slice(5)
	 *     query.where('comments').slice([-10, 5])
	 *
	 * @method slice
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val number/range of elements to slice
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements
	 * @see $slice http://docs.mongodb.org/manual/reference/projection/slice/#prj._S_slice
	 * @api public
	 */
	
	/**
	 * Specifies the maximum number of documents the query will return.
	 *
	 * ####Example
	 *
	 *     query.limit(20)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method limit
	 * @memberOf Query
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies the number of documents to skip.
	 *
	 * ####Example
	 *
	 *     query.skip(100).limit(20)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method skip
	 * @memberOf Query
	 * @param {Number} val
	 * @see cursor.skip http://docs.mongodb.org/manual/reference/method/cursor.skip/
	 * @api public
	 */
	
	/**
	 * Specifies the maxScan option.
	 *
	 * ####Example
	 *
	 *     query.maxScan(100)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method maxScan
	 * @memberOf Query
	 * @param {Number} val
	 * @see maxScan http://docs.mongodb.org/manual/reference/operator/maxScan/
	 * @api public
	 */
	
	/**
	 * Specifies the batchSize option.
	 *
	 * ####Example
	 *
	 *     query.batchSize(100)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method batchSize
	 * @memberOf Query
	 * @param {Number} val
	 * @see batchSize http://docs.mongodb.org/manual/reference/method/cursor.batchSize/
	 * @api public
	 */
	
	/**
	 * Specifies the `comment` option.
	 *
	 * ####Example
	 *
	 *     query.comment('login query')
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method comment
	 * @memberOf Query
	 * @param {Number} val
	 * @see comment http://docs.mongodb.org/manual/reference/operator/comment/
	 * @api public
	 */
	
	/**
	 * Specifies this query as a `snapshot` query.
	 *
	 * ####Example
	 *
	 *     query.snapshot() // true
	 *     query.snapshot(true)
	 *     query.snapshot(false)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method snapshot
	 * @memberOf Query
	 * @see snapshot http://docs.mongodb.org/manual/reference/operator/snapshot/
	 * @return {Query} this
	 * @api public
	 */
	
	/**
	 * Sets query hints.
	 *
	 * ####Example
	 *
	 *     query.hint({ indexA: 1, indexB: -1})
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method hint
	 * @memberOf Query
	 * @param {Object} val a hint object
	 * @return {Query} this
	 * @see $hint http://docs.mongodb.org/manual/reference/operator/hint/
	 * @api public
	 */
	
	/**
	 * Specifies which document fields to include or exclude (also known as the query "projection")
	 *
	 * When using string syntax, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included. Lastly, if a path is prefixed with `+`, it forces inclusion of the path, which is useful for paths excluded at the [schema level](/docs/api.html#schematype_SchemaType-select).
	 *
	 * ####Example
	 *
	 *     // include a and b, exclude other fields
	 *     query.select('a b');
	 *
	 *     // exclude c and d, include other fields
	 *     query.select('-c -d');
	 *
	 *     // or you may use object notation, useful when
	 *     // you have keys already prefixed with a "-"
	 *     query.select({ a: 1, b: 1 });
	 *     query.select({ c: 0, d: 0 });
	 *
	 *     // force inclusion of field excluded at schema level
	 *     query.select('+path')
	 *
	 * ####NOTE:
	 *
	 * Cannot be used with `distinct()`.
	 *
	 * _v2 had slightly different syntax such as allowing arrays of field names. This support was removed in v3._
	 *
	 * @method select
	 * @memberOf Query
	 * @param {Object|String} arg
	 * @return {Query} this
	 * @see SchemaType
	 * @api public
	 */
	
	/**
	 * _DEPRECATED_ Sets the slaveOk option.
	 *
	 * **Deprecated** in MongoDB 2.2 in favor of [read preferences](#query_Query-read).
	 *
	 * ####Example:
	 *
	 *     query.slaveOk() // true
	 *     query.slaveOk(true)
	 *     query.slaveOk(false)
	 *
	 * @method slaveOk
	 * @memberOf Query
	 * @deprecated use read() preferences instead if on mongodb >= 2.2
	 * @param {Boolean} v defaults to true
	 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
	 * @see slaveOk http://docs.mongodb.org/manual/reference/method/rs.slaveOk/
	 * @see read() #query_Query-read
	 * @return {Query} this
	 * @api public
	 */
	
	/**
	 * Determines the MongoDB nodes from which to read.
	 *
	 * ####Preferences:
	 *
	 *     primary - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.
	 *     secondary            Read from secondary if available, otherwise error.
	 *     primaryPreferred     Read from primary if available, otherwise a secondary.
	 *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.
	 *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.
	 *
	 * Aliases
	 *
	 *     p   primary
	 *     pp  primaryPreferred
	 *     s   secondary
	 *     sp  secondaryPreferred
	 *     n   nearest
	 *
	 * ####Example:
	 *
	 *     new Query().read('primary')
	 *     new Query().read('p')  // same as primary
	 *
	 *     new Query().read('primaryPreferred')
	 *     new Query().read('pp') // same as primaryPreferred
	 *
	 *     new Query().read('secondary')
	 *     new Query().read('s')  // same as secondary
	 *
	 *     new Query().read('secondaryPreferred')
	 *     new Query().read('sp') // same as secondaryPreferred
	 *
	 *     new Query().read('nearest')
	 *     new Query().read('n')  // same as nearest
	 *
	 *     // read from secondaries with matching tags
	 *     new Query().read('s', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }])
	 *
	 * Read more about how to use read preferrences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).
	 *
	 * @method read
	 * @memberOf Query
	 * @param {String} pref one of the listed preference options or aliases
	 * @param {Array} [tags] optional tags for this query
	 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
	 * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.read = function read (pref, tags) {
	  // first cast into a ReadPreference object to support tags
	  var read = readPref.apply(readPref, arguments);
	  return Query.base.read.call(this, read);
	}
	
	/**
	 * Merges another Query or conditions object into this one.
	 *
	 * When a Query is passed, conditions, field selection and options are merged.
	 *
	 * New in 3.7.0
	 *
	 * @method merge
	 * @memberOf Query
	 * @param {Query|Object} source
	 * @return {Query} this
	 */
	
	/**
	 * Sets query options.
	 *
	 * ####Options:
	 *
	 * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors) *
	 * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\)%7D%7D) *
	 * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D) *
	 * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D) *
	 * - [maxscan](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24maxScan) *
	 * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D) *
	 * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment) *
	 * - [snapshot](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D) *
	 * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint) *
	 * - [slaveOk](http://docs.mongodb.org/manual/applications/replication/#read-preference) *
	 * - [lean](./api.html#query_Query-lean) *
	 * - [safe](http://www.mongodb.org/display/DOCS/getLastError+Command)
	 *
	 * _* denotes a query helper method is also available_
	 *
	 * @param {Object} options
	 * @api public
	 */
	
	Query.prototype.setOptions = function (options, overwrite) {
	  // overwrite is only for internal use
	  if (overwrite) {
	    // ensure that _mongooseOptions & options are two different objects
	    this._mongooseOptions = (options && utils.clone(options)) || {};
	    this.options = options || {};
	
	    if('populate' in options) {
	      this.populate(this._mongooseOptions);
	    }
	    return this;
	  }
	
	  if (!(options && 'Object' == options.constructor.name)) {
	    return this;
	  }
	
	  return Query.base.setOptions.call(this, options);
	}
	
	/**
	 * Returns fields selection for this query.
	 *
	 * @method _fieldsForExec
	 * @return {Object}
	 * @api private
	 * @receiver Query
	 */
	
	/**
	 * Return an update document with corrected $set operations.
	 *
	 * @method _updateForExec
	 * @api private
	 * @receiver Query
	 */
	
	/**
	 * Makes sure _path is set.
	 *
	 * @method _ensurePath
	 * @param {String} method
	 * @api private
	 * @receiver Query
	 */
	
	/**
	 * Determines if `conds` can be merged using `mquery().merge()`
	 *
	 * @method canMerge
	 * @memberOf Query
	 * @param {Object} conds
	 * @return {Boolean}
	 * @api private
	 */
	
	/**
	 * Returns default options for this query.
	 *
	 * @param {Model} model
	 * @api private
	 */
	
	Query.prototype._optionsForExec = function (model) {
	  var options = Query.base._optionsForExec.call(this);
	
	  delete options.populate;
	  model = model || this.model;
	
	  if (!model) {
	    return options;
	  } else {
	    if (!('safe' in options) && model.schema.options.safe) {
	      options.safe = model.schema.options.safe;
	    }
	
	    if (!('readPreference' in options) && model.schema.options.read) {
	      options.readPreference = model.schema.options.read;
	    }
	
	    return options;
	  }
	};
	
	/**
	 * Sets the lean option.
	 *
	 * Documents returned from queries with the `lean` option enabled are plain javascript objects, not [MongooseDocuments](#document-js). They have no `save` method, getters/setters or other Mongoose magic applied.
	 *
	 * ####Example:
	 *
	 *     new Query().lean() // true
	 *     new Query().lean(true)
	 *     new Query().lean(false)
	 *
	 *     Model.find().lean().exec(function (err, docs) {
	 *       docs[0] instanceof mongoose.Document // false
	 *     });
	 *
	 * This is a [great](https://groups.google.com/forum/#!topic/mongoose-orm/u2_DzDydcnA/discussion) option in high-performance read-only scenarios, especially when combined with [stream](#query_Query-stream).
	 *
	 * @param {Boolean} bool defaults to true
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.lean = function (v) {
	  this._mongooseOptions.lean = arguments.length ? !!v : true;
	  return this;
	}
	
	/**
	 * Finds documents.
	 *
	 * When no `callback` is passed, the query is not executed. When the query is executed, the result will be an array of documents.
	 *
	 * ####Example
	 *
	 *     query.find({ name: 'Los Pollos Hermanos' }).find(callback)
	 *
	 * @param {Object} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.find = function (conditions, callback) {
	  var _this = this;
	
	  if ('function' == typeof conditions) {
	    callback = conditions;
	    conditions = {};
	  } else if (conditions instanceof Document) {
	    conditions = conditions.toObject();
	  }
	
	  if (mquery.canMerge(conditions)) {
	    this.merge(conditions);
	  }
	
	  prepareDiscriminatorCriteria(this);
	
	  try {
	    this.cast(this.model);
	    this._castError = null;
	  } catch (err) {
	    this._castError = err;
	  }
	
	  // if we don't have a callback, then just return the query object
	  if (!callback) {
	    return Query.base.find.call(this);
	  }
	
	  var promise;
	  if (this.schema) {
	    promise = new Promise(function(error, docs) {
	      if (error) {
	        return callback(error);
	      }
	      _this.model.hooks.execPost('find', _this, [docs], callback);
	    });
	  } else {
	    promise = new Promise(callback);
	  }
	  if (this._castError) {
	    promise.error(this._castError);
	    return this;
	  }
	
	  this._applyPaths();
	  this._fields = this._castFields(this._fields);
	
	  var fields = this._fieldsForExec();
	  var options = this._mongooseOptions;
	  var self = this;
	
	  var cb = function(err, docs) {
	    if (err) return promise.error(err);
	
	    if (0 === docs.length) {
	      return promise.complete(docs);
	    }
	
	    if (!options.populate) {
	      return true === options.lean
	        ? promise.complete(docs)
	        : completeMany(self.model, docs, fields, self, null, promise);
	    }
	
	    var pop = helpers.preparePopulationOptionsMQ(self, options);
	    self.model.populate(docs, pop, function (err, docs) {
	      if(err) return promise.error(err);
	      return true === options.lean
	        ? promise.complete(docs)
	        : completeMany(self.model, docs, fields, self, pop, promise);
	    });
	  };
	
	  if (this.schema) {
	    this.model.hooks.execPre('find', this, function(error) {
	      if (error) {
	        return cb(error);
	      }
	      Query.base.find.call(self, {}, cb);
	    });
	    return this;
	  }
	
	  return Query.base.find.call(this, {}, cb);
	}
	
	/*!
	 * hydrates many documents
	 *
	 * @param {Model} model
	 * @param {Array} docs
	 * @param {Object} fields
	 * @param {Query} self
	 * @param {Array} [pop] array of paths used in population
	 * @param {Promise} promise
	 */
	
	function completeMany (model, docs, fields, self, pop, promise) {
	  var arr = [];
	  var count = docs.length;
	  var len = count;
	  var opts = pop ?
	    { populated: pop }
	    : undefined;
	  for (var i=0; i < len; ++i) {
	    arr[i] = helpers.createModel(model, docs[i], fields);
	    arr[i].init(docs[i], opts, function (err) {
	      if (err) return promise.error(err);
	      --count || promise.complete(arr);
	    });
	  }
	}
	
	/**
	 * Declares the query a findOne operation. When executed, the first found document is passed to the callback.
	 *
	 * Passing a `callback` executes the query. The result of the query is a single document.
	 *
	 * ####Example
	 *
	 *     var query  = Kitten.where({ color: 'white' });
	 *     query.findOne(function (err, kitten) {
	 *       if (err) return handleError(err);
	 *       if (kitten) {
	 *         // doc may be null if no document matched
	 *       }
	 *     });
	 *
	 * @param {Object|Query} [criteria] mongodb selector
	 * @param {Object} [projection] optional fields to return (http://bit.ly/1HotzBo)
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @see findOne http://docs.mongodb.org/manual/reference/method/db.collection.findOne/
	 * @api public
	 */
	
	Query.prototype.findOne = function (conditions, projection, options, callback) {
	  if ('function' == typeof conditions) {
	    callback = conditions;
	    conditions = null;
	    projection = null;
	    options = null;
	  } else if ('function' == typeof projection) {
	    callback = projection;
	    options = null;
	    projection = null;
	  } else if ('function' == typeof options) {
	    callback = options;
	    options = null;
	  }
	
	  // make sure we don't send in the whole Document to merge()
	  if (conditions instanceof Document) {
	    conditions = conditions.toObject();
	  }
	
	  if (options) {
	    this.setOptions(options);
	  }
	
	  if (projection) {
	    this.select(projection);
	  }
	
	  if (mquery.canMerge(conditions)) {
	    this.merge(conditions);
	  }
	
	  prepareDiscriminatorCriteria(this);
	
	  try {
	    this.cast(this.model);
	    this._castError = null;
	  } catch (err) {
	    this._castError = err;
	  }
	
	  if (!callback) {
	    // already merged in the conditions, don't need to send them in.
	    return Query.base.findOne.call(this);
	  }
	
	  var promise;
	  if (this.schema) {
	    promise = new Promise(function(error, doc) {
	      if (error) {
	        return callback(error);
	      }
	      self.model.hooks.execPost('findOne', self, [doc], function(error, doc) {
	        if (error) {
	          return callback(error);
	        }
	        return callback(null, doc);
	      });
	    });
	  } else {
	    promise = new Promise(callback);
	  }
	
	  if (this._castError) {
	    promise.error(this._castError);
	    return this;
	  }
	
	  this._applyPaths();
	  this._fields = this._castFields(this._fields);
	
	  var options = this._mongooseOptions;
	  projection = this._fieldsForExec();
	  var self = this;
	
	  this.model.hooks.execPre('findOne', this, function(error) {
	    if (error) {
	      return promise.error(error);
	    }
	    // don't pass in the conditions because we already merged them in
	    Query.base.findOne.call(self, {}, function(err, doc) {
	      if (err) return promise.error(err);
	      if (!doc) return promise.complete(null);
	
	      if (!options.populate) {
	        return true === options.lean
	          ? promise.complete(doc)
	          : completeOne(self.model, doc, projection, self, null, promise);
	      }
	
	      var pop = helpers.preparePopulationOptionsMQ(self, options);
	      self.model.populate(doc, pop, function(err, doc) {
	        if (err) return promise.error(err);
	
	        return true === options.lean
	          ? promise.complete(doc)
	          : completeOne(self.model, doc, projection, self, pop, promise);
	      });
	    });
	  });
	
	  return this;
	}
	
	/**
	 * Internal helper for count
	 *
	 * @param {Object} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @see count http://docs.mongodb.org/manual/reference/method/db.collection.count/
	 * @api private
	 */
	
	function _count(conditions, callback) {
	  try {
	    this.cast(this.model);
	  } catch (err) {
	    process.nextTick(function() {
	      callback(err);
	    });
	    return this;
	  }
	
	  var conds = this._conditions;
	  var options = this._optionsForExec();
	
	  this._collection.count(conds, options, utils.tick(callback));
	}
	
	/**
	 * Specifying this query as a `count` query.
	 *
	 * Passing a `callback` executes the query.
	 *
	 * ####Example:
	 *
	 *     var countQuery = model.where({ 'color': 'black' }).count();
	 *
	 *     query.count({ color: 'black' }).count(callback)
	 *
	 *     query.count({ color: 'black' }, callback)
	 *
	 *     query.where('color', 'black').count(function (err, count) {
	 *       if (err) return handleError(err);
	 *       console.log('there are %d kittens', count);
	 *     })
	 *
	 * @param {Object} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @see count http://docs.mongodb.org/manual/reference/method/db.collection.count/
	 * @api public
	 */
	
	Query.prototype.count = function (conditions, callback) {
	  if ('function' == typeof conditions) {
	    callback = conditions;
	    conditions = undefined;
	  }
	
	  if (mquery.canMerge(conditions)) {
	    this.merge(conditions);
	  }
	
	  this.op = 'count';
	  if (!callback) {
	    return this;
	  }
	
	  this.model.hooks.wrap('count', _count, this, [conditions, callback]);
	
	  return this;
	}
	
	/**
	 * Declares or executes a distict() operation.
	 *
	 * Passing a `callback` executes the query.
	 *
	 * ####Example
	 *
	 *     distinct(field, conditions, callback)
	 *     distinct(field, conditions)
	 *     distinct(field, callback)
	 *     distinct(field)
	 *     distinct(callback)
	 *     distinct()
	 *
	 * @param {String} [field]
	 * @param {Object|Query} [criteria]
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @see distinct http://docs.mongodb.org/manual/reference/method/db.collection.distinct/
	 * @api public
	 */
	
	Query.prototype.distinct = function (field, conditions, callback) {
	  if (!callback) {
	    if ('function' === typeof conditions) {
	      callback = conditions;
	      conditions = undefined;
	    } else if ('function' === typeof field) {
	      callback = field;
	      field = undefined;
	      conditions = undefined;
	    }
	  }
	
	  if (conditions instanceof Document) {
	    conditions = conditions.toObject();
	  }
	
	  if (mquery.canMerge(conditions)) {
	    this.merge(conditions)
	  }
	
	  try {
	    this.cast(this.model);
	  } catch (err) {
	    if (!callback) {
	      throw err;
	    }
	    callback(err);
	    return this;
	  }
	
	  return Query.base.distinct.call(this, {}, field, callback);
	}
	
	/**
	 * Sets the sort order
	 *
	 * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.
	 *
	 * If a string is passed, it must be a space delimited list of path names. The
	 * sort order of each path is ascending unless the path name is prefixed with `-`
	 * which will be treated as descending.
	 *
	 * ####Example
	 *
	 *     // sort by "field" ascending and "test" descending
	 *     query.sort({ field: 'asc', test: -1 });
	 *
	 *     // equivalent
	 *     query.sort('field -test');
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @param {Object|String} arg
	 * @return {Query} this
	 * @see cursor.sort http://docs.mongodb.org/manual/reference/method/cursor.sort/
	 * @api public
	 */
	
	Query.prototype.sort = function (arg) {
	  var nArg = {};
	
	  if (arguments.length > 1) {
	    throw new Error("sort() only takes 1 Argument");
	  }
	
	  if (Array.isArray(arg)) {
	    // time to deal with the terrible syntax
	    for (var i=0; i < arg.length; i++) {
	      if (!Array.isArray(arg[i])) throw new Error("Invalid sort() argument.");
	      nArg[arg[i][0]] = arg[i][1];
	    }
	
	  } else {
	    nArg = arg;
	  }
	
	  // workaround for gh-2374 when sort is called after count
	  // if previous operation is count, we ignore
	  if (this.op == 'count') {
	    delete this.op;
	  }
	  return Query.base.sort.call(this, nArg);
	}
	
	/**
	 * Declare and/or execute this query as a remove() operation.
	 *
	 * ####Example
	 *
	 *     Model.remove({ artist: 'Anne Murray' }, callback)
	 *
	 * ####Note
	 *
	 * The operation is only executed when a callback is passed. To force execution without a callback (which would be an unsafe write), we must first call remove() and then execute it by using the `exec()` method.
	 *
	 *     // not executed
	 *     var query = Model.find().remove({ name: 'Anne Murray' })
	 *
	 *     // executed
	 *     query.remove({ name: 'Anne Murray' }, callback)
	 *     query.remove({ name: 'Anne Murray' }).remove(callback)
	 *
	 *     // executed without a callback (unsafe write)
	 *     query.exec()
	 *
	 *     // summary
	 *     query.remove(conds, fn); // executes
	 *     query.remove(conds)
	 *     query.remove(fn) // executes
	 *     query.remove()
	 *
	 * @param {Object|Query} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @see remove http://docs.mongodb.org/manual/reference/method/db.collection.remove/
	 * @api public
	 */
	
	Query.prototype.remove = function (cond, callback) {
	  if ('function' == typeof cond) {
	    callback = cond;
	    cond = null;
	  }
	
	  var cb = 'function' == typeof callback;
	
	  try {
	    this.cast(this.model);
	  } catch (err) {
	    if (cb) return process.nextTick(callback.bind(null, err));
	    return this;
	  }
	
	  return Query.base.remove.call(this, cond, callback);
	}
	
	/*!
	 * hydrates a document
	 *
	 * @param {Model} model
	 * @param {Document} doc
	 * @param {Object} fields
	 * @param {Query} self
	 * @param {Array} [pop] array of paths used in population
	 * @param {Promise} promise
	 */
	
	function completeOne (model, doc, fields, self, pop, promise) {
	  var opts = pop ?
	    { populated: pop }
	    : undefined;
	
	  var casted = helpers.createModel(model, doc, fields);
	  casted.init(doc, opts, function (err) {
	    if (err) return promise.error(err);
	    promise.complete(casted);
	  });
	}
	
	/*!
	 * If the model is a discriminator type and not root, then add the key & value to the criteria.
	 */
	
	function prepareDiscriminatorCriteria(query) {
	  if (!query || !query.model || !query.model.schema) {
	    return;
	  }
	
	  var schema = query.model.schema;
	
	  if (schema && schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
	    query._conditions[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
	  }
	}
	
	/**
	 * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.
	 *
	 * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed.
	 *
	 * ####Available options
	 *
	 * - `new`: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)
	 * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 *
	 * ####Examples
	 *
	 *     query.findOneAndUpdate(conditions, update, options, callback) // executes
	 *     query.findOneAndUpdate(conditions, update, options)  // returns Query
	 *     query.findOneAndUpdate(conditions, update, callback) // executes
	 *     query.findOneAndUpdate(conditions, update)           // returns Query
	 *     query.findOneAndUpdate(update, callback)             // returns Query
	 *     query.findOneAndUpdate(update)                       // returns Query
	 *     query.findOneAndUpdate(callback)                     // executes
	 *     query.findOneAndUpdate()                             // returns Query
	 *
	 * @method findOneAndUpdate
	 * @memberOf Query
	 * @param {Object|Query} [query]
	 * @param {Object} [doc]
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.findOneAndUpdate = function() {
	  var hasCallback = arguments.length &&
	    typeof arguments[arguments.length - 1] === 'function';
	
	  if (hasCallback && this.schema) {
	    this.model.hooks.wrap('findOneAndUpdate', Query.base.findOneAndUpdate,
	      this, Array.prototype.slice.call(arguments));
	  } else {
	    Query.base.findOneAndUpdate.apply(this, arguments);
	  }
	
	  return this;
	};
	
	/**
	 * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.
	 *
	 * Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if `callback` is passed.
	 *
	 * ####Available options
	 *
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 *
	 * ####Examples
	 *
	 *     A.where().findOneAndRemove(conditions, options, callback) // executes
	 *     A.where().findOneAndRemove(conditions, options)  // return Query
	 *     A.where().findOneAndRemove(conditions, callback) // executes
	 *     A.where().findOneAndRemove(conditions) // returns Query
	 *     A.where().findOneAndRemove(callback)   // executes
	 *     A.where().findOneAndRemove()           // returns Query
	 *
	 * @method findOneAndRemove
	 * @memberOf Query
	 * @param {Object} [conditions]
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 * @api public
	 */
	
	Query.prototype.findOneAndRemove = function() {
	  var hasCallback = arguments.length &&
	    typeof arguments[arguments.length - 1] === 'function';
	
	  if (hasCallback && this.schema) {
	    this.model.hooks.wrap('findOneAndRemove', Query.base.findOneAndRemove,
	      this, Array.prototype.slice.call(arguments));
	  } else {
	    Query.base.findOneAndRemove.apply(this, arguments);
	  }
	
	  return this;
	};
	
	/**
	 * Override mquery.prototype._findAndModify to provide casting etc.
	 *
	 * @param {String} type - either "remove" or "update"
	 * @param {Function} callback
	 * @api private
	 */
	
	Query.prototype._findAndModify = function (type, callback) {
	  if ('function' != typeof callback) {
	    throw new Error("Expected callback in _findAndModify");
	  }
	
	  var model = this.model;
	  var schema = model.schema;
	  var promise = new Promise(callback);
	  var self = this;
	  var castedQuery;
	  var castedDoc;
	  var fields;
	  var opts;
	  var doValidate;
	
	  castedQuery = castQuery(this);
	  if (castedQuery instanceof Error) {
	    process.nextTick(promise.error.bind(promise, castedQuery));
	    return promise;
	  }
	
	  opts = this._optionsForExec(model);
	
	  if ('strict' in opts) {
	    this._mongooseOptions.strict = opts.strict;
	  }
	
	  if ('remove' == type) {
	    opts.remove = true;
	  } else {
	    if (!('new' in opts)) {
	      opts.new = false;
	    }
	    if (!('upsert' in opts)) {
	      opts.upsert = false;
	    }
	    if (opts.upsert || opts['new']) {
	      opts.remove = false;
	    }
	
	    castedDoc = castDoc(this, opts.overwrite);
	    if (!castedDoc) {
	      if (opts.upsert) {
	        // still need to do the upsert to empty doc
	        var doc = utils.clone(castedQuery);
	        delete doc._id;
	        castedDoc = { $set: doc };
	      } else {
	        return this.findOne(callback);
	      }
	    } else if (castedDoc instanceof Error) {
	      process.nextTick(promise.error.bind(promise, castedDoc));
	      return promise;
	    } else {
	      // In order to make MongoDB 2.6 happy (see
	      // https://jira.mongodb.org/browse/SERVER-12266 and related issues)
	      // if we have an actual update document but $set is empty, junk the $set.
	      if (castedDoc.$set && Object.keys(castedDoc.$set).length === 0) {
	        delete castedDoc.$set;
	      }
	    }
	
	    doValidate = updateValidators(this, schema, castedDoc, opts);
	  }
	
	  this._applyPaths();
	
	  var self = this;
	  var options = this._mongooseOptions;
	
	  if (this._fields) {
	    fields = utils.clone(this._fields);
	    opts.fields = this._castFields(fields);
	    if (opts.fields instanceof Error) {
	      process.nextTick(promise.error.bind(promise, opts.fields));
	      return promise;
	    }
	  }
	
	  if (opts.sort) convertSortToArray(opts);
	
	  var cb = function(err, doc) {
	    if (err) return promise.error(err);
	
	    if (!doc || (utils.isObject(doc) && Object.keys(doc).length === 0)) {
	      return promise.complete(null);
	    }
	
	    if (!options.populate) {
	      return true === options.lean
	        ? promise.complete(doc)
	        : completeOne(self.model, doc, fields, self, null, promise);
	    }
	
	    var pop = helpers.preparePopulationOptionsMQ(self, options);
	    self.model.populate(doc, pop, function (err, doc) {
	      if (err) return promise.error(err);
	
	      return true === options.lean
	        ? promise.complete(doc)
	        : completeOne(self.model, doc, fields, self, pop, promise);
	    });
	  };
	
	  if ((opts.runValidators || opts.setDefaultsOnInsert) && doValidate) {
	    doValidate(function(error) {
	      if (error) {
	        return promise.error(error);
	      }
	      self._collection.findAndModify(castedQuery, castedDoc, opts, utils.tick(function(error, res) {
	        return cb(error, res ? res.value : res);
	      }));
	    });
	  } else {
	    this._collection.findAndModify(castedQuery, castedDoc, opts, utils.tick(function(error, res) {
	      return cb(error, res ? res.value : res);
	    }));
	  }
	
	  return promise;
	}
	
	/**
	 * Override mquery.prototype._mergeUpdate to handle mongoose objects in
	 * updates.
	 *
	 * @param {Object} doc
	 * @api private
	 */
	
	Query.prototype._mergeUpdate = function(doc) {
	  if (!this._update) this._update = {};
	  if (doc instanceof Query) {
	    if (doc._update) {
	      utils.mergeClone(this._update, doc._update);
	    }
	  } else {
	    utils.mergeClone(this._update, doc);
	  }
	};
	
	/*!
	 * The mongodb driver 1.3.23 only supports the nested array sort
	 * syntax. We must convert it or sorting findAndModify will not work.
	 */
	
	function convertSortToArray (opts) {
	  if (Array.isArray(opts.sort)) return;
	  if (!utils.isObject(opts.sort)) return;
	
	  var sort = [];
	
	  for (var key in opts.sort) if (utils.object.hasOwnProperty(opts.sort, key)) {
	    sort.push([ key, opts.sort[key] ]);
	  }
	
	  opts.sort = sort;
	};
	
	/**
	 * Internal helper for update
	 *
	 * @param {Object} castedQuery
	 * @param {Object} castedDoc the update command
	 * @param {Object} options
	 * @param {Function} callback
	 * @return {Query} this
	 * @see Model.update #model_Model.update
	 * @api private
	 */
	Query.prototype._execUpdate = function(castedQuery, castedDoc, options, callback) {
	  var schema = this.model.schema;
	  var doValidate;
	  var _this;
	
	  if (this.options.runValidators || this.options.setDefaultsOnInsert) {
	    _this = this;
	    doValidate = updateValidators(this, schema, castedDoc, options);
	    doValidate(function(err) {
	      if (err) {
	        return callback(err);
	      }
	
	      Query.base.update.call(_this, castedQuery, castedDoc, options, callback);
	    });
	    return this;
	  }
	
	  Query.base.update.call(this, castedQuery, castedDoc, options, callback);
	  return this;
	};
	
	/**
	 * Declare and/or execute this query as an update() operation.
	 *
	 * _All paths passed that are not $atomic operations will become $set ops._
	 *
	 * ####Example
	 *
	 *     Model.where({ _id: id }).update({ title: 'words' })
	 *
	 *     // becomes
	 *
	 *     Model.where({ _id: id }).update({ $set: { title: 'words' }})
	 *
	 * ####Note
	 *
	 * Passing an empty object `{}` as the doc will result in a no-op unless the `overwrite` option is passed. Without the `overwrite` option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection.
	 *
	 * ####Note
	 *
	 * The operation is only executed when a callback is passed. To force execution without a callback (which would be an unsafe write), we must first call update() and then execute it by using the `exec()` method.
	 *
	 *     var q = Model.where({ _id: id });
	 *     q.update({ $set: { name: 'bob' }}).update(); // not executed
	 *
	 *     q.update({ $set: { name: 'bob' }}).exec(); // executed as unsafe
	 *
	 *     // keys that are not $atomic ops become $set.
	 *     // this executes the same command as the previous example.
	 *     q.update({ name: 'bob' }).exec();
	 *
	 *     // overwriting with empty docs
	 *     var q = Model.where({ _id: id }).setOptions({ overwrite: true })
	 *     q.update({ }, callback); // executes
	 *
	 *     // multi update with overwrite to empty doc
	 *     var q = Model.where({ _id: id });
	 *     q.setOptions({ multi: true, overwrite: true })
	 *     q.update({ });
	 *     q.update(callback); // executed
	 *
	 *     // multi updates
	 *     Model.where()
	 *          .update({ name: /^match/ }, { $set: { arr: [] }}, { multi: true }, callback)
	 *
	 *     // more multi updates
	 *     Model.where()
	 *          .setOptions({ multi: true })
	 *          .update({ $set: { arr: [] }}, callback)
	 *
	 *     // single update by default
	 *     Model.where({ email: 'address@example.com' })
	 *          .update({ $inc: { counter: 1 }}, callback)
	 *
	 * API summary
	 *
	 *     update(criteria, doc, options, cb) // executes
	 *     update(criteria, doc, options)
	 *     update(criteria, doc, cb) // executes
	 *     update(criteria, doc)
	 *     update(doc, cb) // executes
	 *     update(doc)
	 *     update(cb) // executes
	 *     update(true) // executes (unsafe write)
	 *     update()
	 *
	 * @param {Object} [criteria]
	 * @param {Object} [doc] the update command
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @see Model.update #model_Model.update
	 * @see update http://docs.mongodb.org/manual/reference/method/db.collection.update/
	 * @api public
	 */
	
	Query.prototype.update = function (conditions, doc, options, callback) {
	  if ('function' === typeof options) {
	    // Scenario: update(conditions, doc, callback)
	    callback = options;
	    options = null;
	  } else if ('function' === typeof doc) {
	    // Scenario: update(doc, callback);
	    callback = doc;
	    doc = conditions;
	    conditions = {};
	    options = null;
	  } else if ('function' === typeof conditions) {
	    callback = conditions;
	    conditions = undefined;
	    doc = undefined;
	    options = undefined;
	  }
	
	  // make sure we don't send in the whole Document to merge()
	  if (conditions instanceof Document) {
	    conditions = conditions.toObject();
	  }
	
	  var oldCb = callback;
	  if (oldCb) {
	    callback = function(error, result) {
	      oldCb(error, result ? result.result : { ok: 0, n: 0, nModified: 0 });
	    };
	  }
	
	  // strict is an option used in the update checking, make sure it gets set
	  if (options) {
	    if ('strict' in options) {
	      this._mongooseOptions.strict = options.strict;
	    }
	  }
	
	  // if doc is undefined at this point, this means this function is being
	  // executed by exec(not always see below). Grab the update doc from here in
	  // order to validate
	  // This could also be somebody calling update() or update({}). Probably not a
	  // common use case, check for _update to make sure we don't do anything bad
	  if (!doc && this._update) {
	    doc = this._updateForExec();
	  }
	
	  if (mquery.canMerge(conditions)) {
	    this.merge(conditions);
	  }
	
	  // validate the selector part of the query
	  var castedQuery = castQuery(this);
	  if (castedQuery instanceof Error) {
	    if(callback) {
	      callback(castedQuery);
	      return this;
	    } else {
	      throw castedQuery;
	    }
	  }
	
	  // validate the update part of the query
	  var castedDoc;
	  try {
	    castedDoc = this._castUpdate(doc, options && options.overwrite);
	  } catch (err) {
	    if (callback) {
	      callback(err);
	      return this;
	    } else {
	      throw err;
	    }
	  }
	
	  if (!castedDoc) {
	    // Make sure promises know that this is still an update, see gh-2796
	    this.op = 'update';
	    callback && callback(null);
	    return this;
	  }
	
	  if (utils.isObject(options)) {
	    this.setOptions(options);
	  }
	
	  // Hooks
	  if (callback) {
	    return this._execUpdate(castedQuery, castedDoc, options, callback);
	  }
	
	  return Query.base.update.call(this, castedQuery, castedDoc, options, callback);
	}
	
	/**
	 * Executes the query
	 *
	 * ####Examples:
	 *
	 *     var promise = query.exec();
	 *     var promise = query.exec('update');
	 *
	 *     query.exec(callback);
	 *     query.exec('find', callback);
	 *
	 * @param {String|Function} [operation]
	 * @param {Function} [callback]
	 * @return {Promise}
	 * @api public
	 */
	
	Query.prototype.exec = function exec (op, callback) {
	  var promise = new Promise();
	  var _this = this;
	
	  if ('function' == typeof op) {
	    callback = op;
	    op = null;
	  } else if ('string' == typeof op) {
	    this.op = op;
	  }
	
	  if (callback) promise.addBack(callback);
	
	  if (!this.op) {
	    promise.complete();
	    return promise;
	  }
	
	  this[this.op].call(this, promise.resolve.bind(promise));
	
	  return promise;
	}
	
	/**
	 * Finds the schema for `path`. This is different than
	 * calling `schema.path` as it also resolves paths with
	 * positional selectors (something.$.another.$.path).
	 *
	 * @param {String} path
	 * @api private
	 */
	
	Query.prototype._getSchema = function _getSchema (path) {
	  return this.model._getSchema(path);
	}
	
	/*!
	 * These operators require casting docs
	 * to real Documents for Update operations.
	 */
	
	var castOps = {
	    $push: 1
	  , $pushAll: 1
	  , $addToSet: 1
	  , $set: 1
	};
	
	/*!
	 * These operators should be cast to numbers instead
	 * of their path schema type.
	 */
	
	var numberOps = {
	    $pop: 1
	  , $unset: 1
	  , $inc: 1
	};
	
	/**
	 * Casts obj for an update command.
	 *
	 * @param {Object} obj
	 * @return {Object} obj after casting its values
	 * @api private
	 */
	
	Query.prototype._castUpdate = function _castUpdate (obj, overwrite) {
	  if (!obj) return undefined;
	
	  var ops = Object.keys(obj)
	    , i = ops.length
	    , ret = {}
	    , hasKeys
	    , val;
	
	  while (i--) {
	    var op = ops[i];
	    // if overwrite is set, don't do any of the special $set stuff
	    if ('$' !== op[0] && !overwrite) {
	      // fix up $set sugar
	      if (!ret.$set) {
	        if (obj.$set) {
	          ret.$set = obj.$set;
	        } else {
	          ret.$set = {};
	        }
	      }
	      ret.$set[op] = obj[op];
	      ops.splice(i, 1);
	      if (!~ops.indexOf('$set')) ops.push('$set');
	    } else if ('$set' === op) {
	      if (!ret.$set) {
	        ret[op] = obj[op];
	      }
	    } else {
	      ret[op] = obj[op];
	    }
	  }
	
	  // cast each value
	  i = ops.length;
	
	  // if we get passed {} for the update, we still need to respect that when it
	  // is an overwrite scenario
	  if (overwrite) {
	    hasKeys = true;
	  }
	
	  while (i--) {
	    op = ops[i];
	    val = ret[op];
	    if (val && 'Object' === val.constructor.name && !overwrite) {
	      hasKeys |= this._walkUpdatePath(val, op);
	    } else if (overwrite && 'Object' === ret.constructor.name) {
	      // if we are just using overwrite, cast the query and then we will
	      // *always* return the value, even if it is an empty object. We need to
	      // set hasKeys above because we need to account for the case where the
	      // user passes {} and wants to clobber the whole document
	      // Also, _walkUpdatePath expects an operation, so give it $set since that
	      // is basically what we're doing
	      this._walkUpdatePath(ret.$set || ret, '$set');
	    } else {
	      var msg = 'Invalid atomic update value for ' + op + '. '
	              + 'Expected an object, received ' + typeof val;
	      throw new Error(msg);
	    }
	  }
	
	  return hasKeys && ret;
	}
	
	/**
	 * Walk each path of obj and cast its values
	 * according to its schema.
	 *
	 * @param {Object} obj - part of a query
	 * @param {String} op - the atomic operator ($pull, $set, etc)
	 * @param {String} pref - path prefix (internal only)
	 * @return {Bool} true if this path has keys to update
	 * @api private
	 */
	
	Query.prototype._walkUpdatePath = function _walkUpdatePath (obj, op, pref) {
	  var prefix = pref ? pref + '.' : ''
	    , keys = Object.keys(obj)
	    , i = keys.length
	    , hasKeys = false
	    , schema
	    , key
	    , val;
	
	  var strict = 'strict' in this._mongooseOptions
	    ? this._mongooseOptions.strict
	    : this.model.schema.options.strict;
	
	  while (i--) {
	    key = keys[i];
	    val = obj[key];
	
	    if (val && 'Object' === val.constructor.name) {
	      // watch for embedded doc schemas
	      schema = this._getSchema(prefix + key);
	      if (schema && schema.caster && op in castOps) {
	        // embedded doc schema
	
	        if (strict && !schema) {
	          // path is not in our strict schema
	          if ('throw' == strict) {
	            throw new Error('Field `' + key + '` is not in schema.');
	          } else {
	            // ignore paths not specified in schema
	            delete obj[key];
	          }
	        } else {
	          hasKeys = true;
	
	          if ('$each' in val) {
	            obj[key] = {
	                $each: this._castUpdateVal(schema, val.$each, op)
	            }
	
	            if (val.$slice) {
	              obj[key].$slice = val.$slice | 0;
	            }
	
	            if (val.$sort) {
	              obj[key].$sort = val.$sort;
	            }
	
	            if (!!val.$position || val.$position === 0) {
	              obj[key].$position = val.$position;
	            }
	          } else {
	            obj[key] = this._castUpdateVal(schema, val, op);
	          }
	        }
	      } else if (op === '$currentDate') {
	        // $currentDate can take an object
	        obj[key] = this._castUpdateVal(schema, val, op);
	        hasKeys = true;
	      } else if (op === '$set' && schema) {
	        obj[key] = this._castUpdateVal(schema, val, op);
	        hasKeys = true;
	      } else {
	        // gh-2314
	        // we should be able to set a schema-less field
	        // to an empty object literal
	        hasKeys |= this._walkUpdatePath(val, op, prefix + key) ||
	                   (utils.isObject(val) && Object.keys(val).length === 0);
	      }
	    } else {
	      schema = ('$each' === key || '$or' === key || '$and' === key)
	        ? this._getSchema(pref)
	        : this._getSchema(prefix + key);
	
	      var skip = strict &&
	                 !schema &&
	                 !/real|nested/.test(this.model.schema.pathType(prefix + key));
	
	      if (skip) {
	        if ('throw' == strict) {
	          throw new Error('Field `' + prefix + key + '` is not in schema.');
	        } else {
	          delete obj[key];
	        }
	      } else {
	        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking
	        // improving this.
	        if (op === '$rename') {
	          hasKeys = true;
	          return;
	        }
	
	        hasKeys = true;
	        obj[key] = this._castUpdateVal(schema, val, op, key);
	      }
	    }
	  }
	  return hasKeys;
	}
	
	/**
	 * Casts `val` according to `schema` and atomic `op`.
	 *
	 * @param {Schema} schema
	 * @param {Object} val
	 * @param {String} op - the atomic operator ($pull, $set, etc)
	 * @param {String} [$conditional]
	 * @api private
	 */
	
	Query.prototype._castUpdateVal = function _castUpdateVal (schema, val, op, $conditional) {
	  if (!schema) {
	    // non-existing schema path
	    return op in numberOps
	      ? Number(val)
	      : val
	  }
	
	  var cond = schema.caster && op in castOps &&
	    (utils.isObject(val) || Array.isArray(val));
	  if (cond) {
	    // Cast values for ops that add data to MongoDB.
	    // Ensures embedded documents get ObjectIds etc.
	    var tmp = schema.cast(val);
	
	    if (Array.isArray(val)) {
	      val = tmp;
	    } else {
	      val = tmp[0];
	    }
	  }
	
	  if (op in numberOps) {
	    return Number(val);
	  }
	  if (op === '$currentDate') {
	    if (typeof val === 'object') {
	      return { $type: val.$type };
	    }
	    return Boolean(val);
	  }
	  if (/^\$/.test($conditional)) {
	    return schema.castForQuery($conditional, val);
	  }
	
	  return schema.castForQuery(val);
	}
	
	/*!
	 * castQuery
	 * @api private
	 */
	
	function castQuery (query) {
	  try {
	    return query.cast(query.model);
	  } catch (err) {
	    return err;
	  }
	}
	
	/*!
	 * castDoc
	 * @api private
	 */
	
	function castDoc (query, overwrite) {
	  try {
	    return query._castUpdate(query._update, overwrite);
	  } catch (err) {
	    return err;
	  }
	}
	
	/**
	 * Specifies paths which should be populated with other documents.
	 *
	 * ####Example:
	 *
	 *     Kitten.findOne().populate('owner').exec(function (err, kitten) {
	 *       console.log(kitten.owner.name) // Max
	 *     })
	 *
	 *     Kitten.find().populate({
	 *         path: 'owner'
	 *       , select: 'name'
	 *       , match: { color: 'black' }
	 *       , options: { sort: { name: -1 }}
	 *     }).exec(function (err, kittens) {
	 *       console.log(kittens[0].owner.name) // Zoopa
	 *     })
	 *
	 *     // alternatively
	 *     Kitten.find().populate('owner', 'name', null, {sort: { name: -1 }}).exec(function (err, kittens) {
	 *       console.log(kittens[0].owner.name) // Zoopa
	 *     })
	 *
	 * Paths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.
	 *
	 * @param {Object|String} path either the path to populate or an object specifying all parameters
	 * @param {Object|String} [select] Field selection for the population query
	 * @param {Model} [model] The name of the model you wish to use for population. If not specified, the name is looked up from the Schema ref.
	 * @param {Object} [match] Conditions for the population query
	 * @param {Object} [options] Options for the population query (sort, etc)
	 * @see population ./populate.html
	 * @see Query#select #query_Query-select
	 * @see Model.populate #model_Model.populate
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.populate = function () {
	  var res = utils.populate.apply(null, arguments);
	  var opts = this._mongooseOptions;
	
	  if (!utils.isObject(opts.populate)) {
	    opts.populate = {};
	  }
	
	  for (var i = 0; i < res.length; ++i) {
	    opts.populate[res[i].path] = res[i];
	  }
	
	  return this;
	}
	
	/**
	 * Casts this query to the schema of `model`
	 *
	 * ####Note
	 *
	 * If `obj` is present, it is cast instead of this query.
	 *
	 * @param {Model} model
	 * @param {Object} [obj]
	 * @return {Object}
	 * @api public
	 */
	
	Query.prototype.cast = function (model, obj) {
	  obj || (obj = this._conditions);
	
	  return cast(model.schema, obj);
	}
	
	/**
	 * Casts selected field arguments for field selection with mongo 2.2
	 *
	 *     query.select({ ids: { $elemMatch: { $in: [hexString] }})
	 *
	 * @param {Object} fields
	 * @see https://github.com/Automattic/mongoose/issues/1091
	 * @see http://docs.mongodb.org/manual/reference/projection/elemMatch/
	 * @api private
	 */
	
	Query.prototype._castFields = function _castFields (fields) {
	  var selected
	    , elemMatchKeys
	    , keys
	    , key
	    , out
	    , i
	
	  if (fields) {
	    keys = Object.keys(fields);
	    elemMatchKeys = [];
	    i = keys.length;
	
	    // collect $elemMatch args
	    while (i--) {
	      key = keys[i];
	      if (fields[key].$elemMatch) {
	        selected || (selected = {});
	        selected[key] = fields[key];
	        elemMatchKeys.push(key);
	      }
	    }
	  }
	
	  if (selected) {
	    // they passed $elemMatch, cast em
	    try {
	      out = this.cast(this.model, selected);
	    } catch (err) {
	      return err;
	    }
	
	    // apply the casted field args
	    i = elemMatchKeys.length;
	    while (i--) {
	      key = elemMatchKeys[i];
	      fields[key] = out[key];
	    }
	  }
	
	  return fields;
	}
	
	/**
	 * Applies schematype selected options to this query.
	 * @api private
	 */
	
	Query.prototype._applyPaths = function applyPaths () {
	  // determine if query is selecting or excluding fields
	
	  var fields = this._fields
	    , exclude
	    , keys
	    , ki
	
	  if (fields) {
	    keys = Object.keys(fields);
	    ki = keys.length;
	
	    while (ki--) {
	      if ('+' == keys[ki][0]) continue;
	      exclude = 0 === fields[keys[ki]];
	      break;
	    }
	  }
	
	  // if selecting, apply default schematype select:true fields
	  // if excluding, apply schematype select:false fields
	
	  var selected = []
	    , excluded = []
	    , seen = [];
	
	  var analyzePath = function(path, type) {
	    if ('boolean' != typeof type.selected) return;
	
	    var plusPath = '+' + path;
	    if (fields && plusPath in fields) {
	      // forced inclusion
	      delete fields[plusPath];
	
	      // if there are other fields being included, add this one
	      // if no other included fields, leave this out (implied inclusion)
	      if (false === exclude && keys.length > 1 && !~keys.indexOf(path)) {
	        fields[path] = 1;
	      }
	
	      return
	    };
	
	    // check for parent exclusions
	    var root = path.split('.')[0];
	    if (~excluded.indexOf(root)) return;
	
	    ;(type.selected ? selected : excluded).push(path);
	  };
	
	  var analyzeSchema = function(schema, prefix) {
	    prefix || (prefix = '');
	
	    // avoid recursion
	    if (~seen.indexOf(schema)) return;
	    seen.push(schema);
	
	    schema.eachPath(function (path, type) {
	      if (prefix) path = prefix + '.' + path;
	
	      analyzePath(path, type);
	
	      // array of subdocs?
	      if (type.schema) {
	        analyzeSchema(type.schema, path);
	      }
	
	    });
	  };
	
	  analyzeSchema(this.model.schema);
	
	  switch (exclude) {
	    case true:
	      excluded.length && this.select('-' + excluded.join(' -'));
	      break;
	    case false:
	      selected.length && this.select(selected.join(' '));
	      break;
	    case undefined:
	      // user didn't specify fields, implies returning all fields.
	      // only need to apply excluded fields
	      excluded.length && this.select('-' + excluded.join(' -'));
	      break;
	  }
	
	  return seen = excluded = selected = keys = fields = null;
	}
	
	/**
	 * Returns a Node.js 0.8 style [read stream](http://nodejs.org/docs/v0.8.21/api/stream.html#stream_readable_stream) interface.
	 *
	 * ####Example
	 *
	 *     // follows the nodejs 0.8 stream api
	 *     Thing.find({ name: /^hello/ }).stream().pipe(res)
	 *
	 *     // manual streaming
	 *     var stream = Thing.find({ name: /^hello/ }).stream();
	 *
	 *     stream.on('data', function (doc) {
	 *       // do something with the mongoose document
	 *     }).on('error', function (err) {
	 *       // handle the error
	 *     }).on('close', function () {
	 *       // the stream is closed
	 *     });
	 *
	 * ####Valid options
	 *
	 *   - `transform`: optional function which accepts a mongoose document. The return value of the function will be emitted on `data`.
	 *
	 * ####Example
	 *
	 *     // JSON.stringify all documents before emitting
	 *     var stream = Thing.find().stream({ transform: JSON.stringify });
	 *     stream.pipe(writeStream);
	 *
	 * @return {QueryStream}
	 * @param {Object} [options]
	 * @see QueryStream
	 * @api public
	 */
	
	Query.prototype.stream = function stream (opts) {
	  this._applyPaths();
	  this._fields = this._castFields(this._fields);
	  return new QueryStream(this, opts);
	}
	
	// the rest of these are basically to support older Mongoose syntax with mquery
	
	/**
	 * _DEPRECATED_ Alias of `maxScan`
	 *
	 * @deprecated
	 * @see maxScan #query_Query-maxScan
	 * @method maxscan
	 * @memberOf Query
	 */
	
	Query.prototype.maxscan = Query.base.maxScan;
	
	/**
	 * Sets the tailable option (for use with capped collections).
	 *
	 * ####Example
	 *
	 *     query.tailable() // true
	 *     query.tailable(true)
	 *     query.tailable(false)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @param {Boolean} bool defaults to true
	 * @see tailable http://docs.mongodb.org/manual/tutorial/create-tailable-cursor/
	 * @api public
	 */
	
	Query.prototype.tailable = function (val, opts) {
	  // we need to support the tailable({ awaitdata : true }) as well as the
	  // tailable(true, {awaitdata :true}) syntax that mquery does not support
	  if (val && val.constructor.name == 'Object') {
	    opts = val;
	    val = true;
	  }
	
	  if (val === undefined) {
	    val = true;
	  }
	
	  if (opts && typeof opts === 'object') {
	    for (var key in opts) {
	      if (key === 'awaitdata') {
	        // For backwards compatibility
	        this.options[key] = !!opts[key];
	      } else {
	        this.options[key] = opts[key];
	      }
	    }
	  }
	
	  return Query.base.tailable.call(this, val);
	}
	
	/**
	 * Declares an intersects query for `geometry()`.
	 *
	 * ####Example
	 *
	 *     query.where('path').intersects().geometry({
	 *         type: 'LineString'
	 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
	 *     })
	 *
	 *     query.where('path').intersects({
	 *         type: 'LineString'
	 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
	 *     })
	 *
	 * ####NOTE:
	 *
	 * **MUST** be used after `where()`.
	 *
	 * ####NOTE:
	 *
	 * In Mongoose 3.7, `intersects` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).
	 *
	 * @method intersects
	 * @memberOf Query
	 * @param {Object} [arg]
	 * @return {Query} this
	 * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/
	 * @see geoIntersects http://docs.mongodb.org/manual/reference/operator/geoIntersects/
	 * @api public
	 */
	
	/**
	 * Specifies a `$geometry` condition
	 *
	 * ####Example
	 *
	 *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]
	 *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })
	 *
	 *     // or
	 *     var polyB = [[ 0, 0 ], [ 1, 1 ]]
	 *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })
	 *
	 *     // or
	 *     var polyC = [ 0, 0 ]
	 *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })
	 *
	 *     // or
	 *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })
	 *
	 * The argument is assigned to the most recent path passed to `where()`.
	 *
	 * ####NOTE:
	 *
	 * `geometry()` **must** come after either `intersects()` or `within()`.
	 *
	 * The `object` argument must contain `type` and `coordinates` properties.
	 * - type {String}
	 * - coordinates {Array}
	 *
	 * @method geometry
	 * @memberOf Query
	 * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.
	 * @return {Query} this
	 * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/
	 * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @api public
	 */
	
	/**
	 * Specifies a `$near` or `$nearSphere` condition
	 *
	 * These operators return documents sorted by distance.
	 *
	 * ####Example
	 *
	 *     query.where('loc').near({ center: [10, 10] });
	 *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });
	 *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });
	 *     query.near('loc', { center: [10, 10], maxDistance: 5 });
	 *
	 * @method near
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Object} val
	 * @return {Query} this
	 * @see $near http://docs.mongodb.org/manual/reference/operator/near/
	 * @see $nearSphere http://docs.mongodb.org/manual/reference/operator/nearSphere/
	 * @see $maxDistance http://docs.mongodb.org/manual/reference/operator/maxDistance/
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @api public
	 */
	
	/*!
	 * Overwriting mquery is needed to support a couple different near() forms found in older
	 * versions of mongoose
	 * near([1,1])
	 * near(1,1)
	 * near(field, [1,2])
	 * near(field, 1, 2)
	 * In addition to all of the normal forms supported by mquery
	 */
	
	Query.prototype.near = function () {
	  var params = [];
	  var sphere = this._mongooseOptions.nearSphere;
	
	  // TODO refactor
	
	  if (arguments.length === 1) {
	    if (Array.isArray(arguments[0])) {
	      params.push({ center: arguments[0], spherical: sphere });
	    } else if ('string' == typeof arguments[0]) {
	      // just passing a path
	      params.push(arguments[0]);
	    } else if (utils.isObject(arguments[0])) {
	      if ('boolean' != typeof arguments[0].spherical) {
	        arguments[0].spherical = sphere;
	      }
	      params.push(arguments[0]);
	    } else {
	      throw new TypeError('invalid argument');
	    }
	  } else if (arguments.length === 2) {
	    if ('number' == typeof arguments[0] && 'number' == typeof arguments[1]) {
	      params.push({ center: [arguments[0], arguments[1]], spherical: sphere});
	    } else if ('string' == typeof arguments[0] && Array.isArray(arguments[1])) {
	      params.push(arguments[0]);
	      params.push({ center: arguments[1], spherical: sphere });
	    } else if ('string' == typeof arguments[0] && utils.isObject(arguments[1])) {
	      params.push(arguments[0]);
	      if ('boolean' != typeof arguments[1].spherical) {
	        arguments[1].spherical = sphere;
	      }
	      params.push(arguments[1]);
	    } else {
	      throw new TypeError('invalid argument');
	    }
	  } else if (arguments.length === 3) {
	    if ('string' == typeof arguments[0] && 'number' == typeof arguments[1]
	        && 'number' == typeof arguments[2]) {
	      params.push(arguments[0]);
	      params.push({ center: [arguments[1], arguments[2]], spherical: sphere });
	    } else {
	      throw new TypeError('invalid argument');
	    }
	  } else {
	    throw new TypeError('invalid argument');
	  }
	
	  return Query.base.near.apply(this, params);
	}
	
	/**
	 * _DEPRECATED_ Specifies a `$nearSphere` condition
	 *
	 * ####Example
	 *
	 *     query.where('loc').nearSphere({ center: [10, 10], maxDistance: 5 });
	 *
	 * **Deprecated.** Use `query.near()` instead with the `spherical` option set to `true`.
	 *
	 * ####Example
	 *
	 *     query.where('loc').near({ center: [10, 10], spherical: true });
	 *
	 * @deprecated
	 * @see near() #query_Query-near
	 * @see $near http://docs.mongodb.org/manual/reference/operator/near/
	 * @see $nearSphere http://docs.mongodb.org/manual/reference/operator/nearSphere/
	 * @see $maxDistance http://docs.mongodb.org/manual/reference/operator/maxDistance/
	 */
	
	Query.prototype.nearSphere = function () {
	  this._mongooseOptions.nearSphere = true;
	  this.near.apply(this, arguments);
	  return this;
	}
	
	/**
	 * Specifies a $polygon condition
	 *
	 * ####Example
	 *
	 *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])
	 *     query.polygon('loc', [10,20], [13, 25], [7,15])
	 *
	 * @method polygon
	 * @memberOf Query
	 * @param {String|Array} [path]
	 * @param {Array|Object} [coordinatePairs...]
	 * @return {Query} this
	 * @see $polygon http://docs.mongodb.org/manual/reference/operator/polygon/
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @api public
	 */
	
	/**
	 * Specifies a $box condition
	 *
	 * ####Example
	 *
	 *     var lowerLeft = [40.73083, -73.99756]
	 *     var upperRight= [40.741404,  -73.988135]
	 *
	 *     query.where('loc').within().box(lowerLeft, upperRight)
	 *     query.box({ ll : lowerLeft, ur : upperRight })
	 *
	 * @method box
	 * @memberOf Query
	 * @see $box http://docs.mongodb.org/manual/reference/operator/box/
	 * @see within() Query#within #query_Query-within
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @param {Object} val
	 * @param [Array] Upper Right Coords
	 * @return {Query} this
	 * @api public
	 */
	
	/*!
	 * this is needed to support the mongoose syntax of:
	 * box(field, { ll : [x,y], ur : [x2,y2] })
	 * box({ ll : [x,y], ur : [x2,y2] })
	 */
	
	Query.prototype.box = function (ll, ur) {
	  if (!Array.isArray(ll) && utils.isObject(ll)) {
	    ur = ll.ur;
	    ll = ll.ll;
	  }
	  return Query.base.box.call(this, ll, ur);
	}
	
	/**
	 * Specifies a $center or $centerSphere condition.
	 *
	 * ####Example
	 *
	 *     var area = { center: [50, 50], radius: 10, unique: true }
	 *     query.where('loc').within().circle(area)
	 *     // alternatively
	 *     query.circle('loc', area);
	 *
	 *     // spherical calculations
	 *     var area = { center: [50, 50], radius: 10, unique: true, spherical: true }
	 *     query.where('loc').within().circle(area)
	 *     // alternatively
	 *     query.circle('loc', area);
	 *
	 * New in 3.7.0
	 *
	 * @method circle
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Object} area
	 * @return {Query} this
	 * @see $center http://docs.mongodb.org/manual/reference/operator/center/
	 * @see $centerSphere http://docs.mongodb.org/manual/reference/operator/centerSphere/
	 * @see $geoWithin http://docs.mongodb.org/manual/reference/operator/within/
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @api public
	 */
	
	/**
	 * _DEPRECATED_ Alias for [circle](#query_Query-circle)
	 *
	 * **Deprecated.** Use [circle](#query_Query-circle) instead.
	 *
	 * @deprecated
	 * @method center
	 * @memberOf Query
	 * @api public
	 */
	
	Query.prototype.center = Query.base.circle;
	
	/**
	 * _DEPRECATED_ Specifies a $centerSphere condition
	 *
	 * **Deprecated.** Use [circle](#query_Query-circle) instead.
	 *
	 * ####Example
	 *
	 *     var area = { center: [50, 50], radius: 10 };
	 *     query.where('loc').within().centerSphere(area);
	 *
	 * @deprecated
	 * @param {String} [path]
	 * @param {Object} val
	 * @return {Query} this
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @see $centerSphere http://docs.mongodb.org/manual/reference/operator/centerSphere/
	 * @api public
	 */
	
	Query.prototype.centerSphere = function () {
	  if (arguments[0] && arguments[0].constructor.name == 'Object') {
	    arguments[0].spherical = true;
	  }
	
	  if (arguments[1] && arguments[1].constructor.name == 'Object') {
	    arguments[1].spherical = true;
	  }
	
	  Query.base.circle.apply(this, arguments);
	}
	
	/**
	 * Determines if field selection has been made.
	 *
	 * @method selected
	 * @memberOf Query
	 * @return {Boolean}
	 * @api public
	 */
	
	/**
	 * Determines if inclusive field selection has been made.
	 *
	 *     query.selectedInclusively() // false
	 *     query.select('name')
	 *     query.selectedInclusively() // true
	 *
	 * @method selectedInclusively
	 * @memberOf Query
	 * @return {Boolean}
	 * @api public
	 */
	
	/**
	 * Determines if exclusive field selection has been made.
	 *
	 *     query.selectedExclusively() // false
	 *     query.select('-name')
	 *     query.selectedExclusively() // true
	 *     query.selectedInclusively() // false
	 *
	 * @method selectedExclusively
	 * @memberOf Query
	 * @return {Boolean}
	 * @api public
	 */
	
	/*!
	 * Export
	 */
	
	module.exports = Query;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 201 */
/*!*******************************************!*\
  !*** ./~/mongoose/~/mquery/lib/mquery.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Dependencies
	 */
	
	var slice = __webpack_require__(/*! sliced */ 203)
	var assert = __webpack_require__(/*! assert */ 205)
	var util = __webpack_require__(/*! util */ 57)
	var utils = __webpack_require__(/*! ./utils */ 206)
	var debug = __webpack_require__(/*! debug */ 208)('mquery');
	
	/**
	 * Query constructor used for building queries.
	 *
	 * ####Example:
	 *
	 *     var query = new Query({ name: 'mquery' });
	 *     query.setOptions({ collection: moduleCollection })
	 *     query.where('age').gte(21).exec(callback);
	 *
	 * @param {Object} [criteria]
	 * @param {Object} [options]
	 * @api public
	 */
	
	function Query (criteria, options) {
	  if (!(this instanceof Query))
	    return new Query(criteria, options);
	
	  var proto = this.constructor.prototype;
	
	  this.op = proto.op || undefined;
	
	  this.options = {};
	  this.setOptions(proto.options);
	
	  this._conditions = proto._conditions
	    ? utils.clone(proto._conditions)
	    : {};
	
	  this._fields = proto._fields
	    ? utils.clone(proto._fields)
	    : undefined;
	
	  this._update = proto._update
	    ? utils.clone(proto._update)
	    : undefined;
	
	  this._path = proto._path || undefined;
	  this._distinct = proto._distinct || undefined;
	  this._collection = proto._collection || undefined;
	  this._traceFunction = proto._traceFunction || undefined;
	
	  if (options) {
	    this.setOptions(options);
	  }
	
	  if (criteria) {
	    if (criteria.find && criteria.remove && criteria.update) {
	      // quack quack!
	      this.collection(criteria);
	    } else {
	      this.find(criteria);
	    }
	  }
	}
	
	/**
	 * This is a parameter that the user can set which determines if mquery
	 * uses $within or $geoWithin for queries. It defaults to true which
	 * means $geoWithin will be used. If using MongoDB < 2.4 you should
	 * set this to false.
	 *
	 * @api public
	 * @property use$geoWithin
	 */
	
	var $withinCmd = '$geoWithin';
	Object.defineProperty(Query, 'use$geoWithin', {
	    get: function ( ) { return $withinCmd == '$geoWithin' }
	  , set: function (v) {
	      if (true === v) {
	        // mongodb >= 2.4
	        $withinCmd = '$geoWithin';
	      } else {
	        $withinCmd = '$within';
	      }
	    }
	});
	
	/**
	 * Converts this query to a constructor function with all arguments and options retained.
	 *
	 * ####Example
	 *
	 *     // Create a query that will read documents with a "video" category from
	 *     // `aCollection` on the primary node in the replica-set unless it is down,
	 *     // in which case we'll read from a secondary node.
	 *     var query = mquery({ category: 'video' })
	 *     query.setOptions({ collection: aCollection, read: 'primaryPreferred' });
	 *
	 *     // create a constructor based off these settings
	 *     var Video = query.toConstructor();
	 *
	 *     // Video is now a subclass of mquery() and works the same way but with the
	 *     // default query parameters and options set.
	 *
	 *     // run a query with the previous settings but filter for movies with names
	 *     // that start with "Life".
	 *     Video().where({ name: /^Life/ }).exec(cb);
	 *
	 * @return {Query} new Query
	 * @api public
	 */
	
	Query.prototype.toConstructor = function toConstructor () {
	  function CustomQuery (criteria, options) {
	    if (!(this instanceof CustomQuery))
	      return new CustomQuery(criteria, options);
	    Query.call(this, criteria, options);
	  }
	
	  utils.inherits(CustomQuery, Query);
	
	  // set inherited defaults
	  var p = CustomQuery.prototype;
	
	  p.options = {};
	  p.setOptions(this.options);
	
	  p.op = this.op;
	  p._conditions = utils.clone(this._conditions);
	  p._fields = utils.clone(this._fields);
	  p._update = utils.clone(this._update);
	  p._path = this._path;
	  p._distinct = this._distinct;
	  p._collection = this._collection;
	  p._traceFunction = this._traceFunction;
	
	  return CustomQuery;
	}
	
	/**
	 * Sets query options.
	 *
	 * ####Options:
	 *
	 * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors) *
	 * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\)%7D%7D) *
	 * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D) *
	 * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D) *
	 * - [maxScan](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24maxScan) *
	 * - [maxTime](http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS) *
	 * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D) *
	 * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment) *
	 * - [snapshot](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D) *
	 * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint) *
	 * - [slaveOk](http://docs.mongodb.org/manual/applications/replication/#read-preference) *
	 * - [safe](http://www.mongodb.org/display/DOCS/getLastError+Command)
	 * - collection the collection to query against
	 *
	 * _* denotes a query helper method is also available_
	 *
	 * @param {Object} options
	 * @api public
	 */
	
	Query.prototype.setOptions = function (options) {
	  if (!(options && utils.isObject(options)))
	    return this;
	
	  // set arbitrary options
	  var methods = utils.keys(options)
	    , method
	
	  for (var i = 0; i < methods.length; ++i) {
	    method = methods[i];
	
	    // use methods if exist (safer option manipulation)
	    if ('function' == typeof this[method]) {
	      var args = utils.isArray(options[method])
	        ? options[method]
	        : [options[method]];
	      this[method].apply(this, args)
	    } else {
	      this.options[method] = options[method];
	    }
	  }
	
	  return this;
	}
	
	/**
	 * Sets this Querys collection.
	 *
	 * @param {Collection} coll
	 * @return {Query} this
	 */
	
	Query.prototype.collection = function collection (coll) {
	  this._collection = new Query.Collection(coll);
	
	  return this;
	}
	
	/**
	 * Specifies a `$where` condition
	 *
	 * Use `$where` when you need to select documents using a JavaScript expression.
	 *
	 * ####Example
	 *
	 *     query.$where('this.comments.length > 10 || this.name.length > 5')
	 *
	 *     query.$where(function () {
	 *       return this.comments.length > 10 || this.name.length > 5;
	 *     })
	 *
	 * @param {String|Function} js javascript string or function
	 * @return {Query} this
	 * @memberOf Query
	 * @method $where
	 * @api public
	 */
	
	Query.prototype.$where = function (js) {
	  this._conditions.$where = js;
	  return this;
	}
	
	/**
	 * Specifies a `path` for use with chaining.
	 *
	 * ####Example
	 *
	 *     // instead of writing:
	 *     User.find({age: {$gte: 21, $lte: 65}}, callback);
	 *
	 *     // we can instead write:
	 *     User.where('age').gte(21).lte(65);
	 *
	 *     // passing query conditions is permitted
	 *     User.find().where({ name: 'vonderful' })
	 *
	 *     // chaining
	 *     User
	 *     .where('age').gte(21).lte(65)
	 *     .where('name', /^vonderful/i)
	 *     .where('friends').slice(10)
	 *     .exec(callback)
	 *
	 * @param {String} [path]
	 * @param {Object} [val]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.where = function () {
	  if (!arguments.length) return this;
	  if (!this.op) this.op = 'find';
	
	  var type = typeof arguments[0];
	
	  if ('string' == type) {
	    this._path = arguments[0];
	
	    if (2 === arguments.length) {
	      this._conditions[this._path] = arguments[1];
	    }
	
	    return this;
	  }
	
	  if ('object' == type && !Array.isArray(arguments[0])) {
	    return this.merge(arguments[0]);
	  }
	
	  throw new TypeError('path must be a string or object');
	}
	
	/**
	 * Specifies the complementary comparison value for paths specified with `where()`
	 *
	 * ####Example
	 *
	 *     User.where('age').equals(49);
	 *
	 *     // is the same as
	 *
	 *     User.where('age', 49);
	 *
	 * @param {Object} val
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.equals = function equals (val) {
	  this._ensurePath('equals');
	  var path = this._path;
	  this._conditions[path] = val;
	  return this;
	}
	
	/**
	 * Specifies arguments for an `$or` condition.
	 *
	 * ####Example
	 *
	 *     query.or([{ color: 'red' }, { status: 'emergency' }])
	 *
	 * @param {Array} array array of conditions
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.or = function or (array) {
	  var or = this._conditions.$or || (this._conditions.$or = []);
	  if (!utils.isArray(array)) array = [array];
	  or.push.apply(or, array);
	  return this;
	}
	
	/**
	 * Specifies arguments for a `$nor` condition.
	 *
	 * ####Example
	 *
	 *     query.nor([{ color: 'green' }, { status: 'ok' }])
	 *
	 * @param {Array} array array of conditions
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.nor = function nor (array) {
	  var nor = this._conditions.$nor || (this._conditions.$nor = []);
	  if (!utils.isArray(array)) array = [array];
	  nor.push.apply(nor, array);
	  return this;
	}
	
	/**
	 * Specifies arguments for a `$and` condition.
	 *
	 * ####Example
	 *
	 *     query.and([{ color: 'green' }, { status: 'ok' }])
	 *
	 * @see $and http://docs.mongodb.org/manual/reference/operator/and/
	 * @param {Array} array array of conditions
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.and = function and (array) {
	  var and = this._conditions.$and || (this._conditions.$and = []);
	  if (!Array.isArray(array)) array = [array];
	  and.push.apply(and, array);
	  return this;
	}
	
	/**
	 * Specifies a $gt query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * ####Example
	 *
	 *     Thing.find().where('age').gt(21)
	 *
	 *     // or
	 *     Thing.find().gt('age', 21)
	 *
	 * @method gt
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $gte query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method gte
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $lt query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method lt
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $lte query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method lte
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $ne query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method ne
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies an $in query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method in
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies an $nin query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method nin
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies an $all query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method all
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $size query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method size
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $regex query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method regex
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $maxDistance query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method maxDistance
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/*!
	 * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance
	 *
	 *     Thing.where('type').nin(array)
	 */
	
	'gt gte lt lte ne in nin all regex size maxDistance'.split(' ').forEach(function ($conditional) {
	  Query.prototype[$conditional] = function () {
	    var path, val;
	
	    if (1 === arguments.length) {
	      this._ensurePath($conditional);
	      val = arguments[0];
	      path = this._path;
	    } else {
	      val = arguments[1];
	      path = arguments[0];
	    }
	
	    var conds = this._conditions[path] || (this._conditions[path] = {});
	    conds['$' + $conditional] = val;
	    return this;
	  };
	})
	
	/**
	 * Specifies a `$mod` condition
	 *
	 * @param {String} [path]
	 * @param {Number} val
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.mod = function () {
	  var val, path;
	
	  if (1 === arguments.length) {
	    this._ensurePath('mod')
	    val = arguments[0];
	    path = this._path;
	  } else if (2 === arguments.length && !utils.isArray(arguments[1])) {
	    this._ensurePath('mod')
	    val = slice(arguments);
	    path = this._path;
	  } else if (3 === arguments.length) {
	    val = slice(arguments, 1);
	    path = arguments[0];
	  } else {
	    val = arguments[1];
	    path = arguments[0];
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds.$mod = val;
	  return this;
	}
	
	/**
	 * Specifies an `$exists` condition
	 *
	 * ####Example
	 *
	 *     // { name: { $exists: true }}
	 *     Thing.where('name').exists()
	 *     Thing.where('name').exists(true)
	 *     Thing.find().exists('name')
	 *
	 *     // { name: { $exists: false }}
	 *     Thing.where('name').exists(false);
	 *     Thing.find().exists('name', false);
	 *
	 * @param {String} [path]
	 * @param {Number} val
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.exists = function () {
	  var path, val;
	
	  if (0 === arguments.length) {
	    this._ensurePath('exists');
	    path = this._path;
	    val = true;
	  } else if (1 === arguments.length) {
	    if ('boolean' === typeof arguments[0]) {
	      this._ensurePath('exists');
	      path = this._path;
	      val = arguments[0];
	    } else {
	      path = arguments[0];
	      val = true;
	    }
	  } else if (2 === arguments.length) {
	    path = arguments[0];
	    val = arguments[1];
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds.$exists = val;
	  return this;
	}
	
	/**
	 * Specifies an `$elemMatch` condition
	 *
	 * ####Example
	 *
	 *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})
	 *
	 *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})
	 *
	 *     query.elemMatch('comment', function (elem) {
	 *       elem.where('author').equals('autobot');
	 *       elem.where('votes').gte(5);
	 *     })
	 *
	 *     query.where('comment').elemMatch(function (elem) {
	 *       elem.where({ author: 'autobot' });
	 *       elem.where('votes').gte(5);
	 *     })
	 *
	 * @param {String|Object|Function} path
	 * @param {Object|Function} criteria
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.elemMatch = function () {
	  if (null == arguments[0])
	    throw new TypeError("Invalid argument");
	
	  var fn, path, criteria;
	
	  if ('function' === typeof arguments[0]) {
	    this._ensurePath('elemMatch');
	    path = this._path;
	    fn = arguments[0];
	  } else if (utils.isObject(arguments[0])) {
	    this._ensurePath('elemMatch');
	    path = this._path;
	    criteria = arguments[0];
	  } else if ('function' === typeof arguments[1]) {
	    path = arguments[0];
	    fn = arguments[1];
	  } else if (arguments[1] && utils.isObject(arguments[1])) {
	    path = arguments[0];
	    criteria = arguments[1];
	  } else {
	    throw new TypeError("Invalid argument");
	  }
	
	  if (fn) {
	    criteria = new Query;
	    fn(criteria);
	    criteria = criteria._conditions;
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds.$elemMatch = criteria;
	  return this;
	}
	
	// Spatial queries
	
	/**
	 * Sugar for geo-spatial queries.
	 *
	 * ####Example
	 *
	 *     query.within().box()
	 *     query.within().circle()
	 *     query.within().geometry()
	 *
	 *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });
	 *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });
	 *     query.where('loc').within({ polygon: [[],[],[],[]] });
	 *
	 *     query.where('loc').within([], [], []) // polygon
	 *     query.where('loc').within([], []) // box
	 *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry
	 *
	 * ####NOTE:
	 *
	 * Must be used after `where()`.
	 *
	 * @memberOf Query
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.within = function within () {
	  // opinionated, must be used after where
	  this._ensurePath('within');
	  this._geoComparison = $withinCmd;
	
	  if (0 === arguments.length) {
	    return this;
	  }
	
	  if (2 === arguments.length) {
	    return this.box.apply(this, arguments);
	  } else if (2 < arguments.length) {
	    return this.polygon.apply(this, arguments);
	  }
	
	  var area = arguments[0];
	
	  if (!area)
	    throw new TypeError('Invalid argument');
	
	  if (area.center)
	    return this.circle(area);
	
	  if (area.box)
	    return this.box.apply(this, area.box);
	
	  if (area.polygon)
	    return this.polygon.apply(this, area.polygon);
	
	  if (area.type && area.coordinates)
	    return this.geometry(area);
	
	  throw new TypeError('Invalid argument');
	}
	
	/**
	 * Specifies a $box condition
	 *
	 * ####Example
	 *
	 *     var lowerLeft = [40.73083, -73.99756]
	 *     var upperRight= [40.741404,  -73.988135]
	 *
	 *     query.where('loc').within().box(lowerLeft, upperRight)
	 *     query.box('loc', lowerLeft, upperRight )
	 *
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @see Query#within #query_Query-within
	 * @param {String} path
	 * @param {Object} val
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.box = function () {
	  var path, box;
	
	  if (3 === arguments.length) {
	    // box('loc', [], [])
	    path = arguments[0];
	    box = [arguments[1], arguments[2]];
	  } else if (2 === arguments.length) {
	    // box([], [])
	    this._ensurePath('box');
	    path = this._path;
	    box = [arguments[0], arguments[1]];
	  } else {
	    throw new TypeError("Invalid argument");
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds[this._geoComparison || $withinCmd] = { '$box': box  };
	  return this;
	}
	
	/**
	 * Specifies a $polygon condition
	 *
	 * ####Example
	 *
	 *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])
	 *     query.polygon('loc', [10,20], [13, 25], [7,15])
	 *
	 * @param {String|Array} [path]
	 * @param {Array|Object} [val]
	 * @return {Query} this
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @api public
	 */
	
	Query.prototype.polygon = function () {
	  var val, path;
	
	  if ('string' == typeof arguments[0]) {
	    // polygon('loc', [],[],[])
	    path = arguments[0];
	    val = slice(arguments, 1);
	  } else {
	    // polygon([],[],[])
	    this._ensurePath('polygon');
	    path = this._path;
	    val = slice(arguments);
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds[this._geoComparison || $withinCmd] = { '$polygon': val };
	  return this;
	}
	
	/**
	 * Specifies a $center or $centerSphere condition.
	 *
	 * ####Example
	 *
	 *     var area = { center: [50, 50], radius: 10, unique: true }
	 *     query.where('loc').within().circle(area)
	 *     query.center('loc', area);
	 *
	 *     // for spherical calculations
	 *     var area = { center: [50, 50], radius: 10, unique: true, spherical: true }
	 *     query.where('loc').within().circle(area)
	 *     query.center('loc', area);
	 *
	 * @param {String} [path]
	 * @param {Object} area
	 * @return {Query} this
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @api public
	 */
	
	Query.prototype.circle = function () {
	  var path, val;
	
	  if (1 === arguments.length) {
	    this._ensurePath('circle');
	    path = this._path;
	    val = arguments[0];
	  } else if (2 === arguments.length) {
	    path = arguments[0];
	    val = arguments[1];
	  } else {
	    throw new TypeError("Invalid argument");
	  }
	
	  if (!('radius' in val && val.center))
	    throw new Error('center and radius are required');
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	
	  var type = val.spherical
	    ? '$centerSphere'
	    : '$center';
	
	  var wKey = this._geoComparison || $withinCmd;
	  conds[wKey] = {};
	  conds[wKey][type] = [val.center, val.radius];
	
	  if ('unique' in val)
	    conds[wKey].$uniqueDocs = !! val.unique;
	
	  return this;
	}
	
	/**
	 * Specifies a `$near` or `$nearSphere` condition
	 *
	 * These operators return documents sorted by distance.
	 *
	 * ####Example
	 *
	 *     query.where('loc').near({ center: [10, 10] });
	 *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });
	 *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });
	 *     query.near('loc', { center: [10, 10], maxDistance: 5 });
	 *     query.near({ center: { type: 'Point', coordinates: [..] }})
	 *     query.near().geometry({ type: 'Point', coordinates: [..] })
	 *
	 * @param {String} [path]
	 * @param {Object} val
	 * @return {Query} this
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @api public
	 */
	
	Query.prototype.near = function near () {
	  var path, val;
	
	  this._geoComparison = '$near';
	
	  if (0 === arguments.length) {
	    return this;
	  } else if (1 === arguments.length) {
	    this._ensurePath('near');
	    path = this._path;
	    val = arguments[0];
	  } else if (2 === arguments.length) {
	    path = arguments[0];
	    val = arguments[1];
	  } else {
	    throw new TypeError("Invalid argument");
	  }
	
	  if (!val.center) {
	    throw new Error('center is required');
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	
	  var type = val.spherical
	    ? '$nearSphere'
	    : '$near';
	
	  // center could be a GeoJSON object or an Array
	  if (Array.isArray(val.center)) {
	    conds[type] = val.center;
	
	    var radius = 'maxDistance' in val
	      ? val.maxDistance
	      : null;
	
	    if (null != radius) {
	      conds.$maxDistance = radius;
	    }
	  } else {
	    // GeoJSON?
	    if (val.center.type != 'Point' || !Array.isArray(val.center.coordinates)) {
	      throw new Error(util.format("Invalid GeoJSON specified for %s", type));
	    }
	    conds[type] = { $geometry : val.center };
	
	    // MongoDB 2.6 insists on maxDistance being in $near / $nearSphere
	    if ('maxDistance' in val) {
	      conds[type]['$maxDistance'] = val.maxDistance;
	    }
	  }
	
	  return this;
	}
	
	/**
	 * Declares an intersects query for `geometry()`.
	 *
	 * ####Example
	 *
	 *     query.where('path').intersects().geometry({
	 *         type: 'LineString'
	 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
	 *     })
	 *
	 *     query.where('path').intersects({
	 *         type: 'LineString'
	 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
	 *     })
	 *
	 * @param {Object} [arg]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.intersects = function intersects () {
	  // opinionated, must be used after where
	  this._ensurePath('intersects');
	
	  this._geoComparison = '$geoIntersects';
	
	  if (0 === arguments.length) {
	    return this;
	  }
	
	  var area = arguments[0];
	
	  if (null != area && area.type && area.coordinates)
	    return this.geometry(area);
	
	  throw new TypeError('Invalid argument');
	}
	
	/**
	 * Specifies a `$geometry` condition
	 *
	 * ####Example
	 *
	 *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]
	 *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })
	 *
	 *     // or
	 *     var polyB = [[ 0, 0 ], [ 1, 1 ]]
	 *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })
	 *
	 *     // or
	 *     var polyC = [ 0, 0 ]
	 *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })
	 *
	 *     // or
	 *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })
	 *
	 * ####NOTE:
	 *
	 * `geometry()` **must** come after either `intersects()` or `within()`.
	 *
	 * The `object` argument must contain `type` and `coordinates` properties.
	 * - type {String}
	 * - coordinates {Array}
	 *
	 * The most recent path passed to `where()` is used.
	 *
	 * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.
	 * @return {Query} this
	 * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/
	 * @api public
	 */
	
	Query.prototype.geometry = function geometry () {
	  if (!('$within' == this._geoComparison ||
	        '$geoWithin' == this._geoComparison ||
	        '$near' == this._geoComparison ||
	        '$geoIntersects' == this._geoComparison)) {
	    throw new Error('geometry() must come after `within()`, `intersects()`, or `near()');
	  }
	
	  var val, path;
	
	  if (1 === arguments.length) {
	    this._ensurePath('geometry');
	    path = this._path;
	    val = arguments[0];
	  } else {
	    throw new TypeError("Invalid argument");
	  }
	
	  if (!(val.type && Array.isArray(val.coordinates))) {
	    throw new TypeError('Invalid argument');
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds[this._geoComparison] = { $geometry: val };
	
	  return this;
	}
	
	// end spatial
	
	/**
	 * Specifies which document fields to include or exclude
	 *
	 * ####String syntax
	 *
	 * When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.
	 *
	 * ####Example
	 *
	 *     // include a and b, exclude c
	 *     query.select('a b -c');
	 *
	 *     // or you may use object notation, useful when
	 *     // you have keys already prefixed with a "-"
	 *     query.select({a: 1, b: 1, c: 0});
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @param {Object|String} arg
	 * @return {Query} this
	 * @see SchemaType
	 * @api public
	 */
	
	Query.prototype.select = function select () {
	  var arg = arguments[0];
	  if (!arg) return this;
	
	  if (arguments.length !== 1) {
	    throw new Error("Invalid select: select only takes 1 argument");
	  }
	
	  this._validate('select');
	
	  var fields = this._fields || (this._fields = {});
	  var type = typeof arg;
	
	  if ('string' == type || 'object' == type && 'number' == typeof arg.length && !Array.isArray(arg)) {
	    if ('string' == type)
	      arg = arg.split(/\s+/);
	
	    for (var i = 0, len = arg.length; i < len; ++i) {
	      var field = arg[i];
	      if (!field) continue;
	      var include = '-' == field[0] ? 0 : 1;
	      if (include === 0) field = field.substring(1);
	      fields[field] = include;
	    }
	
	    return this;
	  }
	
	  if (utils.isObject(arg) && !Array.isArray(arg)) {
	    var keys = utils.keys(arg);
	    for (var i = 0; i < keys.length; ++i) {
	      fields[keys[i]] = arg[keys[i]];
	    }
	    return this;
	  }
	
	  throw new TypeError('Invalid select() argument. Must be string or object.');
	}
	
	/**
	 * Specifies a $slice condition for a `path`
	 *
	 * ####Example
	 *
	 *     query.slice('comments', 5)
	 *     query.slice('comments', -5)
	 *     query.slice('comments', [10, 5])
	 *     query.where('comments').slice(5)
	 *     query.where('comments').slice([-10, 5])
	 *
	 * @param {String} [path]
	 * @param {Number} val number/range of elements to slice
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements
	 * @api public
	 */
	
	Query.prototype.slice = function () {
	  if (0 === arguments.length)
	    return this;
	
	  this._validate('slice');
	
	  var path, val;
	
	  if (1 === arguments.length) {
	    var arg = arguments[0];
	    if (typeof arg === 'object' && !Array.isArray(arg)) {
	      var keys = Object.keys(arg);
	      var numKeys = keys.length;
	      for (var i = 0; i < numKeys; ++i) {
	        this.slice(keys[i], arg[keys[i]]);
	      }
	      return this;
	    }
	    this._ensurePath('slice');
	    path = this._path;
	    val = arguments[0];
	  } else if (2 === arguments.length) {
	    if ('number' === typeof arguments[0]) {
	      this._ensurePath('slice');
	      path = this._path;
	      val = slice(arguments);
	    } else {
	      path = arguments[0];
	      val = arguments[1];
	    }
	  } else if (3 === arguments.length) {
	    path = arguments[0];
	    val = slice(arguments, 1);
	  }
	
	  var myFields = this._fields || (this._fields = {});
	  myFields[path] = { '$slice': val };
	  return this;
	}
	
	/**
	 * Sets the sort order
	 *
	 * If an object is passed, values allowed are 'asc', 'desc', 'ascending', 'descending', 1, and -1.
	 *
	 * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.
	 *
	 * ####Example
	 *
	 *     // these are equivalent
	 *     query.sort({ field: 'asc', test: -1 });
	 *     query.sort('field -test');
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @param {Object|String} arg
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.sort = function (arg) {
	  if (!arg) return this;
	
	  this._validate('sort');
	
	  var type = typeof arg;
	
	  if (1 === arguments.length && 'string' == type) {
	    arg = arg.split(/\s+/);
	
	    for (var i = 0, len = arg.length; i < len; ++i) {
	      var field = arg[i];
	      if (!field) continue;
	      var ascend = '-' == field[0] ? -1 : 1;
	      if (ascend === -1) field = field.substring(1);
	      push(this.options, field, ascend);
	    }
	
	    return this;
	  }
	
	  if (utils.isObject(arg)) {
	    var keys = utils.keys(arg);
	    for (var i = 0; i < keys.length; ++i) {
	      var field = keys[i];
	      push(this.options, field, arg[field]);
	    }
	
	    return this;
	  }
	
	  throw new TypeError('Invalid sort() argument. Must be a string or object.');
	}
	
	/*!
	 * @ignore
	 */
	
	function push (opts, field, value) {
	  if (value && value.$meta) {
	    var s = opts.sort || (opts.sort = {});
	    s[field] = { $meta : value.$meta };
	    return;
	  }
	
	  var val = String(value || 1).toLowerCase();
	  if (!/^(?:ascending|asc|descending|desc|1|-1)$/.test(val)) {
	    if (utils.isArray(value)) value = '['+value+']';
	    throw new TypeError('Invalid sort value: {' + field + ': ' + value + ' }');
	  }
	  // store `sort` in a sane format
	  var s = opts.sort || (opts.sort = {});
	  var valueStr = value.toString()
	                  .replace("asc", "1")
	                  .replace("ascending", "1")
	                  .replace("desc", "-1")
	                  .replace("descending", "-1");
	  s[field] = parseInt(valueStr, 10);
	}
	
	/**
	 * Specifies the limit option.
	 *
	 * ####Example
	 *
	 *     query.limit(20)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method limit
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D
	 * @api public
	 */
	/**
	 * Specifies the skip option.
	 *
	 * ####Example
	 *
	 *     query.skip(100).limit(20)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method skip
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D
	 * @api public
	 */
	/**
	 * Specifies the maxScan option.
	 *
	 * ####Example
	 *
	 *     query.maxScan(100)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method maxScan
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24maxScan
	 * @api public
	 */
	/**
	 * Specifies the batchSize option.
	 *
	 * ####Example
	 *
	 *     query.batchSize(100)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method batchSize
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D
	 * @api public
	 */
	/**
	 * Specifies the `comment` option.
	 *
	 * ####Example
	 *
	 *     query.comment('login query')
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method comment
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment
	 * @api public
	 */
	
	/*!
	 * limit, skip, maxScan, batchSize, comment
	 *
	 * Sets these associated options.
	 *
	 *     query.comment('feed query');
	 */
	
	;['limit', 'skip', 'maxScan', 'batchSize', 'comment'].forEach(function (method) {
	  Query.prototype[method] = function (v) {
	    this._validate(method);
	    this.options[method] = v;
	    return this;
	  };
	})
	
	/**
	 * Specifies the maxTimeMS option.
	 *
	 * ####Example
	 *
	 *     query.maxTime(100)
	 *
	 * @method maxTime
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS
	 * @api public
	 */
	
	Query.prototype.maxTime = function (v) {
	  this._validate('maxTime');
	  this.options.maxTimeMS = v;
	  return this;
	};
	
	/**
	 * Specifies this query as a `snapshot` query.
	 *
	 * ####Example
	 *
	 *     mquery().snapshot() // true
	 *     mquery().snapshot(true)
	 *     mquery().snapshot(false)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.snapshot = function () {
	  this._validate('snapshot');
	
	  this.options.snapshot = arguments.length
	    ? !! arguments[0]
	    : true
	
	  return this;
	}
	
	/**
	 * Sets query hints.
	 *
	 * ####Example
	 *
	 *     query.hint({ indexA: 1, indexB: -1})
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @param {Object} val a hint object
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint
	 * @api public
	 */
	
	Query.prototype.hint = function () {
	  if (0 === arguments.length) return this;
	
	  this._validate('hint');
	
	  var arg = arguments[0];
	  if (utils.isObject(arg)) {
	    var hint = this.options.hint || (this.options.hint = {});
	
	    // must keep object keys in order so don't use Object.keys()
	    for (var k in arg) {
	      hint[k] = arg[k];
	    }
	
	    return this;
	  }
	
	  throw new TypeError('Invalid hint. ' + arg);
	}
	
	/**
	 * Sets the slaveOk option. _Deprecated_ in MongoDB 2.2 in favor of read preferences.
	 *
	 * ####Example:
	 *
	 *     query.slaveOk() // true
	 *     query.slaveOk(true)
	 *     query.slaveOk(false)
	 *
	 * @deprecated use read() preferences instead if on mongodb >= 2.2
	 * @param {Boolean} v defaults to true
	 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
	 * @see read()
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.slaveOk = function (v) {
	  this.options.slaveOk = arguments.length ? !!v : true;
	  return this;
	}
	
	/**
	 * Sets the readPreference option for the query.
	 *
	 * ####Example:
	 *
	 *     new Query().read('primary')
	 *     new Query().read('p')  // same as primary
	 *
	 *     new Query().read('primaryPreferred')
	 *     new Query().read('pp') // same as primaryPreferred
	 *
	 *     new Query().read('secondary')
	 *     new Query().read('s')  // same as secondary
	 *
	 *     new Query().read('secondaryPreferred')
	 *     new Query().read('sp') // same as secondaryPreferred
	 *
	 *     new Query().read('nearest')
	 *     new Query().read('n')  // same as nearest
	 *
	 *     // you can also use mongodb.ReadPreference class to also specify tags
	 *     new Query().read(mongodb.ReadPreference('secondary', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }]))
	 *
	 * ####Preferences:
	 *
	 *     primary - (default)  Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.
	 *     secondary            Read from secondary if available, otherwise error.
	 *     primaryPreferred     Read from primary if available, otherwise a secondary.
	 *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.
	 *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.
	 *
	 * Aliases
	 *
	 *     p   primary
	 *     pp  primaryPreferred
	 *     s   secondary
	 *     sp  secondaryPreferred
	 *     n   nearest
	 *
	 * Read more about how to use read preferences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).
	 *
	 * @param {String|ReadPreference} pref one of the listed preference options or their aliases
	 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
	 * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.read = function (pref) {
	  if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {
	    console.error("Deprecation warning: 'tags' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.");
	    Query.prototype.read.deprecationWarningIssued = true;
	  }
	  this.options.readPreference = utils.readPref(pref);
	  return this;
	}
	
	/**
	 * Sets tailable option.
	 *
	 * ####Example
	 *
	 *     query.tailable() <== true
	 *     query.tailable(true)
	 *     query.tailable(false)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @param {Boolean} v defaults to true
	 * @see mongodb http://www.mongodb.org/display/DOCS/Tailable+Cursors
	 * @api public
	 */
	
	Query.prototype.tailable = function () {
	  this._validate('tailable');
	
	  this.options.tailable = arguments.length
	    ? !! arguments[0]
	    : true;
	
	  return this;
	}
	
	/**
	 * Merges another Query or conditions object into this one.
	 *
	 * When a Query is passed, conditions, field selection and options are merged.
	 *
	 * @param {Query|Object} source
	 * @return {Query} this
	 */
	
	Query.prototype.merge = function (source) {
	  if (!source)
	    return this;
	
	  if (!Query.canMerge(source))
	    throw new TypeError('Invalid argument. Expected instanceof mquery or plain object');
	
	  if (source instanceof Query) {
	    // if source has a feature, apply it to ourselves
	
	    if (source._conditions) {
	      utils.merge(this._conditions, source._conditions);
	    }
	
	    if (source._fields) {
	      this._fields || (this._fields = {});
	      utils.merge(this._fields, source._fields);
	    }
	
	    if (source.options) {
	      this.options || (this.options = {});
	      utils.merge(this.options, source.options);
	    }
	
	    if (source._update) {
	      this._update || (this._update = {});
	      utils.mergeClone(this._update, source._update);
	    }
	
	    if (source._distinct) {
	      this._distinct = source._distinct;
	    }
	
	    return this;
	  }
	
	  // plain object
	  utils.merge(this._conditions, source);
	
	  return this;
	}
	
	/**
	 * Finds documents.
	 *
	 * Passing a `callback` executes the query.
	 *
	 * ####Example
	 *
	 *     query.find()
	 *     query.find(callback)
	 *     query.find({ name: 'Burning Lights' }, callback)
	 *
	 * @param {Object} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.find = function (criteria, callback) {
	  this.op = 'find';
	
	  if ('function' === typeof criteria) {
	    callback = criteria;
	    criteria = undefined;
	  } else if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  if (!callback) return this;
	
	  var self = this
	    , conds = this._conditions
	    , options = this._optionsForExec()
	
	  options.fields = this._fieldsForExec()
	
	  debug('find', this._collection.collectionName, conds, options);
	  callback = this._wrapCallback('find', callback, {
	    conditions: conds
	  , options: options
	  });
	
	  this._collection.find(conds, options, utils.tick(callback));
	  return this;
	}
	
	/**
	 * Executes the query as a findOne() operation.
	 *
	 * Passing a `callback` executes the query.
	 *
	 * ####Example
	 *
	 *     query.findOne().where('name', /^Burning/);
	 *
	 *     query.findOne({ name: /^Burning/ })
	 *
	 *     query.findOne({ name: /^Burning/ }, callback); // executes
	 *
	 *     query.findOne(function (err, doc) {
	 *       if (err) return handleError(err);
	 *       if (doc) {
	 *         // doc may be null if no document matched
	 *
	 *       }
	 *     });
	 *
	 * @param {Object|Query} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.findOne = function (criteria, callback) {
	  this.op = 'findOne';
	
	  if ('function' === typeof criteria) {
	    callback = criteria;
	    criteria = undefined;
	  } else if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  if (!callback) return this;
	
	  var self = this
	    , conds = this._conditions
	    , options = this._optionsForExec()
	
	  options.fields = this._fieldsForExec();
	
	  debug('findOne', this._collection.collectionName, conds, options);
	  callback = this._wrapCallback('findOne', callback, {
	    conditions: conds
	  , options: options
	  });
	
	  this._collection.findOne(conds, options, utils.tick(callback));
	
	  return this;
	}
	
	/**
	 * Exectues the query as a count() operation.
	 *
	 * Passing a `callback` executes the query.
	 *
	 * ####Example
	 *
	 *     query.count().where('color', 'black').exec(callback);
	 *
	 *     query.count({ color: 'black' }).count(callback)
	 *
	 *     query.count({ color: 'black' }, callback)
	 *
	 *     query.where('color', 'black').count(function (err, count) {
	 *       if (err) return handleError(err);
	 *       console.log('there are %d kittens', count);
	 *     })
	 *
	 * @param {Object} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Count
	 * @api public
	 */
	
	Query.prototype.count = function (criteria, callback) {
	  this.op = 'count';
	  this._validate();
	
	  if ('function' === typeof criteria) {
	    callback = criteria;
	    criteria = undefined;
	  } else if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  if (!callback) return this;
	
	  var conds = this._conditions
	    , options = this._optionsForExec()
	
	  debug('count', this._collection.collectionName, conds, options);
	  callback = this._wrapCallback('count', callback, {
	    conditions: conds
	  , options: options
	  });
	
	  this._collection.count(conds, options, utils.tick(callback));
	  return this;
	}
	
	/**
	 * Declares or executes a distinct() operation.
	 *
	 * Passing a `callback` executes the query.
	 *
	 * ####Example
	 *
	 *     distinct(criteria, field, fn)
	 *     distinct(criteria, field)
	 *     distinct(field, fn)
	 *     distinct(field)
	 *     distinct(fn)
	 *     distinct()
	 *
	 * @param {Object|Query} [criteria]
	 * @param {String} [field]
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Distinct
	 * @api public
	 */
	
	Query.prototype.distinct = function (criteria, field, callback) {
	  this.op = 'distinct';
	  this._validate();
	
	  if (!callback) {
	    switch (typeof field) {
	      case 'function':
	        callback = field;
	        if ('string' == typeof criteria) {
	          field = criteria;
	          criteria = undefined;
	        }
	        break;
	      case 'undefined':
	      case 'string':
	        break;
	      default:
	        throw new TypeError('Invalid `field` argument. Must be string or function')
	        break;
	    }
	
	    switch (typeof criteria) {
	      case 'function':
	        callback = criteria;
	        criteria = field = undefined;
	        break;
	      case 'string':
	        field = criteria;
	        criteria = undefined;
	        break;
	    }
	  }
	
	  if ('string' == typeof field) {
	    this._distinct = field;
	  }
	
	  if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  if (!callback) {
	    return this;
	  }
	
	  if (!this._distinct) {
	    throw new Error('No value for `distinct` has been declared');
	  }
	
	  var conds = this._conditions
	    , options = this._optionsForExec()
	
	  debug('distinct', this._collection.collectionName, conds, options);
	  callback = this._wrapCallback('distinct', callback, {
	    conditions: conds
	  , options: options
	  });
	
	  this._collection.distinct(this._distinct, conds, options, utils.tick(callback));
	
	  return this;
	}
	
	/**
	 * Declare and/or execute this query as an update() operation.
	 *
	 * _All paths passed that are not $atomic operations will become $set ops._
	 *
	 * ####Example
	 *
	 *     mquery({ _id: id }).update({ title: 'words' }, ...)
	 *
	 * becomes
	 *
	 *     collection.update({ _id: id }, { $set: { title: 'words' }}, ...)
	 *
	 * ####Note
	 *
	 * Passing an empty object `{}` as the doc will result in a no-op unless the `overwrite` option is passed. Without the `overwrite` option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection.
	 *
	 * ####Note
	 *
	 * The operation is only executed when a callback is passed. To force execution without a callback (which would be an unsafe write), we must first call update() and then execute it by using the `exec()` method.
	 *
	 *     var q = mquery(collection).where({ _id: id });
	 *     q.update({ $set: { name: 'bob' }}).update(); // not executed
	 *
	 *     var q = mquery(collection).where({ _id: id });
	 *     q.update({ $set: { name: 'bob' }}).exec(); // executed as unsafe
	 *
	 *     // keys that are not $atomic ops become $set.
	 *     // this executes the same command as the previous example.
	 *     q.update({ name: 'bob' }).where({ _id: id }).exec();
	 *
	 *     var q = mquery(collection).update(); // not executed
	 *
	 *     // overwriting with empty docs
	 *     var q.where({ _id: id }).setOptions({ overwrite: true })
	 *     q.update({ }, callback); // executes
	 *
	 *     // multi update with overwrite to empty doc
	 *     var q = mquery(collection).where({ _id: id });
	 *     q.setOptions({ multi: true, overwrite: true })
	 *     q.update({ });
	 *     q.update(callback); // executed
	 *
	 *     // multi updates
	 *     mquery()
	 *       .collection(coll)
	 *       .update({ name: /^match/ }, { $set: { arr: [] }}, { multi: true }, callback)
	 *     // more multi updates
	 *     mquery({ })
	 *       .collection(coll)
	 *       .setOptions({ multi: true })
	 *       .update({ $set: { arr: [] }}, callback)
	 *
	 *     // single update by default
	 *     mquery({ email: 'address@example.com' })
	 *      .collection(coll)
	 *      .update({ $inc: { counter: 1 }}, callback)
	 *
	 *     // summary
	 *     update(criteria, doc, opts, cb) // executes
	 *     update(criteria, doc, opts)
	 *     update(criteria, doc, cb) // executes
	 *     update(criteria, doc)
	 *     update(doc, cb) // executes
	 *     update(doc)
	 *     update(cb) // executes
	 *     update(true) // executes (unsafe write)
	 *     update()
	 *
	 * @param {Object} [criteria]
	 * @param {Object} [doc] the update command
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.update = function update (criteria, doc, options, callback) {
	  this.op = 'update';
	  var force;
	
	  switch (arguments.length) {
	    case 3:
	      if ('function' == typeof options) {
	        callback = options;
	        options = undefined;
	      }
	      break;
	    case 2:
	      if ('function' == typeof doc) {
	        callback = doc;
	        doc = criteria;
	        criteria = undefined;
	      }
	      break;
	    case 1:
	      switch (typeof criteria) {
	        case 'function':
	          callback = criteria;
	          criteria = options = doc = undefined;
	          break;
	        case 'boolean':
	          // execution with no callback (unsafe write)
	          force = criteria;
	          criteria = undefined;
	          break;
	        default:
	          doc = criteria;
	          criteria = options = undefined;
	          break;
	      }
	  }
	
	  if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  if (doc) {
	    this._mergeUpdate(doc);
	  }
	
	  if (utils.isObject(options)) {
	    // { overwrite: true }
	    this.setOptions(options);
	  }
	
	  // we are done if we don't have callback and they are
	  // not forcing an unsafe write.
	  if (!(force || callback))
	    return this;
	
	  if (!this._update ||
	      !this.options.overwrite && 0 === utils.keys(this._update).length) {
	    callback && utils.soon(callback.bind(null, null, 0));
	    return this;
	  }
	
	  options = this._optionsForExec();
	  if (!callback) options.safe = false;
	
	  var criteria = this._conditions;
	  doc = this._updateForExec();
	
	  debug('update', this._collection.collectionName, criteria, doc, options);
	  callback = this._wrapCallback('update', callback, {
	    conditions: criteria
	  , doc: doc
	  , options: options
	  });
	
	  this._collection.update(criteria, doc, options, utils.tick(callback));
	
	  return this;
	}
	
	/**
	 * Declare and/or execute this query as a remove() operation.
	 *
	 * ####Example
	 *
	 *     mquery(collection).remove({ artist: 'Anne Murray' }, callback)
	 *
	 * ####Note
	 *
	 * The operation is only executed when a callback is passed. To force execution without a callback (which would be an unsafe write), we must first call remove() and then execute it by using the `exec()` method.
	 *
	 *     // not executed
	 *     var query = mquery(collection).remove({ name: 'Anne Murray' })
	 *
	 *     // executed
	 *     mquery(collection).remove({ name: 'Anne Murray' }, callback)
	 *     mquery(collection).remove({ name: 'Anne Murray' }).remove(callback)
	 *
	 *     // executed without a callback (unsafe write)
	 *     query.exec()
	 *
	 *     // summary
	 *     query.remove(conds, fn); // executes
	 *     query.remove(conds)
	 *     query.remove(fn) // executes
	 *     query.remove()
	 *
	 * @param {Object|Query} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.remove = function (criteria, callback) {
	  this.op = 'remove';
	  var force;
	
	  if ('function' === typeof criteria) {
	    callback = criteria;
	    criteria = undefined;
	  } else if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  } else if (true === criteria) {
	    force = criteria;
	    criteria = undefined;
	  }
	
	  if (!(force || callback))
	    return this;
	
	  var options = this._optionsForExec()
	  if (!callback) options.safe = false;
	
	  var conds = this._conditions;
	
	  debug('remove', this._collection.collectionName, conds, options);
	  callback = this._wrapCallback('remove', callback, {
	    conditions: conds
	  , options: options
	  });
	
	  this._collection.remove(conds, options, utils.tick(callback));
	
	  return this;
	}
	
	/**
	 * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.
	 *
	 * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed.
	 *
	 * ####Available options
	 *
	 * - `new`: bool - true to return the modified document rather than the original. defaults to true
	 * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 *
	 * ####Examples
	 *
	 *     query.findOneAndUpdate(conditions, update, options, callback) // executes
	 *     query.findOneAndUpdate(conditions, update, options)  // returns Query
	 *     query.findOneAndUpdate(conditions, update, callback) // executes
	 *     query.findOneAndUpdate(conditions, update)           // returns Query
	 *     query.findOneAndUpdate(update, callback)             // returns Query
	 *     query.findOneAndUpdate(update)                       // returns Query
	 *     query.findOneAndUpdate(callback)                     // executes
	 *     query.findOneAndUpdate()                             // returns Query
	 *
	 * @param {Object|Query} [query]
	 * @param {Object} [doc]
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.findOneAndUpdate = function (criteria, doc, options, callback) {
	  this.op = 'findOneAndUpdate';
	  this._validate();
	
	  switch (arguments.length) {
	    case 3:
	      if ('function' == typeof options) {
	        callback = options;
	        options = {};
	      }
	      break;
	    case 2:
	      if ('function' == typeof doc) {
	        callback = doc;
	        doc = criteria;
	        criteria = undefined;
	      }
	      options = undefined;
	      break;
	    case 1:
	      if ('function' == typeof criteria) {
	        callback = criteria;
	        criteria = options = doc = undefined;
	      } else {
	        doc = criteria;
	        criteria = options = undefined;
	      }
	  }
	
	  if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  // apply doc
	  if (doc) {
	    this._mergeUpdate(doc);
	  }
	
	  options && this.setOptions(options);
	
	  if (!callback) return this;
	  return this._findAndModify('update', callback);
	}
	
	/**
	 * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.
	 *
	 * Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if `callback` is passed.
	 *
	 * ####Available options
	 *
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 *
	 * ####Examples
	 *
	 *     A.where().findOneAndRemove(conditions, options, callback) // executes
	 *     A.where().findOneAndRemove(conditions, options)  // return Query
	 *     A.where().findOneAndRemove(conditions, callback) // executes
	 *     A.where().findOneAndRemove(conditions) // returns Query
	 *     A.where().findOneAndRemove(callback)   // executes
	 *     A.where().findOneAndRemove()           // returns Query
	 *
	 * @param {Object} [conditions]
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 * @api public
	 */
	
	Query.prototype.findOneAndRemove = function (conditions, options, callback) {
	  this.op = 'findOneAndRemove';
	  this._validate();
	
	  if ('function' == typeof options) {
	    callback = options;
	    options = undefined;
	  } else if ('function' == typeof conditions) {
	    callback = conditions;
	    conditions = undefined;
	  }
	
	  // apply conditions
	  if (Query.canMerge(conditions)) {
	    this.merge(conditions);
	  }
	
	  // apply options
	  options && this.setOptions(options);
	
	  if (!callback) return this;
	
	  return this._findAndModify('remove', callback);
	}
	
	/**
	 * _findAndModify
	 *
	 * @param {String} type - either "remove" or "update"
	 * @param {Function} callback
	 * @api private
	 */
	
	Query.prototype._findAndModify = function (type, callback) {
	  assert.equal('function', typeof callback);
	
	  var opts = this._optionsForExec()
	    , self = this
	    , fields
	    , sort
	    , doc
	
	  if ('remove' == type) {
	    opts.remove = true;
	  } else {
	    if (!('new' in opts)) opts.new = true;
	    if (!('upsert' in opts)) opts.upsert = false;
	
	    doc = this._updateForExec()
	    if (!doc) {
	      if (opts.upsert) {
	        // still need to do the upsert to empty doc
	        doc = { $set: {} };
	      } else {
	        return this.findOne(callback);
	      }
	    }
	  }
	
	  var fields = this._fieldsForExec();
	  if (fields) {
	    opts.fields = fields;
	  }
	
	  var conds = this._conditions;
	
	  debug('findAndModify', this._collection.collectionName, conds, doc, opts);
	  callback = this._wrapCallback('findAndModify', callback, {
	    conditions: conds
	  , doc: doc
	  , options: opts
	  });
	
	  this._collection
	  .findAndModify(conds, doc, opts, utils.tick(callback));
	
	  return this;
	}
	
	/**
	 * Wrap callback to add tracing
	 *
	 * @param {Function} callback
	 * @param {Object} [queryInfo]
	 * @api private
	 */
	Query.prototype._wrapCallback = function (method, callback, queryInfo) {
	  var traceFunction = this._traceFunction || Query.traceFunction;
	
	  if (traceFunction) {
	    queryInfo.collectionName = this._collection.collectionName;
	
	    var traceCallback = traceFunction &&
	      traceFunction.call(null, method, queryInfo, this);
	
	    var startTime = new Date().getTime();
	
	    return function wrapperCallback (err, result) {
	      if (traceCallback) {
	        var millis = new Date().getTime() - startTime;
	        traceCallback.call(null, err, result, millis);
	      }
	
	      if (callback) {
	        callback.apply(null, arguments);
	      }
	    };
	  }
	
	  return callback;
	}
	
	/**
	 * Add trace function that gets called when the query is executed.
	 * The function will be called with (method, queryInfo, query) and
	 * should return a callback function which will be called
	 * with (err, result, millis) when the query is complete.
	 *
	 * queryInfo is an object containing: {
	 *   collectionName: <name of the collection>,
	 *   conditions: <query criteria>,
	 *   options: <comment, fields, readPreference, etc>,
	 *   doc: [document to update, if applicable]
	 * }
	 *
	 * NOTE: Does not trace stream queries.
	 *
	 * @param {Function} traceFunction
	 * @return {Query} this
	 * @api public
	 */
	Query.prototype.setTraceFunction = function (traceFunction) {
	  this._traceFunction = traceFunction;
	  return this;
	}
	
	/**
	 * Executes the query
	 *
	 * ####Examples
	 *
	 *     query.exec();
	 *     query.exec(callback);
	 *     query.exec('update');
	 *     query.exec('find', callback);
	 *
	 * @param {String|Function} [operation]
	 * @param {Function} [callback]
	 * @api public
	 */
	
	Query.prototype.exec = function exec (op, callback) {
	  switch (typeof op) {
	    case 'function':
	      callback = op;
	      op = null;
	      break;
	    case 'string':
	      this.op = op;
	      break;
	  }
	
	  assert.ok(this.op, "Missing query type: (find, update, etc)");
	
	  if ('update' == this.op || 'remove' == this.op) {
	    callback || (callback = true);
	  }
	
	  this[this.op](callback);
	}
	
	/**
	 * Returns a thunk which when called runs this.exec()
	 *
	 * The thunk receives a callback function which will be
	 * passed to `this.exec()`
	 *
	 * @return {Function}
	 * @api public
	 */
	
	Query.prototype.thunk = function() {
	  var self = this;
	  return function(cb) {
	    self.exec(cb);
	  }
	}
	
	/**
	 * Executes the query returning a `Promise` which will be
	 * resolved with either the doc(s) or rejected with the error.
	 *
	 * @param {Function} [resolve]
	 * @param {Function} [reject]
	 * @return {Promise}
	 * @api public
	 */
	
	Query.prototype.then = function(resolve, reject) {
	  var self = this;
	  var promise = new Query.Promise(function(success, error) {
	    self.exec(function(err, val) {
	      self = resolve = reject = null;
	      if (err) return error(err);
	      success(val);
	    });
	  });
	  return promise.then(resolve, reject);
	}
	
	/**
	 * Returns a stream for the given find query.
	 *
	 * @throws Error if operation is not a find
	 * @returns {Stream} Node 0.8 style
	 */
	
	Query.prototype.stream = function(streamOptions) {
	  if ('find' != this.op)
	    throw new Error('stream() is only available for find');
	
	  var conds = this._conditions;
	
	  var options = this._optionsForExec()
	  options.fields = this._fieldsForExec()
	
	  debug('stream', this._collection.collectionName, conds, options, streamOptions);
	
	  return this._collection.findStream(conds, options, streamOptions);
	}
	
	/**
	 * Determines if field selection has been made.
	 *
	 * @return {Boolean}
	 * @api public
	 */
	
	Query.prototype.selected = function selected () {
	  return !! (this._fields && Object.keys(this._fields).length > 0);
	}
	
	/**
	 * Determines if inclusive field selection has been made.
	 *
	 *     query.selectedInclusively() // false
	 *     query.select('name')
	 *     query.selectedInclusively() // true
	 *     query.selectedExlusively() // false
	 *
	 * @returns {Boolean}
	 */
	
	Query.prototype.selectedInclusively = function selectedInclusively () {
	  if (!this._fields) return false;
	
	  var keys = Object.keys(this._fields);
	  if (0 === keys.length) return false;
	
	  for (var i = 0; i < keys.length; ++i) {
	    var key = keys[i];
	    if (0 === this._fields[key]) return false;
	  }
	
	  return true;
	}
	
	/**
	 * Determines if exclusive field selection has been made.
	 *
	 *     query.selectedExlusively() // false
	 *     query.select('-name')
	 *     query.selectedExlusively() // true
	 *     query.selectedInclusively() // false
	 *
	 * @returns {Boolean}
	 */
	
	Query.prototype.selectedExclusively = function selectedExclusively () {
	  if (!this._fields) return false;
	
	  var keys = Object.keys(this._fields);
	  if (0 === keys.length) return false;
	
	  for (var i = 0; i < keys.length; ++i) {
	    var key = keys[i];
	    if (0 === this._fields[key]) return true;
	  }
	
	  return false;
	}
	
	/**
	 * Merges `doc` with the current update object.
	 *
	 * @param {Object} doc
	 */
	
	Query.prototype._mergeUpdate = function (doc) {
	  if (!this._update) this._update = {};
	  if (doc instanceof Query) {
	    if (doc._update) {
	      utils.mergeClone(this._update, doc._update);
	    }
	  } else {
	    utils.mergeClone(this._update, doc);
	  }
	}
	
	/**
	 * Returns default options.
	 *
	 * @return {Object}
	 * @api private
	 */
	
	Query.prototype._optionsForExec = function () {
	  var options = utils.clone(this.options, { retainKeyOrder: true });
	  return options;
	}
	
	/**
	 * Returns fields selection for this query.
	 *
	 * @return {Object}
	 * @api private
	 */
	
	Query.prototype._fieldsForExec = function () {
	  return utils.clone(this._fields);
	}
	
	/**
	 * Return an update document with corrected $set operations.
	 *
	 * @api private
	 */
	
	Query.prototype._updateForExec = function () {
	  var update = utils.clone(this._update, { retainKeyOrder: true })
	    , ops = utils.keys(update)
	    , i = ops.length
	    , ret = {}
	    , hasKeys
	    , val
	
	  while (i--) {
	    var op = ops[i];
	
	    if (this.options.overwrite) {
	      ret[op] = update[op];
	      continue;
	    }
	
	    if ('$' !== op[0]) {
	      // fix up $set sugar
	      if (!ret.$set) {
	        if (update.$set) {
	          ret.$set = update.$set;
	        } else {
	          ret.$set = {};
	        }
	      }
	      ret.$set[op] = update[op];
	      ops.splice(i, 1);
	      if (!~ops.indexOf('$set')) ops.push('$set');
	    } else if ('$set' === op) {
	      if (!ret.$set) {
	        ret[op] = update[op];
	      }
	    } else {
	      ret[op] = update[op];
	    }
	  }
	
	  return ret;
	}
	
	/**
	 * Make sure _path is set.
	 *
	 * @parmam {String} method
	 */
	
	Query.prototype._ensurePath = function (method) {
	  if (!this._path) {
	    var msg = method + '() must be used after where() '
	                     + 'when called with these arguments'
	    throw new Error(msg);
	  }
	}
	
	/*!
	 * Permissions
	 */
	
	Query.permissions = __webpack_require__(/*! ./permissions */ 202);
	
	Query._isPermitted = function (a, b) {
	  var denied = Query.permissions[b];
	  if (!denied) return true;
	  return true !== denied[a];
	}
	
	Query.prototype._validate = function (action) {
	  var fail;
	  var validator;
	
	  if (undefined === action) {
	
	    validator = Query.permissions[this.op];
	    if ('function' != typeof validator) return true;
	
	    fail = validator(this);
	
	  } else if (!Query._isPermitted(action, this.op)) {
	    fail = action;
	  }
	
	  if (fail) {
	    throw new Error(fail + ' cannot be used with ' + this.op);
	  }
	}
	
	/**
	 * Determines if `conds` can be merged using `mquery().merge()`
	 *
	 * @param {Object} conds
	 * @return {Boolean}
	 */
	
	Query.canMerge = function (conds) {
	  return conds instanceof Query || utils.isObject(conds);
	}
	
	/**
	 * Set a trace function that will get called whenever a
	 * query is executed.
	 *
	 * See `setTraceFunction()` for details.
	 *
	 * @param {Object} conds
	 * @return {Boolean}
	 */
	Query.setGlobalTraceFunction = function (traceFunction) {
	  Query.traceFunction = traceFunction;
	}
	
	/*!
	 * Exports.
	 */
	
	Query.utils = utils;
	Query.env = __webpack_require__(/*! ./env */ 209)
	Query.Collection = __webpack_require__(/*! ./collection */ 210);
	Query.BaseCollection = __webpack_require__(/*! ./collection/collection */ 212);
	Query.Promise = __webpack_require__(/*! bluebird */ 213);
	module.exports = exports = Query;
	
	// TODO
	// test utils
	


/***/ },
/* 202 */
/*!************************************************!*\
  !*** ./~/mongoose/~/mquery/lib/permissions.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var denied = exports;
	
	denied.distinct = function (self) {
	  if (self._fields && Object.keys(self._fields).length > 0) {
	    return 'field selection and slice'
	  }
	
	  var keys = Object.keys(denied.distinct);
	  var err;
	
	  keys.every(function (option) {
	    if (self.options[option]) {
	      err = option;
	      return false;
	    }
	    return true;
	  });
	
	  return err;
	};
	denied.distinct.select =
	denied.distinct.slice =
	denied.distinct.sort =
	denied.distinct.limit =
	denied.distinct.skip =
	denied.distinct.batchSize =
	denied.distinct.comment =
	denied.distinct.maxScan =
	denied.distinct.snapshot =
	denied.distinct.hint =
	denied.distinct.tailable = true;
	
	
	// aggregation integration
	
	
	denied.findOneAndUpdate =
	denied.findOneAndRemove = function (self) {
	  var keys = Object.keys(denied.findOneAndUpdate);
	  var err;
	
	  keys.every(function (option) {
	    if (self.options[option]) {
	      err = option;
	      return false;
	    }
	    return true;
	  });
	
	  return err;
	}
	denied.findOneAndUpdate.limit =
	denied.findOneAndUpdate.skip =
	denied.findOneAndUpdate.batchSize =
	denied.findOneAndUpdate.maxScan =
	denied.findOneAndUpdate.snapshot =
	denied.findOneAndUpdate.hint =
	denied.findOneAndUpdate.tailable =
	denied.findOneAndUpdate.comment = true;
	
	
	denied.count = function (self) {
	  if (self._fields && Object.keys(self._fields).length > 0) {
	    return 'field selection and slice'
	  }
	
	  var keys = Object.keys(denied.count);
	  var err;
	
	  keys.every(function (option) {
	    if (self.options[option]) {
	      err = option;
	      return false;
	    }
	    return true;
	  });
	
	  return err;
	}
	
	denied.count.select =
	denied.count.slice =
	denied.count.sort =
	denied.count.batchSize =
	denied.count.comment =
	denied.count.maxScan =
	denied.count.snapshot =
	denied.count.tailable = true;


/***/ },
/* 203 */
/*!**************************************!*\
  !*** ./~/mongoose/~/sliced/index.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = exports = __webpack_require__(/*! ./lib/sliced */ 204);


/***/ },
/* 204 */
/*!*******************************************!*\
  !*** ./~/mongoose/~/sliced/lib/sliced.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * An Array.prototype.slice.call(arguments) alternative
	 *
	 * @param {Object} args something with a length
	 * @param {Number} slice
	 * @param {Number} sliceEnd
	 * @api public
	 */
	
	module.exports = function (args, slice, sliceEnd) {
	  var ret = [];
	  var len = args.length;
	
	  if (0 === len) return ret;
	
	  var start = slice < 0
	    ? Math.max(0, slice + len)
	    : slice || 0;
	
	  if (sliceEnd !== undefined) {
	    len = sliceEnd < 0
	      ? sliceEnd + len
	      : sliceEnd
	  }
	
	  while (len-- > start) {
	    ret[len - start] = args[len];
	  }
	
	  return ret;
	}
	


/***/ },
/* 205 */
/*!************************************************!*\
  !*** ./~/node-libs-browser/~/assert/assert.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// when used in node, this will actually load the util module we depend on
	// versus loading the builtin util module as happens otherwise
	// this is a bug in node module loading as far as I am concerned
	var util = __webpack_require__(/*! util/ */ 57);
	
	var pSlice = Array.prototype.slice;
	var hasOwn = Object.prototype.hasOwnProperty;
	
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.
	
	var assert = module.exports = ok;
	
	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })
	
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  }
	  else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;
	
	      // try to strip useless frames
	      var fn_name = stackStartFunction.name;
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }
	
	      this.stack = out;
	    }
	  }
	};
	
	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);
	
	function replacer(key, value) {
	  if (util.isUndefined(value)) {
	    return '' + value;
	  }
	  if (util.isNumber(value) && !isFinite(value)) {
	    return value.toString();
	  }
	  if (util.isFunction(value) || util.isRegExp(value)) {
	    return value.toString();
	  }
	  return value;
	}
	
	function truncate(s, n) {
	  if (util.isString(s)) {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	
	function getMessage(self) {
	  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(JSON.stringify(self.expected, replacer), 128);
	}
	
	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.
	
	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.
	
	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}
	
	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;
	
	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.
	
	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;
	
	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);
	
	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};
	
	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);
	
	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};
	
	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);
	
	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};
	
	function _deepEqual(actual, expected) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	
	  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
	    if (actual.length != expected.length) return false;
	
	    for (var i = 0; i < actual.length; i++) {
	      if (actual[i] !== expected[i]) return false;
	    }
	
	    return true;
	
	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();
	
	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;
	
	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!util.isObject(actual) && !util.isObject(expected)) {
	    return actual == expected;
	
	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected);
	  }
	}
	
	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}
	
	function objEquiv(a, b) {
	  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b)) {
	    return a === b;
	  }
	  var aIsArgs = isArguments(a),
	      bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b);
	  }
	  var ka = objectKeys(a),
	      kb = objectKeys(b),
	      key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key])) return false;
	  }
	  return true;
	}
	
	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);
	
	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};
	
	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);
	
	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};
	
	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
	
	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};
	
	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }
	
	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  } else if (actual instanceof expected) {
	    return true;
	  } else if (expected.call({}, actual) === true) {
	    return true;
	  }
	
	  return false;
	}
	
	function _throws(shouldThrow, block, expected, message) {
	  var actual;
	
	  if (util.isString(expected)) {
	    message = expected;
	    expected = null;
	  }
	
	  try {
	    block();
	  } catch (e) {
	    actual = e;
	  }
	
	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');
	
	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }
	
	  if (!shouldThrow && expectedException(actual, expected)) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }
	
	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}
	
	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);
	
	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws.apply(this, [true].concat(pSlice.call(arguments)));
	};
	
	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/message) {
	  _throws.apply(this, [false].concat(pSlice.call(arguments)));
	};
	
	assert.ifError = function(err) { if (err) {throw err;}};
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};


/***/ },
/* 206 */
/*!******************************************!*\
  !*** ./~/mongoose/~/mquery/lib/utils.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, process, Buffer) {'use strict';
	
	/*!
	 * Module dependencies.
	 */
	
	var RegExpClone = __webpack_require__(/*! regexp-clone */ 207)
	
	/**
	 * Clones objects
	 *
	 * @param {Object} obj the object to clone
	 * @param {Object} options
	 * @return {Object} the cloned object
	 * @api private
	 */
	
	var clone = exports.clone = function clone (obj, options) {
	  if (obj === undefined || obj === null)
	    return obj;
	
	  if (Array.isArray(obj))
	    return exports.cloneArray(obj, options);
	
	  if (obj.constructor) {
	    if (/ObjectI[dD]$/.test(obj.constructor.name)) {
	      return 'function' == typeof obj.clone
	        ? obj.clone()
	        : new obj.constructor(obj.id);
	    }
	
	    if ('ReadPreference' === obj._type && obj.isValid && obj.toObject) {
	      return 'function' == typeof obj.clone
	        ? obj.clone()
	        : new obj.constructor(obj.mode, clone(obj.tags, options));
	    }
	
	    if ('Binary' == obj._bsontype && obj.buffer && obj.value) {
	      return 'function' == typeof obj.clone
	        ? obj.clone()
	        : new obj.constructor(obj.value(true), obj.sub_type);
	    }
	
	    if ('Date' === obj.constructor.name || 'Function' === obj.constructor.name)
	      return new obj.constructor(+obj);
	
	    if ('RegExp' === obj.constructor.name)
	      return RegExpClone(obj);
	
	    if ('Buffer' === obj.constructor.name)
	      return exports.cloneBuffer(obj);
	  }
	
	  if (isObject(obj))
	    return exports.cloneObject(obj, options);
	
	  if (obj.valueOf)
	    return obj.valueOf();
	};
	
	/*!
	 * ignore
	 */
	
	var cloneObject = exports.cloneObject = function cloneObject (obj, options) {
	  var retainKeyOrder = options && options.retainKeyOrder
	    , minimize = options && options.minimize
	    , ret = {}
	    , hasKeys
	    , keys
	    , val
	    , k
	    , i
	
	  if (retainKeyOrder) {
	    for (k in obj) {
	      val = clone(obj[k], options);
	
	      if (!minimize || ('undefined' !== typeof val)) {
	        hasKeys || (hasKeys = true);
	        ret[k] = val;
	      }
	    }
	  } else {
	    // faster
	
	    keys = Object.keys(obj);
	    i = keys.length;
	
	    while (i--) {
	      k = keys[i];
	      val = clone(obj[k], options);
	
	      if (!minimize || ('undefined' !== typeof val)) {
	        if (!hasKeys) hasKeys = true;
	        ret[k] = val;
	      }
	    }
	  }
	
	  return minimize
	    ? hasKeys && ret
	    : ret;
	};
	
	var cloneArray = exports.cloneArray = function cloneArray (arr, options) {
	  var ret = [];
	  for (var i = 0, l = arr.length; i < l; i++)
	    ret.push(clone(arr[i], options));
	  return ret;
	};
	
	/**
	 * process.nextTick helper.
	 *
	 * Wraps the given `callback` in a try/catch. If an error is
	 * caught it will be thrown on nextTick.
	 *
	 * node-mongodb-native had a habit of state corruption when
	 * an error was immediately thrown from within a collection
	 * method (find, update, etc) callback.
	 *
	 * @param {Function} [callback]
	 * @api private
	 */
	
	var tick = exports.tick = function tick (callback) {
	  if ('function' !== typeof callback) return;
	  return function () {
	    // callbacks should always be fired on the next
	    // turn of the event loop. A side benefit is
	    // errors thrown from executing the callback
	    // will not cause drivers state to be corrupted
	    // which has historically been a problem.
	    var args = arguments;
	    soon(function(){
	      callback.apply(this, args);
	    });
	  }
	}
	
	/**
	 * Merges `from` into `to` without overwriting existing properties.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 * @api private
	 */
	
	var merge = exports.merge = function merge (to, from) {
	  var keys = Object.keys(from)
	    , i = keys.length
	    , key
	
	  while (i--) {
	    key = keys[i];
	    if ('undefined' === typeof to[key]) {
	      to[key] = from[key];
	    } else {
	      if (exports.isObject(from[key])) {
	        merge(to[key], from[key]);
	      } else {
	        to[key] = from[key];
	      }
	    }
	  }
	}
	
	/**
	 * Same as merge but clones the assigned values.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 * @api private
	 */
	
	var mergeClone = exports.mergeClone = function mergeClone (to, from) {
	  var keys = Object.keys(from)
	    , i = keys.length
	    , key
	
	  while (i--) {
	    key = keys[i];
	    if ('undefined' === typeof to[key]) {
	      // make sure to retain key order here because of a bug handling the $each
	      // operator in mongodb 2.4.4
	      to[key] = clone(from[key], { retainKeyOrder : 1});
	    } else {
	      if (exports.isObject(from[key])) {
	        mergeClone(to[key], from[key]);
	      } else {
	        // make sure to retain key order here because of a bug handling the
	        // $each operator in mongodb 2.4.4
	        to[key] = clone(from[key], { retainKeyOrder : 1});
	      }
	    }
	  }
	}
	
	/**
	 * Read pref helper (mongo 2.2 drivers support this)
	 *
	 * Allows using aliases instead of full preference names:
	 *
	 *     p   primary
	 *     pp  primaryPreferred
	 *     s   secondary
	 *     sp  secondaryPreferred
	 *     n   nearest
	 *
	 * @param {String} pref
	 */
	
	exports.readPref = function readPref (pref) {
	  switch (pref) {
	    case 'p':
	      pref = 'primary';
	      break;
	    case 'pp':
	      pref = 'primaryPreferred';
	      break;
	    case 's':
	      pref = 'secondary';
	      break;
	    case 'sp':
	      pref = 'secondaryPreferred';
	      break;
	    case 'n':
	      pref = 'nearest';
	      break;
	  }
	
	  return pref;
	}
	
	/**
	 * Object.prototype.toString.call helper
	 */
	
	var _toString = Object.prototype.toString;
	var toString = exports.toString = function (arg) {
	  return _toString.call(arg);
	}
	
	/**
	 * Determines if `arg` is an object.
	 *
	 * @param {Object|Array|String|Function|RegExp|any} arg
	 * @return {Boolean}
	 */
	
	var isObject = exports.isObject = function (arg) {
	  return '[object Object]' == exports.toString(arg);
	}
	
	/**
	 * Determines if `arg` is an array.
	 *
	 * @param {Object}
	 * @return {Boolean}
	 * @see nodejs utils
	 */
	
	var isArray = exports.isArray = function (arg) {
	  return Array.isArray(arg) ||
	    'object' == typeof arg && '[object Array]' == exports.toString(arg);
	}
	
	/**
	 * Object.keys helper
	 */
	
	exports.keys = Object.keys || function (obj) {
	  var keys = [];
	  for (var k in obj) if (obj.hasOwnProperty(k)) {
	    keys.push(k);
	  }
	  return keys;
	}
	
	/**
	 * Basic Object.create polyfill.
	 * Only one argument is supported.
	 *
	 * Based on https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create
	 */
	
	exports.create = 'function' == typeof Object.create
	  ? Object.create
	  : create;
	
	function create (proto) {
	  if (arguments.length > 1) {
	    throw new Error("Adding properties is not supported")
	  }
	
	  function F () {}
	  F.prototype = proto;
	  return new F;
	}
	
	/**
	 * inheritance
	 */
	
	exports.inherits = function (ctor, superCtor) {
	  ctor.prototype = exports.create(superCtor.prototype);
	  ctor.prototype.constructor = ctor;
	}
	
	/**
	 * nextTick helper
	 * compat with node 0.10 which behaves differently than previous versions
	 */
	
	var soon = exports.soon = 'function' == typeof setImmediate
	  ? setImmediate
	  : process.nextTick;
	
	/**
	 * Clones the contents of a buffer.
	 *
	 * @param {Buffer} buff
	 * @return {Buffer}
	 */
	
	exports.cloneBuffer = function (buff) {
	  var dupe = new Buffer(buff.length);
	  buff.copy(dupe, 0, 0, buff.length);
	  return dupe;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/timers-browserify/main.js */ 81).setImmediate, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43), __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 207 */
/*!********************************************!*\
  !*** ./~/mongoose/~/regexp-clone/index.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	
	var toString = Object.prototype.toString;
	
	function isRegExp (o) {
	  return 'object' == typeof o
	      && '[object RegExp]' == toString.call(o);
	}
	
	module.exports = exports = function (regexp) {
	  if (!isRegExp(regexp)) {
	    throw new TypeError('Not a RegExp');
	  }
	
	  var flags = [];
	  if (regexp.global) flags.push('g');
	  if (regexp.multiline) flags.push('m');
	  if (regexp.ignoreCase) flags.push('i');
	  return new RegExp(regexp.source, flags.join(''));
	}
	


/***/ },
/* 208 */
/*!**********************************************!*\
  !*** ./~/mongoose/~/mquery/~/debug/debug.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Expose `debug()` as the module.
	 */
	
	module.exports = debug;
	
	/**
	 * Create a debugger with the given `name`.
	 *
	 * @param {String} name
	 * @return {Type}
	 * @api public
	 */
	
	function debug(name) {
	  if (!debug.enabled(name)) return function(){};
	
	  return function(fmt){
	    fmt = coerce(fmt);
	
	    var curr = new Date;
	    var ms = curr - (debug[name] || curr);
	    debug[name] = curr;
	
	    fmt = name
	      + ' '
	      + fmt
	      + ' +' + debug.humanize(ms);
	
	    // This hackery is required for IE8
	    // where `console.log` doesn't have 'apply'
	    window.console
	      && console.log
	      && Function.prototype.apply.call(console.log, console, arguments);
	  }
	}
	
	/**
	 * The currently active debug mode names.
	 */
	
	debug.names = [];
	debug.skips = [];
	
	/**
	 * Enables a debug mode by name. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} name
	 * @api public
	 */
	
	debug.enable = function(name) {
	  try {
	    localStorage.debug = name;
	  } catch(e){}
	
	  var split = (name || '').split(/[\s,]+/)
	    , len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    name = split[i].replace('*', '.*?');
	    if (name[0] === '-') {
	      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));
	    }
	    else {
	      debug.names.push(new RegExp('^' + name + '$'));
	    }
	  }
	};
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	debug.disable = function(){
	  debug.enable('');
	};
	
	/**
	 * Humanize the given `ms`.
	 *
	 * @param {Number} m
	 * @return {String}
	 * @api private
	 */
	
	debug.humanize = function(ms) {
	  var sec = 1000
	    , min = 60 * 1000
	    , hour = 60 * min;
	
	  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';
	  if (ms >= min) return (ms / min).toFixed(1) + 'm';
	  if (ms >= sec) return (ms / sec | 0) + 's';
	  return ms + 'ms';
	};
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	debug.enabled = function(name) {
	  for (var i = 0, len = debug.skips.length; i < len; i++) {
	    if (debug.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (var i = 0, len = debug.names.length; i < len; i++) {
	    if (debug.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	};
	
	/**
	 * Coerce `val`.
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}
	
	// persist
	
	try {
	  if (window.localStorage) debug.enable(localStorage.debug);
	} catch(e){}


/***/ },
/* 209 */
/*!****************************************!*\
  !*** ./~/mongoose/~/mquery/lib/env.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global, Buffer) {'use strict';
	
	exports.isNode = 'undefined' != typeof process
	           && 'object' == typeof module
	           && 'object' == typeof global
	           && 'function' == typeof Buffer
	           && process.argv
	
	exports.isMongo = !exports.isNode
	           && 'function' == typeof printjson
	           && 'function' == typeof ObjectId
	           && 'function' == typeof rs
	           && 'function' == typeof sh;
	
	exports.isBrowser = !exports.isNode
	                 && !exports.isMongo
	                 && 'undefined' != typeof window;
	
	exports.type = exports.isNode ? 'node'
	  : exports.isMongo ? 'mongo'
	  : exports.isBrowser ? 'browser'
	  : 'unknown'
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43), (function() { return this; }()), __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 28).Buffer))

/***/ },
/* 210 */
/*!*****************************************************!*\
  !*** ./~/mongoose/~/mquery/lib/collection/index.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var env = __webpack_require__(/*! ../env */ 209)
	
	if ('unknown' == env.type) {
	  throw new Error('Unknown environment')
	}
	
	module.exports =
	  env.isNode ? __webpack_require__(/*! ./node */ 211) :
	  env.isMongo ? __webpack_require__(/*! ./collection */ 212) :
	  __webpack_require__(/*! ./collection */ 212);
	


/***/ },
/* 211 */
/*!****************************************************!*\
  !*** ./~/mongoose/~/mquery/lib/collection/node.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Module dependencies
	 */
	
	var Collection = __webpack_require__(/*! ./collection */ 212);
	var utils = __webpack_require__(/*! ../utils */ 206);
	
	function NodeCollection (col) {
	  this.collection = col;
	  this.collectionName = col.collectionName;
	}
	
	/**
	 * inherit from collection base class
	 */
	
	utils.inherits(NodeCollection, Collection);
	
	/**
	 * find(match, options, function(err, docs))
	 */
	
	NodeCollection.prototype.find = function (match, options, cb) {
	  this.collection.find(match, options, function (err, cursor) {
	    if (err) return cb(err);
	
	    cursor.toArray(cb);
	  });
	}
	
	/**
	 * findOne(match, options, function(err, doc))
	 */
	
	NodeCollection.prototype.findOne = function (match, options, cb) {
	  this.collection.findOne(match, options, cb);
	}
	
	/**
	 * count(match, options, function(err, count))
	 */
	
	NodeCollection.prototype.count = function (match, options, cb) {
	  this.collection.count(match, options, cb);
	}
	
	/**
	 * distinct(prop, match, options, function(err, count))
	 */
	
	NodeCollection.prototype.distinct  = function (prop, match, options, cb) {
	  this.collection.distinct(prop, match, options, cb);
	}
	
	/**
	 * update(match, update, options, function(err[, result]))
	 */
	
	NodeCollection.prototype.update = function (match, update, options, cb) {
	  this.collection.update(match, update, options, cb);
	}
	
	/**
	 * remove(match, options, function(err[, result])
	 */
	
	NodeCollection.prototype.remove = function (match, options, cb) {
	  this.collection.remove(match, options, cb);
	}
	
	/**
	 * findAndModify(match, update, options, function(err, doc))
	 */
	
	NodeCollection.prototype.findAndModify = function (match, update, options, cb) {
	  var sort = Array.isArray(options.sort) ? options.sort : [];
	  this.collection.findAndModify(match, sort, update, options, cb);
	}
	
	/**
	 * var stream = findStream(match, findOptions, streamOptions)
	 */
	
	NodeCollection.prototype.findStream = function(match, findOptions, streamOptions) {
	  return this.collection.find(match, findOptions).stream(streamOptions);
	}
	
	/**
	 * aggregation(operators..., function(err, doc))
	 * TODO
	 */
	
	/**
	 * Expose
	 */
	
	module.exports = exports = NodeCollection;
	


/***/ },
/* 212 */
/*!**********************************************************!*\
  !*** ./~/mongoose/~/mquery/lib/collection/collection.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * methods a collection must implement
	 */
	
	var methods = [
	    'find'
	  , 'findOne'
	  , 'update'
	  , 'remove'
	  , 'count'
	  , 'distinct'
	  , 'findAndModify'
	  , 'aggregate'
	  , 'findStream'
	];
	
	/**
	 * Collection base class from which implementations inherit
	 */
	
	function Collection () {}
	
	for (var i = 0, len = methods.length; i < len; ++i) {
	  var method = methods[i];
	  Collection.prototype[method] = notImplemented(method);
	}
	
	module.exports = exports = Collection;
	Collection.methods = methods;
	
	/**
	 * creates a function which throws an implementation error
	 */
	
	function notImplemented (method) {
	  return function () {
	    throw new Error('collection.' + method + ' not implemented');
	  }
	}
	


/***/ },
/* 213 */
/*!***************************************************************!*\
  !*** ./~/mongoose/~/mquery/~/bluebird/js/browser/bluebird.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {/* @preserve
	 * The MIT License (MIT)
	 * 
	 * Copyright (c) 2014 Petka Antonov
	 * 
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 * 
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 * 
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 * 
	 */
	/**
	 * bluebird build version 2.9.9
	 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, progress, cancel, using, filter, any, each, timers
	*/
	!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var SomePromiseArray = Promise._SomePromiseArray;
	function any(promises) {
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(1);
	    ret.setUnwrap();
	    ret.init();
	    return promise;
	}
	
	Promise.any = function (promises) {
	    return any(promises);
	};
	
	Promise.prototype.any = function () {
	    return any(this);
	};
	
	};
	
	},{}],2:[function(_dereq_,module,exports){
	"use strict";
	var firstLineError;
	try {throw new Error(); } catch (e) {firstLineError = e;}
	var schedule = _dereq_("./schedule.js");
	var Queue = _dereq_("./queue.js");
	var _process = typeof process !== "undefined" ? process : undefined;
	
	function Async() {
	    this._isTickUsed = false;
	    this._lateQueue = new Queue(16);
	    this._normalQueue = new Queue(16);
	    var self = this;
	    this.drainQueues = function () {
	        self._drainQueues();
	    };
	    this._schedule =
	        schedule.isStatic ? schedule(this.drainQueues) : schedule;
	}
	
	Async.prototype.haveItemsQueued = function () {
	    return this._normalQueue.length() > 0;
	};
	
	Async.prototype._withDomain = function(fn) {
	    if (_process !== undefined &&
	        _process.domain != null &&
	        !fn.domain) {
	        fn = _process.domain.bind(fn);
	    }
	    return fn;
	};
	
	Async.prototype.throwLater = function(fn, arg) {
	    if (arguments.length === 1) {
	        arg = fn;
	        fn = function () { throw arg; };
	    }
	    fn = this._withDomain(fn);
	    if (typeof setTimeout !== "undefined") {
	        setTimeout(function() {
	            fn(arg);
	        }, 0);
	    } else try {
	        this._schedule(function() {
	            fn(arg);
	        });
	    } catch (e) {
	        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
	    }
	};
	
	Async.prototype.invokeLater = function (fn, receiver, arg) {
	    fn = this._withDomain(fn);
	    this._lateQueue.push(fn, receiver, arg);
	    this._queueTick();
	};
	
	Async.prototype.invokeFirst = function (fn, receiver, arg) {
	    fn = this._withDomain(fn);
	    this._normalQueue.unshift(fn, receiver, arg);
	    this._queueTick();
	};
	
	Async.prototype.invoke = function (fn, receiver, arg) {
	    fn = this._withDomain(fn);
	    this._normalQueue.push(fn, receiver, arg);
	    this._queueTick();
	};
	
	Async.prototype.settlePromises = function(promise) {
	    this._normalQueue._pushOne(promise);
	    this._queueTick();
	};
	
	Async.prototype._drainQueue = function(queue) {
	    while (queue.length() > 0) {
	        var fn = queue.shift();
	        if (typeof fn !== "function") {
	            fn._settlePromises();
	            continue;
	        }
	        var receiver = queue.shift();
	        var arg = queue.shift();
	        fn.call(receiver, arg);
	    }
	};
	
	Async.prototype._drainQueues = function () {
	    this._drainQueue(this._normalQueue);
	    this._reset();
	    this._drainQueue(this._lateQueue);
	};
	
	Async.prototype._queueTick = function () {
	    if (!this._isTickUsed) {
	        this._isTickUsed = true;
	        this._schedule(this.drainQueues);
	    }
	};
	
	Async.prototype._reset = function () {
	    this._isTickUsed = false;
	};
	
	module.exports = new Async();
	module.exports.firstLineError = firstLineError;
	
	},{"./queue.js":28,"./schedule.js":31}],3:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
	function returnThis() { return this.value; }
	function throwThis() { throw this.reason; }
	function awaitBindingThenResolve(value) {
	    return this._then(returnThis, null, null, {value: value}, undefined);
	}
	function awaitBindingThenReject(reason) {
	    return this._then(throwThis, throwThis, null, {reason: reason}, undefined);
	}
	function setBinding(binding) { this._setBoundTo(binding); }
	Promise.prototype.bind = function (thisArg) {
	    var maybePromise = tryConvertToPromise(thisArg);
	    if (maybePromise instanceof Promise) {
	        if (maybePromise.isFulfilled()) {
	            thisArg = maybePromise.value();
	        } else if (maybePromise.isRejected()) {
	            return Promise.reject(maybePromise.reason());
	        } else {
	            var ret = this.then();
	            var parent = ret;
	            ret = ret._then(awaitBindingThenResolve,
	                            awaitBindingThenReject,
	                            null, maybePromise, undefined);
	            maybePromise._then(setBinding, ret._reject, null, ret, null);
	            if (!ret._cancellable()) ret._setPendingCancellationParent(parent);
	            return ret;
	        }
	    }
	    var ret = this.then();
	    ret._setBoundTo(thisArg);
	    return ret;
	};
	
	Promise.bind = function (thisArg, value) {
	    return Promise.resolve(value).bind(thisArg);
	};
	
	Promise.prototype._setPendingCancellationParent = function(parent) {
	    this._settledValue = parent;
	};
	
	Promise.prototype._pendingCancellationParent = function() {
	    if (this.isPending() && this._settledValue !== undefined) {
	        var ret = this._settledValue;
	        ret.cancellable();
	        this._settledValue = undefined;
	        return ret;
	    }
	};
	
	Promise.prototype._setIsBound = function () {
	    this._bitField = this._bitField | 131072;
	};
	
	Promise.prototype._unsetIsBound = function () {
	    this._bitField = this._bitField & (~131072);
	};
	
	Promise.prototype._isBound = function () {
	    return (this._bitField & 131072) === 131072;
	};
	
	Promise.prototype._setIsMigratingBinding = function () {
	    this._bitField = this._bitField | 8388608;
	};
	
	Promise.prototype._unsetIsMigratingBinding = function () {
	    this._bitField = this._bitField & (~8388608);
	};
	
	Promise.prototype._isMigratingBinding = function () {
	    return (this._bitField & 8388608) === 8388608;
	};
	
	Promise.prototype._setBoundTo = function (obj) {
	    if (obj === undefined) {
	        if (this._isBound()) {
	            this._boundTo = undefined;
	        }
	        this._unsetIsBound();
	    } else {
	        this._setIsBound();
	        this._boundTo = obj;
	    }
	};
	};
	
	},{}],4:[function(_dereq_,module,exports){
	"use strict";
	var old;
	if (typeof Promise !== "undefined") old = Promise;
	function noConflict() {
	    try { if (Promise === bluebird) Promise = old; }
	    catch (e) {}
	    return bluebird;
	}
	var bluebird = _dereq_("./promise.js")();
	bluebird.noConflict = noConflict;
	module.exports = bluebird;
	
	},{"./promise.js":23}],5:[function(_dereq_,module,exports){
	"use strict";
	var cr = Object.create;
	if (cr) {
	    var callerCache = cr(null);
	    var getterCache = cr(null);
	    callerCache[" size"] = getterCache[" size"] = 0;
	}
	
	module.exports = function(Promise) {
	var util = _dereq_("./util.js");
	var canEvaluate = util.canEvaluate;
	var isIdentifier = util.isIdentifier;
	
	var getMethodCaller;
	var getGetter;
	if (false) {
	var makeMethodCaller = function (methodName) {
	    return new Function("ensureMethod", "                                    \n\
	        return function(obj) {                                               \n\
	            'use strict'                                                     \n\
	            var len = this.length;                                           \n\
	            ensureMethod(obj, 'methodName');                                 \n\
	            switch(len) {                                                    \n\
	                case 1: return obj.methodName(this[0]);                      \n\
	                case 2: return obj.methodName(this[0], this[1]);             \n\
	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
	                case 0: return obj.methodName();                             \n\
	                default:                                                     \n\
	                    return obj.methodName.apply(obj, this);                  \n\
	            }                                                                \n\
	        };                                                                   \n\
	        ".replace(/methodName/g, methodName))(ensureMethod);
	};
	
	var makeGetter = function (propertyName) {
	    return new Function("obj", "                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName", propertyName));
	};
	
	var getCompiled = function(name, compiler, cache) {
	    var ret = cache[name];
	    if (typeof ret !== "function") {
	        if (!isIdentifier(name)) {
	            return null;
	        }
	        ret = compiler(name);
	        cache[name] = ret;
	        cache[" size"]++;
	        if (cache[" size"] > 512) {
	            var keys = Object.keys(cache);
	            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
	            cache[" size"] = keys.length - 256;
	        }
	    }
	    return ret;
	};
	
	getMethodCaller = function(name) {
	    return getCompiled(name, makeMethodCaller, callerCache);
	};
	
	getGetter = function(name) {
	    return getCompiled(name, makeGetter, getterCache);
	};
	}
	
	function ensureMethod(obj, methodName) {
	    var fn;
	    if (obj != null) fn = obj[methodName];
	    if (typeof fn !== "function") {
	        var message = "Object " + util.classString(obj) + " has no method '" +
	            util.toString(methodName) + "'";
	        throw new Promise.TypeError(message);
	    }
	    return fn;
	}
	
	function caller(obj) {
	    var methodName = this.pop();
	    var fn = ensureMethod(obj, methodName);
	    return fn.apply(obj, this);
	}
	Promise.prototype.call = function (methodName) {
	    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	    if (false) {
	        if (canEvaluate) {
	            var maybeCaller = getMethodCaller(methodName);
	            if (maybeCaller !== null) {
	                return this._then(
	                    maybeCaller, undefined, undefined, args, undefined);
	            }
	        }
	    }
	    args.push(methodName);
	    return this._then(caller, undefined, undefined, args, undefined);
	};
	
	function namedGetter(obj) {
	    return obj[this];
	}
	function indexedGetter(obj) {
	    var index = +this;
	    if (index < 0) index = Math.max(0, index + obj.length);
	    return obj[index];
	}
	Promise.prototype.get = function (propertyName) {
	    var isIndex = (typeof propertyName === "number");
	    var getter;
	    if (!isIndex) {
	        if (canEvaluate) {
	            var maybeGetter = getGetter(propertyName);
	            getter = maybeGetter !== null ? maybeGetter : namedGetter;
	        } else {
	            getter = namedGetter;
	        }
	    } else {
	        getter = indexedGetter;
	    }
	    return this._then(getter, undefined, undefined, propertyName, undefined);
	};
	};
	
	},{"./util.js":38}],6:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var errors = _dereq_("./errors.js");
	var async = _dereq_("./async.js");
	var CancellationError = errors.CancellationError;
	
	Promise.prototype._cancel = function (reason) {
	    if (!this.isCancellable()) return this;
	    var parent;
	    var promiseToReject = this;
	    while ((parent = promiseToReject._cancellationParent) !== undefined &&
	        parent.isCancellable()) {
	        promiseToReject = parent;
	    }
	    this._unsetCancellable();
	    promiseToReject._target()._rejectCallback(reason, false, true);
	};
	
	Promise.prototype.cancel = function (reason) {
	    if (!this.isCancellable()) return this;
	    if (reason === undefined) reason = new CancellationError();
	    async.invokeLater(this._cancel, this, reason);
	    return this;
	};
	
	Promise.prototype.cancellable = function () {
	    if (this._cancellable()) return this;
	    this._setCancellable();
	    this._cancellationParent = this._pendingCancellationParent();
	    return this;
	};
	
	Promise.prototype.uncancellable = function () {
	    var ret = this.then();
	    ret._unsetCancellable();
	    return ret;
	};
	
	Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
	    var ret = this._then(didFulfill, didReject, didProgress,
	                         undefined, undefined);
	
	    ret._setCancellable();
	    ret._cancellationParent = undefined;
	    return ret;
	};
	};
	
	},{"./async.js":2,"./errors.js":13}],7:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var bluebirdFramePattern =
	    /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
	var stackFramePattern = null;
	var formatStack = null;
	var indentStackFrames = false;
	var warn;
	
	function CapturedTrace(parent) {
	    this._parent = parent;
	    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
	    captureStackTrace(this, CapturedTrace);
	    if (length > 32) this.uncycle();
	}
	util.inherits(CapturedTrace, Error);
	
	CapturedTrace.prototype.uncycle = function() {
	    var length = this._length;
	    if (length < 2) return;
	    var nodes = [];
	    var stackToIndex = {};
	
	    for (var i = 0, node = this; node !== undefined; ++i) {
	        nodes.push(node);
	        node = node._parent;
	    }
	    length = this._length = i;
	    for (var i = length - 1; i >= 0; --i) {
	        var stack = nodes[i].stack;
	        if (stackToIndex[stack] === undefined) {
	            stackToIndex[stack] = i;
	        }
	    }
	    for (var i = 0; i < length; ++i) {
	        var currentStack = nodes[i].stack;
	        var index = stackToIndex[currentStack];
	        if (index !== undefined && index !== i) {
	            if (index > 0) {
	                nodes[index - 1]._parent = undefined;
	                nodes[index - 1]._length = 1;
	            }
	            nodes[i]._parent = undefined;
	            nodes[i]._length = 1;
	            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
	
	            if (index < length - 1) {
	                cycleEdgeNode._parent = nodes[index + 1];
	                cycleEdgeNode._parent.uncycle();
	                cycleEdgeNode._length =
	                    cycleEdgeNode._parent._length + 1;
	            } else {
	                cycleEdgeNode._parent = undefined;
	                cycleEdgeNode._length = 1;
	            }
	            var currentChildLength = cycleEdgeNode._length + 1;
	            for (var j = i - 2; j >= 0; --j) {
	                nodes[j]._length = currentChildLength;
	                currentChildLength++;
	            }
	            return;
	        }
	    }
	};
	
	CapturedTrace.prototype.parent = function() {
	    return this._parent;
	};
	
	CapturedTrace.prototype.hasParent = function() {
	    return this._parent !== undefined;
	};
	
	CapturedTrace.prototype.attachExtraTrace = function(error) {
	    if (error.__stackCleaned__) return;
	    this.uncycle();
	    var parsed = CapturedTrace.parseStackAndMessage(error);
	    var message = parsed.message;
	    var stacks = [parsed.stack];
	
	    var trace = this;
	    while (trace !== undefined) {
	        stacks.push(cleanStack(trace.stack.split("\n")));
	        trace = trace._parent;
	    }
	    removeCommonRoots(stacks);
	    removeDuplicateOrEmptyJumps(stacks);
	    error.stack = reconstructStack(message, stacks);
	    error.__stackCleaned__ = true;
	};
	
	function reconstructStack(message, stacks) {
	    for (var i = 0; i < stacks.length - 1; ++i) {
	        stacks[i].push("From previous event:");
	        stacks[i] = stacks[i].join("\n");
	    }
	    if (i < stacks.length) {
	        stacks[i] = stacks[i].join("\n");
	    }
	    return message + "\n" + stacks.join("\n");
	}
	
	function removeDuplicateOrEmptyJumps(stacks) {
	    for (var i = 0; i < stacks.length; ++i) {
	        if (stacks[i].length === 0 ||
	            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
	            stacks.splice(i, 1);
	            i--;
	        }
	    }
	}
	
	function removeCommonRoots(stacks) {
	    var current = stacks[0];
	    for (var i = 1; i < stacks.length; ++i) {
	        var prev = stacks[i];
	        var currentLastIndex = current.length - 1;
	        var currentLastLine = current[currentLastIndex];
	        var commonRootMeetPoint = -1;
	
	        for (var j = prev.length - 1; j >= 0; --j) {
	            if (prev[j] === currentLastLine) {
	                commonRootMeetPoint = j;
	                break;
	            }
	        }
	
	        for (var j = commonRootMeetPoint; j >= 0; --j) {
	            var line = prev[j];
	            if (current[currentLastIndex] === line) {
	                current.pop();
	                currentLastIndex--;
	            } else {
	                break;
	            }
	        }
	        current = prev;
	    }
	}
	
	function cleanStack(stack) {
	    var ret = [];
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        var isTraceLine = stackFramePattern.test(line) ||
	            "    (No stack trace)" === line;
	        var isInternalFrame = isTraceLine && shouldIgnore(line);
	        if (isTraceLine && !isInternalFrame) {
	            if (indentStackFrames && line.charAt(0) !== " ") {
	                line = "    " + line;
	            }
	            ret.push(line);
	        }
	    }
	    return ret;
	}
	
	function stackFramesAsArray(error) {
	    var stack = error.stack.replace(/\s+$/g, "").split("\n");
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
	            break;
	        }
	    }
	    if (i > 0) {
	        stack = stack.slice(i);
	    }
	    return stack;
	}
	
	CapturedTrace.parseStackAndMessage = function(error) {
	    var stack = error.stack;
	    var message = error.toString();
	    stack = typeof stack === "string" && stack.length > 0
	                ? stackFramesAsArray(error) : ["    (No stack trace)"];
	    return {
	        message: message,
	        stack: cleanStack(stack)
	    };
	};
	
	CapturedTrace.formatAndLogError = function(error, title) {
	    if (typeof console !== "undefined") {
	        var message;
	        if (typeof error === "object" || typeof error === "function") {
	            var stack = error.stack;
	            message = title + formatStack(stack, error);
	        } else {
	            message = title + String(error);
	        }
	        if (typeof warn === "function") {
	            warn(message);
	        } else if (typeof console.log === "function" ||
	            typeof console.log === "object") {
	            console.log(message);
	        }
	    }
	};
	
	CapturedTrace.unhandledRejection = function (reason) {
	    CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
	};
	
	CapturedTrace.isSupported = function () {
	    return typeof captureStackTrace === "function";
	};
	
	CapturedTrace.fireRejectionEvent =
	function(name, localHandler, reason, promise) {
	    var localEventFired = false;
	    try {
	        if (typeof localHandler === "function") {
	            localEventFired = true;
	            if (name === "rejectionHandled") {
	                localHandler(promise);
	            } else {
	                localHandler(reason, promise);
	            }
	        }
	    } catch (e) {
	        async.throwLater(e);
	    }
	
	    var globalEventFired = false;
	    try {
	        globalEventFired = fireGlobalEvent(name, reason, promise);
	    } catch (e) {
	        globalEventFired = true;
	        async.throwLater(e);
	    }
	
	    var domEventFired = false;
	    if (fireDomEvent) {
	        try {
	            domEventFired = fireDomEvent(name.toLowerCase(), {
	                reason: reason,
	                promise: promise
	            });
	        } catch (e) {
	            domEventFired = true;
	            async.throwLater(e);
	        }
	    }
	
	    if (!globalEventFired && !localEventFired && !domEventFired &&
	        name === "unhandledRejection") {
	        CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
	    }
	};
	
	function formatNonError(obj) {
	    var str;
	    if (typeof obj === "function") {
	        str = "[function " +
	            (obj.name || "anonymous") +
	            "]";
	    } else {
	        str = obj.toString();
	        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
	        if (ruselessToString.test(str)) {
	            try {
	                var newStr = JSON.stringify(obj);
	                str = newStr;
	            }
	            catch(e) {
	
	            }
	        }
	        if (str.length === 0) {
	            str = "(empty array)";
	        }
	    }
	    return ("(<" + snip(str) + ">, no stack trace)");
	}
	
	function snip(str) {
	    var maxChars = 41;
	    if (str.length < maxChars) {
	        return str;
	    }
	    return str.substr(0, maxChars - 3) + "...";
	}
	
	var shouldIgnore = function() { return false; };
	var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
	function parseLineInfo(line) {
	    var matches = line.match(parseLineInfoRegex);
	    if (matches) {
	        return {
	            fileName: matches[1],
	            line: parseInt(matches[2], 10)
	        };
	    }
	}
	CapturedTrace.setBounds = function(firstLineError, lastLineError) {
	    if (!CapturedTrace.isSupported()) return;
	    var firstStackLines = firstLineError.stack.split("\n");
	    var lastStackLines = lastLineError.stack.split("\n");
	    var firstIndex = -1;
	    var lastIndex = -1;
	    var firstFileName;
	    var lastFileName;
	    for (var i = 0; i < firstStackLines.length; ++i) {
	        var result = parseLineInfo(firstStackLines[i]);
	        if (result) {
	            firstFileName = result.fileName;
	            firstIndex = result.line;
	            break;
	        }
	    }
	    for (var i = 0; i < lastStackLines.length; ++i) {
	        var result = parseLineInfo(lastStackLines[i]);
	        if (result) {
	            lastFileName = result.fileName;
	            lastIndex = result.line;
	            break;
	        }
	    }
	    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
	        firstFileName !== lastFileName || firstIndex >= lastIndex) {
	        return;
	    }
	
	    shouldIgnore = function(line) {
	        if (bluebirdFramePattern.test(line)) return true;
	        var info = parseLineInfo(line);
	        if (info) {
	            if (info.fileName === firstFileName &&
	                (firstIndex <= info.line && info.line <= lastIndex)) {
	                return true;
	            }
	        }
	        return false;
	    };
	};
	
	var captureStackTrace = (function stackDetection() {
	    var v8stackFramePattern = /^\s*at\s*/;
	    var v8stackFormatter = function(stack, error) {
	        if (typeof stack === "string") return stack;
	
	        if (error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };
	
	    if (typeof Error.stackTraceLimit === "number" &&
	        typeof Error.captureStackTrace === "function") {
	        Error.stackTraceLimit = Error.stackTraceLimit + 6;
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        var captureStackTrace = Error.captureStackTrace;
	
	        shouldIgnore = function(line) {
	            return bluebirdFramePattern.test(line);
	        };
	        return function(receiver, ignoreUntil) {
	            Error.stackTraceLimit = Error.stackTraceLimit + 6;
	            captureStackTrace(receiver, ignoreUntil);
	            Error.stackTraceLimit = Error.stackTraceLimit - 6;
	        };
	    }
	    var err = new Error();
	
	    if (typeof err.stack === "string" &&
	        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
	        stackFramePattern = /@/;
	        formatStack = v8stackFormatter;
	        indentStackFrames = true;
	        return function captureStackTrace(o) {
	            o.stack = new Error().stack;
	        };
	    }
	
	    var hasStackAfterThrow;
	    try { throw new Error(); }
	    catch(e) {
	        hasStackAfterThrow = ("stack" in e);
	    }
	    if (!("stack" in err) && hasStackAfterThrow) {
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        return function captureStackTrace(o) {
	            Error.stackTraceLimit = Error.stackTraceLimit + 6;
	            try { throw new Error(); }
	            catch(e) { o.stack = e.stack; }
	            Error.stackTraceLimit = Error.stackTraceLimit - 6;
	        };
	    }
	
	    formatStack = function(stack, error) {
	        if (typeof stack === "string") return stack;
	
	        if ((typeof error === "object" ||
	            typeof error === "function") &&
	            error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };
	
	    return null;
	
	})([]);
	
	var fireDomEvent;
	var fireGlobalEvent = (function() {
	    if (util.isNode) {
	        return function(name, reason, promise) {
	            if (name === "rejectionHandled") {
	                return process.emit(name, promise);
	            } else {
	                return process.emit(name, reason, promise);
	            }
	        };
	    } else {
	        var customEventWorks = false;
	        var anyEventWorks = true;
	        try {
	            var ev = new self.CustomEvent("test");
	            customEventWorks = ev instanceof CustomEvent;
	        } catch (e) {}
	        if (!customEventWorks) {
	            try {
	                var event = document.createEvent("CustomEvent");
	                event.initCustomEvent("testingtheevent", false, true, {});
	                self.dispatchEvent(event);
	            } catch (e) {
	                anyEventWorks = false;
	            }
	        }
	        if (anyEventWorks) {
	            fireDomEvent = function(type, detail) {
	                var event;
	                if (customEventWorks) {
	                    event = new self.CustomEvent(type, {
	                        detail: detail,
	                        bubbles: false,
	                        cancelable: true
	                    });
	                } else if (self.dispatchEvent) {
	                    event = document.createEvent("CustomEvent");
	                    event.initCustomEvent(type, false, true, detail);
	                }
	
	                return event ? !self.dispatchEvent(event) : false;
	            };
	        }
	
	        var toWindowMethodNameMap = {};
	        toWindowMethodNameMap["unhandledRejection"] = ("on" +
	            "unhandledRejection").toLowerCase();
	        toWindowMethodNameMap["rejectionHandled"] = ("on" +
	            "rejectionHandled").toLowerCase();
	
	        return function(name, reason, promise) {
	            var methodName = toWindowMethodNameMap[name];
	            var method = self[methodName];
	            if (!method) return false;
	            if (name === "rejectionHandled") {
	                method.call(self, promise);
	            } else {
	                method.call(self, reason, promise);
	            }
	            return true;
	        };
	    }
	})();
	
	if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
	    warn = function (message) {
	        console.warn(message);
	    };
	    if (util.isNode && process.stderr.isTTY) {
	        warn = function(message) {
	            process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
	        };
	    } else if (!util.isNode && typeof (new Error().stack) === "string") {
	        warn = function(message) {
	            console.warn("%c" + message, "color: red");
	        };
	    }
	}
	
	return CapturedTrace;
	};
	
	},{"./async.js":2,"./util.js":38}],8:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(NEXT_FILTER) {
	var util = _dereq_("./util.js");
	var errors = _dereq_("./errors.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var keys = _dereq_("./es5.js").keys;
	var TypeError = errors.TypeError;
	
	function CatchFilter(instances, callback, promise) {
	    this._instances = instances;
	    this._callback = callback;
	    this._promise = promise;
	}
	
	function safePredicate(predicate, e) {
	    var safeObject = {};
	    var retfilter = tryCatch(predicate).call(safeObject, e);
	
	    if (retfilter === errorObj) return retfilter;
	
	    var safeKeys = keys(safeObject);
	    if (safeKeys.length) {
	        errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
	        return errorObj;
	    }
	    return retfilter;
	}
	
	CatchFilter.prototype.doFilter = function (e) {
	    var cb = this._callback;
	    var promise = this._promise;
	    var boundTo = promise._boundTo;
	    for (var i = 0, len = this._instances.length; i < len; ++i) {
	        var item = this._instances[i];
	        var itemIsErrorType = item === Error ||
	            (item != null && item.prototype instanceof Error);
	
	        if (itemIsErrorType && e instanceof item) {
	            var ret = tryCatch(cb).call(boundTo, e);
	            if (ret === errorObj) {
	                NEXT_FILTER.e = ret.e;
	                return NEXT_FILTER;
	            }
	            return ret;
	        } else if (typeof item === "function" && !itemIsErrorType) {
	            var shouldHandle = safePredicate(item, e);
	            if (shouldHandle === errorObj) {
	                e = errorObj.e;
	                break;
	            } else if (shouldHandle) {
	                var ret = tryCatch(cb).call(boundTo, e);
	                if (ret === errorObj) {
	                    NEXT_FILTER.e = ret.e;
	                    return NEXT_FILTER;
	                }
	                return ret;
	            }
	        }
	    }
	    NEXT_FILTER.e = e;
	    return NEXT_FILTER;
	};
	
	return CatchFilter;
	};
	
	},{"./errors.js":13,"./es5.js":14,"./util.js":38}],9:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, CapturedTrace, isDebugging) {
	var contextStack = [];
	function Context() {
	    this._trace = new CapturedTrace(peekContext());
	}
	Context.prototype._pushContext = function () {
	    if (!isDebugging()) return;
	    if (this._trace !== undefined) {
	        contextStack.push(this._trace);
	    }
	};
	
	Context.prototype._popContext = function () {
	    if (!isDebugging()) return;
	    if (this._trace !== undefined) {
	        contextStack.pop();
	    }
	};
	
	function createContext() {
	    if (isDebugging()) return new Context();
	}
	
	function peekContext() {
	    var lastIndex = contextStack.length - 1;
	    if (lastIndex >= 0) {
	        return contextStack[lastIndex];
	    }
	    return undefined;
	}
	
	Promise.prototype._peekContext = peekContext;
	Promise.prototype._pushContext = Context.prototype._pushContext;
	Promise.prototype._popContext = Context.prototype._popContext;
	
	return createContext;
	};
	
	},{}],10:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, CapturedTrace) {
	var async = _dereq_("./async.js");
	var Warning = _dereq_("./errors.js").Warning;
	var util = _dereq_("./util.js");
	var canAttachTrace = util.canAttachTrace;
	var unhandledRejectionHandled;
	var possiblyUnhandledRejection;
	var debugging = false || (util.isNode &&
	                    (!!process.env["BLUEBIRD_DEBUG"] ||
	                     process.env["NODE_ENV"] === "development"));
	
	Promise.prototype._ensurePossibleRejectionHandled = function () {
	    this._setRejectionIsUnhandled();
	    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
	};
	
	Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
	    CapturedTrace.fireRejectionEvent("rejectionHandled",
	                                  unhandledRejectionHandled, undefined, this);
	};
	
	Promise.prototype._notifyUnhandledRejection = function () {
	    if (this._isRejectionUnhandled()) {
	        var reason = this._getCarriedStackTrace() || this._settledValue;
	        this._setUnhandledRejectionIsNotified();
	        CapturedTrace.fireRejectionEvent("unhandledRejection",
	                                      possiblyUnhandledRejection, reason, this);
	    }
	};
	
	Promise.prototype._setUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField | 524288;
	};
	
	Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField & (~524288);
	};
	
	Promise.prototype._isUnhandledRejectionNotified = function () {
	    return (this._bitField & 524288) > 0;
	};
	
	Promise.prototype._setRejectionIsUnhandled = function () {
	    this._bitField = this._bitField | 2097152;
	};
	
	Promise.prototype._unsetRejectionIsUnhandled = function () {
	    this._bitField = this._bitField & (~2097152);
	    if (this._isUnhandledRejectionNotified()) {
	        this._unsetUnhandledRejectionIsNotified();
	        this._notifyUnhandledRejectionIsHandled();
	    }
	};
	
	Promise.prototype._isRejectionUnhandled = function () {
	    return (this._bitField & 2097152) > 0;
	};
	
	Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
	    this._bitField = this._bitField | 1048576;
	    this._fulfillmentHandler0 = capturedTrace;
	};
	
	Promise.prototype._isCarryingStackTrace = function () {
	    return (this._bitField & 1048576) > 0;
	};
	
	Promise.prototype._getCarriedStackTrace = function () {
	    return this._isCarryingStackTrace()
	        ? this._fulfillmentHandler0
	        : undefined;
	};
	
	Promise.prototype._captureStackTrace = function () {
	    if (debugging) {
	        this._trace = new CapturedTrace(this._peekContext());
	    }
	    return this;
	};
	
	Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
	    if (debugging && canAttachTrace(error)) {
	        var trace = this._trace;
	        if (trace !== undefined) {
	            if (ignoreSelf) trace = trace._parent;
	        }
	        if (trace !== undefined) {
	            trace.attachExtraTrace(error);
	        } else if (!error.__stackCleaned__) {
	            var parsed = CapturedTrace.parseStackAndMessage(error);
	            error.stack = parsed.message + "\n" + parsed.stack.join("\n");
	            error.__stackCleaned__ = true;
	        }
	    }
	};
	
	Promise.prototype._warn = function(message) {
	    var warning = new Warning(message);
	    var ctx = this._peekContext();
	    if (ctx) {
	        ctx.attachExtraTrace(warning);
	    } else {
	        var parsed = CapturedTrace.parseStackAndMessage(warning);
	        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
	    }
	    CapturedTrace.formatAndLogError(warning, "");
	};
	
	Promise.onPossiblyUnhandledRejection = function (fn) {
	    possiblyUnhandledRejection = typeof fn === "function" ? fn : undefined;
	};
	
	Promise.onUnhandledRejectionHandled = function (fn) {
	    unhandledRejectionHandled = typeof fn === "function" ? fn : undefined;
	};
	
	Promise.longStackTraces = function () {
	    if (async.haveItemsQueued() &&
	        debugging === false
	   ) {
	        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
	    }
	    debugging = CapturedTrace.isSupported();
	};
	
	Promise.hasLongStackTraces = function () {
	    return debugging && CapturedTrace.isSupported();
	};
	
	if (!CapturedTrace.isSupported()) {
	    Promise.longStackTraces = function(){};
	    debugging = false;
	}
	
	return function() {
	    return debugging;
	};
	};
	
	},{"./async.js":2,"./errors.js":13,"./util.js":38}],11:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util.js");
	var isPrimitive = util.isPrimitive;
	var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
	
	module.exports = function(Promise) {
	var returner = function () {
	    return this;
	};
	var thrower = function () {
	    throw this;
	};
	
	var wrapper = function (value, action) {
	    if (action === 1) {
	        return function () {
	            throw value;
	        };
	    } else if (action === 2) {
	        return function () {
	            return value;
	        };
	    }
	};
	
	
	Promise.prototype["return"] =
	Promise.prototype.thenReturn = function (value) {
	    if (wrapsPrimitiveReceiver && isPrimitive(value)) {
	        return this._then(
	            wrapper(value, 2),
	            undefined,
	            undefined,
	            undefined,
	            undefined
	       );
	    }
	    return this._then(returner, undefined, undefined, value, undefined);
	};
	
	Promise.prototype["throw"] =
	Promise.prototype.thenThrow = function (reason) {
	    if (wrapsPrimitiveReceiver && isPrimitive(reason)) {
	        return this._then(
	            wrapper(reason, 1),
	            undefined,
	            undefined,
	            undefined,
	            undefined
	       );
	    }
	    return this._then(thrower, undefined, undefined, reason, undefined);
	};
	};
	
	},{"./util.js":38}],12:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseReduce = Promise.reduce;
	
	Promise.prototype.each = function (fn) {
	    return PromiseReduce(this, fn, null, INTERNAL);
	};
	
	Promise.each = function (promises, fn) {
	    return PromiseReduce(promises, fn, null, INTERNAL);
	};
	};
	
	},{}],13:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5.js");
	var Objectfreeze = es5.freeze;
	var util = _dereq_("./util.js");
	var inherits = util.inherits;
	var notEnumerableProp = util.notEnumerableProp;
	
	function subError(nameProperty, defaultMessage) {
	    function SubError(message) {
	        if (!(this instanceof SubError)) return new SubError(message);
	        notEnumerableProp(this, "message",
	            typeof message === "string" ? message : defaultMessage);
	        notEnumerableProp(this, "name", nameProperty);
	        if (Error.captureStackTrace) {
	            Error.captureStackTrace(this, this.constructor);
	        } else {
	            Error.call(this);
	        }
	    }
	    inherits(SubError, Error);
	    return SubError;
	}
	
	var _TypeError, _RangeError;
	var Warning = subError("Warning", "warning");
	var CancellationError = subError("CancellationError", "cancellation error");
	var TimeoutError = subError("TimeoutError", "timeout error");
	var AggregateError = subError("AggregateError", "aggregate error");
	try {
	    _TypeError = TypeError;
	    _RangeError = RangeError;
	} catch(e) {
	    _TypeError = subError("TypeError", "type error");
	    _RangeError = subError("RangeError", "range error");
	}
	
	var methods = ("join pop push shift unshift slice filter forEach some " +
	    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
	
	for (var i = 0; i < methods.length; ++i) {
	    if (typeof Array.prototype[methods[i]] === "function") {
	        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
	    }
	}
	
	es5.defineProperty(AggregateError.prototype, "length", {
	    value: 0,
	    configurable: false,
	    writable: true,
	    enumerable: true
	});
	AggregateError.prototype["isOperational"] = true;
	var level = 0;
	AggregateError.prototype.toString = function() {
	    var indent = Array(level * 4 + 1).join(" ");
	    var ret = "\n" + indent + "AggregateError of:" + "\n";
	    level++;
	    indent = Array(level * 4 + 1).join(" ");
	    for (var i = 0; i < this.length; ++i) {
	        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
	        var lines = str.split("\n");
	        for (var j = 0; j < lines.length; ++j) {
	            lines[j] = indent + lines[j];
	        }
	        str = lines.join("\n");
	        ret += str + "\n";
	    }
	    level--;
	    return ret;
	};
	
	function OperationalError(message) {
	    if (!(this instanceof OperationalError))
	        return new OperationalError(message);
	    notEnumerableProp(this, "name", "OperationalError");
	    notEnumerableProp(this, "message", message);
	    this.cause = message;
	    this["isOperational"] = true;
	
	    if (message instanceof Error) {
	        notEnumerableProp(this, "message", message.message);
	        notEnumerableProp(this, "stack", message.stack);
	    } else if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, this.constructor);
	    }
	
	}
	inherits(OperationalError, Error);
	
	var errorTypes = Error["__BluebirdErrorTypes__"];
	if (!errorTypes) {
	    errorTypes = Objectfreeze({
	        CancellationError: CancellationError,
	        TimeoutError: TimeoutError,
	        OperationalError: OperationalError,
	        RejectionError: OperationalError,
	        AggregateError: AggregateError
	    });
	    notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
	}
	
	module.exports = {
	    Error: Error,
	    TypeError: _TypeError,
	    RangeError: _RangeError,
	    CancellationError: errorTypes.CancellationError,
	    OperationalError: errorTypes.OperationalError,
	    TimeoutError: errorTypes.TimeoutError,
	    AggregateError: errorTypes.AggregateError,
	    Warning: Warning
	};
	
	},{"./es5.js":14,"./util.js":38}],14:[function(_dereq_,module,exports){
	var isES5 = (function(){
	    "use strict";
	    return this === undefined;
	})();
	
	if (isES5) {
	    module.exports = {
	        freeze: Object.freeze,
	        defineProperty: Object.defineProperty,
	        getDescriptor: Object.getOwnPropertyDescriptor,
	        keys: Object.keys,
	        names: Object.getOwnPropertyNames,
	        getPrototypeOf: Object.getPrototypeOf,
	        isArray: Array.isArray,
	        isES5: isES5,
	        propertyIsWritable: function(obj, prop) {
	            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	            return !!(!descriptor || descriptor.writable || descriptor.set);
	        }
	    };
	} else {
	    var has = {}.hasOwnProperty;
	    var str = {}.toString;
	    var proto = {}.constructor.prototype;
	
	    var ObjectKeys = function (o) {
	        var ret = [];
	        for (var key in o) {
	            if (has.call(o, key)) {
	                ret.push(key);
	            }
	        }
	        return ret;
	    };
	
	    var ObjectGetDescriptor = function(o, key) {
	        return {value: o[key]};
	    };
	
	    var ObjectDefineProperty = function (o, key, desc) {
	        o[key] = desc.value;
	        return o;
	    };
	
	    var ObjectFreeze = function (obj) {
	        return obj;
	    };
	
	    var ObjectGetPrototypeOf = function (obj) {
	        try {
	            return Object(obj).constructor.prototype;
	        }
	        catch (e) {
	            return proto;
	        }
	    };
	
	    var ArrayIsArray = function (obj) {
	        try {
	            return str.call(obj) === "[object Array]";
	        }
	        catch(e) {
	            return false;
	        }
	    };
	
	    module.exports = {
	        isArray: ArrayIsArray,
	        keys: ObjectKeys,
	        names: ObjectKeys,
	        defineProperty: ObjectDefineProperty,
	        getDescriptor: ObjectGetDescriptor,
	        freeze: ObjectFreeze,
	        getPrototypeOf: ObjectGetPrototypeOf,
	        isES5: isES5,
	        propertyIsWritable: function() {
	            return true;
	        }
	    };
	}
	
	},{}],15:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseMap = Promise.map;
	
	Promise.prototype.filter = function (fn, options) {
	    return PromiseMap(this, fn, options, INTERNAL);
	};
	
	Promise.filter = function (promises, fn, options) {
	    return PromiseMap(promises, fn, options, INTERNAL);
	};
	};
	
	},{}],16:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
	var util = _dereq_("./util.js");
	var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
	var isPrimitive = util.isPrimitive;
	var thrower = util.thrower;
	
	function returnThis() {
	    return this;
	}
	function throwThis() {
	    throw this;
	}
	function return$(r) {
	    return function() {
	        return r;
	    };
	}
	function throw$(r) {
	    return function() {
	        throw r;
	    };
	}
	function promisedFinally(ret, reasonOrValue, isFulfilled) {
	    var then;
	    if (wrapsPrimitiveReceiver && isPrimitive(reasonOrValue)) {
	        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
	    } else {
	        then = isFulfilled ? returnThis : throwThis;
	    }
	    return ret._then(then, thrower, undefined, reasonOrValue, undefined);
	}
	
	function finallyHandler(reasonOrValue) {
	    var promise = this.promise;
	    var handler = this.handler;
	
	    var ret = promise._isBound()
	                    ? handler.call(promise._boundTo)
	                    : handler();
	
	    if (ret !== undefined) {
	        var maybePromise = tryConvertToPromise(ret, promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            return promisedFinally(maybePromise, reasonOrValue,
	                                    promise.isFulfilled());
	        }
	    }
	
	    if (promise.isRejected()) {
	        NEXT_FILTER.e = reasonOrValue;
	        return NEXT_FILTER;
	    } else {
	        return reasonOrValue;
	    }
	}
	
	function tapHandler(value) {
	    var promise = this.promise;
	    var handler = this.handler;
	
	    var ret = promise._isBound()
	                    ? handler.call(promise._boundTo, value)
	                    : handler(value);
	
	    if (ret !== undefined) {
	        var maybePromise = tryConvertToPromise(ret, promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            return promisedFinally(maybePromise, value, true);
	        }
	    }
	    return value;
	}
	
	Promise.prototype._passThroughHandler = function (handler, isFinally) {
	    if (typeof handler !== "function") return this.then();
	
	    var promiseAndHandler = {
	        promise: this,
	        handler: handler
	    };
	
	    return this._then(
	            isFinally ? finallyHandler : tapHandler,
	            isFinally ? finallyHandler : undefined, undefined,
	            promiseAndHandler, undefined);
	};
	
	Promise.prototype.lastly =
	Promise.prototype["finally"] = function (handler) {
	    return this._passThroughHandler(handler, true);
	};
	
	Promise.prototype.tap = function (handler) {
	    return this._passThroughHandler(handler, false);
	};
	};
	
	},{"./util.js":38}],17:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          apiRejection,
	                          INTERNAL,
	                          tryConvertToPromise) {
	var errors = _dereq_("./errors.js");
	var TypeError = errors.TypeError;
	var util = _dereq_("./util.js");
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	var yieldHandlers = [];
	
	function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
	    for (var i = 0; i < yieldHandlers.length; ++i) {
	        traceParent._pushContext();
	        var result = tryCatch(yieldHandlers[i])(value);
	        traceParent._popContext();
	        if (result === errorObj) {
	            traceParent._pushContext();
	            var ret = Promise.reject(errorObj.e);
	            traceParent._popContext();
	            return ret;
	        }
	        var maybePromise = tryConvertToPromise(result, traceParent);
	        if (maybePromise instanceof Promise) return maybePromise;
	    }
	    return null;
	}
	
	function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
	    var promise = this._promise = new Promise(INTERNAL);
	    promise._captureStackTrace();
	    this._stack = stack;
	    this._generatorFunction = generatorFunction;
	    this._receiver = receiver;
	    this._generator = undefined;
	    this._yieldHandlers = typeof yieldHandler === "function"
	        ? [yieldHandler].concat(yieldHandlers)
	        : yieldHandlers;
	}
	
	PromiseSpawn.prototype.promise = function () {
	    return this._promise;
	};
	
	PromiseSpawn.prototype._run = function () {
	    this._generator = this._generatorFunction.call(this._receiver);
	    this._receiver =
	        this._generatorFunction = undefined;
	    this._next(undefined);
	};
	
	PromiseSpawn.prototype._continue = function (result) {
	    if (result === errorObj) {
	        return this._promise._rejectCallback(result.e, false, true);
	    }
	
	    var value = result.value;
	    if (result.done === true) {
	        this._promise._resolveCallback(value);
	    } else {
	        var maybePromise = tryConvertToPromise(value, this._promise);
	        if (!(maybePromise instanceof Promise)) {
	            maybePromise =
	                promiseFromYieldHandler(maybePromise,
	                                        this._yieldHandlers,
	                                        this._promise);
	            if (maybePromise === null) {
	                this._throw(
	                    new TypeError(
	                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) +
	                        "From coroutine:\u000a" +
	                        this._stack.split("\n").slice(1, -7).join("\n")
	                    )
	                );
	                return;
	            }
	        }
	        maybePromise._then(
	            this._next,
	            this._throw,
	            undefined,
	            this,
	            null
	       );
	    }
	};
	
	PromiseSpawn.prototype._throw = function (reason) {
	    this._promise._attachExtraTrace(reason);
	    this._promise._pushContext();
	    var result = tryCatch(this._generator["throw"])
	        .call(this._generator, reason);
	    this._promise._popContext();
	    this._continue(result);
	};
	
	PromiseSpawn.prototype._next = function (value) {
	    this._promise._pushContext();
	    var result = tryCatch(this._generator.next).call(this._generator, value);
	    this._promise._popContext();
	    this._continue(result);
	};
	
	Promise.coroutine = function (generatorFunction, options) {
	    if (typeof generatorFunction !== "function") {
	        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
	    }
	    var yieldHandler = Object(options).yieldHandler;
	    var PromiseSpawn$ = PromiseSpawn;
	    var stack = new Error().stack;
	    return function () {
	        var generator = generatorFunction.apply(this, arguments);
	        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
	                                      stack);
	        spawn._generator = generator;
	        spawn._next(undefined);
	        return spawn.promise();
	    };
	};
	
	Promise.coroutine.addYieldHandler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    yieldHandlers.push(fn);
	};
	
	Promise.spawn = function (generatorFunction) {
	    if (typeof generatorFunction !== "function") {
	        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
	    }
	    var spawn = new PromiseSpawn(generatorFunction, this);
	    var ret = spawn.promise();
	    spawn._run(Promise.spawn);
	    return ret;
	};
	};
	
	},{"./errors.js":13,"./util.js":38}],18:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
	var util = _dereq_("./util.js");
	var canEvaluate = util.canEvaluate;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var reject;
	
	if (false) {
	if (canEvaluate) {
	    var thenCallback = function(i) {
	        return new Function("value", "holder", "                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g, i));
	    };
	
	    var caller = function(count) {
	        var values = [];
	        for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
	        return new Function("holder", "                                      \n\
	            'use strict';                                                    \n\
	            var callback = holder.fn;                                        \n\
	            return callback(values);                                         \n\
	            ".replace(/values/g, values.join(", ")));
	    };
	    var thenCallbacks = [];
	    var callers = [undefined];
	    for (var i = 1; i <= 5; ++i) {
	        thenCallbacks.push(thenCallback(i));
	        callers.push(caller(i));
	    }
	
	    var Holder = function(total, fn) {
	        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
	        this.fn = fn;
	        this.total = total;
	        this.now = 0;
	    };
	
	    Holder.prototype.callers = callers;
	    Holder.prototype.checkFulfillment = function(promise) {
	        var now = this.now;
	        now++;
	        var total = this.total;
	        if (now >= total) {
	            var handler = this.callers[total];
	            promise._pushContext();
	            var ret = tryCatch(handler)(this);
	            promise._popContext();
	            if (ret === errorObj) {
	                promise._rejectCallback(ret.e, false, true);
	            } else {
	                promise._resolveCallback(ret);
	            }
	        } else {
	            this.now = now;
	        }
	    };
	
	    var reject = function (reason) {
	        this._reject(reason);
	    };
	}
	}
	
	Promise.join = function () {
	    var last = arguments.length - 1;
	    var fn;
	    if (last > 0 && typeof arguments[last] === "function") {
	        fn = arguments[last];
	        if (false) {
	            if (last < 6 && canEvaluate) {
	                var ret = new Promise(INTERNAL);
	                ret._captureStackTrace();
	                var holder = new Holder(last, fn);
	                var callbacks = thenCallbacks;
	                for (var i = 0; i < last; ++i) {
	                    var maybePromise = tryConvertToPromise(arguments[i], ret);
	                    if (maybePromise instanceof Promise) {
	                        maybePromise = maybePromise._target();
	                        if (maybePromise._isPending()) {
	                            maybePromise._then(callbacks[i], reject,
	                                               undefined, ret, holder);
	                        } else if (maybePromise._isFulfilled()) {
	                            callbacks[i].call(ret,
	                                              maybePromise._value(), holder);
	                        } else {
	                            ret._reject(maybePromise._reason());
	                        }
	                    } else {
	                        callbacks[i].call(ret, maybePromise, holder);
	                    }
	                }
	                return ret;
	            }
	        }
	    }
	    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
	    if (fn) args.pop();
	    var ret = new PromiseArray(args).promise();
	    return fn !== undefined ? ret.spread(fn) : ret;
	};
	
	};
	
	},{"./util.js":38}],19:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL) {
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var PENDING = {};
	var EMPTY_ARRAY = [];
	
	function MappingPromiseArray(promises, fn, limit, _filter) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    this._callback = fn;
	    this._preservedValues = _filter === INTERNAL
	        ? new Array(this.length())
	        : null;
	    this._limit = limit;
	    this._inFlight = 0;
	    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
	    this._init$(undefined, -2);
	}
	util.inherits(MappingPromiseArray, PromiseArray);
	
	MappingPromiseArray.prototype._init = function () {};
	
	MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var limit = this._limit;
	    if (values[index] === PENDING) {
	        values[index] = value;
	        if (limit >= 1) {
	            this._inFlight--;
	            this._drainQueue();
	            if (this._isResolved()) return;
	        }
	    } else {
	        if (limit >= 1 && this._inFlight >= limit) {
	            values[index] = value;
	            this._queue.push(index);
	            return;
	        }
	        if (preservedValues !== null) preservedValues[index] = value;
	
	        var callback = this._callback;
	        var receiver = this._promise._boundTo;
	        this._promise._pushContext();
	        var ret = tryCatch(callback).call(receiver, value, index, length);
	        this._promise._popContext();
	        if (ret === errorObj) return this._reject(ret.e);
	
	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (maybePromise._isPending()) {
	                if (limit >= 1) this._inFlight++;
	                values[index] = PENDING;
	                return maybePromise._proxyPromiseArray(this, index);
	            } else if (maybePromise._isFulfilled()) {
	                ret = maybePromise._value();
	            } else {
	                return this._reject(maybePromise._reason());
	            }
	        }
	        values[index] = ret;
	    }
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= length) {
	        if (preservedValues !== null) {
	            this._filter(values, preservedValues);
	        } else {
	            this._resolve(values);
	        }
	
	    }
	};
	
	MappingPromiseArray.prototype._drainQueue = function () {
	    var queue = this._queue;
	    var limit = this._limit;
	    var values = this._values;
	    while (queue.length > 0 && this._inFlight < limit) {
	        if (this._isResolved()) return;
	        var index = queue.pop();
	        this._promiseFulfilled(values[index], index);
	    }
	};
	
	MappingPromiseArray.prototype._filter = function (booleans, values) {
	    var len = values.length;
	    var ret = new Array(len);
	    var j = 0;
	    for (var i = 0; i < len; ++i) {
	        if (booleans[i]) ret[j++] = values[i];
	    }
	    ret.length = j;
	    this._resolve(ret);
	};
	
	MappingPromiseArray.prototype.preservedValues = function () {
	    return this._preservedValues;
	};
	
	function map(promises, fn, options, _filter) {
	    var limit = typeof options === "object" && options !== null
	        ? options.concurrency
	        : 0;
	    limit = typeof limit === "number" &&
	        isFinite(limit) && limit >= 1 ? limit : 0;
	    return new MappingPromiseArray(promises, fn, limit, _filter);
	}
	
	Promise.prototype.map = function (fn, options) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	
	    return map(this, fn, options, null).promise();
	};
	
	Promise.map = function (promises, fn, options, _filter) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    return map(promises, fn, options, _filter).promise();
	};
	
	
	};
	
	},{"./util.js":38}],20:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	
	Promise.method = function (fn) {
	    if (typeof fn !== "function") {
	        throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    return function () {
	        var ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._pushContext();
	        var value = tryCatch(fn).apply(this, arguments);
	        ret._popContext();
	        ret._resolveFromSyncValue(value);
	        return ret;
	    };
	};
	
	Promise.attempt = Promise["try"] = function (fn, args, ctx) {
	    if (typeof fn !== "function") {
	        return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._pushContext();
	    var value = util.isArray(args)
	        ? tryCatch(fn).apply(ctx, args)
	        : tryCatch(fn).call(ctx, args);
	    ret._popContext();
	    ret._resolveFromSyncValue(value);
	    return ret;
	};
	
	Promise.prototype._resolveFromSyncValue = function (value) {
	    if (value === util.errorObj) {
	        this._rejectCallback(value.e, false, true);
	    } else {
	        this._resolveCallback(value, true);
	    }
	};
	};
	
	},{"./util.js":38}],21:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	
	function spreadAdapter(val, nodeback) {
	    var promise = this;
	    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
	    var ret = tryCatch(nodeback).apply(promise._boundTo, [null].concat(val));
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	
	function successAdapter(val, nodeback) {
	    var promise = this;
	    var receiver = promise._boundTo;
	    var ret = val === undefined
	        ? tryCatch(nodeback).call(receiver, null)
	        : tryCatch(nodeback).call(receiver, null, val);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	function errorAdapter(reason, nodeback) {
	    var promise = this;
	    if (!reason) {
	        var target = promise._target();
	        var newReason = target._getCarriedStackTrace();
	        newReason.cause = reason;
	        reason = newReason;
	    }
	    var ret = tryCatch(nodeback).call(promise._boundTo, reason);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	
	Promise.prototype.nodeify = function (nodeback, options) {
	    if (typeof nodeback == "function") {
	        var adapter = successAdapter;
	        if (options !== undefined && Object(options).spread) {
	            adapter = spreadAdapter;
	        }
	        this._then(
	            adapter,
	            errorAdapter,
	            undefined,
	            this,
	            nodeback
	        );
	    }
	    return this;
	};
	};
	
	},{"./async.js":2,"./util.js":38}],22:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, PromiseArray) {
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	
	Promise.prototype.progressed = function (handler) {
	    return this._then(undefined, undefined, handler, undefined, undefined);
	};
	
	Promise.prototype._progress = function (progressValue) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._target()._progressUnchecked(progressValue);
	
	};
	
	Promise.prototype._progressHandlerAt = function (index) {
	    return index === 0
	        ? this._progressHandler0
	        : this[(index << 2) + index - 5 + 2];
	};
	
	Promise.prototype._doProgressWith = function (progression) {
	    var progressValue = progression.value;
	    var handler = progression.handler;
	    var promise = progression.promise;
	    var receiver = progression.receiver;
	
	    var ret = tryCatch(handler).call(receiver, progressValue);
	    if (ret === errorObj) {
	        if (ret.e != null &&
	            ret.e.name !== "StopProgressPropagation") {
	            var trace = util.canAttachTrace(ret.e)
	                ? ret.e : new Error(util.toString(ret.e));
	            promise._attachExtraTrace(trace);
	            promise._progress(ret.e);
	        }
	    } else if (ret instanceof Promise) {
	        ret._then(promise._progress, null, null, promise, undefined);
	    } else {
	        promise._progress(ret);
	    }
	};
	
	
	Promise.prototype._progressUnchecked = function (progressValue) {
	    var len = this._length();
	    var progress = this._progress;
	    for (var i = 0; i < len; i++) {
	        var handler = this._progressHandlerAt(i);
	        var promise = this._promiseAt(i);
	        if (!(promise instanceof Promise)) {
	            var receiver = this._receiverAt(i);
	            if (typeof handler === "function") {
	                handler.call(receiver, progressValue, promise);
	            } else if (receiver instanceof PromiseArray &&
	                       !receiver._isResolved()) {
	                receiver._promiseProgressed(progressValue, promise);
	            }
	            continue;
	        }
	
	        if (typeof handler === "function") {
	            async.invoke(this._doProgressWith, this, {
	                handler: handler,
	                promise: promise,
	                receiver: this._receiverAt(i),
	                value: progressValue
	            });
	        } else {
	            async.invoke(progress, promise, progressValue);
	        }
	    }
	};
	};
	
	},{"./async.js":2,"./util.js":38}],23:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var makeSelfResolutionError = function () {
	    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
	};
	var reflect = function() {
	    return new Promise.PromiseInspection(this._target());
	};
	var apiRejection = function(msg) {
	    return Promise.reject(new TypeError(msg));
	};
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var errors = _dereq_("./errors.js");
	var TypeError = Promise.TypeError = errors.TypeError;
	Promise.RangeError = errors.RangeError;
	Promise.CancellationError = errors.CancellationError;
	Promise.TimeoutError = errors.TimeoutError;
	Promise.OperationalError = errors.OperationalError;
	Promise.RejectionError = errors.OperationalError;
	Promise.AggregateError = errors.AggregateError;
	var INTERNAL = function(){};
	var APPLY = {};
	var NEXT_FILTER = {e: null};
	var tryConvertToPromise = _dereq_("./thenables.js")(Promise, INTERNAL);
	var PromiseArray =
	    _dereq_("./promise_array.js")(Promise, INTERNAL,
	                                    tryConvertToPromise, apiRejection);
	var CapturedTrace = _dereq_("./captured_trace.js")();
	var isDebugging = _dereq_("./debuggability.js")(Promise, CapturedTrace);
	 /*jshint unused:false*/
	var createContext =
	    _dereq_("./context.js")(Promise, CapturedTrace, isDebugging);
	var CatchFilter = _dereq_("./catch_filter.js")(NEXT_FILTER);
	var PromiseResolver = _dereq_("./promise_resolver.js");
	var nodebackForPromise = PromiseResolver._nodebackForPromise;
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	function Promise(resolver) {
	    if (typeof resolver !== "function") {
	        throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
	    }
	    if (this.constructor !== Promise) {
	        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
	    }
	    this._bitField = 0;
	    this._fulfillmentHandler0 = undefined;
	    this._rejectionHandler0 = undefined;
	    this._progressHandler0 = undefined;
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    this._settledValue = undefined;
	    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
	}
	
	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};
	
	Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
	    var len = arguments.length;
	    if (len > 1) {
	        var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (typeof item === "function") {
	                catchInstances[j++] = item;
	            } else {
	                return Promise.reject(
	                    new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
	            }
	        }
	        catchInstances.length = j;
	        fn = arguments[i];
	        var catchFilter = new CatchFilter(catchInstances, fn, this);
	        return this._then(undefined, catchFilter.doFilter, undefined,
	            catchFilter, undefined);
	    }
	    return this._then(undefined, fn, undefined, undefined, undefined);
	};
	
	Promise.prototype.reflect = function () {
	    return this._then(reflect, reflect, undefined, this, undefined);
	};
	
	Promise.prototype.then = function (didFulfill, didReject, didProgress) {
	    if (isDebugging() && arguments.length > 0 &&
	        typeof didFulfill !== "function" &&
	        typeof didReject !== "function") {
	        var msg = ".then() only accepts functions but was passed: " +
	                util.classString(didFulfill);
	        if (arguments.length > 1) {
	            msg += ", " + util.classString(didReject);
	        }
	        this._warn(msg);
	    }
	    return this._then(didFulfill, didReject, didProgress,
	        undefined, undefined);
	};
	
	Promise.prototype.done = function (didFulfill, didReject, didProgress) {
	    var promise = this._then(didFulfill, didReject, didProgress,
	        undefined, undefined);
	    promise._setIsFinal();
	};
	
	Promise.prototype.spread = function (didFulfill, didReject) {
	    return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
	};
	
	Promise.prototype.isCancellable = function () {
	    return !this.isResolved() &&
	        this._cancellable();
	};
	
	Promise.prototype.toJSON = function () {
	    var ret = {
	        isFulfilled: false,
	        isRejected: false,
	        fulfillmentValue: undefined,
	        rejectionReason: undefined
	    };
	    if (this.isFulfilled()) {
	        ret.fulfillmentValue = this.value();
	        ret.isFulfilled = true;
	    } else if (this.isRejected()) {
	        ret.rejectionReason = this.reason();
	        ret.isRejected = true;
	    }
	    return ret;
	};
	
	Promise.prototype.all = function () {
	    return new PromiseArray(this).promise();
	};
	
	Promise.prototype.error = function (fn) {
	    return this.caught(util.originatesFromRejection, fn);
	};
	
	Promise.is = function (val) {
	    return val instanceof Promise;
	};
	
	Promise.fromNode = function(fn) {
	    var ret = new Promise(INTERNAL);
	    var result = tryCatch(fn)(nodebackForPromise(ret));
	    if (result === errorObj) {
	        ret._rejectCallback(result.e, true, true);
	    }
	    return ret;
	};
	
	Promise.all = function (promises) {
	    return new PromiseArray(promises).promise();
	};
	
	Promise.defer = Promise.pending = function () {
	    var promise = new Promise(INTERNAL);
	    return new PromiseResolver(promise);
	};
	
	Promise.cast = function (obj) {
	    var ret = tryConvertToPromise(obj);
	    if (!(ret instanceof Promise)) {
	        var val = ret;
	        ret = new Promise(INTERNAL);
	        ret._fulfillUnchecked(val);
	    }
	    return ret;
	};
	
	Promise.resolve = Promise.fulfilled = Promise.cast;
	
	Promise.reject = Promise.rejected = function (reason) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._rejectCallback(reason, true);
	    return ret;
	};
	
	Promise.setScheduler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    var prev = async._schedule;
	    async._schedule = fn;
	    return prev;
	};
	
	Promise.prototype._then = function (
	    didFulfill,
	    didReject,
	    didProgress,
	    receiver,
	    internalData
	) {
	    var haveInternalData = internalData !== undefined;
	    var ret = haveInternalData ? internalData : new Promise(INTERNAL);
	
	    if (!haveInternalData) {
	        ret._propagateFrom(this, 4 | 1);
	        ret._captureStackTrace();
	    }
	
	    var target = this._target();
	    if (target !== this) {
	        if (!haveInternalData) {
	            ret._setIsMigrated();
	            if (receiver === undefined) {
	                ret._setIsMigratingBinding();
	                receiver = this;
	            }
	        }
	    }
	
	    var callbackIndex =
	        target._addCallbacks(didFulfill, didReject, didProgress, ret, receiver);
	
	    if (target._isResolved() && !target._isSettlePromisesQueued()) {
	        async.invoke(
	            target._settlePromiseAtPostResolution, target, callbackIndex);
	    }
	
	    return ret;
	};
	
	Promise.prototype._settlePromiseAtPostResolution = function (index) {
	    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
	    this._settlePromiseAt(index);
	};
	
	Promise.prototype._length = function () {
	    return this._bitField & 131071;
	};
	
	Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
	    return (this._bitField & 939524096) > 0;
	};
	
	Promise.prototype._isFollowing = function () {
	    return (this._bitField & 536870912) === 536870912;
	};
	
	Promise.prototype._setLength = function (len) {
	    this._bitField = (this._bitField & -131072) |
	        (len & 131071);
	};
	
	Promise.prototype._setFulfilled = function () {
	    this._bitField = this._bitField | 268435456;
	};
	
	Promise.prototype._setRejected = function () {
	    this._bitField = this._bitField | 134217728;
	};
	
	Promise.prototype._setFollowing = function () {
	    this._bitField = this._bitField | 536870912;
	};
	
	Promise.prototype._setIsFinal = function () {
	    this._bitField = this._bitField | 33554432;
	};
	
	Promise.prototype._isFinal = function () {
	    return (this._bitField & 33554432) > 0;
	};
	
	Promise.prototype._cancellable = function () {
	    return (this._bitField & 67108864) > 0;
	};
	
	Promise.prototype._setCancellable = function () {
	    this._bitField = this._bitField | 67108864;
	};
	
	Promise.prototype._unsetCancellable = function () {
	    this._bitField = this._bitField & (~67108864);
	};
	
	Promise.prototype._setIsMigrated = function () {
	    this._bitField = this._bitField | 4194304;
	};
	
	Promise.prototype._unsetIsMigrated = function () {
	    this._bitField = this._bitField & (~4194304);
	};
	
	Promise.prototype._isMigrated = function () {
	    return (this._bitField & 4194304) > 0;
	};
	
	Promise.prototype._receiverAt = function (index) {
	    var ret = index === 0
	        ? this._receiver0
	        : this[
	            index * 5 - 5 + 4];
	    if (ret === undefined && this._isBound()) {
	        return this._boundTo;
	    }
	    return ret;
	};
	
	Promise.prototype._promiseAt = function (index) {
	    return index === 0
	        ? this._promise0
	        : this[index * 5 - 5 + 3];
	};
	
	Promise.prototype._fulfillmentHandlerAt = function (index) {
	    return index === 0
	        ? this._fulfillmentHandler0
	        : this[index * 5 - 5 + 0];
	};
	
	Promise.prototype._rejectionHandlerAt = function (index) {
	    return index === 0
	        ? this._rejectionHandler0
	        : this[index * 5 - 5 + 1];
	};
	
	Promise.prototype._migrateCallbacks = function (follower, index) {
	    var fulfill = follower._fulfillmentHandlerAt(index);
	    var reject = follower._rejectionHandlerAt(index);
	    var progress = follower._progressHandlerAt(index);
	    var promise = follower._promiseAt(index);
	    var receiver = follower._receiverAt(index);
	    if (promise instanceof Promise) {
	        promise._setIsMigrated();
	        if (receiver === undefined) {
	            receiver = follower;
	            promise._setIsMigratingBinding();
	        }
	    }
	    this._addCallbacks(fulfill, reject, progress, promise, receiver);
	};
	
	Promise.prototype._addCallbacks = function (
	    fulfill,
	    reject,
	    progress,
	    promise,
	    receiver
	) {
	    var index = this._length();
	
	    if (index >= 131071 - 5) {
	        index = 0;
	        this._setLength(0);
	    }
	
	    if (index === 0) {
	        this._promise0 = promise;
	        if (receiver !== undefined) this._receiver0 = receiver;
	        if (typeof fulfill === "function" && !this._isCarryingStackTrace())
	            this._fulfillmentHandler0 = fulfill;
	        if (typeof reject === "function") this._rejectionHandler0 = reject;
	        if (typeof progress === "function") this._progressHandler0 = progress;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] = promise;
	        this[base + 4] = receiver;
	        if (typeof fulfill === "function")
	            this[base + 0] = fulfill;
	        if (typeof reject === "function")
	            this[base + 1] = reject;
	        if (typeof progress === "function")
	            this[base + 2] = progress;
	    }
	    this._setLength(index + 1);
	    return index;
	};
	
	Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
	    var index = this._length();
	
	    if (index >= 131071 - 5) {
	        index = 0;
	        this._setLength(0);
	    }
	    if (index === 0) {
	        this._promise0 = promiseSlotValue;
	        this._receiver0 = receiver;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] = promiseSlotValue;
	        this[base + 4] = receiver;
	    }
	    this._setLength(index + 1);
	};
	
	Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
	    this._setProxyHandlers(promiseArray, index);
	};
	
	Promise.prototype._resolveCallback = function(value, shouldBind) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    if (value === this)
	        return this._rejectCallback(makeSelfResolutionError(), false, true);
	    var maybePromise = tryConvertToPromise(value, this);
	    if (!(maybePromise instanceof Promise)) return this._fulfill(value);
	
	    var propagationFlags = 1 | (shouldBind ? 4 : 0);
	    this._propagateFrom(maybePromise, propagationFlags);
	    var promise = maybePromise._target();
	    if (promise._isPending()) {
	        var len = this._length();
	        for (var i = 0; i < len; ++i) {
	            promise._migrateCallbacks(this, i);
	        }
	        this._setFollowing();
	        this._setLength(0);
	        this._setFollowee(promise);
	    } else if (promise._isFulfilled()) {
	        this._fulfillUnchecked(promise._value());
	    } else {
	        this._rejectUnchecked(promise._reason(),
	            promise._getCarriedStackTrace());
	    }
	};
	
	Promise.prototype._rejectCallback =
	function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
	    if (!shouldNotMarkOriginatingFromRejection) {
	        util.markAsOriginatingFromRejection(reason);
	    }
	    var trace = util.ensureErrorObject(reason);
	    var hasStack = util.canAttachTrace(reason) &&
	        typeof trace.stack === "string" && trace.stack.length > 0;
	    this._attachExtraTrace(trace, synchronous ? hasStack : false);
	    this._reject(reason, trace === reason ? undefined : trace);
	};
	
	Promise.prototype._resolveFromResolver = function (resolver) {
	    var promise = this;
	    this._captureStackTrace();
	    this._pushContext();
	    var synchronous = true;
	    var r = tryCatch(resolver)(function(value) {
	        if (promise === null) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }, function (reason) {
	        if (promise === null) return;
	        promise._rejectCallback(reason, synchronous);
	        promise = null;
	    });
	    synchronous = false;
	    this._popContext();
	
	    if (r !== undefined && r === errorObj && promise !== null) {
	        promise._rejectCallback(r.e, true, true);
	        promise = null;
	    }
	};
	
	Promise.prototype._settlePromiseFromHandler = function (
	    handler, receiver, value, promise
	) {
	    if (promise._isRejected()) return;
	    promise._pushContext();
	    var x;
	    if (receiver === APPLY && !this._isRejected()) {
	        x = tryCatch(handler).apply(this._boundTo, value);
	    } else {
	        x = tryCatch(handler).call(receiver, value);
	    }
	    promise._popContext();
	
	    if (x === errorObj || x === promise || x === NEXT_FILTER) {
	        var err = x === promise ? makeSelfResolutionError() : x.e;
	        promise._rejectCallback(err, false, true);
	    } else {
	        promise._resolveCallback(x);
	    }
	};
	
	Promise.prototype._target = function() {
	    var ret = this;
	    while (ret._isFollowing()) ret = ret._followee();
	    return ret;
	};
	
	Promise.prototype._followee = function() {
	    return this._rejectionHandler0;
	};
	
	Promise.prototype._setFollowee = function(promise) {
	    this._rejectionHandler0 = promise;
	};
	
	Promise.prototype._cleanValues = function () {
	    if (this._cancellable()) {
	        this._cancellationParent = undefined;
	    }
	};
	
	Promise.prototype._propagateFrom = function (parent, flags) {
	    if ((flags & 1) > 0 && parent._cancellable()) {
	        this._setCancellable();
	        this._cancellationParent = parent;
	    }
	    if ((flags & 4) > 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	};
	
	Promise.prototype._fulfill = function (value) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._fulfillUnchecked(value);
	};
	
	Promise.prototype._reject = function (reason, carriedStackTrace) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._rejectUnchecked(reason, carriedStackTrace);
	};
	
	Promise.prototype._settlePromiseAt = function (index) {
	    var promise = this._promiseAt(index);
	    var isPromise = promise instanceof Promise;
	
	    if (isPromise && promise._isMigrated()) {
	        promise._unsetIsMigrated();
	        return async.invoke(this._settlePromiseAt, this, index);
	    }
	    var handler = this._isFulfilled()
	        ? this._fulfillmentHandlerAt(index)
	        : this._rejectionHandlerAt(index);
	
	    var carriedStackTrace =
	        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
	    var value = this._settledValue;
	    var receiver = this._receiverAt(index);
	    if (isPromise && promise._isMigratingBinding()) {
	        promise._unsetIsMigratingBinding();
	        receiver = receiver._boundTo;
	    }
	
	    this._clearCallbackDataAtIndex(index);
	
	    if (typeof handler === "function") {
	        if (!isPromise) {
	            handler.call(receiver, value, promise);
	        } else {
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (receiver instanceof PromiseArray) {
	        if (!receiver._isResolved()) {
	            if (this._isFulfilled()) {
	                receiver._promiseFulfilled(value, promise);
	            }
	            else {
	                receiver._promiseRejected(value, promise);
	            }
	        }
	    } else if (isPromise) {
	        if (this._isFulfilled()) {
	            promise._fulfill(value);
	        } else {
	            promise._reject(value, carriedStackTrace);
	        }
	    }
	
	    if (index >= 4 && (index & 31) === 4)
	        async.invokeLater(this._setLength, this, 0);
	};
	
	Promise.prototype._clearCallbackDataAtIndex = function(index) {
	    if (index === 0) {
	        if (!this._isCarryingStackTrace()) {
	            this._fulfillmentHandler0 = undefined;
	        }
	        this._rejectionHandler0 =
	        this._progressHandler0 =
	        this._receiver0 =
	        this._promise0 = undefined;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] =
	        this[base + 4] =
	        this[base + 0] =
	        this[base + 1] =
	        this[base + 2] = undefined;
	    }
	};
	
	Promise.prototype._isSettlePromisesQueued = function () {
	    return (this._bitField &
	            -1073741824) === -1073741824;
	};
	
	Promise.prototype._setSettlePromisesQueued = function () {
	    this._bitField = this._bitField | -1073741824;
	};
	
	Promise.prototype._unsetSettlePromisesQueued = function () {
	    this._bitField = this._bitField & (~-1073741824);
	};
	
	Promise.prototype._queueSettlePromises = function() {
	    async.settlePromises(this);
	    this._setSettlePromisesQueued();
	};
	
	Promise.prototype._fulfillUnchecked = function (value) {
	    if (value === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err, undefined);
	    }
	    this._setFulfilled();
	    this._settledValue = value;
	    this._cleanValues();
	
	    if (this._length() > 0) {
	        this._queueSettlePromises();
	    }
	};
	
	Promise.prototype._rejectUncheckedCheckError = function (reason) {
	    var trace = util.ensureErrorObject(reason);
	    this._rejectUnchecked(reason, trace === reason ? undefined : trace);
	};
	
	Promise.prototype._rejectUnchecked = function (reason, trace) {
	    if (reason === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err);
	    }
	    this._setRejected();
	    this._settledValue = reason;
	    this._cleanValues();
	
	    if (this._isFinal()) {
	        async.throwLater(function(e) {
	            if ("stack" in e) {
	                async.invokeFirst(
	                    CapturedTrace.unhandledRejection, undefined, e);
	            }
	            throw e;
	        }, trace === undefined ? reason : trace);
	        return;
	    }
	
	    if (trace !== undefined && trace !== reason) {
	        this._setCarriedStackTrace(trace);
	    }
	
	    if (this._length() > 0) {
	        this._queueSettlePromises();
	    } else {
	        this._ensurePossibleRejectionHandled();
	    }
	};
	
	Promise.prototype._settlePromises = function () {
	    this._unsetSettlePromisesQueued();
	    var len = this._length();
	    for (var i = 0; i < len; i++) {
	        this._settlePromiseAt(i);
	    }
	};
	
	Promise._makeSelfResolutionError = makeSelfResolutionError;
	_dereq_("./method.js")(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_("./bind.js")(Promise, INTERNAL, tryConvertToPromise);
	_dereq_("./finally.js")(Promise, NEXT_FILTER, tryConvertToPromise);
	_dereq_("./direct_resolve.js")(Promise);
	_dereq_("./synchronous_inspection.js")(Promise);
	_dereq_("./join.js")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
	Promise.Promise = Promise;
	_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
	_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
	_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
	_dereq_('./nodeify.js')(Promise);
	_dereq_('./cancel.js')(Promise);
	_dereq_('./promisify.js')(Promise, INTERNAL);
	_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
	_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
	_dereq_('./settle.js')(Promise, PromiseArray);
	_dereq_('./call_get.js')(Promise);
	_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
	_dereq_('./progress.js')(Promise, PromiseArray);
	_dereq_('./any.js')(Promise);
	_dereq_('./each.js')(Promise, INTERNAL);
	_dereq_('./timers.js')(Promise, INTERNAL);
	_dereq_('./filter.js')(Promise, INTERNAL);
	                                                         
	    util.toFastProperties(Promise);                                          
	    util.toFastProperties(Promise.prototype);                                
	    function fillTypes(value) {                                              
	        var p = new Promise(INTERNAL);                                       
	        p._fulfillmentHandler0 = value;                                      
	        p._rejectionHandler0 = value;                                        
	        p._progressHandler0 = value;                                         
	        p._promise0 = value;                                                 
	        p._receiver0 = value;                                                
	        p._settledValue = value;                                             
	    }                                                                        
	    // Complete slack tracking, opt out of field-type tracking and           
	    // stabilize map                                                         
	    fillTypes({a: 1});                                                       
	    fillTypes({b: 2});                                                       
	    fillTypes({c: 3});                                                       
	    fillTypes(1);                                                            
	    fillTypes(function(){});                                                 
	    fillTypes(undefined);                                                    
	    fillTypes(false);                                                        
	    fillTypes(new Promise(INTERNAL));                                        
	    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       
	    return Promise;                                                          
	
	};
	
	},{"./any.js":1,"./async.js":2,"./bind.js":3,"./call_get.js":5,"./cancel.js":6,"./captured_trace.js":7,"./catch_filter.js":8,"./context.js":9,"./debuggability.js":10,"./direct_resolve.js":11,"./each.js":12,"./errors.js":13,"./filter.js":15,"./finally.js":16,"./generators.js":17,"./join.js":18,"./map.js":19,"./method.js":20,"./nodeify.js":21,"./progress.js":22,"./promise_array.js":24,"./promise_resolver.js":25,"./promisify.js":26,"./props.js":27,"./race.js":29,"./reduce.js":30,"./settle.js":32,"./some.js":33,"./synchronous_inspection.js":34,"./thenables.js":35,"./timers.js":36,"./using.js":37,"./util.js":38}],24:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise,
	    apiRejection) {
	var util = _dereq_("./util.js");
	var isArray = util.isArray;
	
	function toResolutionValue(val) {
	    switch(val) {
	    case -2: return [];
	    case -3: return {};
	    }
	}
	
	function PromiseArray(values) {
	    var promise = this._promise = new Promise(INTERNAL);
	    var parent;
	    if (values instanceof Promise) {
	        parent = values;
	        promise._propagateFrom(parent, 1 | 4);
	    }
	    this._values = values;
	    this._length = 0;
	    this._totalResolved = 0;
	    this._init(undefined, -2);
	}
	PromiseArray.prototype.length = function () {
	    return this._length;
	};
	
	PromiseArray.prototype.promise = function () {
	    return this._promise;
	};
	
	PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
	    var values = tryConvertToPromise(this._values, this._promise);
	    if (values instanceof Promise) {
	        values = values._target();
	        this._values = values;
	        if (values._isFulfilled()) {
	            values = values._value();
	            if (!isArray(values)) {
	                var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
	                this.__hardReject__(err);
	                return;
	            }
	        } else if (values._isPending()) {
	            values._then(
	                init,
	                this._reject,
	                undefined,
	                this,
	                resolveValueIfEmpty
	           );
	            return;
	        } else {
	            this._reject(values._reason());
	            return;
	        }
	    } else if (!isArray(values)) {
	        this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
	        return;
	    }
	
	    if (values.length === 0) {
	        if (resolveValueIfEmpty === -5) {
	            this._resolveEmptyArray();
	        }
	        else {
	            this._resolve(toResolutionValue(resolveValueIfEmpty));
	        }
	        return;
	    }
	    var len = this.getActualLength(values.length);
	    this._length = len;
	    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
	    var promise = this._promise;
	    for (var i = 0; i < len; ++i) {
	        var isResolved = this._isResolved();
	        var maybePromise = tryConvertToPromise(values[i], promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (isResolved) {
	                maybePromise._unsetRejectionIsUnhandled();
	            } else if (maybePromise._isPending()) {
	                maybePromise._proxyPromiseArray(this, i);
	            } else if (maybePromise._isFulfilled()) {
	                this._promiseFulfilled(maybePromise._value(), i);
	            } else {
	                this._promiseRejected(maybePromise._reason(), i);
	            }
	        } else if (!isResolved) {
	            this._promiseFulfilled(maybePromise, i);
	        }
	    }
	};
	
	PromiseArray.prototype._isResolved = function () {
	    return this._values === null;
	};
	
	PromiseArray.prototype._resolve = function (value) {
	    this._values = null;
	    this._promise._fulfill(value);
	};
	
	PromiseArray.prototype.__hardReject__ =
	PromiseArray.prototype._reject = function (reason) {
	    this._values = null;
	    this._promise._rejectCallback(reason, false, true);
	};
	
	PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
	    this._promise._progress({
	        index: index,
	        value: progressValue
	    });
	};
	
	
	PromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};
	
	PromiseArray.prototype._promiseRejected = function (reason, index) {
	    this._totalResolved++;
	    this._reject(reason);
	};
	
	PromiseArray.prototype.shouldCopyValues = function () {
	    return true;
	};
	
	PromiseArray.prototype.getActualLength = function (len) {
	    return len;
	};
	
	return PromiseArray;
	};
	
	},{"./util.js":38}],25:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util.js");
	var maybeWrapAsError = util.maybeWrapAsError;
	var errors = _dereq_("./errors.js");
	var TimeoutError = errors.TimeoutError;
	var OperationalError = errors.OperationalError;
	var haveGetters = util.haveGetters;
	var es5 = _dereq_("./es5.js");
	
	function isUntypedError(obj) {
	    return obj instanceof Error &&
	        es5.getPrototypeOf(obj) === Error.prototype;
	}
	
	var rErrorKey = /^(?:name|message|stack|cause)$/;
	function wrapAsOperationalError(obj) {
	    var ret;
	    if (isUntypedError(obj)) {
	        ret = new OperationalError(obj);
	        ret.name = obj.name;
	        ret.message = obj.message;
	        ret.stack = obj.stack;
	        var keys = es5.keys(obj);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (!rErrorKey.test(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    util.markAsOriginatingFromRejection(obj);
	    return obj;
	}
	
	function nodebackForPromise(promise) {
	    return function(err, value) {
	        if (promise === null) return;
	
	        if (err) {
	            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
	            promise._attachExtraTrace(wrapped);
	            promise._reject(wrapped);
	        } else if (arguments.length > 2) {
	            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	            promise._fulfill(args);
	        } else {
	            promise._fulfill(value);
	        }
	
	        promise = null;
	    };
	}
	
	
	var PromiseResolver;
	if (!haveGetters) {
	    PromiseResolver = function (promise) {
	        this.promise = promise;
	        this.asCallback = nodebackForPromise(promise);
	        this.callback = this.asCallback;
	    };
	}
	else {
	    PromiseResolver = function (promise) {
	        this.promise = promise;
	    };
	}
	if (haveGetters) {
	    var prop = {
	        get: function() {
	            return nodebackForPromise(this.promise);
	        }
	    };
	    es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
	    es5.defineProperty(PromiseResolver.prototype, "callback", prop);
	}
	
	PromiseResolver._nodebackForPromise = nodebackForPromise;
	
	PromiseResolver.prototype.toString = function () {
	    return "[object PromiseResolver]";
	};
	
	PromiseResolver.prototype.resolve =
	PromiseResolver.prototype.fulfill = function (value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._resolveCallback(value);
	};
	
	PromiseResolver.prototype.reject = function (reason) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._rejectCallback(reason);
	};
	
	PromiseResolver.prototype.progress = function (value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._progress(value);
	};
	
	PromiseResolver.prototype.cancel = function (err) {
	    this.promise.cancel(err);
	};
	
	PromiseResolver.prototype.timeout = function () {
	    this.reject(new TimeoutError("timeout"));
	};
	
	PromiseResolver.prototype.isResolved = function () {
	    return this.promise.isResolved();
	};
	
	PromiseResolver.prototype.toJSON = function () {
	    return this.promise.toJSON();
	};
	
	module.exports = PromiseResolver;
	
	},{"./errors.js":13,"./es5.js":14,"./util.js":38}],26:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var THIS = {};
	var util = _dereq_("./util.js");
	var nodebackForPromise = _dereq_("./promise_resolver.js")
	    ._nodebackForPromise;
	var withAppended = util.withAppended;
	var maybeWrapAsError = util.maybeWrapAsError;
	var canEvaluate = util.canEvaluate;
	var TypeError = _dereq_("./errors").TypeError;
	var defaultSuffix = "Async";
	var defaultPromisified = {__isPromisified__: true};
	var noCopyPropsPattern =
	    /^(?:length|name|arguments|caller|prototype|__isPromisified__)$/;
	var defaultFilter = function(name, func) {
	    return util.isIdentifier(name) &&
	        name.charAt(0) !== "_" &&
	        !util.isClass(func);
	};
	
	function propsFilter(key) {
	    return !noCopyPropsPattern.test(key);
	}
	
	function isPromisified(fn) {
	    try {
	        return fn.__isPromisified__ === true;
	    }
	    catch (e) {
	        return false;
	    }
	}
	
	function hasPromisified(obj, key, suffix) {
	    var val = util.getDataPropertyOrDefault(obj, key + suffix,
	                                            defaultPromisified);
	    return val ? isPromisified(val) : false;
	}
	function checkValid(ret, suffix, suffixRegexp) {
	    for (var i = 0; i < ret.length; i += 2) {
	        var key = ret[i];
	        if (suffixRegexp.test(key)) {
	            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
	            for (var j = 0; j < ret.length; j += 2) {
	                if (ret[j] === keyWithoutAsyncSuffix) {
	                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a"
	                        .replace("%s", suffix));
	                }
	            }
	        }
	    }
	}
	
	function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
	    var keys = util.inheritedDataKeys(obj);
	    var ret = [];
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var value = obj[key];
	        var passesDefaultFilter = filter === defaultFilter
	            ? true : defaultFilter(key, value, obj);
	        if (typeof value === "function" &&
	            !isPromisified(value) &&
	            !hasPromisified(obj, key, suffix) &&
	            filter(key, value, obj, passesDefaultFilter)) {
	            ret.push(key, value);
	        }
	    }
	    checkValid(ret, suffix, suffixRegexp);
	    return ret;
	}
	
	var escapeIdentRegex = function(str) {
	    return str.replace(/([$])/, "\\$");
	};
	
	var makeNodePromisifiedEval;
	if (false) {
	var switchCaseArgumentOrder = function(likelyArgumentCount) {
	    var ret = [likelyArgumentCount];
	    var min = Math.max(0, likelyArgumentCount - 1 - 3);
	    for(var i = likelyArgumentCount - 1; i >= min; --i) {
	        ret.push(i);
	    }
	    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
	        ret.push(i);
	    }
	    return ret;
	};
	
	var argumentSequence = function(argumentCount) {
	    return util.filledRange(argumentCount, "_arg", "");
	};
	
	var parameterDeclaration = function(parameterCount) {
	    return util.filledRange(
	        Math.max(parameterCount, 3), "_arg", "");
	};
	
	var parameterCount = function(fn) {
	    if (typeof fn.length === "number") {
	        return Math.max(Math.min(fn.length, 1023 + 1), 0);
	    }
	    return 0;
	};
	
	makeNodePromisifiedEval =
	function(callback, receiver, originalName, fn) {
	    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
	    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
	    var shouldProxyThis = typeof callback === "string" || receiver === THIS;
	
	    function generateCallForArgumentCount(count) {
	        var args = argumentSequence(count).join(", ");
	        var comma = count > 0 ? ", " : "";
	        var ret;
	        if (shouldProxyThis) {
	            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
	        } else {
	            ret = receiver === undefined
	                ? "ret = callback({{args}}, nodeback); break;\n"
	                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
	        }
	        return ret.replace("{{args}}", args).replace(", ", comma);
	    }
	
	    function generateArgumentSwitchCase() {
	        var ret = "";
	        for (var i = 0; i < argumentOrder.length; ++i) {
	            ret += "case " + argumentOrder[i] +":" +
	                generateCallForArgumentCount(argumentOrder[i]);
	        }
	
	        ret += "                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = nodeback;                                              \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]", (shouldProxyThis
	                                ? "ret = callback.apply(this, args);\n"
	                                : "ret = callback.apply(receiver, args);\n"));
	        return ret;
	    }
	
	    var getFunctionCode = typeof callback === "string"
	                                ? ("this != null ? this['"+callback+"'] : fn")
	                                : "fn";
	
	    return new Function("Promise",
	                        "fn",
	                        "receiver",
	                        "withAppended",
	                        "maybeWrapAsError",
	                        "nodebackForPromise",
	                        "tryCatch",
	                        "errorObj",
	                        "INTERNAL","'use strict';                            \n\
	        var ret = function (Parameters) {                                    \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._captureStackTrace();                                    \n\
	            var nodeback = nodebackForPromise(promise);                      \n\
	            var ret;                                                         \n\
	            var callback = tryCatch([GetFunctionCode]);                      \n\
	            switch(len) {                                                    \n\
	                [CodeForSwitchCase]                                          \n\
	            }                                                                \n\
	            if (ret === errorObj) {                                          \n\
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
	            }                                                                \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        ret.__isPromisified__ = true;                                        \n\
	        return ret;                                                          \n\
	        "
	        .replace("Parameters", parameterDeclaration(newParameterCount))
	        .replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
	        .replace("[GetFunctionCode]", getFunctionCode))(
	            Promise,
	            fn,
	            receiver,
	            withAppended,
	            maybeWrapAsError,
	            nodebackForPromise,
	            util.tryCatch,
	            util.errorObj,
	            INTERNAL
	        );
	};
	}
	
	function makeNodePromisifiedClosure(callback, receiver, _, fn) {
	    var defaultThis = (function() {return this;})();
	    var method = callback;
	    if (typeof method === "string") {
	        callback = fn;
	    }
	    function promisified() {
	        var _receiver = receiver;
	        if (receiver === THIS) _receiver = this;
	        var promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	        var cb = typeof method === "string" && this !== defaultThis
	            ? this[method] : callback;
	        var fn = nodebackForPromise(promise);
	        try {
	            cb.apply(_receiver, withAppended(arguments, fn));
	        } catch(e) {
	            promise._rejectCallback(maybeWrapAsError(e), true, true);
	        }
	        return promise;
	    }
	    promisified.__isPromisified__ = true;
	    return promisified;
	}
	
	var makeNodePromisified = canEvaluate
	    ? makeNodePromisifiedEval
	    : makeNodePromisifiedClosure;
	
	function promisifyAll(obj, suffix, filter, promisifier) {
	    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
	    var methods =
	        promisifiableMethods(obj, suffix, suffixRegexp, filter);
	
	    for (var i = 0, len = methods.length; i < len; i+= 2) {
	        var key = methods[i];
	        var fn = methods[i+1];
	        var promisifiedKey = key + suffix;
	        obj[promisifiedKey] = promisifier === makeNodePromisified
	                ? makeNodePromisified(key, THIS, key, fn, suffix)
	                : promisifier(fn, function() {
	                    return makeNodePromisified(key, THIS, key, fn, suffix);
	                });
	    }
	    util.toFastProperties(obj);
	    return obj;
	}
	
	function promisify(callback, receiver) {
	    return makeNodePromisified(callback, receiver, undefined, callback);
	}
	
	Promise.promisify = function (fn, receiver) {
	    if (typeof fn !== "function") {
	        throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    if (isPromisified(fn)) {
	        return fn;
	    }
	    var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
	    util.copyDescriptors(fn, ret, propsFilter);
	    return ret;
	};
	
	Promise.promisifyAll = function (target, options) {
	    if (typeof target !== "function" && typeof target !== "object") {
	        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
	    }
	    options = Object(options);
	    var suffix = options.suffix;
	    if (typeof suffix !== "string") suffix = defaultSuffix;
	    var filter = options.filter;
	    if (typeof filter !== "function") filter = defaultFilter;
	    var promisifier = options.promisifier;
	    if (typeof promisifier !== "function") promisifier = makeNodePromisified;
	
	    if (!util.isIdentifier(suffix)) {
	        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
	    }
	
	    var keys = util.inheritedDataKeys(target);
	    for (var i = 0; i < keys.length; ++i) {
	        var value = target[keys[i]];
	        if (keys[i] !== "constructor" &&
	            util.isClass(value)) {
	            promisifyAll(value.prototype, suffix, filter, promisifier);
	            promisifyAll(value, suffix, filter, promisifier);
	        }
	    }
	
	    return promisifyAll(target, suffix, filter, promisifier);
	};
	};
	
	
	},{"./errors":13,"./promise_resolver.js":25,"./util.js":38}],27:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util.js");
	var isObject = util.isObject;
	var es5 = _dereq_("./es5.js");
	
	function PropertiesPromiseArray(obj) {
	    var keys = es5.keys(obj);
	    var len = keys.length;
	    var values = new Array(len * 2);
	    for (var i = 0; i < len; ++i) {
	        var key = keys[i];
	        values[i] = obj[key];
	        values[i + len] = key;
	    }
	    this.constructor$(values);
	}
	util.inherits(PropertiesPromiseArray, PromiseArray);
	
	PropertiesPromiseArray.prototype._init = function () {
	    this._init$(undefined, -3) ;
	};
	
	PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        var val = {};
	        var keyOffset = this.length();
	        for (var i = 0, len = this.length(); i < len; ++i) {
	            val[this._values[i + keyOffset]] = this._values[i];
	        }
	        this._resolve(val);
	    }
	};
	
	PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
	    this._promise._progress({
	        key: this._values[index + this.length()],
	        value: value
	    });
	};
	
	PropertiesPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};
	
	PropertiesPromiseArray.prototype.getActualLength = function (len) {
	    return len >> 1;
	};
	
	function props(promises) {
	    var ret;
	    var castValue = tryConvertToPromise(promises);
	
	    if (!isObject(castValue)) {
	        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
	    } else if (castValue instanceof Promise) {
	        ret = castValue._then(
	            Promise.props, undefined, undefined, undefined, undefined);
	    } else {
	        ret = new PropertiesPromiseArray(castValue).promise();
	    }
	
	    if (castValue instanceof Promise) {
	        ret._propagateFrom(castValue, 4);
	    }
	    return ret;
	}
	
	Promise.prototype.props = function () {
	    return props(this);
	};
	
	Promise.props = function (promises) {
	    return props(promises);
	};
	};
	
	},{"./es5.js":14,"./util.js":38}],28:[function(_dereq_,module,exports){
	"use strict";
	function arrayMove(src, srcIndex, dst, dstIndex, len) {
	    for (var j = 0; j < len; ++j) {
	        dst[j + dstIndex] = src[j + srcIndex];
	        src[j + srcIndex] = void 0;
	    }
	}
	
	function Queue(capacity) {
	    this._capacity = capacity;
	    this._length = 0;
	    this._front = 0;
	}
	
	Queue.prototype._willBeOverCapacity = function (size) {
	    return this._capacity < size;
	};
	
	Queue.prototype._pushOne = function (arg) {
	    var length = this.length();
	    this._checkCapacity(length + 1);
	    var i = (this._front + length) & (this._capacity - 1);
	    this[i] = arg;
	    this._length = length + 1;
	};
	
	Queue.prototype._unshiftOne = function(value) {
	    var capacity = this._capacity;
	    this._checkCapacity(this.length() + 1);
	    var front = this._front;
	    var i = (((( front - 1 ) &
	                    ( capacity - 1) ) ^ capacity ) - capacity );
	    this[i] = value;
	    this._front = i;
	    this._length = this.length() + 1;
	};
	
	Queue.prototype.unshift = function(fn, receiver, arg) {
	    this._unshiftOne(arg);
	    this._unshiftOne(receiver);
	    this._unshiftOne(fn);
	};
	
	Queue.prototype.push = function (fn, receiver, arg) {
	    var length = this.length() + 3;
	    if (this._willBeOverCapacity(length)) {
	        this._pushOne(fn);
	        this._pushOne(receiver);
	        this._pushOne(arg);
	        return;
	    }
	    var j = this._front + length - 3;
	    this._checkCapacity(length);
	    var wrapMask = this._capacity - 1;
	    this[(j + 0) & wrapMask] = fn;
	    this[(j + 1) & wrapMask] = receiver;
	    this[(j + 2) & wrapMask] = arg;
	    this._length = length;
	};
	
	Queue.prototype.shift = function () {
	    var front = this._front,
	        ret = this[front];
	
	    this[front] = undefined;
	    this._front = (front + 1) & (this._capacity - 1);
	    this._length--;
	    return ret;
	};
	
	Queue.prototype.length = function () {
	    return this._length;
	};
	
	Queue.prototype._checkCapacity = function (size) {
	    if (this._capacity < size) {
	        this._resizeTo(this._capacity << 1);
	    }
	};
	
	Queue.prototype._resizeTo = function (capacity) {
	    var oldCapacity = this._capacity;
	    this._capacity = capacity;
	    var front = this._front;
	    var length = this._length;
	    var moveItemsCount = (front + length) & (oldCapacity - 1);
	    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
	};
	
	module.exports = Queue;
	
	},{}],29:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var isArray = _dereq_("./util.js").isArray;
	
	var raceLater = function (promise) {
	    return promise.then(function(array) {
	        return race(array, promise);
	    });
	};
	
	function race(promises, parent) {
	    var maybePromise = tryConvertToPromise(promises);
	
	    if (maybePromise instanceof Promise) {
	        return raceLater(maybePromise);
	    } else if (!isArray(promises)) {
	        return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
	    }
	
	    var ret = new Promise(INTERNAL);
	    if (parent !== undefined) {
	        ret._propagateFrom(parent, 4 | 1);
	    }
	    var fulfill = ret._fulfill;
	    var reject = ret._reject;
	    for (var i = 0, len = promises.length; i < len; ++i) {
	        var val = promises[i];
	
	        if (val === undefined && !(i in promises)) {
	            continue;
	        }
	
	        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
	    }
	    return ret;
	}
	
	Promise.race = function (promises) {
	    return race(promises, undefined);
	};
	
	Promise.prototype.race = function () {
	    return race(this, undefined);
	};
	
	};
	
	},{"./util.js":38}],30:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL) {
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	function ReductionPromiseArray(promises, fn, accum, _each) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    this._preservedValues = _each === INTERNAL ? [] : null;
	    this._zerothIsAccum = (accum === undefined);
	    this._gotAccum = false;
	    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
	    this._valuesPhase = undefined;
	    var maybePromise = tryConvertToPromise(accum, this._promise);
	    var rejected = false;
	    var isPromise = maybePromise instanceof Promise;
	    if (isPromise) {
	        maybePromise = maybePromise._target();
	        if (maybePromise._isPending()) {
	            maybePromise._proxyPromiseArray(this, -1);
	        } else if (maybePromise._isFulfilled()) {
	            accum = maybePromise._value();
	            this._gotAccum = true;
	        } else {
	            this._reject(maybePromise._reason());
	            rejected = true;
	        }
	    }
	    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
	    this._callback = fn;
	    this._accum = accum;
	    if (!rejected) this._init$(undefined, -5);
	}
	util.inherits(ReductionPromiseArray, PromiseArray);
	
	ReductionPromiseArray.prototype._init = function () {};
	
	ReductionPromiseArray.prototype._resolveEmptyArray = function () {
	    if (this._gotAccum || this._zerothIsAccum) {
	        this._resolve(this._preservedValues !== null
	                        ? [] : this._accum);
	    }
	};
	
	ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    values[index] = value;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var isEach = preservedValues !== null;
	    var gotAccum = this._gotAccum;
	    var valuesPhase = this._valuesPhase;
	    var valuesPhaseIndex;
	    if (!valuesPhase) {
	        valuesPhase = this._valuesPhase = new Array(length);
	        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
	            valuesPhase[valuesPhaseIndex] = 0;
	        }
	    }
	    valuesPhaseIndex = valuesPhase[index];
	
	    if (index === 0 && this._zerothIsAccum) {
	        this._accum = value;
	        this._gotAccum = gotAccum = true;
	        valuesPhase[index] = ((valuesPhaseIndex === 0)
	            ? 1 : 2);
	    } else if (index === -1) {
	        this._accum = value;
	        this._gotAccum = gotAccum = true;
	    } else {
	        if (valuesPhaseIndex === 0) {
	            valuesPhase[index] = 1;
	        } else {
	            valuesPhase[index] = 2;
	            this._accum = value;
	        }
	    }
	    if (!gotAccum) return;
	
	    var callback = this._callback;
	    var receiver = this._promise._boundTo;
	    var ret;
	
	    for (var i = this._reducingIndex; i < length; ++i) {
	        valuesPhaseIndex = valuesPhase[i];
	        if (valuesPhaseIndex === 2) {
	            this._reducingIndex = i + 1;
	            continue;
	        }
	        if (valuesPhaseIndex !== 1) return;
	        value = values[i];
	        this._promise._pushContext();
	        if (isEach) {
	            preservedValues.push(value);
	            ret = tryCatch(callback).call(receiver, value, i, length);
	        }
	        else {
	            ret = tryCatch(callback)
	                .call(receiver, this._accum, value, i, length);
	        }
	        this._promise._popContext();
	
	        if (ret === errorObj) return this._reject(ret.e);
	
	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (maybePromise._isPending()) {
	                valuesPhase[i] = 4;
	                return maybePromise._proxyPromiseArray(this, i);
	            } else if (maybePromise._isFulfilled()) {
	                ret = maybePromise._value();
	            } else {
	                return this._reject(maybePromise._reason());
	            }
	        }
	
	        this._reducingIndex = i + 1;
	        this._accum = ret;
	    }
	
	    this._resolve(isEach ? preservedValues : this._accum);
	};
	
	function reduce(promises, fn, initialValue, _each) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
	    return array.promise();
	}
	
	Promise.prototype.reduce = function (fn, initialValue) {
	    return reduce(this, fn, initialValue, null);
	};
	
	Promise.reduce = function (promises, fn, initialValue, _each) {
	    return reduce(promises, fn, initialValue, _each);
	};
	};
	
	},{"./util.js":38}],31:[function(_dereq_,module,exports){
	"use strict";
	var schedule;
	if (_dereq_("./util.js").isNode) {
	    var version = process.versions.node.split(".").map(Number);
	    schedule = (version[0] === 0 && version[1] > 10) || (version[0] > 0)
	        ? global.setImmediate : process.nextTick;
	}
	else if (typeof MutationObserver !== "undefined") {
	    schedule = function(fn) {
	        var div = document.createElement("div");
	        var observer = new MutationObserver(fn);
	        observer.observe(div, {attributes: true});
	        return function() { div.classList.toggle("foo"); };
	    };
	    schedule.isStatic = true;
	}
	else if (typeof setTimeout !== "undefined") {
	    schedule = function (fn) {
	        setTimeout(fn, 0);
	    };
	}
	else {
	    schedule = function() {
	        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
	    };
	}
	module.exports = schedule;
	
	},{"./util.js":38}],32:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	    function(Promise, PromiseArray) {
	var PromiseInspection = Promise.PromiseInspection;
	var util = _dereq_("./util.js");
	
	function SettledPromiseArray(values) {
	    this.constructor$(values);
	}
	util.inherits(SettledPromiseArray, PromiseArray);
	
	SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
	    this._values[index] = inspection;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};
	
	SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 268435456;
	    ret._settledValue = value;
	    this._promiseResolved(index, ret);
	};
	SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 134217728;
	    ret._settledValue = reason;
	    this._promiseResolved(index, ret);
	};
	
	Promise.settle = function (promises) {
	    return new SettledPromiseArray(promises).promise();
	};
	
	Promise.prototype.settle = function () {
	    return new SettledPromiseArray(this).promise();
	};
	};
	
	},{"./util.js":38}],33:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, apiRejection) {
	var util = _dereq_("./util.js");
	var RangeError = _dereq_("./errors.js").RangeError;
	var AggregateError = _dereq_("./errors.js").AggregateError;
	var isArray = util.isArray;
	
	
	function SomePromiseArray(values) {
	    this.constructor$(values);
	    this._howMany = 0;
	    this._unwrap = false;
	    this._initialized = false;
	}
	util.inherits(SomePromiseArray, PromiseArray);
	
	SomePromiseArray.prototype._init = function () {
	    if (!this._initialized) {
	        return;
	    }
	    if (this._howMany === 0) {
	        this._resolve([]);
	        return;
	    }
	    this._init$(undefined, -5);
	    var isArrayResolved = isArray(this._values);
	    if (!this._isResolved() &&
	        isArrayResolved &&
	        this._howMany > this._canPossiblyFulfill()) {
	        this._reject(this._getRangeError(this.length()));
	    }
	};
	
	SomePromiseArray.prototype.init = function () {
	    this._initialized = true;
	    this._init();
	};
	
	SomePromiseArray.prototype.setUnwrap = function () {
	    this._unwrap = true;
	};
	
	SomePromiseArray.prototype.howMany = function () {
	    return this._howMany;
	};
	
	SomePromiseArray.prototype.setHowMany = function (count) {
	    this._howMany = count;
	};
	
	SomePromiseArray.prototype._promiseFulfilled = function (value) {
	    this._addFulfilled(value);
	    if (this._fulfilled() === this.howMany()) {
	        this._values.length = this.howMany();
	        if (this.howMany() === 1 && this._unwrap) {
	            this._resolve(this._values[0]);
	        } else {
	            this._resolve(this._values);
	        }
	    }
	
	};
	SomePromiseArray.prototype._promiseRejected = function (reason) {
	    this._addRejected(reason);
	    if (this.howMany() > this._canPossiblyFulfill()) {
	        var e = new AggregateError();
	        for (var i = this.length(); i < this._values.length; ++i) {
	            e.push(this._values[i]);
	        }
	        this._reject(e);
	    }
	};
	
	SomePromiseArray.prototype._fulfilled = function () {
	    return this._totalResolved;
	};
	
	SomePromiseArray.prototype._rejected = function () {
	    return this._values.length - this.length();
	};
	
	SomePromiseArray.prototype._addRejected = function (reason) {
	    this._values.push(reason);
	};
	
	SomePromiseArray.prototype._addFulfilled = function (value) {
	    this._values[this._totalResolved++] = value;
	};
	
	SomePromiseArray.prototype._canPossiblyFulfill = function () {
	    return this.length() - this._rejected();
	};
	
	SomePromiseArray.prototype._getRangeError = function (count) {
	    var message = "Input array must contain at least " +
	            this._howMany + " items but contains only " + count + " items";
	    return new RangeError(message);
	};
	
	SomePromiseArray.prototype._resolveEmptyArray = function () {
	    this._reject(this._getRangeError(0));
	};
	
	function some(promises, howMany) {
	    if ((howMany | 0) !== howMany || howMany < 0) {
	        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
	    }
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(howMany);
	    ret.init();
	    return promise;
	}
	
	Promise.some = function (promises, howMany) {
	    return some(promises, howMany);
	};
	
	Promise.prototype.some = function (howMany) {
	    return some(this, howMany);
	};
	
	Promise._SomePromiseArray = SomePromiseArray;
	};
	
	},{"./errors.js":13,"./util.js":38}],34:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	function PromiseInspection(promise) {
	    if (promise !== undefined) {
	        promise = promise._target();
	        this._bitField = promise._bitField;
	        this._settledValue = promise._settledValue;
	    }
	    else {
	        this._bitField = 0;
	        this._settledValue = undefined;
	    }
	}
	
	PromiseInspection.prototype.value = function () {
	    if (!this.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
	    }
	    return this._settledValue;
	};
	
	PromiseInspection.prototype.error =
	PromiseInspection.prototype.reason = function () {
	    if (!this.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
	    }
	    return this._settledValue;
	};
	
	PromiseInspection.prototype.isFulfilled =
	Promise.prototype._isFulfilled = function () {
	    return (this._bitField & 268435456) > 0;
	};
	
	PromiseInspection.prototype.isRejected =
	Promise.prototype._isRejected = function () {
	    return (this._bitField & 134217728) > 0;
	};
	
	PromiseInspection.prototype.isPending =
	Promise.prototype._isPending = function () {
	    return (this._bitField & 402653184) === 0;
	};
	
	PromiseInspection.prototype.isResolved =
	Promise.prototype._isResolved = function () {
	    return (this._bitField & 402653184) > 0;
	};
	
	Promise.prototype.isPending = function() {
	    return this._target()._isPending();
	};
	
	Promise.prototype.isRejected = function() {
	    return this._target()._isRejected();
	};
	
	Promise.prototype.isFulfilled = function() {
	    return this._target()._isFulfilled();
	};
	
	Promise.prototype.isResolved = function() {
	    return this._target()._isResolved();
	};
	
	Promise.prototype._value = function() {
	    return this._settledValue;
	};
	
	Promise.prototype._reason = function() {
	    this._unsetRejectionIsUnhandled();
	    return this._settledValue;
	};
	
	Promise.prototype.value = function() {
	    var target = this._target();
	    if (!target.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
	    }
	    return target._settledValue;
	};
	
	Promise.prototype.reason = function() {
	    var target = this._target();
	    if (!target.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
	    }
	    target._unsetRejectionIsUnhandled();
	    return target._settledValue;
	};
	
	
	Promise.PromiseInspection = PromiseInspection;
	};
	
	},{}],35:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util.js");
	var errorObj = util.errorObj;
	var isObject = util.isObject;
	
	function tryConvertToPromise(obj, context) {
	    if (isObject(obj)) {
	        if (obj instanceof Promise) {
	            return obj;
	        }
	        else if (isAnyBluebirdPromise(obj)) {
	            var ret = new Promise(INTERNAL);
	            obj._then(
	                ret._fulfillUnchecked,
	                ret._rejectUncheckedCheckError,
	                ret._progressUnchecked,
	                ret,
	                null
	            );
	            return ret;
	        }
	        var then = util.tryCatch(getThen)(obj);
	        if (then === errorObj) {
	            if (context) context._pushContext();
	            var ret = Promise.reject(then.e);
	            if (context) context._popContext();
	            return ret;
	        } else if (typeof then === "function") {
	            return doThenable(obj, then, context);
	        }
	    }
	    return obj;
	}
	
	function getThen(obj) {
	    return obj.then;
	}
	
	var hasProp = {}.hasOwnProperty;
	function isAnyBluebirdPromise(obj) {
	    return hasProp.call(obj, "_promise0");
	}
	
	function doThenable(x, then, context) {
	    var promise = new Promise(INTERNAL);
	    var ret = promise;
	    if (context) context._pushContext();
	    promise._captureStackTrace();
	    if (context) context._popContext();
	    var synchronous = true;
	    var result = util.tryCatch(then).call(x,
	                                        resolveFromThenable,
	                                        rejectFromThenable,
	                                        progressFromThenable);
	    synchronous = false;
	    if (promise && result === errorObj) {
	        promise._rejectCallback(result.e, true, true);
	        promise = null;
	    }
	
	    function resolveFromThenable(value) {
	        if (!promise) return;
	        if (x === value) {
	            promise._rejectCallback(
	                Promise._makeSelfResolutionError(), false, true);
	        } else {
	            promise._resolveCallback(value);
	        }
	        promise = null;
	    }
	
	    function rejectFromThenable(reason) {
	        if (!promise) return;
	        promise._rejectCallback(reason, synchronous, true);
	        promise = null;
	    }
	
	    function progressFromThenable(value) {
	        if (!promise) return;
	        if (typeof promise._progress === "function") {
	            promise._progress(value);
	        }
	    }
	    return ret;
	}
	
	return tryConvertToPromise;
	};
	
	},{"./util.js":38}],36:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util.js");
	var TimeoutError = Promise.TimeoutError;
	
	var afterTimeout = function (promise, message) {
	    if (!promise.isPending()) return;
	    if (typeof message !== "string") {
	        message = "operation timed out";
	    }
	    var err = new TimeoutError(message);
	    util.markAsOriginatingFromRejection(err);
	    promise._attachExtraTrace(err);
	    promise._cancel(err);
	};
	
	var afterValue = function(value) { return delay(+this).thenReturn(value); };
	var delay = Promise.delay = function (value, ms) {
	    if (ms === undefined) {
	        ms = value;
	        value = undefined;
	        var ret = new Promise(INTERNAL);
	        setTimeout(function() { ret._fulfill(); }, ms);
	        return ret;
	    }
	    ms = +ms;
	    return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
	};
	
	Promise.prototype.delay = function (ms) {
	    return delay(this, ms);
	};
	
	function successClear(value) {
	    var handle = this;
	    if (handle instanceof Number) handle = +handle;
	    clearTimeout(handle);
	    return value;
	}
	
	function failureClear(reason) {
	    var handle = this;
	    if (handle instanceof Number) handle = +handle;
	    clearTimeout(handle);
	    throw reason;
	}
	
	Promise.prototype.timeout = function (ms, message) {
	    ms = +ms;
	    var ret = this.then().cancellable();
	    ret._cancellationParent = this;
	    var handle = setTimeout(function timeoutTimeout() {
	        afterTimeout(ret, message);
	    }, ms);
	    return ret._then(successClear, failureClear, undefined, handle, undefined);
	};
	
	};
	
	},{"./util.js":38}],37:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function (Promise, apiRejection, tryConvertToPromise,
	    createContext) {
	    var TypeError = _dereq_("./errors.js").TypeError;
	    var inherits = _dereq_("./util.js").inherits;
	    var PromiseInspection = Promise.PromiseInspection;
	
	    function inspectionMapper(inspections) {
	        var len = inspections.length;
	        for (var i = 0; i < len; ++i) {
	            var inspection = inspections[i];
	            if (inspection.isRejected()) {
	                return Promise.reject(inspection.error());
	            }
	            inspections[i] = inspection._settledValue;
	        }
	        return inspections;
	    }
	
	    function thrower(e) {
	        setTimeout(function(){throw e;}, 0);
	    }
	
	    function castPreservingDisposable(thenable) {
	        var maybePromise = tryConvertToPromise(thenable);
	        if (maybePromise !== thenable &&
	            typeof thenable._isDisposable === "function" &&
	            typeof thenable._getDisposer === "function" &&
	            thenable._isDisposable()) {
	            maybePromise._setDisposable(thenable._getDisposer());
	        }
	        return maybePromise;
	    }
	    function dispose(resources, inspection) {
	        var i = 0;
	        var len = resources.length;
	        var ret = Promise.defer();
	        function iterator() {
	            if (i >= len) return ret.resolve();
	            var maybePromise = castPreservingDisposable(resources[i++]);
	            if (maybePromise instanceof Promise &&
	                maybePromise._isDisposable()) {
	                try {
	                    maybePromise = tryConvertToPromise(
	                        maybePromise._getDisposer().tryDispose(inspection),
	                        resources.promise);
	                } catch (e) {
	                    return thrower(e);
	                }
	                if (maybePromise instanceof Promise) {
	                    return maybePromise._then(iterator, thrower,
	                                              null, null, null);
	                }
	            }
	            iterator();
	        }
	        iterator();
	        return ret.promise;
	    }
	
	    function disposerSuccess(value) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = value;
	        inspection._bitField = 268435456;
	        return dispose(this, inspection).thenReturn(value);
	    }
	
	    function disposerFail(reason) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = reason;
	        inspection._bitField = 134217728;
	        return dispose(this, inspection).thenThrow(reason);
	    }
	
	    function Disposer(data, promise, context) {
	        this._data = data;
	        this._promise = promise;
	        this._context = context;
	    }
	
	    Disposer.prototype.data = function () {
	        return this._data;
	    };
	
	    Disposer.prototype.promise = function () {
	        return this._promise;
	    };
	
	    Disposer.prototype.resource = function () {
	        if (this.promise().isFulfilled()) {
	            return this.promise().value();
	        }
	        return null;
	    };
	
	    Disposer.prototype.tryDispose = function(inspection) {
	        var resource = this.resource();
	        var context = this._context;
	        if (context !== undefined) context._pushContext();
	        var ret = resource !== null
	            ? this.doDispose(resource, inspection) : null;
	        if (context !== undefined) context._popContext();
	        this._promise._unsetDisposable();
	        this._data = null;
	        return ret;
	    };
	
	    Disposer.isDisposer = function (d) {
	        return (d != null &&
	                typeof d.resource === "function" &&
	                typeof d.tryDispose === "function");
	    };
	
	    function FunctionDisposer(fn, promise, context) {
	        this.constructor$(fn, promise, context);
	    }
	    inherits(FunctionDisposer, Disposer);
	
	    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
	        var fn = this.data();
	        return fn.call(resource, resource, inspection);
	    };
	
	    function maybeUnwrapDisposer(value) {
	        if (Disposer.isDisposer(value)) {
	            this.resources[this.index]._setDisposable(value);
	            return value.promise();
	        }
	        return value;
	    }
	
	    Promise.using = function () {
	        var len = arguments.length;
	        if (len < 2) return apiRejection(
	                        "you must pass at least 2 arguments to Promise.using");
	        var fn = arguments[len - 1];
	        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	        len--;
	        var resources = new Array(len);
	        for (var i = 0; i < len; ++i) {
	            var resource = arguments[i];
	            if (Disposer.isDisposer(resource)) {
	                var disposer = resource;
	                resource = resource.promise();
	                resource._setDisposable(disposer);
	            } else {
	                var maybePromise = tryConvertToPromise(resource);
	                if (maybePromise instanceof Promise) {
	                    resource =
	                        maybePromise._then(maybeUnwrapDisposer, null, null, {
	                            resources: resources,
	                            index: i
	                    }, undefined);
	                }
	            }
	            resources[i] = resource;
	        }
	
	        var promise = Promise.settle(resources)
	            .then(inspectionMapper)
	            .then(function(vals) {
	                promise._pushContext();
	                var ret;
	                try {
	                    ret = fn.apply(undefined, vals);
	                } finally {
	                    promise._popContext();
	                }
	                return ret;
	            })
	            ._then(
	                disposerSuccess, disposerFail, undefined, resources, undefined);
	        resources.promise = promise;
	        return promise;
	    };
	
	    Promise.prototype._setDisposable = function (disposer) {
	        this._bitField = this._bitField | 262144;
	        this._disposer = disposer;
	    };
	
	    Promise.prototype._isDisposable = function () {
	        return (this._bitField & 262144) > 0;
	    };
	
	    Promise.prototype._getDisposer = function () {
	        return this._disposer;
	    };
	
	    Promise.prototype._unsetDisposable = function () {
	        this._bitField = this._bitField & (~262144);
	        this._disposer = undefined;
	    };
	
	    Promise.prototype.disposer = function (fn) {
	        if (typeof fn === "function") {
	            return new FunctionDisposer(fn, this, createContext());
	        }
	        throw new TypeError();
	    };
	
	};
	
	},{"./errors.js":13,"./util.js":38}],38:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5.js");
	var canEvaluate = typeof navigator == "undefined";
	var haveGetters = (function(){
	    try {
	        var o = {};
	        es5.defineProperty(o, "f", {
	            get: function () {
	                return 3;
	            }
	        });
	        return o.f === 3;
	    }
	    catch (e) {
	        return false;
	    }
	
	})();
	
	var errorObj = {e: {}};
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	
	var inherits = function(Child, Parent) {
	    var hasProp = {}.hasOwnProperty;
	
	    function T() {
	        this.constructor = Child;
	        this.constructor$ = Parent;
	        for (var propertyName in Parent.prototype) {
	            if (hasProp.call(Parent.prototype, propertyName) &&
	                propertyName.charAt(propertyName.length-1) !== "$"
	           ) {
	                this[propertyName + "$"] = Parent.prototype[propertyName];
	            }
	        }
	    }
	    T.prototype = Parent.prototype;
	    Child.prototype = new T();
	    return Child.prototype;
	};
	
	
	function isPrimitive(val) {
	    return val == null || val === true || val === false ||
	        typeof val === "string" || typeof val === "number";
	
	}
	
	function isObject(value) {
	    return !isPrimitive(value);
	}
	
	function maybeWrapAsError(maybeError) {
	    if (!isPrimitive(maybeError)) return maybeError;
	
	    return new Error(safeToString(maybeError));
	}
	
	function withAppended(target, appendee) {
	    var len = target.length;
	    var ret = new Array(len + 1);
	    var i;
	    for (i = 0; i < len; ++i) {
	        ret[i] = target[i];
	    }
	    ret[i] = appendee;
	    return ret;
	}
	
	function getDataPropertyOrDefault(obj, key, defaultValue) {
	    if (es5.isES5) {
	        var desc = Object.getOwnPropertyDescriptor(obj, key);
	        if (desc != null) {
	            return desc.get == null && desc.set == null
	                    ? desc.value
	                    : defaultValue;
	        }
	    } else {
	        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
	    }
	}
	
	function notEnumerableProp(obj, name, value) {
	    if (isPrimitive(obj)) return obj;
	    var descriptor = {
	        value: value,
	        configurable: true,
	        enumerable: false,
	        writable: true
	    };
	    es5.defineProperty(obj, name, descriptor);
	    return obj;
	}
	
	
	var wrapsPrimitiveReceiver = (function() {
	    return this !== "string";
	}).call("string");
	
	function thrower(r) {
	    throw r;
	}
	
	var inheritedDataKeys = (function() {
	    if (es5.isES5) {
	        var oProto = Object.prototype;
	        var getKeys = Object.getOwnPropertyNames;
	        return function(obj) {
	            var ret = [];
	            var visitedKeys = Object.create(null);
	            while (obj != null && obj !== oProto) {
	                var keys;
	                try {
	                    keys = getKeys(obj);
	                } catch (e) {
	                    return ret;
	                }
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (visitedKeys[key]) continue;
	                    visitedKeys[key] = true;
	                    var desc = Object.getOwnPropertyDescriptor(obj, key);
	                    if (desc != null && desc.get == null && desc.set == null) {
	                        ret.push(key);
	                    }
	                }
	                obj = es5.getPrototypeOf(obj);
	            }
	            return ret;
	        };
	    } else {
	        return function(obj) {
	            var ret = [];
	            /*jshint forin:false */
	            for (var key in obj) {
	                ret.push(key);
	            }
	            return ret;
	        };
	    }
	
	})();
	
	function isClass(fn) {
	    try {
	        if (typeof fn === "function") {
	            var keys = es5.names(fn.prototype);
	            if (es5.isES5) return keys.length > 1;
	            return keys.length > 0 &&
	                   !(keys.length === 1 && keys[0] === "constructor");
	        }
	        return false;
	    } catch (e) {
	        return false;
	    }
	}
	
	function toFastProperties(obj) {
	    /*jshint -W027*/
	    function f() {}
	    f.prototype = obj;
	    return f;
	    eval(obj);
	}
	
	var rident = /^[a-z$_][a-z$_0-9]*$/i;
	function isIdentifier(str) {
	    return rident.test(str);
	}
	
	function filledRange(count, prefix, suffix) {
	    var ret = new Array(count);
	    for(var i = 0; i < count; ++i) {
	        ret[i] = prefix + i + suffix;
	    }
	    return ret;
	}
	
	function safeToString(obj) {
	    try {
	        return obj + "";
	    } catch (e) {
	        return "[no string representation]";
	    }
	}
	
	function markAsOriginatingFromRejection(e) {
	    try {
	        notEnumerableProp(e, "isOperational", true);
	    }
	    catch(ignore) {}
	}
	
	function originatesFromRejection(e) {
	    if (e == null) return false;
	    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
	        e["isOperational"] === true);
	}
	
	function canAttachTrace(obj) {
	    return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
	}
	
	var ensureErrorObject = (function() {
	    if (!("stack" in new Error())) {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            try {throw new Error(safeToString(value));}
	            catch(err) {return err;}
	        };
	    } else {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            return new Error(safeToString(value));
	        };
	    }
	})();
	
	function classString(obj) {
	    return {}.toString.call(obj);
	}
	
	function copyDescriptors(from, to, filter) {
	    var keys = es5.names(from);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        if (filter(key)) {
	            es5.defineProperty(to, key, es5.getDescriptor(from, key));
	        }
	    }
	}
	
	var ret = {
	    isClass: isClass,
	    isIdentifier: isIdentifier,
	    inheritedDataKeys: inheritedDataKeys,
	    getDataPropertyOrDefault: getDataPropertyOrDefault,
	    thrower: thrower,
	    isArray: es5.isArray,
	    haveGetters: haveGetters,
	    notEnumerableProp: notEnumerableProp,
	    isPrimitive: isPrimitive,
	    isObject: isObject,
	    canEvaluate: canEvaluate,
	    errorObj: errorObj,
	    tryCatch: tryCatch,
	    inherits: inherits,
	    withAppended: withAppended,
	    maybeWrapAsError: maybeWrapAsError,
	    wrapsPrimitiveReceiver: wrapsPrimitiveReceiver,
	    toFastProperties: toFastProperties,
	    filledRange: filledRange,
	    toString: safeToString,
	    canAttachTrace: canAttachTrace,
	    ensureErrorObject: ensureErrorObject,
	    originatesFromRejection: originatesFromRejection,
	    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
	    classString: classString,
	    copyDescriptors: copyDescriptors,
	    isNode: typeof process !== "undefined" &&
	        classString(process).toLowerCase() === "[object process]"
	};
	try {throw new Error(); } catch (e) {ret.lastLineError = e;}
	module.exports = ret;
	
	},{"./es5.js":14}]},{},[4])(4)
	});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43), (function() { return this; }())))

/***/ },
/* 214 */
/*!*****************************************************!*\
  !*** ./~/mongoose/lib/services/updateValidators.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var async = __webpack_require__(/*! async */ 215);
	var ValidationError = __webpack_require__(/*! ../error/validation.js */ 36);
	var ObjectId = __webpack_require__(/*! ../types/objectid */ 45);
	
	/**
	 * Applies validators and defaults to update and fineOneAndUpdate operations,
	 * specifically passing a null doc as `this` to validators and defaults
	 *
	 * @param {Query} query
	 * @param {Schema} schema
	 * @param {Object} castedDoc
	 * @param {Object} options
	 * @method runValidatorsOnUpdate
	 * @api private
	 */
	
	module.exports = function(query, schema, castedDoc, options) {
	  var keys = Object.keys(castedDoc || {});
	  var updatedKeys = {};
	  var updatedValues = {};
	  var numKeys = keys.length;
	  var hasDollarUpdate = false;
	
	  for (var i = 0; i < numKeys; ++i) {
	    if (keys[i].charAt(0) === '$') {
	      var flat = flatten(castedDoc[keys[i]]);
	      var paths = Object.keys(flat);
	      var numPaths = paths.length;
	      for (var j = 0; j < numPaths; ++j) {
	        if (keys[i] === '$set' || keys[i] === '$setOnInsert') {
	          updatedValues[paths[j]] = flat[paths[j]];
	        } else if (keys[i] === '$unset') {
	          updatedValues[paths[j]] = undefined;
	        }
	        updatedKeys[paths[j]] = true;
	      }
	      hasDollarUpdate = true;
	    }
	  }
	
	  if (!hasDollarUpdate) {
	    updatedValues = flatten(castedDoc);
	    updatedKeys = Object.keys(updatedValues);
	  }
	
	  if (options && options.upsert) {
	    paths = Object.keys(query._conditions);
	    numPaths = keys.length;
	    for (var i = 0; i < numPaths; ++i) {
	      if (typeof query._conditions[paths[i]] === 'object') {
	        var conditionKeys = Object.keys(query._conditions[paths[i]]);
	        var numConditionKeys = conditionKeys.length;
	        var hasDollarKey = false;
	        for (var j = 0; j < numConditionKeys; ++j) {
	          if (conditionKeys[j].charAt(0) === '$') {
	            hasDollarKey = true;
	            break;
	          }
	        }
	        if (hasDollarKey) {
	          continue;
	        }
	      }
	      updatedKeys[paths[i]] = true;
	    }
	
	    if (options.setDefaultsOnInsert) {
	      schema.eachPath(function(path, schemaType) {
	        if (path === '_id') {
	          // Ignore _id for now because it causes bugs in 2.4
	          return;
	        }
	        var def = schemaType.getDefault(null, true);
	        if (!updatedKeys[path] && typeof def !== 'undefined') {
	          castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};
	          castedDoc.$setOnInsert[path] = def;
	          updatedValues[path] = def;
	        }
	      });
	    }
	  }
	
	  var updates = Object.keys(updatedValues);
	  var numUpdates = updates.length;
	  var validatorsToExecute = [];
	  var validationErrors = [];
	  for (var i = 0; i < numUpdates; ++i) {
	    (function(i) {
	      if (schema.path(updates[i])) {
	        validatorsToExecute.push(function(callback) {
	          schema.path(updates[i]).doValidate(
	            updatedValues[updates[i]],
	            function(err) {
	              if (err) {
	                validationErrors.push(err);
	              }
	              callback(null);
	            },
	            null);
	        });
	      }
	    })(i);
	  }
	
	  return function(callback) {
	    async.parallel(validatorsToExecute, function() {
	      if (validationErrors.length) {
	        var err = new ValidationError(null);
	        for (var i = 0; i < validationErrors.length; ++i) {
	          err.errors[validationErrors[i].path] = validationErrors[i];
	        }
	        return callback(err);
	      }
	      callback(null);
	    });
	  };
	};
	
	function flatten(update, path) {
	  var keys = Object.keys(update);
	  var numKeys = keys.length;
	  var result = {};
	  path = path ? path + '.' : '';
	
	  for (var i = 0; i < numKeys; ++i) {
	    var key = keys[i];
	    var val = update[key];
	    if (shouldFlatten(val)) {
	      var flat = flatten(val, path + key);
	      for (var k in flat) {
	        result[k] = flat[k];
	      }
	    } else {
	      result[path + key] = val;
	    }
	  }
	
	  return result;
	}
	
	function shouldFlatten(val) {
	  return val && typeof val === 'object' && !(val instanceof ObjectId);
	}


/***/ },
/* 215 */
/*!*****************************************!*\
  !*** ./~/mongoose/~/async/lib/async.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, setImmediate) {/*!
	 * async
	 * https://github.com/caolan/async
	 *
	 * Copyright 2010-2014 Caolan McMahon
	 * Released under the MIT license
	 */
	/*jshint onevar: false, indent:4 */
	/*global setImmediate: false, setTimeout: false, console: false */
	(function () {
	
	    var async = {};
	
	    // global on the server, window in the browser
	    var root, previous_async;
	
	    root = this;
	    if (root != null) {
	      previous_async = root.async;
	    }
	
	    async.noConflict = function () {
	        root.async = previous_async;
	        return async;
	    };
	
	    function only_once(fn) {
	        var called = false;
	        return function() {
	            if (called) throw new Error("Callback was already called.");
	            called = true;
	            fn.apply(root, arguments);
	        }
	    }
	
	    //// cross-browser compatiblity functions ////
	
	    var _toString = Object.prototype.toString;
	
	    var _isArray = Array.isArray || function (obj) {
	        return _toString.call(obj) === '[object Array]';
	    };
	
	    var _each = function (arr, iterator) {
	        if (arr.forEach) {
	            return arr.forEach(iterator);
	        }
	        for (var i = 0; i < arr.length; i += 1) {
	            iterator(arr[i], i, arr);
	        }
	    };
	
	    var _map = function (arr, iterator) {
	        if (arr.map) {
	            return arr.map(iterator);
	        }
	        var results = [];
	        _each(arr, function (x, i, a) {
	            results.push(iterator(x, i, a));
	        });
	        return results;
	    };
	
	    var _reduce = function (arr, iterator, memo) {
	        if (arr.reduce) {
	            return arr.reduce(iterator, memo);
	        }
	        _each(arr, function (x, i, a) {
	            memo = iterator(memo, x, i, a);
	        });
	        return memo;
	    };
	
	    var _keys = function (obj) {
	        if (Object.keys) {
	            return Object.keys(obj);
	        }
	        var keys = [];
	        for (var k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                keys.push(k);
	            }
	        }
	        return keys;
	    };
	
	    //// exported async module functions ////
	
	    //// nextTick implementation with browser-compatible fallback ////
	    if (typeof process === 'undefined' || !(process.nextTick)) {
	        if (typeof setImmediate === 'function') {
	            async.nextTick = function (fn) {
	                // not a direct alias for IE10 compatibility
	                setImmediate(fn);
	            };
	            async.setImmediate = async.nextTick;
	        }
	        else {
	            async.nextTick = function (fn) {
	                setTimeout(fn, 0);
	            };
	            async.setImmediate = async.nextTick;
	        }
	    }
	    else {
	        async.nextTick = process.nextTick;
	        if (typeof setImmediate !== 'undefined') {
	            async.setImmediate = function (fn) {
	              // not a direct alias for IE10 compatibility
	              setImmediate(fn);
	            };
	        }
	        else {
	            async.setImmediate = async.nextTick;
	        }
	    }
	
	    async.each = function (arr, iterator, callback) {
	        callback = callback || function () {};
	        if (!arr.length) {
	            return callback();
	        }
	        var completed = 0;
	        _each(arr, function (x) {
	            iterator(x, only_once(done) );
	        });
	        function done(err) {
	          if (err) {
	              callback(err);
	              callback = function () {};
	          }
	          else {
	              completed += 1;
	              if (completed >= arr.length) {
	                  callback();
	              }
	          }
	        }
	    };
	    async.forEach = async.each;
	
	    async.eachSeries = function (arr, iterator, callback) {
	        callback = callback || function () {};
	        if (!arr.length) {
	            return callback();
	        }
	        var completed = 0;
	        var iterate = function () {
	            iterator(arr[completed], function (err) {
	                if (err) {
	                    callback(err);
	                    callback = function () {};
	                }
	                else {
	                    completed += 1;
	                    if (completed >= arr.length) {
	                        callback();
	                    }
	                    else {
	                        iterate();
	                    }
	                }
	            });
	        };
	        iterate();
	    };
	    async.forEachSeries = async.eachSeries;
	
	    async.eachLimit = function (arr, limit, iterator, callback) {
	        var fn = _eachLimit(limit);
	        fn.apply(null, [arr, iterator, callback]);
	    };
	    async.forEachLimit = async.eachLimit;
	
	    var _eachLimit = function (limit) {
	
	        return function (arr, iterator, callback) {
	            callback = callback || function () {};
	            if (!arr.length || limit <= 0) {
	                return callback();
	            }
	            var completed = 0;
	            var started = 0;
	            var running = 0;
	
	            (function replenish () {
	                if (completed >= arr.length) {
	                    return callback();
	                }
	
	                while (running < limit && started < arr.length) {
	                    started += 1;
	                    running += 1;
	                    iterator(arr[started - 1], function (err) {
	                        if (err) {
	                            callback(err);
	                            callback = function () {};
	                        }
	                        else {
	                            completed += 1;
	                            running -= 1;
	                            if (completed >= arr.length) {
	                                callback();
	                            }
	                            else {
	                                replenish();
	                            }
	                        }
	                    });
	                }
	            })();
	        };
	    };
	
	
	    var doParallel = function (fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [async.each].concat(args));
	        };
	    };
	    var doParallelLimit = function(limit, fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [_eachLimit(limit)].concat(args));
	        };
	    };
	    var doSeries = function (fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [async.eachSeries].concat(args));
	        };
	    };
	
	
	    var _asyncMap = function (eachfn, arr, iterator, callback) {
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        if (!callback) {
	            eachfn(arr, function (x, callback) {
	                iterator(x.value, function (err) {
	                    callback(err);
	                });
	            });
	        } else {
	            var results = [];
	            eachfn(arr, function (x, callback) {
	                iterator(x.value, function (err, v) {
	                    results[x.index] = v;
	                    callback(err);
	                });
	            }, function (err) {
	                callback(err, results);
	            });
	        }
	    };
	    async.map = doParallel(_asyncMap);
	    async.mapSeries = doSeries(_asyncMap);
	    async.mapLimit = function (arr, limit, iterator, callback) {
	        return _mapLimit(limit)(arr, iterator, callback);
	    };
	
	    var _mapLimit = function(limit) {
	        return doParallelLimit(limit, _asyncMap);
	    };
	
	    // reduce only has a series version, as doing reduce in parallel won't
	    // work in many situations.
	    async.reduce = function (arr, memo, iterator, callback) {
	        async.eachSeries(arr, function (x, callback) {
	            iterator(memo, x, function (err, v) {
	                memo = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, memo);
	        });
	    };
	    // inject alias
	    async.inject = async.reduce;
	    // foldl alias
	    async.foldl = async.reduce;
	
	    async.reduceRight = function (arr, memo, iterator, callback) {
	        var reversed = _map(arr, function (x) {
	            return x;
	        }).reverse();
	        async.reduce(reversed, memo, iterator, callback);
	    };
	    // foldr alias
	    async.foldr = async.reduceRight;
	
	    var _filter = function (eachfn, arr, iterator, callback) {
	        var results = [];
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        eachfn(arr, function (x, callback) {
	            iterator(x.value, function (v) {
	                if (v) {
	                    results.push(x);
	                }
	                callback();
	            });
	        }, function (err) {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    };
	    async.filter = doParallel(_filter);
	    async.filterSeries = doSeries(_filter);
	    // select alias
	    async.select = async.filter;
	    async.selectSeries = async.filterSeries;
	
	    var _reject = function (eachfn, arr, iterator, callback) {
	        var results = [];
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        eachfn(arr, function (x, callback) {
	            iterator(x.value, function (v) {
	                if (!v) {
	                    results.push(x);
	                }
	                callback();
	            });
	        }, function (err) {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    };
	    async.reject = doParallel(_reject);
	    async.rejectSeries = doSeries(_reject);
	
	    var _detect = function (eachfn, arr, iterator, main_callback) {
	        eachfn(arr, function (x, callback) {
	            iterator(x, function (result) {
	                if (result) {
	                    main_callback(x);
	                    main_callback = function () {};
	                }
	                else {
	                    callback();
	                }
	            });
	        }, function (err) {
	            main_callback();
	        });
	    };
	    async.detect = doParallel(_detect);
	    async.detectSeries = doSeries(_detect);
	
	    async.some = function (arr, iterator, main_callback) {
	        async.each(arr, function (x, callback) {
	            iterator(x, function (v) {
	                if (v) {
	                    main_callback(true);
	                    main_callback = function () {};
	                }
	                callback();
	            });
	        }, function (err) {
	            main_callback(false);
	        });
	    };
	    // any alias
	    async.any = async.some;
	
	    async.every = function (arr, iterator, main_callback) {
	        async.each(arr, function (x, callback) {
	            iterator(x, function (v) {
	                if (!v) {
	                    main_callback(false);
	                    main_callback = function () {};
	                }
	                callback();
	            });
	        }, function (err) {
	            main_callback(true);
	        });
	    };
	    // all alias
	    async.all = async.every;
	
	    async.sortBy = function (arr, iterator, callback) {
	        async.map(arr, function (x, callback) {
	            iterator(x, function (err, criteria) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    callback(null, {value: x, criteria: criteria});
	                }
	            });
	        }, function (err, results) {
	            if (err) {
	                return callback(err);
	            }
	            else {
	                var fn = function (left, right) {
	                    var a = left.criteria, b = right.criteria;
	                    return a < b ? -1 : a > b ? 1 : 0;
	                };
	                callback(null, _map(results.sort(fn), function (x) {
	                    return x.value;
	                }));
	            }
	        });
	    };
	
	    async.auto = function (tasks, callback) {
	        callback = callback || function () {};
	        var keys = _keys(tasks);
	        var remainingTasks = keys.length
	        if (!remainingTasks) {
	            return callback();
	        }
	
	        var results = {};
	
	        var listeners = [];
	        var addListener = function (fn) {
	            listeners.unshift(fn);
	        };
	        var removeListener = function (fn) {
	            for (var i = 0; i < listeners.length; i += 1) {
	                if (listeners[i] === fn) {
	                    listeners.splice(i, 1);
	                    return;
	                }
	            }
	        };
	        var taskComplete = function () {
	            remainingTasks--
	            _each(listeners.slice(0), function (fn) {
	                fn();
	            });
	        };
	
	        addListener(function () {
	            if (!remainingTasks) {
	                var theCallback = callback;
	                // prevent final callback from calling itself if it errors
	                callback = function () {};
	
	                theCallback(null, results);
	            }
	        });
	
	        _each(keys, function (k) {
	            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
	            var taskCallback = function (err) {
	                var args = Array.prototype.slice.call(arguments, 1);
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                if (err) {
	                    var safeResults = {};
	                    _each(_keys(results), function(rkey) {
	                        safeResults[rkey] = results[rkey];
	                    });
	                    safeResults[k] = args;
	                    callback(err, safeResults);
	                    // stop subsequent errors hitting callback multiple times
	                    callback = function () {};
	                }
	                else {
	                    results[k] = args;
	                    async.setImmediate(taskComplete);
	                }
	            };
	            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
	            var ready = function () {
	                return _reduce(requires, function (a, x) {
	                    return (a && results.hasOwnProperty(x));
	                }, true) && !results.hasOwnProperty(k);
	            };
	            if (ready()) {
	                task[task.length - 1](taskCallback, results);
	            }
	            else {
	                var listener = function () {
	                    if (ready()) {
	                        removeListener(listener);
	                        task[task.length - 1](taskCallback, results);
	                    }
	                };
	                addListener(listener);
	            }
	        });
	    };
	
	    async.retry = function(times, task, callback) {
	        var DEFAULT_TIMES = 5;
	        var attempts = [];
	        // Use defaults if times not passed
	        if (typeof times === 'function') {
	            callback = task;
	            task = times;
	            times = DEFAULT_TIMES;
	        }
	        // Make sure times is a number
	        times = parseInt(times, 10) || DEFAULT_TIMES;
	        var wrappedTask = function(wrappedCallback, wrappedResults) {
	            var retryAttempt = function(task, finalAttempt) {
	                return function(seriesCallback) {
	                    task(function(err, result){
	                        seriesCallback(!err || finalAttempt, {err: err, result: result});
	                    }, wrappedResults);
	                };
	            };
	            while (times) {
	                attempts.push(retryAttempt(task, !(times-=1)));
	            }
	            async.series(attempts, function(done, data){
	                data = data[data.length - 1];
	                (wrappedCallback || callback)(data.err, data.result);
	            });
	        }
	        // If a callback is passed, run this as a controll flow
	        return callback ? wrappedTask() : wrappedTask
	    };
	
	    async.waterfall = function (tasks, callback) {
	        callback = callback || function () {};
	        if (!_isArray(tasks)) {
	          var err = new Error('First argument to waterfall must be an array of functions');
	          return callback(err);
	        }
	        if (!tasks.length) {
	            return callback();
	        }
	        var wrapIterator = function (iterator) {
	            return function (err) {
	                if (err) {
	                    callback.apply(null, arguments);
	                    callback = function () {};
	                }
	                else {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    var next = iterator.next();
	                    if (next) {
	                        args.push(wrapIterator(next));
	                    }
	                    else {
	                        args.push(callback);
	                    }
	                    async.setImmediate(function () {
	                        iterator.apply(null, args);
	                    });
	                }
	            };
	        };
	        wrapIterator(async.iterator(tasks))();
	    };
	
	    var _parallel = function(eachfn, tasks, callback) {
	        callback = callback || function () {};
	        if (_isArray(tasks)) {
	            eachfn.map(tasks, function (fn, callback) {
	                if (fn) {
	                    fn(function (err) {
	                        var args = Array.prototype.slice.call(arguments, 1);
	                        if (args.length <= 1) {
	                            args = args[0];
	                        }
	                        callback.call(null, err, args);
	                    });
	                }
	            }, callback);
	        }
	        else {
	            var results = {};
	            eachfn.each(_keys(tasks), function (k, callback) {
	                tasks[k](function (err) {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    if (args.length <= 1) {
	                        args = args[0];
	                    }
	                    results[k] = args;
	                    callback(err);
	                });
	            }, function (err) {
	                callback(err, results);
	            });
	        }
	    };
	
	    async.parallel = function (tasks, callback) {
	        _parallel({ map: async.map, each: async.each }, tasks, callback);
	    };
	
	    async.parallelLimit = function(tasks, limit, callback) {
	        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
	    };
	
	    async.series = function (tasks, callback) {
	        callback = callback || function () {};
	        if (_isArray(tasks)) {
	            async.mapSeries(tasks, function (fn, callback) {
	                if (fn) {
	                    fn(function (err) {
	                        var args = Array.prototype.slice.call(arguments, 1);
	                        if (args.length <= 1) {
	                            args = args[0];
	                        }
	                        callback.call(null, err, args);
	                    });
	                }
	            }, callback);
	        }
	        else {
	            var results = {};
	            async.eachSeries(_keys(tasks), function (k, callback) {
	                tasks[k](function (err) {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    if (args.length <= 1) {
	                        args = args[0];
	                    }
	                    results[k] = args;
	                    callback(err);
	                });
	            }, function (err) {
	                callback(err, results);
	            });
	        }
	    };
	
	    async.iterator = function (tasks) {
	        var makeCallback = function (index) {
	            var fn = function () {
	                if (tasks.length) {
	                    tasks[index].apply(null, arguments);
	                }
	                return fn.next();
	            };
	            fn.next = function () {
	                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
	            };
	            return fn;
	        };
	        return makeCallback(0);
	    };
	
	    async.apply = function (fn) {
	        var args = Array.prototype.slice.call(arguments, 1);
	        return function () {
	            return fn.apply(
	                null, args.concat(Array.prototype.slice.call(arguments))
	            );
	        };
	    };
	
	    var _concat = function (eachfn, arr, fn, callback) {
	        var r = [];
	        eachfn(arr, function (x, cb) {
	            fn(x, function (err, y) {
	                r = r.concat(y || []);
	                cb(err);
	            });
	        }, function (err) {
	            callback(err, r);
	        });
	    };
	    async.concat = doParallel(_concat);
	    async.concatSeries = doSeries(_concat);
	
	    async.whilst = function (test, iterator, callback) {
	        if (test()) {
	            iterator(function (err) {
	                if (err) {
	                    return callback(err);
	                }
	                async.whilst(test, iterator, callback);
	            });
	        }
	        else {
	            callback();
	        }
	    };
	
	    async.doWhilst = function (iterator, test, callback) {
	        iterator(function (err) {
	            if (err) {
	                return callback(err);
	            }
	            var args = Array.prototype.slice.call(arguments, 1);
	            if (test.apply(null, args)) {
	                async.doWhilst(iterator, test, callback);
	            }
	            else {
	                callback();
	            }
	        });
	    };
	
	    async.until = function (test, iterator, callback) {
	        if (!test()) {
	            iterator(function (err) {
	                if (err) {
	                    return callback(err);
	                }
	                async.until(test, iterator, callback);
	            });
	        }
	        else {
	            callback();
	        }
	    };
	
	    async.doUntil = function (iterator, test, callback) {
	        iterator(function (err) {
	            if (err) {
	                return callback(err);
	            }
	            var args = Array.prototype.slice.call(arguments, 1);
	            if (!test.apply(null, args)) {
	                async.doUntil(iterator, test, callback);
	            }
	            else {
	                callback();
	            }
	        });
	    };
	
	    async.queue = function (worker, concurrency) {
	        if (concurrency === undefined) {
	            concurrency = 1;
	        }
	        function _insert(q, data, pos, callback) {
	          if (!q.started){
	            q.started = true;
	          }
	          if (!_isArray(data)) {
	              data = [data];
	          }
	          if(data.length == 0) {
	             // call drain immediately if there are no tasks
	             return async.setImmediate(function() {
	                 if (q.drain) {
	                     q.drain();
	                 }
	             });
	          }
	          _each(data, function(task) {
	              var item = {
	                  data: task,
	                  callback: typeof callback === 'function' ? callback : null
	              };
	
	              if (pos) {
	                q.tasks.unshift(item);
	              } else {
	                q.tasks.push(item);
	              }
	
	              if (q.saturated && q.tasks.length === q.concurrency) {
	                  q.saturated();
	              }
	              async.setImmediate(q.process);
	          });
	        }
	
	        var workers = 0;
	        var q = {
	            tasks: [],
	            concurrency: concurrency,
	            saturated: null,
	            empty: null,
	            drain: null,
	            started: false,
	            paused: false,
	            push: function (data, callback) {
	              _insert(q, data, false, callback);
	            },
	            kill: function () {
	              q.drain = null;
	              q.tasks = [];
	            },
	            unshift: function (data, callback) {
	              _insert(q, data, true, callback);
	            },
	            process: function () {
	                if (!q.paused && workers < q.concurrency && q.tasks.length) {
	                    var task = q.tasks.shift();
	                    if (q.empty && q.tasks.length === 0) {
	                        q.empty();
	                    }
	                    workers += 1;
	                    var next = function () {
	                        workers -= 1;
	                        if (task.callback) {
	                            task.callback.apply(task, arguments);
	                        }
	                        if (q.drain && q.tasks.length + workers === 0) {
	                            q.drain();
	                        }
	                        q.process();
	                    };
	                    var cb = only_once(next);
	                    worker(task.data, cb);
	                }
	            },
	            length: function () {
	                return q.tasks.length;
	            },
	            running: function () {
	                return workers;
	            },
	            idle: function() {
	                return q.tasks.length + workers === 0;
	            },
	            pause: function () {
	                if (q.paused === true) { return; }
	                q.paused = true;
	                q.process();
	            },
	            resume: function () {
	                if (q.paused === false) { return; }
	                q.paused = false;
	                q.process();
	            }
	        };
	        return q;
	    };
	    
	    async.priorityQueue = function (worker, concurrency) {
	        
	        function _compareTasks(a, b){
	          return a.priority - b.priority;
	        };
	        
	        function _binarySearch(sequence, item, compare) {
	          var beg = -1,
	              end = sequence.length - 1;
	          while (beg < end) {
	            var mid = beg + ((end - beg + 1) >>> 1);
	            if (compare(item, sequence[mid]) >= 0) {
	              beg = mid;
	            } else {
	              end = mid - 1;
	            }
	          }
	          return beg;
	        }
	        
	        function _insert(q, data, priority, callback) {
	          if (!q.started){
	            q.started = true;
	          }
	          if (!_isArray(data)) {
	              data = [data];
	          }
	          if(data.length == 0) {
	             // call drain immediately if there are no tasks
	             return async.setImmediate(function() {
	                 if (q.drain) {
	                     q.drain();
	                 }
	             });
	          }
	          _each(data, function(task) {
	              var item = {
	                  data: task,
	                  priority: priority,
	                  callback: typeof callback === 'function' ? callback : null
	              };
	              
	              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
	
	              if (q.saturated && q.tasks.length === q.concurrency) {
	                  q.saturated();
	              }
	              async.setImmediate(q.process);
	          });
	        }
	        
	        // Start with a normal queue
	        var q = async.queue(worker, concurrency);
	        
	        // Override push to accept second parameter representing priority
	        q.push = function (data, priority, callback) {
	          _insert(q, data, priority, callback);
	        };
	        
	        // Remove unshift function
	        delete q.unshift;
	
	        return q;
	    };
	
	    async.cargo = function (worker, payload) {
	        var working     = false,
	            tasks       = [];
	
	        var cargo = {
	            tasks: tasks,
	            payload: payload,
	            saturated: null,
	            empty: null,
	            drain: null,
	            drained: true,
	            push: function (data, callback) {
	                if (!_isArray(data)) {
	                    data = [data];
	                }
	                _each(data, function(task) {
	                    tasks.push({
	                        data: task,
	                        callback: typeof callback === 'function' ? callback : null
	                    });
	                    cargo.drained = false;
	                    if (cargo.saturated && tasks.length === payload) {
	                        cargo.saturated();
	                    }
	                });
	                async.setImmediate(cargo.process);
	            },
	            process: function process() {
	                if (working) return;
	                if (tasks.length === 0) {
	                    if(cargo.drain && !cargo.drained) cargo.drain();
	                    cargo.drained = true;
	                    return;
	                }
	
	                var ts = typeof payload === 'number'
	                            ? tasks.splice(0, payload)
	                            : tasks.splice(0, tasks.length);
	
	                var ds = _map(ts, function (task) {
	                    return task.data;
	                });
	
	                if(cargo.empty) cargo.empty();
	                working = true;
	                worker(ds, function () {
	                    working = false;
	
	                    var args = arguments;
	                    _each(ts, function (data) {
	                        if (data.callback) {
	                            data.callback.apply(null, args);
	                        }
	                    });
	
	                    process();
	                });
	            },
	            length: function () {
	                return tasks.length;
	            },
	            running: function () {
	                return working;
	            }
	        };
	        return cargo;
	    };
	
	    var _console_fn = function (name) {
	        return function (fn) {
	            var args = Array.prototype.slice.call(arguments, 1);
	            fn.apply(null, args.concat([function (err) {
	                var args = Array.prototype.slice.call(arguments, 1);
	                if (typeof console !== 'undefined') {
	                    if (err) {
	                        if (console.error) {
	                            console.error(err);
	                        }
	                    }
	                    else if (console[name]) {
	                        _each(args, function (x) {
	                            console[name](x);
	                        });
	                    }
	                }
	            }]));
	        };
	    };
	    async.log = _console_fn('log');
	    async.dir = _console_fn('dir');
	    /*async.info = _console_fn('info');
	    async.warn = _console_fn('warn');
	    async.error = _console_fn('error');*/
	
	    async.memoize = function (fn, hasher) {
	        var memo = {};
	        var queues = {};
	        hasher = hasher || function (x) {
	            return x;
	        };
	        var memoized = function () {
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            var key = hasher.apply(null, args);
	            if (key in memo) {
	                async.nextTick(function () {
	                    callback.apply(null, memo[key]);
	                });
	            }
	            else if (key in queues) {
	                queues[key].push(callback);
	            }
	            else {
	                queues[key] = [callback];
	                fn.apply(null, args.concat([function () {
	                    memo[key] = arguments;
	                    var q = queues[key];
	                    delete queues[key];
	                    for (var i = 0, l = q.length; i < l; i++) {
	                      q[i].apply(null, arguments);
	                    }
	                }]));
	            }
	        };
	        memoized.memo = memo;
	        memoized.unmemoized = fn;
	        return memoized;
	    };
	
	    async.unmemoize = function (fn) {
	      return function () {
	        return (fn.unmemoized || fn).apply(null, arguments);
	      };
	    };
	
	    async.times = function (count, iterator, callback) {
	        var counter = [];
	        for (var i = 0; i < count; i++) {
	            counter.push(i);
	        }
	        return async.map(counter, iterator, callback);
	    };
	
	    async.timesSeries = function (count, iterator, callback) {
	        var counter = [];
	        for (var i = 0; i < count; i++) {
	            counter.push(i);
	        }
	        return async.mapSeries(counter, iterator, callback);
	    };
	
	    async.seq = function (/* functions... */) {
	        var fns = arguments;
	        return function () {
	            var that = this;
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            async.reduce(fns, args, function (newargs, fn, cb) {
	                fn.apply(that, newargs.concat([function () {
	                    var err = arguments[0];
	                    var nextargs = Array.prototype.slice.call(arguments, 1);
	                    cb(err, nextargs);
	                }]))
	            },
	            function (err, results) {
	                callback.apply(that, [err].concat(results));
	            });
	        };
	    };
	
	    async.compose = function (/* functions... */) {
	      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
	    };
	
	    var _applyEach = function (eachfn, fns /*args...*/) {
	        var go = function () {
	            var that = this;
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            return eachfn(fns, function (fn, cb) {
	                fn.apply(that, args.concat([cb]));
	            },
	            callback);
	        };
	        if (arguments.length > 2) {
	            var args = Array.prototype.slice.call(arguments, 2);
	            return go.apply(this, args);
	        }
	        else {
	            return go;
	        }
	    };
	    async.applyEach = doParallel(_applyEach);
	    async.applyEachSeries = doSeries(_applyEach);
	
	    async.forever = function (fn, callback) {
	        function next(err) {
	            if (err) {
	                if (callback) {
	                    return callback(err);
	                }
	                throw err;
	            }
	            fn(next);
	        }
	        next();
	    };
	
	    // Node.js
	    if (typeof module !== 'undefined' && module.exports) {
	        module.exports = async;
	    }
	    // AMD / RequireJS
	    else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return async;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    // included directly via <script> tag
	    else {
	        root.async = async;
	    }
	
	}());
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43), __webpack_require__(/*! ./~/node-libs-browser/~/timers-browserify/main.js */ 81).setImmediate))

/***/ },
/* 216 */
/*!****************************************!*\
  !*** ./~/mongoose/lib/queryhelpers.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies
	 */
	
	var utils = __webpack_require__(/*! ./utils */ 42)
	
	/*!
	 * Prepare a set of path options for query population.
	 *
	 * @param {Query} query
	 * @param {Object} options
	 * @return {Array}
	 */
	
	exports.preparePopulationOptions = function preparePopulationOptions (query, options) {
	  var pop = utils.object.vals(query.options.populate);
	
	  // lean options should trickle through all queries
	  if (options.lean) pop.forEach(makeLean);
	
	  return pop;
	}
	
	/*!
	 * Prepare a set of path options for query population. This is the MongooseQuery
	 * version
	 *
	 * @param {Query} query
	 * @param {Object} options
	 * @return {Array}
	 */
	
	exports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ (query, options) {
	  var pop = utils.object.vals(query._mongooseOptions.populate);
	
	  // lean options should trickle through all queries
	  if (options.lean) pop.forEach(makeLean);
	
	  return pop;
	}
	
	/*!
	 * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,
	 * it returns an instance of the given model.
	 *
	 * @param {Model}  model
	 * @param {Object} doc
	 * @param {Object} fields
	 *
	 * @return {Model}
	 */
	exports.createModel = function createModel(model, doc, fields) {
	  var discriminatorMapping = model.schema
	    ? model.schema.discriminatorMapping
	    : null;
	
	  var key = discriminatorMapping && discriminatorMapping.isRoot
	    ? discriminatorMapping.key
	    : null;
	
	  if (key && doc[key] && model.discriminators && model.discriminators[doc[key]]) {
	    return new model.discriminators[doc[key]](undefined, fields, true);
	  }
	
	  return new model(undefined, fields, true);
	}
	
	/*!
	 * Set each path query option to lean
	 *
	 * @param {Object} option
	 */
	
	function makeLean (option) {
	  option.options || (option.options = {});
	  option.options.lean = true;
	}
	


/***/ },
/* 217 */
/*!***************************************!*\
  !*** ./~/mongoose/lib/querystream.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {
	/*!
	 * Module dependencies.
	 */
	
	var Stream = __webpack_require__(/*! stream */ 121).Stream
	var utils = __webpack_require__(/*! ./utils */ 42)
	var helpers = __webpack_require__(/*! ./queryhelpers */ 216)
	var K = function(k){ return k }
	
	/**
	 * Provides a Node.js 0.8 style [ReadStream](http://nodejs.org/docs/v0.8.21/api/stream.html#stream_readable_stream) interface for Queries.
	 *
	 *     var stream = Model.find().stream();
	 *
	 *     stream.on('data', function (doc) {
	 *       // do something with the mongoose document
	 *     }).on('error', function (err) {
	 *       // handle the error
	 *     }).on('close', function () {
	 *       // the stream is closed
	 *     });
	 *
	 *
	 * The stream interface allows us to simply "plug-in" to other _Node.js 0.8_ style write streams.
	 *
	 *     Model.where('created').gte(twoWeeksAgo).stream().pipe(writeStream);
	 *
	 * ####Valid options
	 *
	 *   - `transform`: optional function which accepts a mongoose document. The return value of the function will be emitted on `data`.
	 *
	 * ####Example
	 *
	 *     // JSON.stringify all documents before emitting
	 *     var stream = Thing.find().stream({ transform: JSON.stringify });
	 *     stream.pipe(writeStream);
	 *
	 * _NOTE: plugging into an HTTP response will *not* work out of the box. Those streams expect only strings or buffers to be emitted, so first formatting our documents as strings/buffers is necessary._
	 *
	 * _NOTE: these streams are Node.js 0.8 style read streams which differ from Node.js 0.10 style. Node.js 0.10 streams are not well tested yet and are not guaranteed to work._
	 *
	 * @param {Query} query
	 * @param {Object} [options]
	 * @inherits NodeJS Stream http://nodejs.org/docs/v0.8.21/api/stream.html#stream_readable_stream
	 * @event `data`: emits a single Mongoose document
	 * @event `error`: emits when an error occurs during streaming. This will emit _before_ the `close` event.
	 * @event `close`: emits when the stream reaches the end of the cursor or an error occurs, or the stream is manually `destroy`ed. After this event, no more events are emitted.
	 * @api public
	 */
	
	function QueryStream (query, options) {
	  Stream.call(this);
	
	  this.query = query;
	  this.readable = true;
	  this.paused = false;
	  this._cursor = null;
	  this._destroyed = null;
	  this._fields = null;
	  this._buffer = null;
	  this._inline = T_INIT;
	  this._running = false;
	  this._transform = options && 'function' == typeof options.transform
	    ? options.transform
	    : K;
	
	  // give time to hook up events
	  var self = this;
	  process.nextTick(function () {
	    self._init();
	  });
	}
	
	/*!
	 * Inherit from Stream
	 */
	
	QueryStream.prototype.__proto__ = Stream.prototype;
	
	/**
	 * Flag stating whether or not this stream is readable.
	 *
	 * @property readable
	 * @api public
	 */
	
	QueryStream.prototype.readable;
	
	/**
	 * Flag stating whether or not this stream is paused.
	 *
	 * @property paused
	 * @api public
	 */
	
	QueryStream.prototype.paused;
	
	// trampoline flags
	var T_INIT = 0;
	var T_IDLE = 1;
	var T_CONT = 2;
	
	/**
	 * Initializes the query.
	 *
	 * @api private
	 */
	
	QueryStream.prototype._init = function () {
	  if (this._destroyed) return;
	
	  var query = this.query
	    , model = query.model
	    , options = query._optionsForExec(model)
	    , self = this
	
	  try {
	    query.cast(model);
	  } catch (err) {
	    return self.destroy(err);
	  }
	
	  self._fields = utils.clone(query._fields);
	  options.fields = query._castFields(self._fields);
	
	  model.collection.find(query._conditions, options, function (err, cursor) {
	    if (err) return self.destroy(err);
	    self._cursor = cursor;
	    self._next();
	  });
	}
	
	/**
	 * Trampoline for pulling the next doc from cursor.
	 *
	 * @see QueryStream#__next #querystream_QueryStream-__next
	 * @api private
	 */
	
	QueryStream.prototype._next = function _next () {
	  if (this.paused || this._destroyed) {
	    return this._running = false;
	  }
	
	  this._running = true;
	
	  if (this._buffer && this._buffer.length) {
	    var arg;
	    while (!this.paused && !this._destroyed && (arg = this._buffer.shift())) {
	      this._onNextObject.apply(this, arg);
	    }
	  }
	
	  // avoid stack overflows with large result sets.
	  // trampoline instead of recursion.
	  while (this.__next()) {}
	}
	
	/**
	 * Pulls the next doc from the cursor.
	 *
	 * @see QueryStream#_next #querystream_QueryStream-_next
	 * @api private
	 */
	
	QueryStream.prototype.__next = function () {
	  if (this.paused || this._destroyed)
	    return this._running = false;
	
	  var self = this;
	  self._inline = T_INIT;
	
	  self._cursor.nextObject(function cursorcb (err, doc) {
	    self._onNextObject(err, doc);
	  });
	
	  // if onNextObject() was already called in this tick
	  // return ourselves to the trampoline.
	  if (T_CONT === this._inline) {
	    return true;
	  } else {
	    // onNextObject() hasn't fired yet. tell onNextObject
	    // that its ok to call _next b/c we are not within
	    // the trampoline anymore.
	    this._inline = T_IDLE;
	  }
	}
	
	/**
	 * Transforms raw `doc`s returned from the cursor into a model instance.
	 *
	 * @param {Error|null} err
	 * @param {Object} doc
	 * @api private
	 */
	
	QueryStream.prototype._onNextObject = function _onNextObject (err, doc) {
	  if (this._destroyed) return;
	
	  if (this.paused) {
	    this._buffer || (this._buffer = []);
	    this._buffer.push([err, doc]);
	    return this._running = false;
	  }
	
	  if (err) return this.destroy(err);
	
	  // when doc is null we hit the end of the cursor
	  if (!doc) {
	    this.emit('end');
	    return this.destroy();
	  }
	
	  var opts = this.query._mongooseOptions;
	
	  if (!opts.populate) {
	    return true === opts.lean ?
	      emit(this, doc) :
	      createAndEmit(this, null, doc);
	  }
	
	  var self = this;
	  var pop = helpers.preparePopulationOptionsMQ(self.query, self.query._mongooseOptions);
	
	  self.query.model.populate(doc, pop, function (err, doc) {
	    if (err) return self.destroy(err);
	    return true === opts.lean ?
	      emit(self, doc) :
	      createAndEmit(self, pop, doc);
	  });
	}
	
	function createAndEmit (self, populatedIds, doc) {
	  var instance = helpers.createModel(self.query.model, doc, self._fields);
	  var opts = populatedIds ?
	    { populated: populatedIds } :
	    undefined;
	
	  instance.init(doc, opts, function (err) {
	    if (err) return self.destroy(err);
	    emit(self, instance);
	  });
	}
	
	/*!
	 * Emit a data event and manage the trampoline state
	 */
	
	function emit (self, doc) {
	  self.emit('data', self._transform(doc));
	
	  // trampoline management
	  if (T_IDLE === self._inline) {
	    // no longer in trampoline. restart it.
	    self._next();
	  } else {
	    // in a trampoline. tell __next that its
	    // ok to continue jumping.
	    self._inline = T_CONT;
	  }
	}
	
	/**
	 * Pauses this stream.
	 *
	 * @api public
	 */
	
	QueryStream.prototype.pause = function () {
	  this.paused = true;
	}
	
	/**
	 * Resumes this stream.
	 *
	 * @api public
	 */
	
	QueryStream.prototype.resume = function () {
	  this.paused = false;
	
	  if (!this._cursor) {
	    // cannot start if not initialized
	    return;
	  }
	
	  // are we within the trampoline?
	  if (T_INIT === this._inline) {
	    return;
	  }
	
	  if (!this._running) {
	    // outside QueryStream control, need manual restart
	    return this._next();
	  }
	}
	
	/**
	 * Destroys the stream, closing the underlying cursor. No more events will be emitted.
	 *
	 * @param {Error} [err]
	 * @api public
	 */
	
	QueryStream.prototype.destroy = function (err) {
	  if (this._destroyed) return;
	  this._destroyed = true;
	  this._running = false;
	  this.readable = false;
	
	  if (this._cursor) {
	    this._cursor.close();
	  }
	
	  if (err) {
	    this.emit('error', err);
	  }
	
	  this.emit('close');
	}
	
	/**
	 * Pipes this query stream into another stream. This method is inherited from NodeJS Streams.
	 *
	 * ####Example:
	 *
	 *     query.stream().pipe(writeStream [, options])
	 *
	 * @method pipe
	 * @memberOf QueryStream
	 * @see NodeJS http://nodejs.org/api/stream.html
	 * @api public
	 */
	
	/*!
	 * Module exports
	 */
	
	module.exports = exports = QueryStream;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ },
/* 218 */
/*!*************************************!*\
  !*** ./~/mongoose/lib/aggregate.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies
	 */
	
	var Promise = __webpack_require__(/*! ./promise */ 183)
	  , util = __webpack_require__(/*! util */ 57)
	  , utils = __webpack_require__(/*! ./utils */ 42)
	  , Query = __webpack_require__(/*! ./query */ 200)
	  , read = Query.prototype.read
	
	/**
	 * Aggregate constructor used for building aggregation pipelines.
	 *
	 * ####Example:
	 *
	 *     new Aggregate();
	 *     new Aggregate({ $project: { a: 1, b: 1 } });
	 *     new Aggregate({ $project: { a: 1, b: 1 } }, { $skip: 5 });
	 *     new Aggregate([{ $project: { a: 1, b: 1 } }, { $skip: 5 }]);
	 *
	 * Returned when calling Model.aggregate().
	 *
	 * ####Example:
	 *
	 *     Model
	 *     .aggregate({ $match: { age: { $gte: 21 }}})
	 *     .unwind('tags')
	 *     .exec(callback)
	 *
	 * ####Note:
	 *
	 * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).
	 * - Requires MongoDB >= 2.1
	 *
	 * @see MongoDB http://docs.mongodb.org/manual/applications/aggregation/
	 * @see driver http://mongodb.github.com/node-mongodb-native/api-generated/collection.html#aggregate
	 * @param {Object|Array} [ops] aggregation operator(s) or operator array
	 * @api public
	 */
	
	function Aggregate () {
	  this._pipeline = [];
	  this._model = undefined;
	  this.options = undefined;
	
	  if (1 === arguments.length && util.isArray(arguments[0])) {
	    this.append.apply(this, arguments[0]);
	  } else {
	    this.append.apply(this, arguments);
	  }
	}
	
	/**
	 * Binds this aggregate to a model.
	 *
	 * @param {Model} model the model to which the aggregate is to be bound
	 * @return {Aggregate}
	 * @api private
	 */
	
	Aggregate.prototype.bind = function (model) {
	  this._model = model;
	  return this;
	}
	
	/**
	 * Appends new operators to this aggregate pipeline
	 *
	 * ####Examples:
	 *
	 *     aggregate.append({ $project: { field: 1 }}, { $limit: 2 });
	 *
	 *     // or pass an array
	 *     var pipeline = [{ $match: { daw: 'Logic Audio X' }} ];
	 *     aggregate.append(pipeline);
	 *
	 * @param {Object} ops operator(s) to append
	 * @return {Aggregate}
	 * @api public
	 */
	
	Aggregate.prototype.append = function () {
	  var args = utils.args(arguments)
	    , arg;
	
	  if (!args.every(isOperator)) {
	    throw new Error("Arguments must be aggregate pipeline operators");
	  }
	
	  this._pipeline = this._pipeline.concat(args);
	
	  return this;
	}
	
	/**
	 * Appends a new $project operator to this aggregate pipeline.
	 *
	 * Mongoose query [selection syntax](#query_Query-select) is also supported.
	 *
	 * ####Examples:
	 *
	 *     // include a, include b, exclude _id
	 *     aggregate.project("a b -_id");
	 *
	 *     // or you may use object notation, useful when
	 *     // you have keys already prefixed with a "-"
	 *     aggregate.project({a: 1, b: 1, _id: 0});
	 *
	 *     // reshaping documents
	 *     aggregate.project({
	 *         newField: '$b.nested'
	 *       , plusTen: { $add: ['$val', 10]}
	 *       , sub: {
	 *            name: '$a'
	 *         }
	 *     })
	 *
	 *     // etc
	 *     aggregate.project({ salary_k: { $divide: [ "$salary", 1000 ] } });
	 *
	 * @param {Object|String} arg field specification
	 * @see projection http://docs.mongodb.org/manual/reference/aggregation/project/
	 * @return {Aggregate}
	 * @api public
	 */
	
	Aggregate.prototype.project = function (arg) {
	  var fields = {};
	
	  if ('object' === typeof arg && !util.isArray(arg)) {
	    Object.keys(arg).forEach(function (field) {
	      fields[field] = arg[field];
	    });
	  } else if (1 === arguments.length && 'string' === typeof arg) {
	    arg.split(/\s+/).forEach(function (field) {
	      if (!field) return;
	      var include = '-' == field[0] ? 0 : 1;
	      if (include === 0) field = field.substring(1);
	      fields[field] = include;
	    });
	  } else {
	    throw new Error("Invalid project() argument. Must be string or object");
	  }
	
	  return this.append({ $project: fields });
	}
	
	/**
	 * Appends a new custom $group operator to this aggregate pipeline.
	 *
	 * ####Examples:
	 *
	 *     aggregate.group({ _id: "$department" });
	 *
	 * @see $group http://docs.mongodb.org/manual/reference/aggregation/group/
	 * @method group
	 * @memberOf Aggregate
	 * @param {Object} arg $group operator contents
	 * @return {Aggregate}
	 * @api public
	 */
	
	/**
	 * Appends a new custom $match operator to this aggregate pipeline.
	 *
	 * ####Examples:
	 *
	 *     aggregate.match({ department: { $in: [ "sales", "engineering" } } });
	 *
	 * @see $match http://docs.mongodb.org/manual/reference/aggregation/match/
	 * @method match
	 * @memberOf Aggregate
	 * @param {Object} arg $match operator contents
	 * @return {Aggregate}
	 * @api public
	 */
	
	/**
	 * Appends a new $skip operator to this aggregate pipeline.
	 *
	 * ####Examples:
	 *
	 *     aggregate.skip(10);
	 *
	 * @see $skip http://docs.mongodb.org/manual/reference/aggregation/skip/
	 * @method skip
	 * @memberOf Aggregate
	 * @param {Number} num number of records to skip before next stage
	 * @return {Aggregate}
	 * @api public
	 */
	
	/**
	 * Appends a new $limit operator to this aggregate pipeline.
	 *
	 * ####Examples:
	 *
	 *     aggregate.limit(10);
	 *
	 * @see $limit http://docs.mongodb.org/manual/reference/aggregation/limit/
	 * @method limit
	 * @memberOf Aggregate
	 * @param {Number} num maximum number of records to pass to the next stage
	 * @return {Aggregate}
	 * @api public
	 */
	
	/**
	 * Appends a new $geoNear operator to this aggregate pipeline.
	 *
	 * ####NOTE:
	 *
	 * **MUST** be used as the first operator in the pipeline.
	 *
	 * ####Examples:
	 *
	 *     aggregate.near({
	 *       near: [40.724, -73.997],
	 *       distanceField: "dist.calculated", // required
	 *       maxDistance: 0.008,
	 *       query: { type: "public" },
	 *       includeLocs: "dist.location",
	 *       uniqueDocs: true,
	 *       num: 5
	 *     });
	 *
	 * @see $geoNear http://docs.mongodb.org/manual/reference/aggregation/geoNear/
	 * @method near
	 * @memberOf Aggregate
	 * @param {Object} parameters
	 * @return {Aggregate}
	 * @api public
	 */
	
	Aggregate.prototype.near = function (arg) {
	  var op = {};
	  op.$geoNear = arg;
	  return this.append(op);
	};
	
	/*!
	 * define methods
	 */
	
	'group match skip limit out'.split(' ').forEach(function ($operator) {
	  Aggregate.prototype[$operator] = function (arg) {
	    var op = {};
	    op['$' + $operator] = arg;
	    return this.append(op);
	  };
	});
	
	/**
	 * Appends new custom $unwind operator(s) to this aggregate pipeline.
	 *
	 * ####Examples:
	 *
	 *     aggregate.unwind("tags");
	 *     aggregate.unwind("a", "b", "c");
	 *
	 * @see $unwind http://docs.mongodb.org/manual/reference/aggregation/unwind/
	 * @param {String} fields the field(s) to unwind
	 * @return {Aggregate}
	 * @api public
	 */
	
	Aggregate.prototype.unwind = function () {
	  var args = utils.args(arguments);
	
	  return this.append.apply(this, args.map(function (arg) {
	    return { $unwind: '$' + arg };
	  }));
	}
	
	/**
	 * Appends a new $sort operator to this aggregate pipeline.
	 *
	 * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.
	 *
	 * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.
	 *
	 * ####Examples:
	 *
	 *     // these are equivalent
	 *     aggregate.sort({ field: 'asc', test: -1 });
	 *     aggregate.sort('field -test');
	 *
	 * @see $sort http://docs.mongodb.org/manual/reference/aggregation/sort/
	 * @param {Object|String} arg
	 * @return {Aggregate} this
	 * @api public
	 */
	
	Aggregate.prototype.sort = function (arg) {
	  // TODO refactor to reuse the query builder logic
	
	  var sort = {};
	
	  if ('Object' === arg.constructor.name) {
	    var desc = ['desc', 'descending', -1];
	    Object.keys(arg).forEach(function (field) {
	      sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;
	    });
	  } else if (1 === arguments.length && 'string' == typeof arg) {
	    arg.split(/\s+/).forEach(function (field) {
	      if (!field) return;
	      var ascend = '-' == field[0] ? -1 : 1;
	      if (ascend === -1) field = field.substring(1);
	      sort[field] = ascend;
	    });
	  } else {
	    throw new TypeError('Invalid sort() argument. Must be a string or object.');
	  }
	
	  return this.append({ $sort: sort });
	}
	
	/**
	 * Sets the readPreference option for the aggregation query.
	 *
	 * ####Example:
	 *
	 *     Model.aggregate(..).read('primaryPreferred').exec(callback)
	 *
	 * @param {String} pref one of the listed preference options or their aliases
	 * @param {Array} [tags] optional tags for this query
	 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
	 * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences
	 */
	
	Aggregate.prototype.read = function (pref) {
	  if (!this.options) this.options = {};
	  read.apply(this, arguments);
	  return this;
	};
	
	/**
	 * Sets the allowDiskUse option for the aggregation query (ignored for < 2.6.0)
	 *
	 * ####Example:
	 *
	 *     Model.aggregate(..).allowDiskUse(true).exec(callback)
	 *
	 * @param {Boolean} value Should tell server it can use hard drive to store data during aggregation.
	 * @param {Array} [tags] optional tags for this query
	 * @see mongodb http://docs.mongodb.org/manual/reference/command/aggregate/
	 */
	
	Aggregate.prototype.allowDiskUse = function(value) {
	  if (!this.options) this.options = {};
	  this.options.allowDiskUse = value;
	  return this;
	};
	
	/**
	 * Sets the cursor option option for the aggregation query (ignored for < 2.6.0).
	 * Note the different syntax below: .exec() returns a cursor object, and no callback
	 * is necessary.
	 *
	 * ####Example:
	 *
	 *     var cursor = Model.aggregate(..).cursor({ batchSize: 1000 }).exec();
	 *     cursor.each(function(error, doc) {
	 *       // use doc
	 *     });
	 *
	 * @param {Object} options set the cursor batch size
	 * @see mongodb http://mongodb.github.io/node-mongodb-native/2.0/api/AggregationCursor.html
	 */
	
	Aggregate.prototype.cursor = function(options) {
	  if (!this.options) this.options = {};
	  this.options.cursor = options;
	  return this;
	};
	
	/**
	 * Executes the aggregate pipeline on the currently bound Model.
	 *
	 * ####Example:
	 *
	 *     aggregate.exec(callback);
	 *
	 *     // Because a promise is returned, the `callback` is optional.
	 *     var promise = aggregate.exec();
	 *     promise.then(..);
	 *
	 * @see Promise #promise_Promise
	 * @param {Function} [callback]
	 * @return {Promise}
	 * @api public
	 */
	
	Aggregate.prototype.exec = function (callback) {
	  var promise = new Promise();
	
	  if (callback) {
	    promise.addBack(callback);
	  }
	
	  if (!this._pipeline.length) {
	    promise.error(new Error("Aggregate has empty pipeline"));
	    return promise;
	  }
	
	  if (!this._model) {
	    promise.error(new Error("Aggregate not bound to any Model"));
	    return promise;
	  }
	
	  prepareDiscriminatorPipeline(this);
	
	  if (this.options && this.options.cursor) {
	    return this._model.collection.aggregate(this._pipeline, this.options || {});
	  }
	
	  this._model
	    .collection
	    .aggregate(this._pipeline, this.options || {}, promise.resolve.bind(promise));
	
	  return promise;
	};
	
	/*!
	 * Helpers
	 */
	
	/**
	 * Checks whether an object is likely a pipeline operator
	 *
	 * @param {Object} obj object to check
	 * @return {Boolean}
	 * @api private
	 */
	
	function isOperator (obj) {
	  var k;
	
	  if ('object' !== typeof obj) {
	    return false;
	  }
	
	  k = Object.keys(obj);
	
	  return 1 === k.length && k.some(function (key) {
	    return '$' === key[0];
	  });
	}
	
	/*!
	 * Adds the appropriate `$match` pipeline step to the top of an aggregate's
	 * pipeline, should it's model is a non-root discriminator type. This is
	 * analogous to the `prepareDiscriminatorCriteria` function in `lib/query.js`.
	 *
	 * @param {Aggregate} aggregate Aggregate to prepare
	 */
	
	function prepareDiscriminatorPipeline (aggregate) {
	  var schema = aggregate._model.schema,
	      discriminatorMapping = schema && schema.discriminatorMapping;
	
	  if (discriminatorMapping && !discriminatorMapping.isRoot) {
	    var originalPipeline = aggregate._pipeline,
	        discriminatorKey = discriminatorMapping.key,
	        discriminatorValue = discriminatorMapping.value;
	
	    // If the first pipeline stage is a match and it doesn't specify a `__t`
	    // key, add the discriminator key to it. This allows for potential
	    // aggregation query optimizations not to be disturbed by this feature.
	    if (originalPipeline[0] && originalPipeline[0].$match &&
	        !originalPipeline[0].$match[discriminatorKey]) {
	      originalPipeline[0].$match[discriminatorKey] = discriminatorValue;
	      // `originalPipeline` is a ref, so there's no need for
	      // aggregate._pipeline = originalPipeline
	    } else {
	      var match = {};
	      match[discriminatorKey] = discriminatorValue;
	      aggregate._pipeline = [{ $match: match }].concat(originalPipeline);
	    }
	  }
	}
	
	
	/*!
	 * Exports
	 */
	
	module.exports = Aggregate;


/***/ },
/* 219 */
/*!*****************************************************!*\
  !*** ./~/mongoose/lib/drivers ^\.\/.*\/collection$ ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./browser/collection": 67,
		"./node-mongodb-native/collection": 163
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 219;


/***/ },
/* 220 */
/*!************************************!*\
  !*** ./~/mongoose/~/muri/index.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = exports = __webpack_require__(/*! ./lib */ 221);


/***/ },
/* 221 */
/*!****************************************!*\
  !*** ./~/mongoose/~/muri/lib/index.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {// muri
	
	/**
	 * MongoDB URI parser as described here:
	 * http://www.mongodb.org/display/DOCS/Connections
	 */
	
	/**
	 * Module dependencies
	 */
	
	var qs = __webpack_require__(/*! querystring */ 222);
	
	/**
	 * Defaults
	 */
	
	var DEFAULT_PORT = 27017;
	var DEFAULT_DB = 'test';
	var ADMIN_DB = 'admin';
	
	/**
	 * Muri
	 */
	
	module.exports = exports = function muri (str) {
	  if (!/^mongodb:\/\//.test(str)) {
	    throw new Error('Invalid mongodb uri. Must begin with "mongodb://"'
	                  + '\n  Received: ' + str);
	  }
	
	  var ret = {
	      hosts: []
	    , db: DEFAULT_DB
	    , options: {}
	  }
	
	  var match = /^mongodb:\/\/([^?]+)(\??.*)$/.exec(str);
	  if (!match || '/' == match[1]) {
	    throw new Error('Invalid mongodb uri. Missing hostname');
	  }
	
	  var uris = match[1];
	  var path = match[2];
	  var db;
	
	  uris.split(',').forEach(function (uri) {
	    var o = parse(uri);
	
	    if (o.host) {
	      ret.hosts.push({
	          host: o.host
	        , port: parseInt(o.port, 10)
	      })
	
	      if (!db && o.db) {
	        db = o.db;
	      }
	    } else if (o.ipc) {
	      ret.hosts.push({ ipc: o.ipc });
	    }
	
	    if (o.auth) {
	      ret.auth = {
	          user: o.auth.user
	        , pass: o.auth.pass
	      }
	    }
	  })
	
	  if (!ret.hosts.length) {
	    throw new Error('Invalid mongodb uri. Missing hostname');
	  }
	
	  var parts = path.split('?');
	
	  if (!db) {
	    if (parts[0]) {
	      db = parts[0].replace(/^\//, '');
	    } else {
	      // deal with ipc formats
	      db = /\/([^\.]+)$/.exec(match[1]);
	      if (db && db[1]) {
	        db = db[1];
	      }
	    }
	  }
	
	  if (db) {
	    ret.db = db;
	  } else if (ret.auth) {
	    ret.db = ADMIN_DB;
	  }
	
	  if (parts[1]) {
	    ret.options = options(parts[1]);
	  }
	
	  return ret;
	}
	
	/**
	 * Parse str into key/val pairs casting values appropriately.
	 */
	
	function options (str) {
	  var sep = /;/.test(str)
	    ? ';'
	    : '&';
	
	  var ret = qs.parse(str, sep);
	
	  Object.keys(ret).forEach(function (key) {
	    var val = ret[key];
	    if ('readPreferenceTags' == key) {
	      val = readPref(val);
	      if (val) {
	        ret[key] = Array.isArray(val)
	          ? val
	          : [val];
	      }
	    } else {
	      ret[key] = format(val);
	    }
	  });
	
	  return ret;
	}
	
	function format (val) {
	  var num;
	
	  if ('true' == val) {
	    return true;
	  } else if ('false' == val) {
	    return false;
	  } else {
	    num = parseInt(val, 10);
	    if (!isNaN(num)) {
	      return num;
	    }
	  }
	
	  return val;
	}
	
	function readPref (val) {
	  var ret;
	
	  if (Array.isArray(val)) {
	    ret = val.map(readPref).filter(Boolean);
	    return ret.length
	      ? ret
	      : undefined
	  }
	
	  var pair = val.split(',');
	  var hasKeys;
	  ret = {};
	
	  pair.forEach(function (kv) {
	    kv = (kv || '').trim();
	    if (!kv) return;
	    hasKeys = true;
	    var split = kv.split(':');
	    ret[split[0]] = format(split[1]);
	  });
	
	  return hasKeys && ret;
	}
	
	var ipcRgx = /\.sock/;
	
	function parse (uriString) {
	  // do not use require('url').parse b/c it can't handle # in username or pwd
	  // mongo uris are strange
	
	  var uri = uriString;
	  var ret = {};
	  var parts;
	  var auth;
	  var ipcs;
	
	  // skip protocol
	  uri = uri.replace(/^mongodb:\/\//, '');
	
	  // auth
	  if (/@/.test(uri)) {
	    parts = uri.split(/@/);
	    auth = parts[0];
	    uri = parts[1];
	
	    parts = auth.split(':');
	    ret.auth = {};
	    ret.auth.user = parts[0];
	    ret.auth.pass = parts[1];
	  }
	
	  // unix domain sockets
	  if (ipcRgx.test(uri)) {
	    ipcs = uri.split(ipcRgx);
	    ret.ipc = ipcs[0] + '.sock';
	
	    // included a database?
	    if (ipcs[1]) {
	      // strip leading / from database name
	      ipcs[1] = ipcs[1].replace(/^\//, '');
	
	      if (ipcs[1]) {
	        ret.db = ipcs[1];
	      }
	    }
	
	    return ret;
	  }
	
	  // database name
	  parts = uri.split('/');
	  if (parts[1]) ret.db = parts[1];
	
	  // host:port
	  parts = parts[0].split(':');
	  ret.host = parts[0];
	  ret.port = parts[1] || DEFAULT_PORT;
	
	  return ret;
	}
	
	/**
	 * Version
	 */
	
	module.exports.version = JSON.parse(
	  __webpack_require__(/*! fs */ 84).readFileSync(__dirname + '/../package.json', 'utf8')
	).version;
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 222 */
/*!********************************************************!*\
  !*** ./~/node-libs-browser/~/querystring-es3/index.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.decode = exports.parse = __webpack_require__(/*! ./decode */ 223);
	exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ 224);


/***/ },
/* 223 */
/*!*********************************************************!*\
  !*** ./~/node-libs-browser/~/querystring-es3/decode.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;
	
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	
	  return obj;
	};
	
	var isArray = Array.isArray || function (xs) {
	  return Object.prototype.toString.call(xs) === '[object Array]';
	};


/***/ },
/* 224 */
/*!*********************************************************!*\
  !*** ./~/node-libs-browser/~/querystring-es3/encode.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if (typeof obj === 'object') {
	    return map(objectKeys(obj), function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (isArray(obj[k])) {
	        return map(obj[k], function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};
	
	var isArray = Array.isArray || function (xs) {
	  return Object.prototype.toString.call(xs) === '[object Array]';
	};
	
	function map (xs, f) {
	  if (xs.map) return xs.map(f);
	  var res = [];
	  for (var i = 0; i < xs.length; i++) {
	    res.push(f(xs[i], i));
	  }
	  return res;
	}
	
	var objectKeys = Object.keys || function (obj) {
	  var res = [];
	  for (var key in obj) {
	    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
	  }
	  return res;
	};


/***/ },
/* 225 */
/*!*************************************************************!*\
  !*** ./~/mongoose/lib/drivers/node-mongodb-native/index.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	exports.Binary = __webpack_require__(/*! ./binary */ 162);
	exports.ObjectId = __webpack_require__(/*! ./objectid */ 226);
	exports.ReadPreference = __webpack_require__(/*! ./ReadPreference */ 71);


/***/ },
/* 226 */
/*!****************************************************************!*\
  !*** ./~/mongoose/lib/drivers/node-mongodb-native/objectid.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) ObjectId
	 * @constructor NodeMongoDbObjectId
	 * @see ObjectId
	 */
	
	var ObjectId = __webpack_require__(/*! mongodb */ 72).ObjectId;
	
	/*!
	 * ignore
	 */
	
	module.exports = exports = ObjectId;


/***/ },
/* 227 */
/*!*************************************!*\
  !*** ./~/mongoose/~/mpath/index.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = exports = __webpack_require__(/*! ./lib */ 228);


/***/ },
/* 228 */
/*!*****************************************!*\
  !*** ./~/mongoose/~/mpath/lib/index.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Returns the value of object `o` at the given `path`.
	 *
	 * ####Example:
	 *
	 *     var obj = {
	 *         comments: [
	 *             { title: 'exciting!', _doc: { title: 'great!' }}
	 *           , { title: 'number dos' }
	 *         ]
	 *     }
	 *
	 *     mpath.get('comments.0.title', o)         // 'exciting!'
	 *     mpath.get('comments.0.title', o, '_doc') // 'great!'
	 *     mpath.get('comments.title', o)           // ['exciting!', 'number dos']
	 *
	 *     // summary
	 *     mpath.get(path, o)
	 *     mpath.get(path, o, special)
	 *     mpath.get(path, o, map)
	 *     mpath.get(path, o, special, map)
	 *
	 * @param {String} path
	 * @param {Object} o
	 * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.
	 * @param {Function} [map] Optional function which receives each individual found value. The value returned from `map` is used in the original values place.
	 */
	
	exports.get = function (path, o, special, map) {
	  if ('function' == typeof special) {
	    map = special;
	    special = undefined;
	  }
	
	  map || (map = K);
	
	  var parts = 'string' == typeof path
	    ? path.split('.')
	    : path
	
	  if (!Array.isArray(parts)) {
	    throw new TypeError('Invalid `path`. Must be either string or array');
	  }
	
	  var obj = o
	    , part;
	
	  for (var i = 0; i < parts.length; ++i) {
	    part = parts[i];
	
	    if (Array.isArray(obj) && !/^\d+$/.test(part)) {
	      // reading a property from the array items
	      var paths = parts.slice(i);
	
	      return obj.map(function (item) {
	        return item
	          ? exports.get(paths, item, special, map)
	          : map(undefined);
	      });
	    }
	
	    obj = special && obj[special]
	      ? obj[special][part]
	      : obj[part];
	
	    if (!obj) return map(obj);
	  }
	
	  return map(obj);
	}
	
	/**
	 * Sets the `val` at the given `path` of object `o`.
	 *
	 * @param {String} path
	 * @param {Anything} val
	 * @param {Object} o
	 * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.
	 * @param {Function} [map] Optional function which is passed each individual value before setting it. The value returned from `map` is used in the original values place.
	
	 */
	
	exports.set = function (path, val, o, special, map, _copying) {
	  if ('function' == typeof special) {
	    map = special;
	    special = undefined;
	  }
	
	  map || (map = K);
	
	  var parts = 'string' == typeof path
	    ? path.split('.')
	    : path
	
	  if (!Array.isArray(parts)) {
	    throw new TypeError('Invalid `path`. Must be either string or array');
	  }
	
	  if (null == o) return;
	
	  // the existance of $ in a path tells us if the user desires
	  // the copying of an array instead of setting each value of
	  // the array to the one by one to matching positions of the
	  // current array.
	  var copy = _copying || /\$/.test(path)
	    , obj = o
	    , part
	
	  for (var i = 0, len = parts.length - 1; i < len; ++i) {
	    part = parts[i];
	
	    if ('$' == part) {
	      if (i == len - 1) {
	        break;
	      } else {
	        continue;
	      }
	    }
	
	    if (Array.isArray(obj) && !/^\d+$/.test(part)) {
	      var paths = parts.slice(i);
	      if (!copy && Array.isArray(val)) {
	        for (var j = 0; j < obj.length && j < val.length; ++j) {
	          // assignment of single values of array
	          exports.set(paths, val[j], obj[j], special, map, copy);
	        }
	      } else {
	        for (var j = 0; j < obj.length; ++j) {
	          // assignment of entire value
	          exports.set(paths, val, obj[j], special, map, copy);
	        }
	      }
	      return;
	    }
	
	    obj = special && obj[special]
	      ? obj[special][part]
	      : obj[part];
	
	    if (!obj) return;
	  }
	
	  // process the last property of the path
	
	  part = parts[len];
	
	  // use the special property if exists
	  if (special && obj[special]) {
	    obj = obj[special];
	  }
	
	  // set the value on the last branch
	  if (Array.isArray(obj) && !/^\d+$/.test(part)) {
	    if (!copy && Array.isArray(val)) {
	      for (var item, j = 0; j < obj.length && j < val.length; ++j) {
	        item = obj[j];
	        if (item) {
	          if (item[special]) item = item[special];
	          item[part] = map(val[j]);
	        }
	      }
	    } else {
	      for (var j = 0; j < obj.length; ++j) {
	        item = obj[j];
	        if (item) {
	          if (item[special]) item = item[special];
	          item[part] = map(val);
	        }
	      }
	    }
	  } else {
	    obj[part] = map(val);
	  }
	}
	
	/*!
	 * Returns the value passed to it.
	 */
	
	function K (v) {
	  return v;
	}


/***/ },
/* 229 */
/*!***************************************!*\
  !*** ./~/mongoose/lib/virtualtype.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * VirtualType constructor
	 *
	 * This is what mongoose uses to define virtual attributes via `Schema.prototype.virtual`.
	 *
	 * ####Example:
	 *
	 *     var fullname = schema.virtual('fullname');
	 *     fullname instanceof mongoose.VirtualType // true
	 *
	 * @parma {Object} options
	 * @api public
	 */
	
	function VirtualType (options, name) {
	  this.path = name;
	  this.getters = [];
	  this.setters = [];
	  this.options = options || {};
	}
	
	/**
	 * Defines a getter.
	 *
	 * ####Example:
	 *
	 *     var virtual = schema.virtual('fullname');
	 *     virtual.get(function () {
	 *       return this.name.first + ' ' + this.name.last;
	 *     });
	 *
	 * @param {Function} fn
	 * @return {VirtualType} this
	 * @api public
	 */
	
	VirtualType.prototype.get = function (fn) {
	  this.getters.push(fn);
	  return this;
	};
	
	/**
	 * Defines a setter.
	 *
	 * ####Example:
	 *
	 *     var virtual = schema.virtual('fullname');
	 *     virtual.set(function (v) {
	 *       var parts = v.split(' ');
	 *       this.name.first = parts[0];
	 *       this.name.last = parts[1];
	 *     });
	 *
	 * @param {Function} fn
	 * @return {VirtualType} this
	 * @api public
	 */
	
	VirtualType.prototype.set = function (fn) {
	  this.setters.push(fn);
	  return this;
	};
	
	/**
	 * Applies getters to `value` using optional `scope`.
	 *
	 * @param {Object} value
	 * @param {Object} scope
	 * @return {any} the value after applying all getters
	 * @api public
	 */
	
	VirtualType.prototype.applyGetters = function (value, scope) {
	  var v = value;
	  for (var l = this.getters.length - 1; l >= 0; l--) {
	    v = this.getters[l].call(scope, v, this);
	  }
	  return v;
	};
	
	/**
	 * Applies setters to `value` using optional `scope`.
	 *
	 * @param {Object} value
	 * @param {Object} scope
	 * @return {any} the value after applying all setters
	 * @api public
	 */
	
	VirtualType.prototype.applySetters = function (value, scope) {
	  var v = value;
	  for (var l = this.setters.length - 1; l >= 0; l--) {
	    v = this.setters[l].call(scope, v, this);
	  }
	  return v;
	};
	
	/*!
	 * exports
	 */
	
	module.exports = VirtualType;


/***/ },
/* 230 */
/*!**************************************!*\
  !*** ./~/mongoose/~/kareem/index.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	function Kareem() {
	  this._pres = {};
	  this._posts = {};
	}
	
	Kareem.prototype.execPre = function(name, context, callback) {
	  var pres = this._pres[name] || [];
	  var numPres = pres.length;
	  var numAsyncPres = pres.numAsync || 0;
	  var currentPre = 0;
	  var asyncPresLeft = numAsyncPres;
	  var done = false;
	
	  if (!numPres) {
	    return process.nextTick(function() {
	      callback(null);
	    });
	  }
	
	  var next = function() {
	    if (currentPre >= numPres) {
	      return;
	    }
	    var pre = pres[currentPre];
	
	    if (pre.isAsync) {
	      pre.fn.call(
	        context,
	        function(error) {
	          if (error) {
	            if (done) {
	              return;
	            }
	            done = true;
	            return callback(error);
	          }
	
	          ++currentPre;
	          next.apply(context, arguments);
	        },
	        function(error) {
	          if (error) {
	            if (done) {
	              return;
	            }
	            done = true;
	            return callback(error);
	          }
	
	          if (--numAsyncPres === 0) {
	            return callback(null);
	          }
	        });
	    } else if (pre.fn.length > 0) {
	      var args = [function(error) {
	        if (error) {
	          if (done) {
	            return;
	          }
	          done = true;
	          return callback(error);
	        }
	
	        if (++currentPre >= numPres) {
	          if (asyncPresLeft > 0) {
	            // Leave parallel hooks to run
	            return;
	          } else {
	            return callback(null);
	          }
	        }
	
	        next.apply(context, arguments);
	      }];
	      if (arguments.length >= 2) {
	        for (var i = 1; i < arguments.length; ++i) {
	          args.push(arguments[i]);
	        }
	      }
	      pre.fn.apply(context, args);
	    } else {
	      pre.fn.call(context);
	      if (++currentPre >= numPres) {
	        if (asyncPresLeft > 0) {
	          // Leave parallel hooks to run
	          return;
	        } else {
	          return process.nextTick(function() {
	            callback(null);
	          });
	        }
	      }
	      next();
	    }
	  };
	
	  next();
	};
	
	Kareem.prototype.execPost = function(name, context, args, callback) {
	  var posts = this._posts[name] || [];
	  var numPosts = posts.length;
	  var currentPost = 0;
	
	  if (!numPosts) {
	    return process.nextTick(function() {
	      callback.apply(null, [null].concat(args));
	    });
	  }
	
	  var next = function() {
	    var post = posts[currentPost];
	
	    if (post.length > args.length) {
	      post.apply(context, args.concat(function(error) {
	        if (error) {
	          return callback(error);
	        }
	
	        if (++currentPost >= numPosts) {
	          return callback.apply(null, [null].concat(args));
	        }
	
	        next();
	      }));
	    } else {
	      post.apply(context, args);
	
	      if (++currentPost >= numPosts) {
	        return callback.apply(null, [null].concat(args));
	      }
	
	      next();
	    }
	  };
	
	  next();
	};
	
	Kareem.prototype.wrap = function(name, fn, context, args, useLegacyPost) {
	  var lastArg = (args.length > 0 ? args[args.length - 1] : null);
	  var _this = this;
	
	  this.execPre(name, context, function(error) {
	    if (error) {
	      if (typeof lastArg === 'function') {
	        return lastArg(error);
	      }
	      return;
	    }
	
	    var end = (typeof lastArg === 'function' ? args.length - 1 : args.length);
	
	    fn.apply(context, args.slice(0, end).concat(function() {
	      if (arguments[0]) {
	        // Assume error
	        return typeof lastArg === 'function' ?
	          lastArg(arguments[0]) :
	          undefined;
	      }
	
	      if (useLegacyPost && typeof lastArg === 'function') {
	        lastArg.apply(context, arguments);
	      }
	
	      var argsWithoutError = Array.prototype.slice.call(arguments, 1);
	      _this.execPost(name, context, argsWithoutError, function() {
	        if (arguments[0]) {
	          return typeof lastArg === 'function' ?
	            lastArg(arguments[0]) :
	            undefined;
	        }
	
	        return typeof lastArg === 'function' && !useLegacyPost ?
	          lastArg.apply(context, arguments) :
	          undefined;
	      });
	    }));
	  });
	};
	
	Kareem.prototype.createWrapper = function(name, fn, context) {
	  var _this = this;
	  return function() {
	    var args = Array.prototype.slice.call(arguments);
	    _this.wrap(name, fn, context, args);
	  };
	};
	
	Kareem.prototype.pre = function(name, isAsync, fn, error) {
	  if (typeof arguments[1] !== 'boolean') {
	    error = fn;
	    fn = isAsync;
	    isAsync = false;
	  }
	
	  this._pres[name] = this._pres[name] || [];
	  var pres = this._pres[name];
	
	  if (isAsync) {
	    pres.numAsync = pres.numAsync || 0;
	    ++pres.numAsync;
	  }
	
	  pres.push({ fn: fn, isAsync: isAsync });
	
	  return this;
	};
	
	Kareem.prototype.post = function(name, fn) {
	  (this._posts[name] = this._posts[name] || []).push(fn);
	  return this;
	};
	
	Kareem.prototype.clone = function() {
	  var n = new Kareem();
	  for (var key in this._pres) {
	    n._pres[key] = this._pres[key].slice();
	  }
	  for (var key in this._posts) {
	    n._posts[key] = this._posts[key].slice();
	  }
	
	  return n;
	};
	
	module.exports = Kareem;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 43)))

/***/ }
/******/ ]);
//# sourceMappingURL=vendors.js.map